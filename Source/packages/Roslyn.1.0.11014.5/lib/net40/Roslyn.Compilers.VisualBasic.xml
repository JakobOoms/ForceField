<?xml version="1.0"?>
<doc>
<assembly>
<name>
Roslyn.Compilers.VisualBasic
</name>
</assembly>
<members>
<member name="M:Roslyn.Compilers.VisualBasic.TypeUnification.CanUnify(Roslyn.Compilers.VisualBasic.NamedTypeSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 Determine whether there is any substitution of type parameters that will
 make two types identical.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeUnification.CanUnifyHelper(Roslyn.Compilers.VisualBasic.NamedTypeSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.TypeSubstitution@)">
	<summary>
 Determine whether there is any substitution of type parameters that will
 make two types identical.
 </summary>
	<param name="containingGenericType">The generic containing type.</param>
	<param name="t1">LHS</param>
	<param name="t2">RHS</param>
	<param name="substitution">
 Substitutions performed so far (or null for none).
 Keys are type parameters, values are types (possibly type parameters).
 Will be updated with new subsitutions by the callee.
 Irrelevant if false is returned.
 </param>
	<returns>True if there exists a type map such that Map(LHS) == Map(RHS).</returns>
	<remarks>
 Derived from C# Dev10's BSYMMGR::UnifyTypes.
 Two types will not unify if they have different custom modifiers.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeUnification.AddSubstitution(Roslyn.Compilers.VisualBasic.TypeSubstitution@,Roslyn.Compilers.VisualBasic.NamedTypeSymbol,Roslyn.Compilers.VisualBasic.TypeParameterSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 Add a type parameter -&gt; type argument substitution to a TypeSubstitution object, returning a new TypeSubstitution object
 ByRef.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeUnification.Contains(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.TypeParameterSymbol)">
	<summary>
 Return true if the given type contains the specified type parameter.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Iterator`1.GeneratorFunc`1">
	<summary>
 special func to create generators. the value is returned as a ByRef argument 
 while result used to indicate when iterating finishes.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Iterator`1.Enumerator`1">
	<summary>
 Enumerator wrapper for a generator lambda.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Iterator`1">
	<summary>
 Poor man's Iterator
 wraps a generator factory into an IEnumerable.
 generator is a lambda with a state (machine) that will produce sequence of values when called repeatedly.
 returning False from generator indicates that sequence is finished.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.FindToken(System.Int32,System.Func{Roslyn.Compilers.VisualBasic.SyntaxTrivia,System.Boolean})">
	<summary>
 Finds a token according to the following rules:
 1)	If position matches the End of the node's FullSpan and the node is CompilationUnit, then EoF is returned. 
 
 2)	If node.FullSpan.Contains(position) the token that contains given position is returned.
     If stepInto is not Nothing, then structured trivia that satisfies the condition will also be visited during the search.
 
 3)	Otherwise an IndexOutOfRange is thrown
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.FindToken(System.Int32,System.Boolean)">
	<summary>
 Finds a token according to the following rules:
 1)	If position matches the End of the node's FullSpan and the node is CompilationUnit, then EoF is returned. 
 
 2)	If node.FullSpan.Contains(position) then the token that contains given position is returned.
 
 3)	Otherwise an IndexOutOfRange is thrown
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.DescendentTrivia(System.Func{Roslyn.Compilers.VisualBasic.SyntaxNode,System.Boolean},System.Boolean)">
	<summary>
 A list of all trivia for all descendent tokens.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.DescendentTrivia(Roslyn.Compilers.TextSpan,System.Func{Roslyn.Compilers.VisualBasic.SyntaxNode,System.Boolean},System.Boolean)">
	<summary>
 A list of all trivia for all descendent tokens.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.DescendentTokens(System.Func{Roslyn.Compilers.VisualBasic.SyntaxNode,System.Boolean},System.Boolean)">
	<summary>
 Gets a list of descendent tokens under this node.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.DescendentTokens(Roslyn.Compilers.TextSpan,System.Func{Roslyn.Compilers.VisualBasic.SyntaxNode,System.Boolean},System.Boolean)">
	<summary>
 Gets a list of descendent tokens under this node with a full span that intersects the specified span.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTrivia.WriteTo(System.IO.TextWriter)">
	<summary>
 Writes the full text of this trivia to the specified TextWriter
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTrivia.WithAdditionalAnnotations(Roslyn.Compilers.SyntaxAnnotation[])">
	<summary>
 Adds this annotation to a given syntax token, creating a new syntax token of the same type with the
 annotation on it.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTrivia.CopyAnnotations(Roslyn.Compilers.VisualBasic.SyntaxTrivia)">
	<summary>
 Finds any annotations that are on token "from", and then attaches them to token "to",
 returning a new token with the annotations attached. 
 
 If no annotations are copied, just returns "to".
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SyntaxTree.FileName">
	<summary>
 The name of the source document file.
 </summary>
	<remarks>
 If this syntax tree is not associated with a file, this FileName can (and often will) be the empty string.
 
 Clients must not assume that a file exists on disk with the given name, even if a non-empty
 string is returned. Clients must also not assume that the values of this property are unique
 within a Compilation.
 
 The FileName is used in two important ways:
    When debug information is emitted, this name is embedded in the debug information.
    When the GetLineSpan function on the SyntaxTree is called, it is used as the file name
    in the returned FileLinePositionSpan.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.SyntaxTree.Text">
	<summary>
 The text of the source document.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SyntaxTree.Options">
	<summary>
 The options used by the parser to produce the syntax tree.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SyntaxTree.Root">
	<summary>
 The root node of the syntax tree.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTree.GetText(System.Threading.CancellationToken)">
	<summary>
 Gets the text of the source document.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTree.GetRoot(System.Threading.CancellationToken)">
	<summary>
 Gets the root node of the syntax tree. 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTree.WithChange(Roslyn.Compilers.IText,Roslyn.Compilers.TextChangeRange[])">
	<summary>
 Create a new syntax tree based off this tree, the new source text and a list of changes to the old text. The
 changes must be a list of non-overlapping, non-abutting ranges. The list must be sorted in ascending order
 of the range's start positions.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTree.GetReference(Roslyn.Compilers.VisualBasic.SyntaxNode)">
	<summary>
 Gets a SyntaxReference for a specified syntax node. SyntaxReferences can be used to regain access to a
 syntax node without keeping the entire tree and source text in memory.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTree.ParseCompilationUnit(System.String,System.String,Roslyn.Compilers.VisualBasic.ParseOptions,System.Threading.CancellationToken)">
	<summary>
 Produce a syntax tree by parsing the source text.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTree.ParseCompilationUnit(Roslyn.Compilers.IText,System.String,Roslyn.Compilers.VisualBasic.ParseOptions,System.Threading.CancellationToken)">
	<summary>
 Produce a syntax tree by parsing the source text.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTree.GetDiagnostics(Roslyn.Compilers.VisualBasic.SyntaxNode)">
	<summary>
 Gets a list of all the diagnostics in the sub tree that has the specified node as its root.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTree.GetDiagnostics(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Gets a list of all the diagnostics associated with the token and any related trivia.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTree.GetDiagnostics(Roslyn.Compilers.VisualBasic.SyntaxTrivia)">
	<summary>
 Gets a list of all the diagnostics associated with the trivia.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTree.GetDiagnostics(Roslyn.Compilers.VisualBasic.SyntaxNodeOrToken)">
	<summary>
 Gets a list of all the diagnostics in either the sub tree that has the specified node as its root or
 associated with the token and its related trivia. 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTree.GetDiagnostics(System.Threading.CancellationToken)">
	<summary>
 Gets a list of all the diagnostics in the syntax tree.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTree.GetLineSpan(Roslyn.Compilers.TextSpan,System.Boolean)">
	<summary>
 Gets a FileLinePositionSpan for a TextSpan. FileLinePositionSpans are used primarily for diagnostics and
 source locations.
 </summary>
	<param name="usePreprocessorDirectives">An indicator that determines whether preprocessor #line directives
 are used to alter the resulting line span.</param>
	<returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTree.GetLocation(Roslyn.Compilers.VisualBasic.SyntaxNode)">
	<summary>
 Gets a location for the specified syntax node.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTree.GetLocation(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Gets a location for the specified token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTree.GetLocation(Roslyn.Compilers.VisualBasic.SyntaxNodeOrToken)">
	<summary>
 Gets a location for the specified node or token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTree.GetLocation(Roslyn.Compilers.VisualBasic.SyntaxTrivia)">
	<summary>
 Gets a location for the specified trivia.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTree.GetLocation(Roslyn.Compilers.TextSpan)">
	<summary>
 Gets a location for the specified text span.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTree.IsEquivalentTo(Roslyn.Compilers.VisualBasic.SyntaxTree,System.Boolean)">
	<summary>
 Determines if two trees are the same, disregarding trivia differences.
 </summary>
	<param name="tree">The tree to compare against.</param>
	<param name="topLevel"> If true then the trees are equivalent if the contained nodes and tokens declaring
 metadata visible symbolic information are equivalent, ignoring any differences of nodes inside method bodies
 or initializer expressions, otherwise all nodes and tokens must be equivalent. 
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.SyntaxTree">
	<summary>
 The parsed representation of a Visual Basic source document.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SyntaxToken.HasStructuredTrivia">
	<summary>
 True if any trivia of this token is structured.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxToken.WriteTo(System.IO.TextWriter)">
	<summary>
 Writes the full text of this token to the specified TextWriter
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxToken.GetAllTrivia">
	<summary>
 Gets a list of both leading and trailing trivia for the token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxToken.GetSyntaxErrors(Roslyn.Compilers.VisualBasic.SyntaxTree)">
	<summary>
 Get all syntax errors associated with this node, or any child nodes, grand-child nodes, etc. The errors
 are not in order.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxToken.WithAdditionalAnnotations(Roslyn.Compilers.SyntaxAnnotation[])">
	<summary>
 Adds this annotation to a given syntax token, creating a new syntax token of the same type with the
 annotation on it.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxToken.CopyAnnotations(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Finds any annotations that are on token "from", and then attaches them to token "to",
 returning a new token with the annotations attached. 
 
 If no annotations are copied, just returns "to".
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SyntaxReference">
	<summary>
 A SyntaxReference allows one to get a reference to a syntax node that can be
 re-obtained later.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ParseLeadingTrivia(System.String,System.Int32)">
	<summary>
Parse the input for leading trivia.
 </summary>
	<param name="text">The input string</param>
	<param name="offset">The starting offset in the string</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ParseTrailingTrivia(System.String,System.Int32)">
	<summary>
 Parse the input for trailing trivia.
 </summary>
	<param name="text">The input string</param>
	<param name="offset">The starting offset in the string</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ParseToken(System.String,System.Int32,System.Boolean)">
	<summary>
 Parse one token.
 </summary>
	<param name="text">The input string</param>
	<param name="offset">The starting offset in the string</param>
	<param name="startStatement">Scan using rules for the start of a statement</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ParseTokens(System.String,System.Int32,System.Int32)">
	<summary>
 Parse tokens in the input.
 </summary>
	<param name="text">The input string</param>
	<param name="offset">The starting offset in the string</param>
	<param name="initialTokenPosition">The position of the first token</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ParseName(System.String,System.Int32)">
	<summary>
 Parse a name.
 </summary>
	<param name="text">The input string</param>
	<param name="offset">The starting offset in the string</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ParseTypeName(System.String,System.Int32)">
	<summary>
 Parse a type name.
 </summary>
	<param name="text">The input string</param>
	<param name="offset">The starting offset in the string</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ParseExpression(System.String,System.Int32)">
	<summary>
 Parse an expression.
 </summary>
	<param name="text">The input string</param>
	<param name="offset">The starting offset in the string</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ParseExecutableStatement(System.String,System.Int32)">
	<summary>
 Parse an executable statement.
 </summary>
	<param name="text">The input string</param>
	<param name="offset">The starting offset in the string</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ParseCompilationUnit(System.String,System.Int32)">
	<summary>
 Parse a compilation unit (a single source file).
 </summary>
	<param name="text">The input string</param>
	<param name="offset">The starting offset in the string</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ParseParameterList(System.String,System.Int32)">
	<summary>
 Parse a parameter list.
 </summary>
	<param name="text">The input string</param>
	<param name="offset">The starting offset in the string</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.MakeIText(System.String,System.Int32)">
	<summary>
 Helper method for wrapping a string and offset in an IText.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.MissingIdentifier">
	<summary>
 Create a missing identifier.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.MissingIdentifier(Roslyn.Compilers.VisualBasic.SyntaxKind)">
	<summary>
 Create a missing contextual keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.MissingKeyword(Roslyn.Compilers.VisualBasic.SyntaxKind)">
	<summary>
 Create a missing keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.MissingPunctuation(Roslyn.Compilers.VisualBasic.SyntaxKind)">
	<summary>
 Create a missing punctutation mark.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.MissingStringLiteral">
	<summary>
 Create a missing string literal.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.MissingCharacterLiteralToken">
	<summary>
 Create a missing character literal.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.MissingIntegerLiteralToken">
	<summary>
 Create a missing integer literal.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.MissingToken(Roslyn.Compilers.VisualBasic.SyntaxKind)">
	<summary>
 Creates a copy of a token.
 <para name="err"></para>
		<para name="trivia"></para>
	</summary>
	<returns>The new token</returns>
</member><member name="P:Roslyn.Compilers.VisualBasic.SyntaxNode.Green">
	<summary>
 Return the green node this node wraps. Never null.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SyntaxNode.Position">
	<summary>
 The start location of this node.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SyntaxNode.EndLocation">
	<summary>
 The start location of this node.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SyntaxNode.Kind">
	<summary>
 The kind of this node.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SyntaxNode.Parent">
	<summary>
 The parent of this node.
 </summary>
	<value>The parent node of this node, or Nothing if this node is the root.</value>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.GetText">
	<summary>
 Gets the text of this node, including all children, but not
 including preceding and trailing trivia.
 </summary>
	<remarks>The length of the returned string is always the same as Span.Length</remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.GetFullText">
	<summary>
 Gets the full text of this node, including all children, and including
 preceding and trailing trivia.
 </summary>
	<remarks>The length of the returned string is always the same as FullSpan.Length</remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.WriteTo(System.IO.TextWriter)">
	<summary>
 Writes the full text of this node to the specified TextWriter
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.ToString">
	<summary>
 Gets the full text of this node, including all children, and including
 preceding and trailing trivia.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SyntaxNode.IsStructuredTrivia">
	<summary>
 Returns if this node is a trivia node, representing whitespace, comments, disabled
 code, etc. Trivia nodes do not themselves have trivia, although they can have children which have trivia.
 </summary>
	<value>True if node is a trivia, false if a non-terminal or token node.</value>
</member><member name="P:Roslyn.Compilers.VisualBasic.SyntaxNode.HasStructuredTrivia">
	<summary>
 Determines whether a descendent trivia of this node is structured.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SyntaxNode.IsDirective">
	<summary>
 Returns True if this node represents a directive.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SyntaxNode.Span">
	<summary>
 Get the span of this node, not including preceding trivia on this node or children. If this is a token, gets
 the span not including its trivia. If this is a non-terminal, gets the span not including the preceding
 trivia of the first token, and not including the following trivia of the last token.
 </summary>
	<value>The span of the node, not including preceding or following trivia.</value>
</member><member name="P:Roslyn.Compilers.VisualBasic.SyntaxNode.FullSpan">
	<summary>
 Get the span of this node, including preceding trivia on this node or children. If this 
 is a token, gets the span including its trivia. If this is a non-terminal, gets this 
 full span of all children.
 </summary>
	<value>The span of the node, including preceding or following trivia.</value>
</member><member name="P:Roslyn.Compilers.VisualBasic.SyntaxNode.FullWidth">
	<summary>
 The width of this item, in characters. Includes any associated trivia (whitespace/comments).
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SyntaxNode.HasChildren">
	<summary>
 Returns true if this node has children.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SyntaxNode.IsMissing">
	<summary>
 Returns true if this node was missing; i.e., was synthesized by the parser. A missing node
 has an empty Span and FullSpan, but the location of the Span still shows where it was expected
 to be in the source.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.GetLeadingTrivia">
	<summary>
 Get the preceding trivia nodes of this node. If this node is a token, returns the preceding trivia
 associated with this node. If this is a non-terminal, returns the preceding trivia of the first token
 of this node. 
 </summary>
	<returns>A list of a the preceding trivia.</returns>
	<remarks>If this node is a non-terminal, the parents of the trivia will be the first token of this 
 non-terminal; NOT this node.</remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.GetTrailingTrivia">
	<summary>
 Get the following trivia nodes of this node. If this node is a token, returns the following trivia
 associated with this node. If this is a non-terminal, returns the following trivia of the last token
 of this node. 
 </summary>
	<returns>A list of a the following trivia.</returns>
	<remarks>If this node is a non-terminal, the parents of the trivia will be the first token of this 
 non-terminal; NOT this node.</remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.SyntaxNode.HasLeadingTrivia">
	<summary>
 Returns 'true' if this node has any leading trivia.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SyntaxNode.HasTrailingTrivia">
	<summary>
 Returns 'true' if this node has any trailing trivia.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SyntaxNode.HasDiagnostics">
	<summary>
 Does this node, or any nodes beneath it, have syntax errors? Checking this property is much faster
 than actually getting the list of errors with GetSyntaxErrors()
 </summary>
	<returns>True if there is a syntax error associated with the node, or with any children, grandchildren, etc.</returns>
</member><member name="P:Roslyn.Compilers.VisualBasic.SyntaxNode.HasAnnotations">
	<summary>
 Does this node, or any nodes beneath it, have syntax annotations?
 </summary>
	<returns>True if there is a syntax annotation associated with the node, or with any children, grandchildren, etc.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.GetChildPosition(System.Int32)">
	<summary>
 This function calculates the offset of a child at given position.
 Often that there are some children to the left of the given index that
 Already have know their offsets so we first check if that is the case.
 In a worst case the cost is O(n), but it is not generally an issue 
 because number of children in regular nodes and lists is typically small.
 In a case where the number of children could often be large (separated lists) 
 this function is overridden with more efficient implementations.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.GetSyntaxErrors(Roslyn.Compilers.VisualBasic.SyntaxTree)">
	<summary>
 Get all syntax errors associated with this node, or any child nodes, grand-child nodes, etc. The errors
 are not in order.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.PushNodesWithErrors(System.Collections.Generic.Stack{Roslyn.Compilers.VisualBasic.SyntaxNodeOrToken},Roslyn.Compilers.VisualBasic.ChildSyntaxList)">
	<summary>
 Push any nodes that have errors in the given collection onto a stack
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.CreateSyntaxError(Roslyn.Compilers.VisualBasic.SyntaxTree,Roslyn.Compilers.VisualBasic.SyntaxNodeOrToken,Roslyn.Compilers.DiagnosticInfo)">
	<summary>
 Given a error info from this node, create the corresponding syntax error with the right span.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.EquivalentTo(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.SyntaxNode)">
	<summary>
 Compares two trees for structural equivalence.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.AddError(Roslyn.Compilers.DiagnosticInfo)">
	<summary>
 Add an error to the given node, creating a new node that is the same except it has no parent,
 and has the given error attached to it. The error span is the entire span of this node.
 </summary>
	<param name="err">The error to attach to this node</param>
	<returns>A new node, with no parent, that has this error added to it.</returns>
	<remarks>Since nodes are immutable, the only way to create nodes with errors attached is to create a node without an error,
 then add an error with this method to create another node.</remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.ChildNodes">
	<summary>
 Gets a list of the child nodes in document order. This list does not contain tokens.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.ChildNodesAndTokens">
	<summary>
 Gets the list of child nodes and tokens of this node in document order, where each element
 is a SyntaxNodeOrToken instance.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.Ancestors(System.Boolean)">
	<summary>
 Gets a list of ancestor nodes that have type TNode and satisfies the predicate.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.AncestorsAndSelf(System.Boolean)">
	<summary>
 Gets a list of ancestor nodes (including this node) that have type TNode and satisfies the predicate.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.DescendentNodes(System.Func{Roslyn.Compilers.VisualBasic.SyntaxNode,System.Boolean},System.Boolean)">
	<summary>
 Gets a list of descendent nodes in prefix document order.
 </summary>
	<param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
	<param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.DescendentNodes(Roslyn.Compilers.TextSpan,System.Func{Roslyn.Compilers.VisualBasic.SyntaxNode,System.Boolean},System.Boolean)">
	<summary>
 Gets a list of descendent nodes in prefix document order.
 </summary>
	<param name="span">The span the node's full span must intersect.</param>
	<param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
	<param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.DescendentNodesAndSelf(System.Func{Roslyn.Compilers.VisualBasic.SyntaxNode,System.Boolean},System.Boolean)">
	<summary>
 Gets a list of descendent nodes (including this node) in prefix document order.
 </summary>
	<param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
	<param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.DescendentNodesAndSelf(Roslyn.Compilers.TextSpan,System.Func{Roslyn.Compilers.VisualBasic.SyntaxNode,System.Boolean},System.Boolean)">
	<summary>
 Gets a list of descendent nodes (including this node) in prefix document order.
 </summary>
	<param name="span">The span the node's full span must intersect.</param>
	<param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
	<param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.DescendentNodesAndTokens(System.Func{Roslyn.Compilers.VisualBasic.SyntaxNode,System.Boolean},System.Boolean)">
	<summary>
 Gets a list of descendent nodes and tokens in prefix document order.
 </summary>
	<param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
	<param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.DescendentNodesAndTokens(Roslyn.Compilers.TextSpan,System.Func{Roslyn.Compilers.VisualBasic.SyntaxNode,System.Boolean},System.Boolean)">
	<summary>
 Gets a list of the descendent nodes and tokens in prefix document order.
 </summary>
	<param name="span">The span the node's full span must intersect.</param>
	<param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
	<param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.DescendentNodesAndTokensAndSelf(System.Func{Roslyn.Compilers.VisualBasic.SyntaxNode,System.Boolean},System.Boolean)">
	<summary>
 Gets a list of descendent nodes and tokens (including this node) in prefix document order.
 </summary>
	<param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
	<param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.DescendentNodesAndTokensAndSelf(Roslyn.Compilers.TextSpan,System.Func{Roslyn.Compilers.VisualBasic.SyntaxNode,System.Boolean},System.Boolean)">
	<summary>
 Gets a list of the descendent nodes and tokens (including this node) in prefix document order.
 </summary>
	<param name="span">The span the node's full span must intersect.</param>
	<param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
	<param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.WithAdditionalAnnotations(Roslyn.Compilers.SyntaxAnnotation[])">
	<summary>
 Adds this annotation to a given syntax token, creating a new syntax token of the same type with the
 annotation on it.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.GetAnnotatedNodesAndTokens(Roslyn.Compilers.SyntaxAnnotation)">
	<summary>
 Finds all nodes with this annotation attached, that are on or under this node.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.GetAnnotatedTrivia(Roslyn.Compilers.SyntaxAnnotation)">
	<summary>
 Finds all trivia with this annotation attached, that are on or under node.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxList.GetRedListElement(Roslyn.Compilers.VisualBasic.SyntaxNode@,System.Int32)">
	<summary>
 This works the same as GetRedOnly, but intended to be used in lists
 The only difference is that the public parent of the node is not the list, 
 but the list's parent. (element's grand parent).
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.GetStandAloneExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary> 
 Names on the right of qualified names and member access expressions are not stand-alone expressions.
 This method returns the appropriate parent of name syntax nodes that are on right of these constructs.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AreEquivalent(Roslyn.Compilers.VisualBasic.SyntaxTree,Roslyn.Compilers.VisualBasic.SyntaxTree,System.Boolean)">
	<summary>
 Determines if two trees are the same, disregarding trivia differences.
 </summary>
	<param name="oldTree">The original tree.</param>
	<param name="newTree">The new tree.</param>
	<param name="topLevel"> If true then the trees are equivalent if the contained nodes and tokens declaring
 metadata visible symbolic information are equivalent, ignoring any differences of nodes inside method bodies
 or initializer expressions, otherwise all nodes and tokens must be equivalent. 
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AreEquivalent(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.SyntaxNode,System.Boolean)">
	<summary>
 Determines if two syntax nodes are the same, disregarding trivia differences.
 </summary>
	<param name="oldNode">The old node.</param>
	<param name="newNode">The new node.</param>
	<param name="topLevel"> If true then the nodes are equivalent if the contained nodes and tokens declaring
 metadata visible symbolic information are equivalent, ignoring any differences of nodes inside method bodies
 or initializer expressions, otherwise all nodes and tokens must be equivalent. 
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.SeparatedSyntaxList`1.GetSeparator(System.Int32)">
	<summary>
 Gets the separator at the given index in this list.
 </summary>
	<param name="index">The index.</param><returns></returns>
</member><member name="T:Roslyn.Compilers.VisualBasic.SyntaxRewriter">
	<summary>
 Represents a <see cref="T:Roslyn.Compilers.VisualBasic.SyntaxVisitor`1"/> which descends an entire <see cref="T:Roslyn.Compilers.VisualBasic.SyntaxNode"/> graph and
 may replace or remove visited SyntaxNodes in depth-first order.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.VisualBasicLineDirectiveMap">
	<summary>
 Adds VB specific parts to the line directive map
 </summary>
	<remarks></remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.SyntaxWalker">
	<summary>
 Represents a <see cref="T:Roslyn.Compilers.VisualBasic.SyntaxVisitor"/> that descends an entire <see cref="T:Roslyn.Compilers.VisualBasic.SyntaxNode"/> graph
 visiting each SyntaxNode and its child SyntaxNodes and <see cref="T:Roslyn.Compilers.VisualBasic.SyntaxToken"/>s in depth-first order.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SyntaxVisitor">
	<summary>
 Represents a <see cref="T:Roslyn.Compilers.VisualBasic.SyntaxNode"/> visitor that visits only the single SyntaxNode
 passed into its <see cref="M:Roslyn.Compilers.VisualBasic.SyntaxVisitor.Visit(Roslyn.Compilers.VisualBasic.SyntaxNode)"/> method.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SyntaxVisitor`1">
	<summary>
 Represents a <see cref="T:Roslyn.Compilers.VisualBasic.SyntaxNode"/> visitor that visits only the single SyntaxNode
 passed into its <see cref="M:Roslyn.Compilers.VisualBasic.SyntaxVisitor`1.Visit(Roslyn.Compilers.VisualBasic.SyntaxNode)"/> method and produces 
 a value of the type specified by the <typeparamref name="TResult"/> parameter.
 </summary>
	<typeparam name="TResult">
 The type of the return value this visitor's Visit method.
 </typeparam>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTree.ParsedSyntaxTree.#ctor(Roslyn.Compilers.IText,System.String,Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.ParseOptions,System.Int32)">
	<summary>
 Used to create new tree incrementally.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTree.ParsedSyntaxTree.GetReference(Roslyn.Compilers.VisualBasic.SyntaxNode)">
	<summary>
 Get a reference to the given node.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTree.ParsedSyntaxTree.WithChange(Roslyn.Compilers.IText,Roslyn.Compilers.TextChangeRange[])">
	<summary>
 Apply a text change to this syntax tree, returning a new syntax tree with the
 changes applied to it.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTree.ParsedSyntaxTree.ToString">
	<summary>
 Returns a <see cref="T:System.String"/> that represents the source code of this parsed tree.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SyntaxTree.ParsedSyntaxTree">
	<summary>
 A SyntaxTree is a tree of nodes that represents an entire file of VB
 code, and is parsed by the parser.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNodeExtensions.ContainingWithStatement(Roslyn.Compilers.VisualBasic.SyntaxNode)">
	<summary>
 Find enclosing WithStatement if it exists.
 </summary>
	<param name="node"></param>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxFormatter.#ctor(System.String,System.Boolean,System.Boolean)">
	<summary>
 Creates a Syntax Formatter visitor
 </summary>
	<param name="indentWhitespace">The whitespace to indent with</param>
	<param name="useElasticTrivia">Whether to use elastic trivia or not</param>
	<param name="useDefaultCasing">Whether to rewrite keywords in default casing or not</param>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxFormatter.GetIndentationDepth(Roslyn.Compilers.VisualBasic.SyntaxToken,System.Int32)">
	<summary>
 indentation depth is the declaration depth for statements within the block. for start/end statements
 of these blocks (e.g. the if statement), it is a level less
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxExtensions.IsPartOfStructuredTrivia(Roslyn.Compilers.VisualBasic.SyntaxNode)">
	<summary>
 Determines if the node is a descendant of a structured trivia.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxExtensions.IsPartOfStructuredTrivia(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Determines if the token is a descendant of a structured trivia.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxExtensions.IsPartOfStructuredTrivia(Roslyn.Compilers.VisualBasic.SyntaxTrivia)">
	<summary>
 Determines if the trivia is a descendant of a structured trivia.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxExtensions.Type(Roslyn.Compilers.VisualBasic.NewExpressionSyntax)">
	<summary>
 Returns the TypeSyntax of the given NewExpressionSyntax if specified.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxExtensions.Type(Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 Returns the TypeSyntax of the given AsClauseSyntax if specified.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxExtensions.Attributes(Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 Returns the AttributeBlockSyntax of the given AsClauseSyntax if specified.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken.CollectConstituentTokensAndDiagnostics(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxListBuilder{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken},System.Collections.Generic.IList{Roslyn.Compilers.DiagnosticInfo})">
	<summary>
 Add this token to the token list builder.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken.IsKeyword">
	<summary>
 Helper to check whether the token is a keyword
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken.IsBinaryOperator">
	<summary>
 Helpers to check whether the token is a binary operator
 </summary>
	<returns>True if it is a binary operator</returns>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken.IsEndOfLine">
	<summary>
 Check whether the token is a statement terminator
 </summary>
	<returns>True if it is statement terminator</returns>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken.IsEndOfParse">
	<summary>
 Check whether token is end of text
 </summary>
	<value></value>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken.AddLeadingTrivia``1(``0,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode})">
	<summary>
 Create a new token with the trivia prepended to the existing preceding trivia
 </summary>
	<typeparam name="T"></typeparam>
	<param name="token"></param>
	<param name="newTrivia"></param>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken.AddTrailingTrivia``1(``0,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode})">
	<summary>
 Create a new token with the trivia appended to the existing following trivia
 </summary>
	<typeparam name="T"></typeparam>
	<param name="token"></param>
	<param name="newTrivia"></param>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.Identifier(System.String,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode)">
	<summary>
 Create an identifier node without brackets or type character.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.Identifier(System.String,Roslyn.Compilers.VisualBasic.SyntaxKind,System.Boolean,System.String,Roslyn.Compilers.VisualBasic.TypeCharacter,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode)">
	<summary>
 Create an identifier node with brackets or type character.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.Identifier(System.String)">
	<summary>
 Create an identifier node without brackets or type character or trivia.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.MissingIdentifier">
	<summary>
 Create a missing identifier.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.MissingIdentifier(Roslyn.Compilers.VisualBasic.SyntaxKind)">
	<summary>
 Create a missing contextual keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.MissingKeyword(Roslyn.Compilers.VisualBasic.SyntaxKind)">
	<summary>
 Create a missing keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.MissingPunctuation(Roslyn.Compilers.VisualBasic.SyntaxKind)">
	<summary>
 Create a missing punctutation mark.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.MissingStringLiteral">
	<summary>
 Create a missing string literal.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.MissingCharacterLiteralToken">
	<summary>
 Create a missing character literal.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.MissingIntegerLiteralToken">
	<summary>
 Create a missing integer literal.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.MissingToken(Roslyn.Compilers.VisualBasic.SyntaxKind)">
	<summary>
 Creates a copy of a token.
 <para name="err"></para>
		<para name="trivia"></para>
	</summary>
	<returns>The new token</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EndOfFileToken(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxTrivia)">
	<summary>
 Create an end-of-text token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EndOfFileToken">
	<summary>
 Create an end-of-text token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.IntegerLiteralTokenSyntax`1.Value">
	<summary>
 The value of the token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.IntegerLiteralTokenSyntax.Base">
	<summary>
 Whether the token was specified in base 10, 16, or 8.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.IntegerLiteralTokenSyntax.TypeSuffix">
	<summary>
 The type suffix or type character that was on the literal, if any. If no suffix
 was present, TypeCharacter.None is returned.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.IntegerLiteralTokenSyntax">
	<summary>
 Represents an integer literal token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.FloatingLiteralTokenSyntax`1.Value">
	<summary>
 The value of the token.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.FloatingLiteralTokenSyntax`1">
	<summary>
 Represents an floating literal token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.FloatingLiteralTokenSyntax.TypeSuffix">
	<summary>
 The type suffix or type character that was on the literal, if any. If no suffix
 was present, TypeCharacter.None is returned.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.FloatingLiteralTokenSyntax">
	<summary>
 Represents an floating literal token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode.FullWidth">
	<summary>
 The width of this item, in characters. Includes any associated trivia (whitespace/comments).
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode.WriteTo(System.IO.TextWriter)">
	<summary>
 Append the full text of this node including children and trivia to the given stringbuilder.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode.CollectConstituentTokensAndDiagnostics(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxListBuilder{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken},System.Collections.Generic.IList{Roslyn.Compilers.DiagnosticInfo})">
	<summary>
 Add all the tokens in this node and children to the build token list builder. While doing this, add any
 diagnostics not on tokens to the given diagnostic info list.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode.AddError(Roslyn.Compilers.DiagnosticInfo)">
	<summary>
 Add an error to the given node, creating a new node that is the same except it has no parent,
 and has the given error attached to it. The error span is the entire span of this node.
 </summary>
	<param name="err">The error to attach to this node</param>
	<returns>A new node, with no parent, that has this error added to it.</returns>
	<remarks>Since nodes are immutable, the only way to create nodes with errors attached is to create a node without an error,
 then add an error with this method to create another node.</remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode.GetSyntaxErrors">
	<summary>
 Get all syntax errors associated with this node, or any child nodes, grand-child nodes, etc. The errors
 are not in order.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SimpleIdentifierSyntax.PossibleKeywordKind">
	<summary>
 Contextual Nodekind
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SimpleIdentifierSyntax.IsBracketed">
	<summary>
 If true, the identifier was enclosed in brackets, such as "[End]".
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SimpleIdentifierSyntax.IdentifierText">
	<summary>
 The text of the identifier, not including the brackets or type character.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SimpleIdentifierSyntax.TypeCharacter">
	<summary>
 The type character suffix, if present. Returns TypeCharacter.None if no type
 character was present. The only allowed values are None, Integer, Long,
 Decimal, Single, Double, and String.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList`1.GetSeparator(System.Int32)">
	<summary>
 Gets the separator at the given index in this list.
 </summary>
	<param name="index">The index.</param><returns></returns>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax.PossibleKeywordKind">
	<summary>
 Contextual Nodekind
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax.IsBracketed">
	<summary>
 If true, the identifier was enclosed in brackets, such as "[End]".
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax.IdentifierText">
	<summary>
 The text of the identifier, not including the brackets or type character.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax.TypeCharacter">
	<summary>
 The type character suffix, if present. Returns TypeCharacter.None if no type
 character was present. The only allowed values are None, Integer, Long,
 Decimal, Single, Double, and String.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax">
	<summary>
 Represents an identifier token. This might include brackets around the name,
 and a type character.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode">
	<summary>
 The base class for all nodes in the VB syntax tree.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax">
	<summary>
 The base class for all nodes that represent statements. This includes both
 declaration statements, such as class declarations as well as executable
 statements.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.EmptyStatementSyntax.Empty">
	<summary>
 An empty token because all non terminals must have a token.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.EmptyStatementSyntax">
	<summary>
 A class to represent an empty statement. This can occur when a colon is on a
 line without anything else.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.EndBlockStatementSyntax.EndKeyword">
	<summary>
 The "End" keyword
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.EndBlockStatementSyntax.BlockKeyword">
	<summary>
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.EndBlockStatementSyntax">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CompilationUnitSyntax.Options">
	<summary>
 Represents the list of Option statements at the beginning of a source file.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CompilationUnitSyntax.Imports">
	<summary>
 Represents the list of Imports statements at the beginning of a source file.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CompilationUnitSyntax.Attributes">
	<summary>
 Represents the list of AttributeStatements at the beginning of a source file
 that contain the Assembly and Module attributes.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CompilationUnitSyntax.Members">
	<summary>
 Represents the members of the default namespace for this source file: all the
 top-level type and namespace declarations in the file. May also contain
 Statements that are not valid
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CompilationUnitSyntax.EndOfFileToken">
	<summary>
 Represents the end of the source file. This token may have trivia (whitespace,
 comments, ...) attached to it.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.CompilationUnitSyntax">
	<summary>
 Represents an entire source file of VB code.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.OptionStatementSyntax.OptionKeyword">
	<summary>
 The "Option" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.OptionStatementSyntax.NameKeyword">
	<summary>
 The keyword that identifies the option being set: Explicit, Strict, Compare or
 Infer.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.OptionStatementSyntax.ValueKeywordOpt">
	<summary>
 The keyword that identifiers the value being set for the opition: On, Off, Text
 or Binary.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.OptionStatementSyntax">
	<summary>
 Represents an Option statement, such as "Option Strict On".
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ImportsStatementSyntax.ImportsKeyword">
	<summary>
 The "Imports" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ImportsStatementSyntax.ImportsClauses">
	<summary>
 A list of one or more import clauses. Each clause is either an alias, namespace
 or XML namespace import.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ImportsStatementSyntax">
	<summary>
 Represents an Imports statement, which has one or more imports clauses.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ImportsClauseSyntax">
	<summary>
 The base class for the possible clauses of an Imports statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.AliasImportsClauseSyntax.Alias">
	<summary>
 The identifier that the alias is being defined for.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.AliasImportsClauseSyntax.EqualsToken">
	<summary>
 The equals sign token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.AliasImportsClauseSyntax.Name">
	<summary>
 The namespace or type the alias refers to.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.AliasImportsClauseSyntax">
	<summary>
 Represents the clause of an Imports statement that defines an alias for a
 namespace or type.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.MembersImportsClauseSyntax.Name">
	<summary>
 The namespace or type being imported.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.MembersImportsClauseSyntax">
	<summary>
 Represents the clause of an Imports statement that imports all members of a
 namespace.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlNamespaceImportsClauseSyntax.XmlNamespace">
	<summary>
 Identifies the XML namespace alias and URI.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlNamespaceImportsClauseSyntax">
	<summary>
 Defines a XML namespace for XML expressions.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.NamespaceBlockSyntax.Begin">
	<summary>
 The statement that begins the NamespaceBlock.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.NamespaceBlockSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.NamespaceBlockSyntax.Members">
	<summary>
 The declarations contained in the namespace statement.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.NamespaceBlockSyntax.End">
	<summary>
 The End Namespace statement that ends the block.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.NamespaceBlockSyntax">
	<summary>
 Represents a Namespace statement, its contents and the End Namespace statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.NamespaceStatementSyntax.NamespaceKeyword">
	<summary>
 The "Namespace" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.NamespaceStatementSyntax.Name">
	<summary>
 A (possibly dotted) name denoting the namespace being declared.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.NamespaceStatementSyntax">
	<summary>
 Represents the beginning statement of a namespace declaration. This node always
 appears as the Begin of a BlockStatement with Kind=NamespaceBlock.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeBlockSyntax.Begin">
	<summary>
 The statement that begins the type or module.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeBlockSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeBlockSyntax.Inherits">
	<summary>
 A list of the Inherits declarations for the type.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeBlockSyntax.Implements">
	<summary>
 A list of the Implements declarations for the type.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeBlockSyntax.Members">
	<summary>
 The declarations contained in the type or module.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeBlockSyntax.End">
	<summary>
 The End XXX statement that ends the block.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeBlockSyntax">
	<summary>
 Represents a declaration of a Class, Interface, Structure, Module, its contents
 and the End statement that ends it.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ModuleBlockSyntax">
	<summary>
 Represents a declaration of Module, its contents and the End statement that
 ends it.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.StructureBlockSyntax">
	<summary>
 Represents a declaration of a Structure, its contents and the End statement
 that ends it.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.InterfaceBlockSyntax">
	<summary>
 Represents a declaration of a Interface, its contents and the End statement
 that ends it.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ClassBlockSyntax">
	<summary>
 Represents a declaration of a Class its contents and the End statement that
 ends it.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.EnumBlockSyntax.Begin">
	<summary>
 The statement that begins the type or module.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.EnumBlockSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.EnumBlockSyntax.Members">
	<summary>
 The declarations contained in the enumeration.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.EnumBlockSyntax.End">
	<summary>
 The End XXX statement that ends the block.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.EnumBlockSyntax">
	<summary>
 Represents a declaration of an Enum, its contents and the End Enum statement
 that ends it.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.InheritsOrImplementsStatementSyntax">
	<summary>
 Represents an Inherits or Implements statement in a Class, Structure or
 Interface.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.InheritsStatementSyntax.InheritsKeyword">
	<summary>
 The "Inherits" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.InheritsStatementSyntax.Types">
	<summary>
 A list of the types being inherited.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.InheritsStatementSyntax">
	<summary>
 Represents an Inherits statement in a Class, Structure or Interface.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ImplementsStatementSyntax.ImplementsKeyword">
	<summary>
 The "Implements" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ImplementsStatementSyntax.Types">
	<summary>
 A list of the types being implemented.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ImplementsStatementSyntax">
	<summary>
 Represents an Implements statement in a Class or Structure.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeStatementSyntax.Attributes">
	<summary>
 A list of all attribute blocks on this declaration. If no attributes were
 specified, an empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeStatementSyntax.Modifiers">
	<summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeStatementSyntax.Keyword">
	<summary>
 The "Module", "Class", "Interface" or "Structure" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeStatementSyntax.Identifier">
	<summary>
 The name of the type being declared.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeStatementSyntax.TypeParameterListOpt">
	<summary>
 If present, a type parameter list with generic parameters for this type. If no
 generic parameters were present, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeStatementSyntax">
	<summary>
 Abstract class for the beginning statement of a Module, Class, Interface or
 Structure declaration. This node always appears as the Begin of a TypeBlock
 with Kind=ModuleDeclarationBlock, ClassDeclarationBlock,
 InterfaceDeclarationBlock or StructureDeclarationBlock.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ModuleStatementSyntax">
	<summary>
 Represents the beginning statement of a Module declaration. This node always
 appears as the Begin of a TypeBlock with Kind=ModuleDeclarationBlock.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.StructureStatementSyntax">
	<summary>
 Represents the beginning statement of a Structure declaration. This node always
 appears as the Begin of a TypeBlock with Kind=StructureDeclarationBlock.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.InterfaceStatementSyntax">
	<summary>
 Represents the beginning statement of a Interface declaration. This node always
 appears as the Begin of a TypeBlock with Kind=InterfaceDeclarationBlock.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ClassStatementSyntax">
	<summary>
 Represents the beginning statement of a Class declaration. This node always
 appears as the Begin of a TypeBlock with Kind=ClassDeclarationBlock.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.EnumStatementSyntax.Attributes">
	<summary>
 A list of all attribute blocks on this declaration. If no attributes were
 specified, an empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.EnumStatementSyntax.Modifiers">
	<summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.EnumStatementSyntax.EnumKeyword">
	<summary>
 The "Enum" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.EnumStatementSyntax.Identifier">
	<summary>
 The name of the enum being declared.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.EnumStatementSyntax.UnderlyingTypeOpt">
	<summary>
 Optional "As XXX" clause describing the underlying type of the enumeration. If
 no As clause was specified, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.EnumStatementSyntax">
	<summary>
 Represents the beginning statement of an Enum declaration. This node always
 appears as the Begin of an EnumBlock with Kind=EnumDeclarationBlock.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeParameterListSyntax.OpenParenToken">
	<summary>
 The "(" token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeParameterListSyntax.OfKeyword">
	<summary>
 The "Of" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeParameterListSyntax.Parameters">
	<summary>
 A list of the type parameters. There must be at least one type parameter in the
 list.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeParameterListSyntax.CloseParenToken">
	<summary>
 The ")" token.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeParameterListSyntax">
	<summary>
 Represents the type parameter list in a declaration.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeParameterSyntax.VarianceKeywordOpt">
	<summary>
 Represents the "In" or "Out" variance keyword on a type parameter, if present.
 If no variance modifier was present, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeParameterSyntax.Identifier">
	<summary>
 The name of the type parameter
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeParameterSyntax.TypeParameterConstraintClauseOpt">
	<summary>
 The "As" keyword, if any type constraints were supplied. If no type constraints
 were supplied, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeParameterSyntax">
	<summary>
 Represents a type parameter on a generic type declaration.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeParameterConstraintClauseSyntax">
	<summary>
 An abstract node class that is the parent of classes that describe type
 parameter constraint clauses.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeParameterSingleConstraintClauseSyntax.AsKeyword">
	<summary>
 The "As" keyword, if any type constraints were supplied. If no type constraints
 were supplied, Nothing is returned.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeParameterSingleConstraintClauseSyntax.Constraint">
	<summary>
 A list of the supplied constraints. If no constraints were supplied, Nothing is
 returned.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeParameterSingleConstraintClauseSyntax">
	<summary>
 One of the type parameter constraints clauses. This represents a constraint
 clause in the form of "As Constraint".
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeParameterMultipleConstraintClauseSyntax.AsKeyword">
	<summary>
 The "As" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeParameterMultipleConstraintClauseSyntax.OpenBraceToken">
	<summary>
 The "{" token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeParameterMultipleConstraintClauseSyntax.Constraints">
	<summary>
 A list of the supplied constraints. If no constraints were supplied, an empty
 list is returned.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeParameterMultipleConstraintClauseSyntax.CloseBraceToken">
	<summary>
 The "}" token.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeParameterMultipleConstraintClauseSyntax">
	<summary>
 One of the type parameter constraints clauses. This represents a constraint
 clause in the form of "As { Constraints }".
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ConstraintSyntax">
	<summary>
 An abstract node class that is the parent of classes that describe type
 parameter constraints.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SpecialConstraintSyntax.ConstraintKeyword">
	<summary>
 The "New", "Class" or "Structure" keyword that denotes the kind of special
 constraint.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.SpecialConstraintSyntax">
	<summary>
 One of the special type parameter constraints: New, Class or Structure. Which
 kind of special constraint it is can be obtained from the Kind property and is
 one of: NewConstraint, ReferenceConstraint or ValueConstraint.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeConstraintSyntax.Type">
	<summary>
 The type describing the constraint.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeConstraintSyntax">
	<summary>
 Represents a type parameter constraint that is a type.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.EnumMemberDeclarationSyntax.Attributes">
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.EnumMemberDeclarationSyntax.InitializerOpt">
	<summary>
 An optional value for the enum member.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.EnumMemberDeclarationSyntax">
	<summary>
 Represents a name and value in an EnumDeclarationBlock.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.MethodBlockSyntax.Begin">
	<summary>
 The declaration that begins the block.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.MethodBlockSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.MethodBlockSyntax.Statements">
	<summary>
 The statements contained in the block statement. This might be an empty list.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.MethodBlockSyntax.End">
	<summary>
 The End XXX statement that ends the block declaration.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.MethodBlockSyntax">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.PropertyBlockSyntax.Begin">
	<summary>
 The property declaration that begins the block.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.PropertyBlockSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.PropertyBlockSyntax.Accessors">
	<summary>
 The accessor blocks contained in the property, between the Property and the End
 Property statements.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.PropertyBlockSyntax.End">
	<summary>
 The End Property statement that ends the block.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.PropertyBlockSyntax">
	<summary>
 Represents a block property declaration: A declaration that has a beginning
 declaration, some get or set accessor blocks and an end statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.EventBlockSyntax.Begin">
	<summary>
 The event declaration that begins the block.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.EventBlockSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.EventBlockSyntax.Accessors">
	<summary>
 The accessor blocks contained in the custom event declaration, between the
 Event statement and the End Event statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.EventBlockSyntax.End">
	<summary>
 The End Event statement that ends the block.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.EventBlockSyntax">
	<summary>
 Represents a custom event declaration: A declaration that has a beginning event
 declaration, some accessor blocks and an end statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.MethodBaseSyntax.Attributes">
	<summary>
 A list of all attribute blocks on this declaration. If no attributes were
 specified, Nothing is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.MethodBaseSyntax.Modifiers">
	<summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.MethodBaseSyntax.Keyword">
	<summary>
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.MethodBaseSyntax.ParameterListOpt">
	<summary>
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.MethodBaseSyntax.AsClauseOpt">
	<summary>
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.MethodBaseSyntax">
	<summary>
 An abstract node class that is the parent for declarations that are
 "method-like"; i.e., that have a parameter list and return type. This includes
 methods, constructors, properties, events, operators, declares, delegates,
 property accessors and custom event accessors.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ParameterListSyntax.OpenParenToken">
	<summary>
 The "(" token that introduces the parameter list. If no parameter list was
 present, Nothing is returned.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ParameterListSyntax.Parameters">
	<summary>
 The list of parameters. If no parameter list was present, Nothing is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ParameterListSyntax.CloseParenToken">
	<summary>
 The ")" token that concludes the parameter list. If no parameter list was
 present, Nothing is returned.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ParameterListSyntax">
	<summary>
 Represents the parameter list in a method declaration.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.MethodStatementSyntax.Identifier">
	<summary>
 The name of the method being declared.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.MethodStatementSyntax.TypeParameterListOpt">
	<summary>
 If present, a type parameter list with generic type parameters for this method.
 If no generic type parameters were present, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.MethodStatementSyntax.HandlesClauseOpt">
	<summary>
 If present, a Handles clause indicated the events that this method handles.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.MethodStatementSyntax.ImplementsClauseOpt">
	<summary>
 If present, an Implements clause indicated the interface methods that this
 method implements.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.MethodStatementSyntax">
	<summary>
 The statement that declares a Sub or Function. If this method has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ConstructorStatementSyntax.NewKeyword">
	<summary>
 The "New" keyword in the constructor declaration.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ConstructorStatementSyntax">
	<summary>
 A statement that declares a constructor. This statement will be the Begin of a
 BlockStatement with Kind=MethodDeclarationBlock, and the body of the method
 will be the Body of that BlockStatement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.DeclareStatementSyntax.DeclareKeyword">
	<summary>
 The "Declare" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.DeclareStatementSyntax.CharsetKeywordOpt">
	<summary>
 If present, the keyword that defines the string translation semantics of the
 external method.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.DeclareStatementSyntax.Identifier">
	<summary>
 The name of the method being declared.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.DeclareStatementSyntax.LibKeyword">
	<summary>
 The "Lib" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.DeclareStatementSyntax.LibraryName">
	<summary>
 The string literal with the library name.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.DeclareStatementSyntax.AliasKeywordOpt">
	<summary>
 If present, the "Alias" keyword. If not present, returns Nothing.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.DeclareStatementSyntax.AliasNameOpt">
	<summary>
 The string literal with the alias. If not present, returns Nothing.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.DeclareStatementSyntax">
	<summary>
 A Declare statement that declares an external DLL method.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.DelegateStatementSyntax.DelegateKeyword">
	<summary>
 The "Delegate" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.DelegateStatementSyntax.Identifier">
	<summary>
 The name of the delegate being declared.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.DelegateStatementSyntax.TypeParameterListOpt">
	<summary>
 If present, a type parameter list with generic type parameters for this
 delegate. If no generic type parameters were present, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.DelegateStatementSyntax">
	<summary>
 A statement that declares a delegate type.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.EventStatementSyntax.CustomKeywordOpt">
	<summary>
 The optional Custom keyword for custom event declarations.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.EventStatementSyntax.Identifier">
	<summary>
 The name of the event being declared.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.EventStatementSyntax.ImplementsClauseOpt">
	<summary>
 If present, an Implements clause indicates the interface methods that this
 method implements.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.EventStatementSyntax">
	<summary>
 A statement that declares an event. If the event being declared is a custom
 event, this statement will be the Begin of a PropertyOrEventBlock, and the
 accessors will be part of the Accessors of that node.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.OperatorStatementSyntax.Operator">
	<summary>
 The operator being defined.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.OperatorStatementSyntax">
	<summary>
 A statement that declares an operator. If this operator has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.PropertyStatementSyntax.Identifier">
	<summary>
 The name of the property being declared.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.PropertyStatementSyntax.InitializerOpt">
	<summary>
 If present, an "= initial-value" clause describing the initial value of the
 property.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.PropertyStatementSyntax.ImplementsClauseOpt">
	<summary>
 If present, an Implements clause indicated the interface methods that this
 method implements.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.PropertyStatementSyntax">
	<summary>
 Statement that declares a property. If this property has accessors declared,
 this statement will be the Begin of a BlockNode, and the accessors will be the
 Body of that node. Auto properties are property declarations without a
 PropertyBlock.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.AccessorStatementSyntax">
	<summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ImplementsClauseSyntax.ImplementsKeyword">
	<summary>
 The "Implements" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ImplementsClauseSyntax.InterfaceMembers">
	<summary>
 The list of interface members being implemented.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ImplementsClauseSyntax">
	<summary>
 Represents the "Implements ..." clause on a type member, which describes which
 interface members this member implements.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.HandlesClauseSyntax.HandlesKeyword">
	<summary>
 The "Handles" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.HandlesClauseSyntax.Events">
	<summary>
 The list of event members being handled.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.HandlesClauseSyntax">
	<summary>
 Represents the "Handles ..." clause on a method declaration that describes
 which events this method handles.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.HandlesClauseItemSyntax.EventContainer">
	<summary>
 The container of the event. This can either be an simple identifier
 (identifying a members of the containing type) or one of the special keywords
 "Me", "MyBase" or "MyClass".
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.HandlesClauseItemSyntax.DotToken">
	<summary>
 The "." token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.HandlesClauseItemSyntax.EventMember">
	<summary>
 The event being handled. This must be a simple identifier.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.HandlesClauseItemSyntax">
	<summary>
 Represents a single handled event in a "Handles ..." clause.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.IncompleteMemberSyntax.Attributes">
	<summary>
 A list of all attribute blocks on this declaration. If no attributes were
 specified, an empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.IncompleteMemberSyntax.Modifiers">
	<summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.IncompleteMemberSyntax">
	<summary>
 Represents the beginning of a declaration. However, not enough syntax is
 detected to classify this as a field, method, property or event. This is node
 always represents a syntax error.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.FieldDeclarationSyntax.Attributes">
	<summary>
 A list of all attribute blocks on this declaration. If no attributes were
 specified, an empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.FieldDeclarationSyntax.Modifiers">
	<summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.FieldDeclarationSyntax.Declarators">
	<summary>
 The list of variable declarator. Each declarator specifies one or more variable
 names along with a type and/or initializer.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.FieldDeclarationSyntax">
	<summary>
 Represents the declaration of one or more variables or constants, either as
 local variables or as class/structure members. In the case of a constant, it is
 represented by having "Const" in the Modifiers (although technically "Const" is
 not a modifier, it is represented as one in the parse trees.)
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.VariableDeclaratorSyntax.Names">
	<summary>
 The names of the variables being declared. Each name might have a "?" or "()"
 modifier(s) attached.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.VariableDeclaratorSyntax.AsClauseOpt">
	<summary>
 The "As" clause that describes the return type, and possibly includes "New",
 "With" or "From". If no As clause was present, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.VariableDeclaratorSyntax.InitializerOpt">
	<summary>
 If present, an "= initial-value" clause describing the initial value of the
 variable or the value of the constant.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.VariableDeclaratorSyntax">
	<summary>
 Represents the part of a variable or constant declaration statement that
 associated one or more variable names with a type.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.AsClauseSyntax.AsKeyword">
	<summary>
 The "As" keyword.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.AsClauseSyntax">
	<summary>
 Abstract node class that represents the different kinds of "As {type-name}"
 clauses in a declaration: simple "As" clauses and "As New" clauses. The type
 has optional attributes associated with it, although attributes are not
 permitted in all possible places where this node occurs.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SimpleAsClauseSyntax.Attributes">
	<summary>
 A list of all attribute blocks on the type. If no attributes were specified, an
 empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SimpleAsClauseSyntax.Type">
	<summary>
 The type-name part of the As clause.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.SimpleAsClauseSyntax">
	<summary>
 Represents an "As {type-name}" clause that does not have an initializer or
 "New". The type has optional attributes associated with it, although attributes
 are not permitted in all possible places where this node occurs.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.AsNewClauseSyntax.NewExpression">
	<summary>
 The New expression
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.AsNewClauseSyntax">
	<summary>
 Represents an "As New {type-name} [arguments] [initializers]" clause in a
 declaration. The type has optional attributes associated with it, although
 attributes are not permitted in many places where this node occurs (they are
 permitted, for example, on automatically implemented properties.)
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ObjectCreationInitializerSyntax">
	<summary>
 An abstract node class that represents a "With" or "From" clause used to
 initializer an new object.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ObjectMemberInitializerSyntax.WithKeyword">
	<summary>
 The "With" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ObjectMemberInitializerSyntax.OpenBraceToken">
	<summary>
 The "{" token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ObjectMemberInitializerSyntax.Initializers">
	<summary>
 The comma-separated list of field initializers.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ObjectMemberInitializerSyntax.CloseBraceToken">
	<summary>
 The "}" token.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ObjectMemberInitializerSyntax">
	<summary>
 Represents a "With {...} clause used to initialize a new object's members.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ObjectCollectionInitializerSyntax.FromKeyword">
	<summary>
 The "From" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ObjectCollectionInitializerSyntax.Initializer">
	<summary>
 The initializer including the braces.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ObjectCollectionInitializerSyntax">
	<summary>
 Represents a "From {...} clause used to initialize a new collection object's
 elements.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.FieldInitializerSyntax.KeyKeywordOpt">
	<summary>
 The optional "Key" keyword.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.FieldInitializerSyntax">
	<summary>
 Abstract class that represent a single field initializer used in a "With {...}"
 field initializer list.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.InferredFieldInitializerSyntax.Expression">
	<summary>
 The value being assigned.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.InferredFieldInitializerSyntax">
	<summary>
 Represent a field initializer in a With {...} initializer where the field name
 is inferred from the initializer expression.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.NamedFieldInitializerSyntax.DotToken">
	<summary>
 The "." token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.NamedFieldInitializerSyntax.Identifier">
	<summary>
 The name of the field being initialized.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.NamedFieldInitializerSyntax.EqualsToken">
	<summary>
 The "=" token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.NamedFieldInitializerSyntax.Expression">
	<summary>
 The value being assigned to the field.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.NamedFieldInitializerSyntax">
	<summary>
 Represent a named field initializer in a With {...} initializer, such as ".x =
 expr".
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.EqualsValueSyntax.EqualsToken">
	<summary>
 The "=" token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.EqualsValueSyntax.Value">
	<summary>
 The expression used as the initial value.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.EqualsValueSyntax">
	<summary>
 Represents an "= initializer" clause in a declaration for a variable,
 pararameter or automatic property.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ParameterSyntax.Attributes">
	<summary>
 A list of all attribute blocks on this parameter. If no attributes were
 specified, Nothing is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ParameterSyntax.Modifiers">
	<summary>
 A list of the modifier tokens "ByVal", "ByRef", "Optional" or "ParamArray" that
 modify this parameter.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ParameterSyntax.Identifier">
	<summary>
 The name of the parameter, including any "?" or "()" modifiers.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ParameterSyntax.AsClauseOpt">
	<summary>
 If present, the "As type-name" clause describing the type of the parameter. If
 no As clause is present, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ParameterSyntax.DefaultOpt">
	<summary>
 If present, an initializer with the default value of the parameter. If no
 default value is present, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ParameterSyntax">
	<summary>
 Represent a parameter to a method, property, constructor, etc.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ModifiedIdentifierSyntax.Identifier">
	<summary>
 The identifier that names the item being declared.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ModifiedIdentifierSyntax.NullableOpt">
	<summary>
 The "?" token that indicates a nullable type.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ModifiedIdentifierSyntax.ArrayBoundsOpt">
	<summary>
 The optional array bounds, such as "(4)" or "(0 to 5, 0 To 6)".
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ModifiedIdentifierSyntax.ArrayRankSpecifiers">
	<summary>
 A list of array modifiers for the type. If no array modifiers were present, an
 empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ModifiedIdentifierSyntax">
	<summary>
 Represents an identifier with optional "?" or "()" or "(,,,)" modifiers, as
 used in parameter declarations and variable declarations.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ArrayRankSpecifierSyntax.OpenParenToken">
	<summary>
 The "(" token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ArrayRankSpecifierSyntax.CommaTokens">
	<summary>
 The comma tokens in the array type. There is one less comma than the rank.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ArrayRankSpecifierSyntax.CloseParenToken">
	<summary>
 The ")" token.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ArrayRankSpecifierSyntax">
	<summary>
 Represents a modifier that describes an array type, without bounds, such as
 "()" or "(,)".
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.AttributeBlockSyntax.LessThanToken">
	<summary>
 The "&amp;lt;" token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.AttributeBlockSyntax.Attributes">
	<summary>
 A comma separated list of attribute declarations in this attribute block.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.AttributeBlockSyntax.GreaterThanToken">
	<summary>
 The "&amp;gt;" token.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.AttributeBlockSyntax">
	<summary>
 Represents a group of attributes within "&amp;lt;" and "&amp;gt;" brackets.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.AttributeSyntax.TargetOpt">
	<summary>
 Optional attribute target. Assembly|Module :
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.AttributeSyntax.Name">
	<summary>
 The name of the attribute.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.AttributeSyntax.ArgumentListOpt">
	<summary>
 The argument list, if present. If no argument list was supplied, Nothing is
 returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.AttributeSyntax">
	<summary>
 Represents a single attribute declaration within an attribute block.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.AttributeTargetSyntax.AttributeModifier">
	<summary>
 The "Assembly" or "Module" attribute modifier, is present. If no attribute
 modifier is present, Nothing is returned.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.AttributeTargetSyntax.ColonToken">
	<summary>
 The ":" token, if an attribute modifier is present. If no attribute modifier is
 present, Nothing is returned.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.AttributeTargetSyntax">
	<summary>
 Represents a single attribute declaration within an attribute block.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.AttributesStatementSyntax.Attributes">
	<summary>
 The list of attribute blocks.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.AttributesStatementSyntax">
	<summary>
 Represents a file-level attribute, in which the attributes have no other
 syntactic element they are attached to.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.WhileBlockSyntax.Begin">
	<summary>
 The While statement that begins the block.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.WhileBlockSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.WhileBlockSyntax.Statements">
	<summary>
 The statements contained in the While...End While. This might be an empty list.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.WhileBlockSyntax.End">
	<summary>
 The End While statement that ends the block.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.WhileBlockSyntax">
	<summary>
 Represents a While...End While statement, including the While, body and End
 While.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.UsingBlockSyntax.Begin">
	<summary>
 The UsingStatement that begins the Using...End Using block.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.UsingBlockSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.UsingBlockSyntax.Statements">
	<summary>
 The statements contained in the Using...End Using block. This might be an empty
 list.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.UsingBlockSyntax.End">
	<summary>
 The End Using statement that ends the block.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.UsingBlockSyntax">
	<summary>
 Represents an entire Using...End Using statement, including the Using, body and
 End Using statements.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SyncLockBlockSyntax.Begin">
	<summary>
 The SyncLock statement that begins the block.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SyncLockBlockSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SyncLockBlockSyntax.Statements">
	<summary>
 The statements contained in the SyncLock...End SyncLock statement. This might
 be an empty list.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SyncLockBlockSyntax.End">
	<summary>
 The End SyncLock statement that ends the block.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.SyncLockBlockSyntax">
	<summary>
 Represents a entire SyncLock...End SyncLock block, including the SyncLock
 statement, the enclosed statements, and the End SyncLock statment.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.WithBlockSyntax.Begin">
	<summary>
 The WithStatement that begins the With...End With block.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.WithBlockSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.WithBlockSyntax.Statements">
	<summary>
 The statements contained in the With...End With block. This might be an empty
 list.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.WithBlockSyntax.End">
	<summary>
 The End With statement that ends the block.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.WithBlockSyntax">
	<summary>
 Represents a With...End With block, include the With statement, the body of the
 block and the End With statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.LocalDeclarationSyntax.Modifiers">
	<summary>
 The modifier token (Static, Dim or Const) that introduces this local variable
 declaration.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.LocalDeclarationSyntax.Declarators">
	<summary>
 The list of variable declarator. Each declarator specifies one or more variable
 names along with a type and/or initializer.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.LocalDeclarationSyntax">
	<summary>
 Represents the declaration of one or more local variables or constants.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.LabelStatementSyntax.LabelName">
	<summary>
 The name of the label. If the label is a line number, returns an IntegerLiteral
 that is the line number, otherwise, returns an Identifier.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.LabelStatementSyntax">
	<summary>
 Represents a label statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.GoToStatementSyntax.GoToKeyword">
	<summary>
 The "GoTo" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.GoToStatementSyntax.LabelName">
	<summary>
 The name of the label. If the label is a line number, returns an IntegerLiteral
 that is the line number, otherwise, returns an Identifier.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.GoToStatementSyntax">
	<summary>
 Represents a "GoTo" statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.StopOrEndStatementSyntax.StopOrEndKeyword">
	<summary>
 The "Stop" or "End" keyword.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.StopOrEndStatementSyntax">
	<summary>
 Represents a "Stop" or "End" statement. The Kind can be used to determine which
 kind of statement this is.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ExitStatementSyntax.ExitKeyword">
	<summary>
 The "Exit" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ExitStatementSyntax.BlockKeyword">
	<summary>
 The keyword describing the block to exit.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ExitStatementSyntax">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ContinueStatementSyntax.ContinueKeyword">
	<summary>
 The "Continue" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ContinueStatementSyntax.BlockKeyword">
	<summary>
 The "Do", "For" or "While" keyword that identifies the kind of loop being
 continued.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ContinueStatementSyntax">
	<summary>
 Represents a "Continue (block)" statement. THe kind of block referenced can be
 determined by examining the Kind.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ReturnStatementSyntax.ReturnKeyword">
	<summary>
 The "Return" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ReturnStatementSyntax.ExpressionOpt">
	<summary>
 The expression being returned, if present.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ReturnStatementSyntax">
	<summary>
 Represents a "Return" statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SingleLineIfStatementSyntax.IfPart">
	<summary>
 The If part of the statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SingleLineIfStatementSyntax.ElsePartOpt">
	<summary>
 The Else part of the statement. If there is no Else part, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.SingleLineIfStatementSyntax">
	<summary>
 Represents a line If-Then-Else statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SingleLineIfPartSyntax.Begin">
	<summary>
 The statement that introduces this part of the If...Then...Else...End If. This
 must be an IfStatement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SingleLineIfPartSyntax.Statements">
	<summary>
 The statements controlled by this If or Else If. This might be an empty list.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.SingleLineIfPartSyntax">
	<summary>
 Represents part of a single line If statement, consisting of a beginning
 if-statement, followed by a body of statement controlled by that beginning
 statement. The Kind property returns if this is an SingleLineIf.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SingleLineElsePartSyntax.Begin">
	<summary>
 The Else statement that introduces this part.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SingleLineElsePartSyntax.Statements">
	<summary>
 The statements controlled by the Else.This might be an empty list.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.SingleLineElsePartSyntax">
	<summary>
 Represents the Else part of an If statement, consisting of a Else statement,
 followed by a body of statement controlled by that Else.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.MultiLineIfBlockSyntax.IfPart">
	<summary>
 The If part of the statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.MultiLineIfBlockSyntax.ElseIfParts">
	<summary>
 A list of the "ElseIf" parts of the statement. If there are no ElseIf parts,
 then an empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.MultiLineIfBlockSyntax.ElsePartOpt">
	<summary>
 The Else part of the statement. If there is no Else part, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.MultiLineIfBlockSyntax.EndIf">
	<summary>
 If this is a block if, returns the "End If" statement.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.MultiLineIfBlockSyntax">
	<summary>
 Represents a block If...Then...Else...EndIf Statement. The Kind property can be
 used to determine if it is a block or line If.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.IfPartSyntax.Begin">
	<summary>
 The statement that introduces this part of the If...Then...Else...End If. This
 must be an IfStatement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.IfPartSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.IfPartSyntax.Statements">
	<summary>
 The statements controlled by this If or Else If. This might be an empty list.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.IfPartSyntax">
	<summary>
 Represents part of an If statement, consisting of a beginning statement (If or
 ElseIf), followed by a body of statement controlled by that beginning
 statement. The Kind property returns if this is an If or ElseIf.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ElsePartSyntax.Begin">
	<summary>
 The Else statement that introduces this part.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ElsePartSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ElsePartSyntax.Statements">
	<summary>
 The statements controlled by the Else. This might be an empty list.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ElsePartSyntax">
	<summary>
 Represents the Else part of an If statement, consisting of a Else statement,
 followed by a body of statement controlled by that Else.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.IfStatementSyntax.ElseKeywordOpt">
	<summary>
 If this ElseIf was written as "Else If", contains the "Else" keyword. Otherwise
 returns Nothing.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.IfStatementSyntax.IfOrElseIfKeyword">
	<summary>
 The "If" or "ElseIf" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.IfStatementSyntax.Condition">
	<summary>
 The boolean expression that is being tested.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.IfStatementSyntax.ThenKeywordOpt">
	<summary>
 The "Then" keyword.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.IfStatementSyntax">
	<summary>
 Represents the If part or ElseIf part of a If...End If block (or line If). This
 statement is always the Begin of a IfPart. The Kind can be examined to
 determine if this is an If or an ElseIf statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ElseStatementSyntax.ElseKeyword">
	<summary>
 The "Else" keyword
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ElseStatementSyntax">
	<summary>
 Represents the Else part of a If...End If block (or line If). This statement is
 always the Begin of a ElsePart.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TryBlockSyntax.TryPart">
	<summary>
 The Try part of the statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TryBlockSyntax.CatchParts">
	<summary>
 A list of the Catch parts of the statement. If there are no Catch parts, then
 an empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TryBlockSyntax.FinallyPartOpt">
	<summary>
 The Finally part of the statement, if present.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TryBlockSyntax.End">
	<summary>
 The "End Try" statement.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.TryBlockSyntax">
	<summary>
 Represents an entire Try...Catch...Finally...End Try statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TryPartSyntax.Begin">
	<summary>
 The TryStatement that introduces this part of the Try...Catch...Finally...End
 Try.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TryPartSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TryPartSyntax.Statements">
	<summary>
 The statements inside the Try part of the Try...Catch...Finally...End Try. This
 might be an empty list.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.TryPartSyntax">
	<summary>
 Represents part of an Try...Catch...Finally...End Try statement, consisting of
 a beginning statement (Try, Catch or Finally), followed by a body of statements
 controlled by that beginning statement. The Kind property returns which kind of
 part this is.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CatchPartSyntax.Begin">
	<summary>
 The CatchStatement that introduces this part.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CatchPartSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CatchPartSyntax.Statements">
	<summary>
 The statements controlled by the Catch statement. This might be an empty list.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.CatchPartSyntax">
	<summary>
 Represents a Catch part of an Try...Catch...Finally...End Try statement,
 consisting of a Catch statement, followed by a body of statements controlled by
 that Catch statement. The Kind property returns which kind of part this is.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.FinallyPartSyntax.Begin">
	<summary>
 The FinallyStatement that introduces the Finally part of a Try.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.FinallyPartSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.FinallyPartSyntax.Statements">
	<summary>
 The statements inside the Finally part of the Try...Catch...Finally...End Try.
 This might be an empty list.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.FinallyPartSyntax">
	<summary>
 Represents the Finally part of an Try...Catch...Finally...End Try statement,
 consisting of a Finally statement, followed by a body of statements controlled
 by the Finally.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TryStatementSyntax.TryKeyword">
	<summary>
 The "Try" keyword
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.TryStatementSyntax">
	<summary>
 Represents the Try part part of a Try...Catch...Finally...End Try. This
 statement is always the Begin of a TryPart.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CatchStatementSyntax.CatchKeyword">
	<summary>
 The "Catch" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CatchStatementSyntax.IdentifierOpt">
	<summary>
 The identifier representing the exception that was caught, if present.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CatchStatementSyntax.AsClauseOpt">
	<summary>
 The As clause that defines the type of exception being caught.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CatchStatementSyntax.WhenClauseOpt">
	<summary>
 The "When" clause, if present.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.CatchStatementSyntax">
	<summary>
 Represents the Catch part part of a Try...Catch...Finally...End Try. This
 statement is always the Begin of a CatchPart.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CatchFilterClauseSyntax.WhenKeyword">
	<summary>
 The "When" keyword
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CatchFilterClauseSyntax.Filter">
	<summary>
 The filter expression
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.CatchFilterClauseSyntax">
	<summary>
 Represents the When/Filter clause of a Catch statement
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.FinallyStatementSyntax.FinallyKeyword">
	<summary>
 The "Finally" keyword.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.FinallyStatementSyntax">
	<summary>
 Represents the Finally part part of a Try...Catch...Finally...End Try. This
 statement is always the Begin of a FinallyPart.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ErrorStatementSyntax.ErrorKeyword">
	<summary>
 The "Error" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ErrorStatementSyntax.ErrorNumber">
	<summary>
 The expression that represents the error number.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ErrorStatementSyntax">
	<summary>
 Represents the "Error" statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.OnErrorGoToStatementSyntax.OnKeyword">
	<summary>
 The "On" keyword
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.OnErrorGoToStatementSyntax.ErrorKeyword">
	<summary>
 The "Error" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.OnErrorGoToStatementSyntax.GoToKeyword">
	<summary>
 The "GoTo" keyword
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.OnErrorGoToStatementSyntax.MinusOpt">
	<summary>
 An optional minus for On Error Goto -1
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.OnErrorGoToStatementSyntax.Label">
	<summary>
 The name of the label. If the label is a line number, 0 or -1, returns an
 IntegerLiteralToken that is the line number, otherwise, returns an Identifier.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.OnErrorGoToStatementSyntax">
	<summary>
 Represents an OnError Goto statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.OnErrorResumeNextStatementSyntax.OnKeyword">
	<summary>
 The "On" keyword
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.OnErrorResumeNextStatementSyntax.ErrorKeyword">
	<summary>
 The "Error" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.OnErrorResumeNextStatementSyntax.ResumeKeyword">
	<summary>
 The "Resume" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.OnErrorResumeNextStatementSyntax.NextKeyword">
	<summary>
 The "Next"
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.OnErrorResumeNextStatementSyntax">
	<summary>
 Represents an OnError Resume Next statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ResumeStatementSyntax.ResumeKeyword">
	<summary>
 The "Resume" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ResumeStatementSyntax.LabelOpt">
	<summary>
 The label. The value of this depends on the Kind. If Kind=Resume, returns
 Nothing. If Kind=ResumeNext, returns the keyword "Next", If Kind=ResumeLabel,
 returns an Identifier or IntegerLiteralToken with the label or line number.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ResumeStatementSyntax">
	<summary>
 Represents a "Resume" statement. The Kind property can be used to determine if
 this is a "Resume", "Resume Next" or "Resume label" statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SelectBlockSyntax.Begin">
	<summary>
 The Select Case statement that begins the block.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SelectBlockSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SelectBlockSyntax.CaseBlocks">
	<summary>
 A list of the contained Case blocks.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SelectBlockSyntax.End">
	<summary>
 The End Select statement that ends the block.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.SelectBlockSyntax">
	<summary>
 Represents a Select Case block, including the Select Case that begins it, the
 contains Case blocks and the End Select.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SelectStatementSyntax.SelectKeyword">
	<summary>
 The "Select" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SelectStatementSyntax.CaseKeywordOpt">
	<summary>
 The "Case" keyword, if present.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SelectStatementSyntax.Expression">
	<summary>
 The value that branching is based on.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.SelectStatementSyntax">
	<summary>
 Represents a Select Case statement. This statement always occurs as the Begin
 of a SelectBlock.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CaseBlockSyntax.Begin">
	<summary>
 The statement that begins the case block.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CaseBlockSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CaseBlockSyntax.Statements">
	<summary>
 The statements contained in the case block. This might be an empty list.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.CaseBlockSyntax">
	<summary>
 Represents a case statement and its subsequent block.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CaseStatementSyntax.CaseKeyword">
	<summary>
 The "Case" keyword
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CaseStatementSyntax.Cases">
	<summary>
 A list of clauses associated with this Case. If Kind=CaseElse, then this list
 has exactly one child, which is a CaseElseClause.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.CaseStatementSyntax">
	<summary>
 Represents a Case or Case Else statement. This statement is always the Begin of
 a CaseBlock. If this is a Case Else statement, the Kind=CaseElse, otherwise the
 Kind=Case.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.CaseClauseSyntax">
	<summary>
 Represents a single clause in a case statement. An abstract node that is the
 parent of different kinds of Case clauses.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CaseElseClauseSyntax.ElseKeyword">
	<summary>
 The "Else" keyword.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.CaseElseClauseSyntax">
	<summary>
 The "Else" part in a Case Else statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CaseValueClauseSyntax.Value">
	<summary>
 The expression that denotes the value being tested against.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.CaseValueClauseSyntax">
	<summary>
 Represents a single value in a Case.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CaseRangeClauseSyntax.LowerBound">
	<summary>
 The lower bound of the range.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CaseRangeClauseSyntax.ToKeyword">
	<summary>
 The "To" keyword
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CaseRangeClauseSyntax.UpperBound">
	<summary>
 The upper bound of the range.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.CaseRangeClauseSyntax">
	<summary>
 Represents a range "expression To expression" in a Case.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CaseRelationalClauseSyntax.IsKeywordOpt">
	<summary>
 The "Is" keyword, if present.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CaseRelationalClauseSyntax.OperatorToken">
	<summary>
 The operator in the relational clause. One of "=", "&amp;lt;", "&amp;gt;",
 "&amp;lt;=" or "&amp;gt;=".
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CaseRelationalClauseSyntax.Value">
	<summary>
 The expression that denotes the value being tested against.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.CaseRelationalClauseSyntax">
	<summary>
 Represents a relation clause in a Case statement, such as "Is &amp;gt;
 expression".
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SyncLockStatementSyntax.SyncLockKeyword">
	<summary>
 The "SyncLock" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SyncLockStatementSyntax.Expression">
	<summary>
 The expression being synchronized on.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.SyncLockStatementSyntax">
	<summary>
 Represents the "SyncLock" statement. This statement always occurs as the Begin
 of a SyncLockBlock.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.DoLoopBlockSyntax.Begin">
	<summary>
 The Do statement that begins the block.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.DoLoopBlockSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.DoLoopBlockSyntax.Statements">
	<summary>
 The statements contained in the block statement. This might be an empty list.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.DoLoopBlockSyntax.End">
	<summary>
 The Loop statement that ends the block.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.DoLoopBlockSyntax">
	<summary>
 Represents a Do-Loop block. The Kind property can be used to determine if this
 is a top-test, bottom-test or infinite loop.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.DoStatementSyntax.DoKeyword">
	<summary>
 The "Do" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.DoStatementSyntax.WhileUntilClauseOpt">
	<summary>
 The "While expression" or "Until expression" part of the Do statement, if
 present.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.DoStatementSyntax">
	<summary>
 The Do statement that begins a Do-Loop block. This statement always occurs as
 the Begin of a DoLoopBlock.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.LoopStatementSyntax.LoopKeyword">
	<summary>
 The "Loop" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.LoopStatementSyntax.WhileUntilClauseOpt">
	<summary>
 The "While expression" or "Until expression" part of the Loop statement, if
 present.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.LoopStatementSyntax">
	<summary>
 The Loop statement that ends a Do-Loop block. This statement always occurs as
 the End of a DoLoopBlock.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.WhileUntilClauseSyntax.WhileOrUntilKeyword">
	<summary>
 The "While" or "Until" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.WhileUntilClauseSyntax.Condition">
	<summary>
 The boolean expression after the While or Until.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.WhileUntilClauseSyntax">
	<summary>
 Represents a "While expression" or "Until expression" in a Do or Loop
 statement. The Kind of the clause can be "WhileClause" or "UntilClause" to
 indicate which kind of clause.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.WhileStatementSyntax.WhileKeyword">
	<summary>
 The "While" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.WhileStatementSyntax.Condition">
	<summary>
 The boolean expression that controls the While loop.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.WhileStatementSyntax">
	<summary>
 The While statement that begins a While...End While block. This statement
 always occurs as the Begin of a WhileBlock.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ForBlockSyntax.Begin">
	<summary>
 The For or For Each statement that begins the block.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ForBlockSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ForBlockSyntax.Statements">
	<summary>
 The statements contained in the For or For Each loop. This might be an empty
 list.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ForBlockSyntax.EndOpt">
	<summary>
 The Next statement that ends the block. If two For statements are ended by a
 single Next statement, the inner For will not have an EndStatment.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ForBlockSyntax">
	<summary>
 Represents a For or For Each block, including the introducting statement, the
 body and the "Next" (which can be omitted if a containing For has a Next with
 multiple variables).
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ForStatementSyntax.ForKeyword">
	<summary>
 The "For" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ForStatementSyntax.ControlVariable">
	<summary>
 If the For or For Each statement is of a form that does not declare a new loop
 control variable, this is the expression that denotes the loop control
 variable. If this loop is of a form that does declare a new control variable,
 this is a VariableDeclarator that has the variable being declared.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ForStatementSyntax.EqualsToken">
	<summary>
 The "=" token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ForStatementSyntax.FromValue">
	<summary>
 The expression denoting the initial value of the iteration.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ForStatementSyntax.ToKeyword">
	<summary>
 The "To" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ForStatementSyntax.ToValue">
	<summary>
 The expression denoting the final value of the iteration.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ForStatementSyntax.StepClauseOpt">
	<summary>
 The optional Step clause.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ForStatementSyntax">
	<summary>
 The For statement that begins a For-Next block. This statement always occurs as
 the Begin of a ForBlock. Most of the time, the End of that ForBlock is the
 corresponding Next statement. However, multiple nested For statements are ended
 by a single Next statement with multiple variables, then the inner For
 statements will have End set to Nothing, and the Next statement is the End of
 the outermost For statement that is being ended.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ForStepClauseSyntax.StepKeyword">
	<summary>
 The "Step" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ForStepClauseSyntax.StepValue">
	<summary>
 The expression denoting the step increment.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ForStepClauseSyntax">
	<summary>
 The Step clause in a For Statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ForEachStatementSyntax.ForKeyword">
	<summary>
 The "For" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ForEachStatementSyntax.EachKeyword">
	<summary>
 The "Each" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ForEachStatementSyntax.ControlVariable">
	<summary>
 If the For or For Each statement is of a form that does not declare a new loop
 control variable, this is the expression that denotes the loop control
 variable. If this loop is of a form that does declare a new control variable,
 this is a VariableDeclarator that has the variable being declared.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ForEachStatementSyntax.InKeyword">
	<summary>
 The "In" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ForEachStatementSyntax.Expression">
	<summary>
 The expression denoting the collection to iterate over.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ForEachStatementSyntax">
	<summary>
 The For Each statement that begins a For Each-Next block. This statement always
 occurs as the Begin of a ForBlock, and the body of the For Each-Next is the
 Body of that ForBlock. Most of the time, the End of that ForBlock is the
 corresponding Next statement. However, multiple nested For statements are ended
 by a single Next statement with multiple variables, then the inner For
 statements will have End set to Nothing, and the Next statement is the End of
 the outermost For statement that is being ended.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.NextStatementSyntax.NextKeyword">
	<summary>
 The "Next" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.NextStatementSyntax.ControlVariables">
	<summary>
 The variables in the Next statement, if present
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.NextStatementSyntax">
	<summary>
 The Next statement that ends a For-Next or For Each-Next block. This statement
 always occurs as the End of a ForBlock (with Kind=ForBlock or ForEachBlock),
 and the body of the For-Next is the Body of that ForBlock. The Begin of that
 ForBlock has the corresponding For or For Each statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.UsingStatementSyntax.UsingKeyword">
	<summary>
 The "Using" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.UsingStatementSyntax.ExpressionOpt">
	<summary>
 If the Using statement is of a form that does not declare a new variable, this
 is the expression used in the using. Otherwise, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.UsingStatementSyntax.Variables">
	<summary>
 If the Using statement is of a form that declares one or more new variables,
 this is the list of variable declarations. Otherwise, Nothing is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.UsingStatementSyntax">
	<summary>
 The Using statement that begins a Using block. This statement always occurs as
 the Begin of a UsingBlock, and the body of the Using is the Body of that
 UsingBlock.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ThrowStatementSyntax.ThrowKeyword">
	<summary>
 The "Throw" keyword
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ThrowStatementSyntax.ExpressionOpt">
	<summary>
 The expression denoting the value being thrown.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ThrowStatementSyntax">
	<summary>
 Represents a Throw statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.AssignmentStatementSyntax.Left">
	<summary>
 The target (left hand side) of the assignment.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.AssignmentStatementSyntax.OperatorToken">
	<summary>
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&amp;lt;&amp;lt;=" or "&amp;gt;&amp;gt;=".
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.AssignmentStatementSyntax.Right">
	<summary>
 The source (right hand side) of the assignment.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.AssignmentStatementSyntax">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CallStatementSyntax.CallKeywordOpt">
	<summary>
 The "Call" keyword, if present.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CallStatementSyntax.Invocation">
	<summary>
 The expression denoting the call. This could be an Invocation or a MemberAccess
 (in the case where no parentheses were supplied.)
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.CallStatementSyntax">
	<summary>
 Represent an call statement (also known as a invocation statement).
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.AddRemoveHandlerStatementSyntax.AddHandlerOrRemoveHandlerKeyword">
	<summary>
 The "AddHandler" or "RemoveHandler" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.AddRemoveHandlerStatementSyntax.EventExpression">
	<summary>
 The event being accessed.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.AddRemoveHandlerStatementSyntax.CommaToken">
	<summary>
 The "," token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.AddRemoveHandlerStatementSyntax.DelegateExpression">
	<summary>
 The delegate being added or removed.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.AddRemoveHandlerStatementSyntax">
	<summary>
 Represents an AddHandler or RemoveHandler statement. The Kind property
 determines which one.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.RaiseEventStatementSyntax.RaiseEventKeyword">
	<summary>
 The "RaiseEvent" keyword
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.RaiseEventStatementSyntax.Identifier">
	<summary>
 The name of the event being raised.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.RaiseEventStatementSyntax.ArgumentListOpt">
	<summary>
 The argument list, if present.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.RaiseEventStatementSyntax">
	<summary>
 Represent a RaiseEvent statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.WithStatementSyntax.WithKeyword">
	<summary>
 The "With" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.WithStatementSyntax.Expression">
	<summary>
 The expression that is the operand of the With statement.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.WithStatementSyntax">
	<summary>
 Represents a "With" statement. This statement always occurs as the
 BeginStatement of a WithBlock, and the body of the With is the Body of that
 WithBlock.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ReDimStatementSyntax.ReDimKeyword">
	<summary>
 The "ReDim" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ReDimStatementSyntax.PreserveKeywordOpt">
	<summary>
 Returns Nothing if Kind=ReDim, returns the "Preserve" keyword if
 Kind=RedimPreserve.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ReDimStatementSyntax.Clauses">
	<summary>
 The list of ReDim clauses. Each clause is a Invocation node with an argument
 list denoting the new bounds for the array.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ReDimStatementSyntax">
	<summary>
 Represents a ReDim statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.EraseStatementSyntax.EraseKeyword">
	<summary>
 The "Erase" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.EraseStatementSyntax.Expressions">
	<summary>
 A list of expressions denoting the arrays to erase.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.EraseStatementSyntax">
	<summary>
 Represents an "Erase" statement.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax">
	<summary>
 An abstract base class for all node classes that define expressions.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.LiteralExpressionSyntax.Token">
	<summary>
 The token that represents the literal. The Kind property determines what type
 this property returns: Kind=IntegerLiteral ==&amp;gt; Returns
 IntegerLiteralToken. Kind=CharacterLiteral ==&amp;gt; Returns
 CharacterLiteralToken. Kind=DecimalLiteral ==&amp;gt; Returns
 DecimalLiteralToken Kind=FloatingLiteral ==&amp;gt; Returns
 FloatingLiteralToken Kind=DateLiteral ==&amp;gt; Returns DateLiteralToken
 Kind=StringLiteral ==&amp;gt; Returns StringLiteralToken Kind=BooleanLiteral
 ==&amp;gt; Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
 Kind=NothingLiteral ==&amp;gt; Returns Keyword (with it's kind being
 NothingKeyword)
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.LiteralExpressionSyntax">
	<summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ParenthesizedExpressionSyntax.OpenParenToken">
	<summary>
 The "(" token
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ParenthesizedExpressionSyntax.Expression">
	<summary>
 The expression inside the parentheses.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ParenthesizedExpressionSyntax.CloseParenToken">
	<summary>
 The ")" token
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ParenthesizedExpressionSyntax">
	<summary>
 Represents a parenthesized expression.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.InstanceExpressionSyntax.Keyword">
	<summary>
 The "Me", "MyClass" or "MyBase" keyword.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.InstanceExpressionSyntax">
	<summary>
 Identifies one of the special instances "Me", "MyClass" or "MyBase". The Kind
 property identifies which.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.MeExpressionSyntax">
	<summary>
 Identifies the special instance "Me"
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.MyBaseExpressionSyntax">
	<summary>
 Identifies the special instance "MyBase"
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.MyClassExpressionSyntax">
	<summary>
 Identifies the special instance "MyClass"
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.GetTypeExpressionSyntax.GetTypeKeyword">
	<summary>
 The "GetType" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.GetTypeExpressionSyntax.OpenParenToken">
	<summary>
 The "(" token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.GetTypeExpressionSyntax.Type">
	<summary>
 The type to get the Type object for. This can be an open generic type.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.GetTypeExpressionSyntax.CloseParenToken">
	<summary>
 The ")" token.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.GetTypeExpressionSyntax">
	<summary>
 Represents a GetType expression.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeOfIsExpressionSyntax.TypeOfKeyword">
	<summary>
 The "TypeOf" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeOfIsExpressionSyntax.Expression">
	<summary>
 The expression being tested.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeOfIsExpressionSyntax.IsKeyword">
	<summary>
 The "Is" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeOfIsExpressionSyntax.Type">
	<summary>
 The name of the type being tested against.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeOfIsExpressionSyntax">
	<summary>
 Represents a TypeOf...Is expression.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.GetXmlNamespaceExpressionSyntax.GetXmlNamespaceKeyword">
	<summary>
 The "GetXmlNamespace" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.GetXmlNamespaceExpressionSyntax.OpenParenToken">
	<summary>
 The "(" token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.GetXmlNamespaceExpressionSyntax.NameOpt">
	<summary>
 The Xml namespace name being referenced.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.GetXmlNamespaceExpressionSyntax.CloseParenToken">
	<summary>
 The ")" token.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.GetXmlNamespaceExpressionSyntax">
	<summary>
 Represents a GetXmlNamespace expression.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.MemberAccessExpressionSyntax.LeftOpt">
	<summary>
 The expression on the left-hand-side of the "." or "!" token.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.MemberAccessExpressionSyntax.Token">
	<summary>
 The "." or "!" token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.MemberAccessExpressionSyntax.Name">
	<summary>
 The identifier after the "." or "!" token.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.MemberAccessExpressionSyntax">
	<summary>
 Represents member access (.name) or dictionary access (!name). The Kind
 property determines which kind of access.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlMemberAccessExpressionSyntax.BaseOpt">
	<summary>
 The expression on the left-hand-side of the ".", ".@" or "..." .
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlMemberAccessExpressionSyntax.Token1">
	<summary>
 The initial dot "." part of the separator.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlMemberAccessExpressionSyntax.Token2Opt">
	<summary>
 The "@" part of .@ or the second "." of "...".
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlMemberAccessExpressionSyntax.Token3Opt">
	<summary>
 The third "." in a "..." separator.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlMemberAccessExpressionSyntax.Name">
	<summary>
 The identifier after the ".", ".@" or "..."
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlMemberAccessExpressionSyntax">
	<summary>
 Represents an XML member element access (node.&amp;lt;Element&amp;gt;),
 attribute access (node.@Attribute) or descendents access
 (node...&amp;lt;Descendent&amp;gt;). The Kind property determines which kind of
 access.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.InvocationExpressionSyntax.Expression">
	<summary>
 The target of the call or index expression.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.InvocationExpressionSyntax.ArgumentListOpt">
	<summary>
 The argument list.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.InvocationExpressionSyntax">
	<summary>
 Represents an invocation expression consisting of an invocation target and an
 optional argument list or an array, parameterized property or object default
 property index.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.NewExpressionSyntax.NewKeyword">
	<summary>
 The "New" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.NewExpressionSyntax.Attributes">
	<summary>
 A list of all attribute blocks on the type. If no attributes were specified, an
 empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.NewExpressionSyntax">
	<summary>
 Base class for object, array and anonymous object creation expressions
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ObjectCreationExpressionSyntax.Type">
	<summary>
 The type of the object being initialized.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ObjectCreationExpressionSyntax.ArgumentListOpt">
	<summary>
 The argument list, if present. If no argument list was supplied, Nothing is
 returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ObjectCreationExpressionSyntax.InitializerOpt">
	<summary>
 An optional From or With clause to initialize the new object.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ObjectCreationExpressionSyntax">
	<summary>
 Represents a New expression that creates a new non-array object, possibly with
 a "With" or "From" clause.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.AnonymousObjectCreationExpressionSyntax.Initializer">
	<summary>
 The With clause to initialize the new object.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.AnonymousObjectCreationExpressionSyntax">
	<summary>
 Represents a New expression that create an object of anonymous type.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ArrayCreationExpressionSyntax.Type">
	<summary>
 The element type of the array being created.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ArrayCreationExpressionSyntax.ArrayBoundsOpt">
	<summary>
 The optional array bounds, such as "(4)" or "(0 to 5, 0 To 6)".
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ArrayCreationExpressionSyntax.RankSpecifiers">
	<summary>
 A list of array modifiers such as "()" or "(,)". If no array modifiers were
 present, an empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ArrayCreationExpressionSyntax.Initializer">
	<summary>
 The initializer including the braces.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ArrayCreationExpressionSyntax">
	<summary>
 Represents an expression that creates a new array.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CollectionInitializerSyntax.OpenBraceToken">
	<summary>
 The "{" token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CollectionInitializerSyntax.Initializers">
	<summary>
 The list of initializers between the braces.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CollectionInitializerSyntax.CloseBraceToken">
	<summary>
 The "}" token.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.CollectionInitializerSyntax">
	<summary>
 Represents an expression that creates a new array wihout naming the element
 type.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CastExpressionSyntax.Keyword">
	<summary>
 The "CType", "DirectCast" or "TryCast" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CastExpressionSyntax.OpenParenToken">
	<summary>
 The "(" token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CastExpressionSyntax.Expression">
	<summary>
 The expression being cast.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CastExpressionSyntax.CommaToken">
	<summary>
 The "," token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CastExpressionSyntax.Type">
	<summary>
 The type the expression is being cast to.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CastExpressionSyntax.CloseParenToken">
	<summary>
 The ")" token.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.CastExpressionSyntax">
	<summary>
 Represents a CType, DirectCast or TryCast conversion expression. The Kind
 property determines which kind of cast it is.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.PredefinedCastExpressionSyntax.Keyword">
	<summary>
 The keyword that was used in the cast operation.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.PredefinedCastExpressionSyntax.OpenParenToken">
	<summary>
 The "(" token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.PredefinedCastExpressionSyntax.Expression">
	<summary>
 The expression being cast.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.PredefinedCastExpressionSyntax.CloseParenToken">
	<summary>
 The ")" token.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.PredefinedCastExpressionSyntax">
	<summary>
 Represents a cast to a pre-defined type using a pre-defined cast expression,
 such as CInt or CLng.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.BinaryExpressionSyntax.Left">
	<summary>
 The left operand.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.BinaryExpressionSyntax.Right">
	<summary>
 The right operand.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.BinaryExpressionSyntax">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.UnaryExpressionSyntax.OperatorToken">
	<summary>
 The token that is the operator.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.UnaryExpressionSyntax.Operand">
	<summary>
 The expression being operated on.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.UnaryExpressionSyntax">
	<summary>
 Describes a unary operator: Plus, Negate, Not or AddressOf.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.BinaryConditionalExpressionSyntax.IfKeyword">
	<summary>
 The "If" keyword
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.BinaryConditionalExpressionSyntax.OpenParenToken">
	<summary>
 The "(" token
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.BinaryConditionalExpressionSyntax.FirstExpression">
	<summary>
 The first expression inside the parentheses.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.BinaryConditionalExpressionSyntax.CommaToken">
	<summary>
 The "," token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.BinaryConditionalExpressionSyntax.SecondExpression">
	<summary>
 The second expression inside the parentheses.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.BinaryConditionalExpressionSyntax.CloseParenToken">
	<summary>
 The ")" token
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.BinaryConditionalExpressionSyntax">
	<summary>
 Represents a conditional expression, If(condition, true-expr, false-expr) or
 If(expr, nothing-expr).
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TernaryConditionalExpressionSyntax.IfKeyword">
	<summary>
 The "If" keyword
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TernaryConditionalExpressionSyntax.OpenParenToken">
	<summary>
 The "(" token
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TernaryConditionalExpressionSyntax.Condition">
	<summary>
 The first expression inside the parentheses.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TernaryConditionalExpressionSyntax.FirstCommaToken">
	<summary>
 The "," token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TernaryConditionalExpressionSyntax.WhenTrue">
	<summary>
 The second expression inside the parentheses.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TernaryConditionalExpressionSyntax.SecondCommaToken">
	<summary>
 The "," token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TernaryConditionalExpressionSyntax.WhenFalse">
	<summary>
 The second expression inside the parentheses.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TernaryConditionalExpressionSyntax.CloseParenToken">
	<summary>
 The ")" token
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.TernaryConditionalExpressionSyntax">
	<summary>
 Represents a conditional expression, If(condition, true-expr, false-expr) or
 If(expr, nothing-expr).
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.LambdaExpressionSyntax.Begin">
	<summary>
 The header part of the lambda that includes the "Sub" or "Function" keyword,
 the argument list and return type.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.LambdaExpressionSyntax.BeginTerminatorOpt">
	<summary>
 The statement terminator token that ended the Begin statement. Optional only
 for single line lambdas.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.LambdaExpressionSyntax">
	<summary>
 Represents a lambda expression, either single line or multi-line.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SingleLineLambdaExpressionSyntax.Body">
	<summary>
 The body of the lambda. Depending on the kind of lambda, this is either a
 Statement (single-line Sub lambda) or Expression (single-line Function).
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.SingleLineLambdaExpressionSyntax">
	<summary>
 Represents a single line lambda expression.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.MultiLineLambdaExpressionSyntax.Statements">
	<summary>
 The body of the lambda. Depending on the kind of lambda, this is either a
 StatementBody (multi-line lambda), Statement (single-line Sub lambda) or
 Expression (single-line Function). This might be an empty list.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.MultiLineLambdaExpressionSyntax.End">
	<summary>
 Returns the "End Sub" or "End Function" statement if this is a multi-line
 lambda.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.MultiLineLambdaExpressionSyntax">
	<summary>
 Represents a multi-line lambda expression.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.LambdaHeaderSyntax">
	<summary>
 Represents the header part of a lambda expression
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ArgumentListSyntax.OpenParenToken">
	<summary>
 The "(" token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ArgumentListSyntax.Arguments">
	<summary>
 The list of arguments. This may be empty. Ommitted argument are represented by
 an OmittedArgumentSyntax node.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ArgumentListSyntax.CloseParenToken">
	<summary>
 The ")" token.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ArgumentListSyntax">
	<summary>
 Represents a parenthesized argument list.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ArgumentSyntax">
	<summary>
 Base class for the possible kinds of arguments that can appear in an argument
 list.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.OmittedArgumentSyntax.Empty">
	<summary>
 An empty token because all non terminals must have a token.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.OmittedArgumentSyntax">
	<summary>
 Represents an omitted argument in an argument list. An omitted argument is not
 considered a syntax error but a valid case when no argument is required.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SimpleArgumentSyntax.Expression">
	<summary>
 The expression that is the argument.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.SimpleArgumentSyntax">
	<summary>
 Represents a simple argument that is just an expression.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.NamedArgumentSyntax.Identifier">
	<summary>
 The name used to identify the named argument.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.NamedArgumentSyntax.ColonEqualsToken">
	<summary>
 The ":=" token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.NamedArgumentSyntax.Expression">
	<summary>
 The expression that is the named argument.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.NamedArgumentSyntax">
	<summary>
 Represents a named argument, such as "Value:=7".
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.RangeArgumentSyntax.LowerBound">
	<summary>
 The lower bound of the range. This is typically the integer constant zero.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.RangeArgumentSyntax.ToKeyword">
	<summary>
 The "To" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.RangeArgumentSyntax.UpperBound">
	<summary>
 The upper bound of the range.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.RangeArgumentSyntax">
	<summary>
 Represents a range argument, such as "0 to 5", used in array bounds. The
 "Value" property represents the upper bound of the range.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.QueryExpressionSyntax.QueryOperators">
	<summary>
 A list of all the query operators in this query expression. This list always
 contains at least one operator.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.QueryExpressionSyntax">
	<summary>
 This class represents a query expression. A query expression is composed of one
 or more query operators in a row. The first query operator must be a From or
 Aggregate.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.QueryOperatorSyntax">
	<summary>
 This is a base class for all query operators.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CollectionRangeVariableSyntax.Identifier">
	<summary>
 The name of the range variable being defined.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CollectionRangeVariableSyntax.AsClauseOpt">
	<summary>
 Describes the type of the variable being defined.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CollectionRangeVariableSyntax.InKeyword">
	<summary>
 The "In" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CollectionRangeVariableSyntax.Expression">
	<summary>
 The expression that serves as the source of items for the range variable.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.CollectionRangeVariableSyntax">
	<summary>
 Describes a single variable of the form "x [As Type] In expression" for use in
 query expressions.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionRangeVariableSyntax.NameEqualsOpt">
	<summary>
 The optional name and type of the expression range variable. If ommitted, the
 name of the expression range variable is inferred from the expression.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionRangeVariableSyntax.Expression">
	<summary>
 The expression used to initialize the expression variable.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionRangeVariableSyntax">
	<summary>
 Describes a single variable of the form "[x [As Type] =] expression" for use in
 query expressions.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.AggregationRangeVariableSyntax.NameEqualsOpt">
	<summary>
 The optional name and type of the expression range variable. If ommitted, the
 name of the expression range variable is inferred from the aggregation
 expression.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.AggregationRangeVariableSyntax.Aggregation">
	<summary>
 The name of the aggregation function. The "Group" aggregation function is
 represented by the identifier "Group".
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.AggregationRangeVariableSyntax">
	<summary>
 Describes a single variable of the form "[x [As Type] =] aggregation-function"
 for use in the Into clause of Aggregate or Group By or Group Join query
 operators.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.VariableNameEqualsSyntax.Identifier">
	<summary>
 The name of the variable being defined.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.VariableNameEqualsSyntax.AsClauseOpt">
	<summary>
 Describes the type of the variable being defined.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.VariableNameEqualsSyntax.EqualsToken">
	<summary>
 The "=" token.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.VariableNameEqualsSyntax">
	<summary>
 Represents the name and optional type of an expression range variable.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.AggregationSyntax">
	<summary>
 Represents aggregation in aggregation range variable declaration of a Group By,
 Group Join or Aggregate query operator.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.FunctionAggregationSyntax.FunctionName">
	<summary>
 The name of the aggregation function.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.FunctionAggregationSyntax.OpenParenTokenOpt">
	<summary>
 The "(" token if present.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.FunctionAggregationSyntax.ArgumentOpt">
	<summary>
 The argument to the aggregation function.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.FunctionAggregationSyntax.CloseParenTokenOpt">
	<summary>
 The ")" token, if present.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.FunctionAggregationSyntax">
	<summary>
 Represents an invocation of an Aggregation function in the aggregation range
 variable declaration of a Group By, Group Join or Aggregate query operator.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.GroupAggregationSyntax.GroupKeyword">
	<summary>
 The "Group" keyword.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.GroupAggregationSyntax">
	<summary>
 Represents the use of "Group" as the aggregation function in the in the
 aggregation range variable declaration of a Group By or Group Join query
 operator.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.FromQueryOperatorSyntax.FromKeyword">
	<summary>
 The "From" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.FromQueryOperatorSyntax.Variables">
	<summary>
 The list of collection variables declared by this From operator.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.FromQueryOperatorSyntax">
	<summary>
 Represents a "From" query operator. If this is the beginning of a query, the
 Source will be Nothing. Otherwise, the Source will be the part of the query to
 the left of the From.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.LetQueryOperatorSyntax.LetKeyword">
	<summary>
 The "Let" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.LetQueryOperatorSyntax.Variables">
	<summary>
 The list of expression range variable being defined by the Let operator.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.LetQueryOperatorSyntax">
	<summary>
 Represents a "Let" query operator.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.AggregateQueryOperatorSyntax.AggregateKeyword">
	<summary>
 The "Aggregate" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.AggregateQueryOperatorSyntax.Variables">
	<summary>
 The list of collection range variables declared by this Aggregate operator.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.AggregateQueryOperatorSyntax.AdditionalQueryOperators">
	<summary>
 A list of additional query operators. It may be empty.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.AggregateQueryOperatorSyntax.IntoKeyword">
	<summary>
 The "Into" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.AggregateQueryOperatorSyntax.AggregationVariables">
	<summary>
 The list of new variables being defined by the aggregation.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.AggregateQueryOperatorSyntax">
	<summary>
 Represents an Aggregate query operator.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.DistinctQueryOperatorSyntax.DistinctKeyword">
	<summary>
 The "Distinct" keyword.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.DistinctQueryOperatorSyntax">
	<summary>
 Represents the "Distinct" query operator.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.WhereQueryOperatorSyntax.WhereKeyword">
	<summary>
 The "Where" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.WhereQueryOperatorSyntax.Condition">
	<summary>
 The boolean expression used for filtering.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.WhereQueryOperatorSyntax">
	<summary>
 Represents a "Where" query operator.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.PartitionWhileQueryOperatorSyntax.SkipOrTakeKeyword">
	<summary>
 The "Skip" or "Take" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.PartitionWhileQueryOperatorSyntax.WhileKeyword">
	<summary>
 The "While" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.PartitionWhileQueryOperatorSyntax.Condition">
	<summary>
 The boolean expression used for partitioning.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.PartitionWhileQueryOperatorSyntax">
	<summary>
 Represents a "Skip While" or "Take While" query operator. The Kind property
 tells which.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.PartitionQueryOperatorSyntax.SkipOrTakeKeyword">
	<summary>
 The "Skip" or "Take" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.PartitionQueryOperatorSyntax.Count">
	<summary>
 Represents the expression with the number of items to take or skip.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.PartitionQueryOperatorSyntax">
	<summary>
 Represents a "Skip" or "Take" query operator. The Kind property tells which.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.GroupByQueryOperatorSyntax.GroupKeyword">
	<summary>
 The "Group" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.GroupByQueryOperatorSyntax.Items">
	<summary>
 The optional list of variables being grouped; the contents of the Group clause.
 If none were specified, an empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.GroupByQueryOperatorSyntax.ByKeyword">
	<summary>
 The "By" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.GroupByQueryOperatorSyntax.Keys">
	<summary>
 The key values being used for grouping.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.GroupByQueryOperatorSyntax.AggregationVariables">
	<summary>
 The list of new variables that calculate aggregations.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.GroupByQueryOperatorSyntax">
	<summary>
 Represents the "Group By" query operator.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.JoinQueryOperatorSyntax.JoinKeyword">
	<summary>
 The "Join" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.JoinQueryOperatorSyntax.JoinedVariables">
	<summary>
 Defines the collection range variables being joined to.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.JoinQueryOperatorSyntax.AdditionalJoins">
	<summary>
 An additional Join or Group Join query operator.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.JoinQueryOperatorSyntax.OnKeyword">
	<summary>
 The "On" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.JoinQueryOperatorSyntax.JoinConditions">
	<summary>
 The conditions indicating what expressions to compare during the join. Each
 condition is a JoinCondition, and the separators are "And" keywords.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.JoinQueryOperatorSyntax">
	<summary>
 Represents a Join query operator.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.JoinConditionSyntax.Left">
	<summary>
 The left expression in the Join condition.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.JoinConditionSyntax.EqualsKeyword">
	<summary>
 The "Equals" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.JoinConditionSyntax.Right">
	<summary>
 The right expression in the Join condition.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.JoinConditionSyntax">
	<summary>
 Represents the "expression Equals expression" condition in a Join.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.GroupJoinQueryOperatorSyntax.GroupKeyword">
	<summary>
 The "Group" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.GroupJoinQueryOperatorSyntax.IntoKeyword">
	<summary>
 The "Into" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.GroupJoinQueryOperatorSyntax.AggregationVariables">
	<summary>
 The list of new variables that calculate aggregations.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.GroupJoinQueryOperatorSyntax">
	<summary>
 Represents the "Group Join" query operator.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.OrderByQueryOperatorSyntax.OrderKeyword">
	<summary>
 The "Order" keyword
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.OrderByQueryOperatorSyntax.ByKeyword">
	<summary>
 The "By" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.OrderByQueryOperatorSyntax.Orderings">
	<summary>
 The list of OrderExpression's to sort by.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.OrderByQueryOperatorSyntax">
	<summary>
 Represents the "Order By" query operator.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.OrderingSyntax.Expression">
	<summary>
 The expression to sort by.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.OrderingSyntax.AscendingOrDescendingKeywordOpt">
	<summary>
 The "Ascending" or "Descending" keyword, if present. To determine whether to
 sort in ascending or descending order, checking the Kind property is easier.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.OrderingSyntax">
	<summary>
 An expression to order by, plus an optional ordering. The Kind indicates
 whether to order in ascending or descending order.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SelectQueryOperatorSyntax.SelectKeyword">
	<summary>
 The "Select" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SelectQueryOperatorSyntax.Variables">
	<summary>
 The list of expression range variables being defined by the Select query
 operator.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.SelectQueryOperatorSyntax">
	<summary>
 Represents the "Select" query operator.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlNodeSyntax">
	<summary>
 This is the base class for all XML expression syntax nodes (XmlDocument and
 XmlElement).
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlDocumentSyntax.PrecedingMisc">
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlDocumentSyntax.FollowingMisc">
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlDocumentSyntax">
	<summary>
 Represents and XML Document literal expression.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlDeclarationSyntax.EncodingOpt">
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlDeclarationSyntax.StandaloneOpt">
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlDeclarationSyntax">
	<summary>
 Represents the XML declaration prologue in an XML literal expression.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlDeclarationOptionSyntax">
	<summary>
 Represents an XML document prologue option - version, encoding, standalone or
 whitespace in an XML literal expression.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlElementSyntax.Content">
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlElementSyntax">
	<summary>
 Represents an XML element with content in an XML literal expression.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlTextSyntax.TextTokens">
	<summary>
 A list of all the text tokens in the Xml text. This list always contains at
 least one token.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlTextSyntax">
	<summary>
 Represents Xml text.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlElementStartTagSyntax.Attributes">
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlElementStartTagSyntax">
	<summary>
 Represents the start tag of an XML element of the form &amp;lt;element&amp;gt;.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlElementEndTagSyntax.NameOpt">
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlElementEndTagSyntax">
	<summary>
 Represents the end tag of an XML element of the form &amp;lt;/element&amp;gt;.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlEmptyElementSyntax.Attributes">
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlEmptyElementSyntax">
	<summary>
 Represents an empty XML element of the form &amp;lt;element /&amp;gt;
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlAttributeSyntax">
	<summary>
 Represents an XML attribute in an XML literal expression.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlStringSyntax.TextTokens">
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlStringSyntax">
	<summary>
 Represents a string of XML characters embedded as the content of an XML
 element.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlNameSyntax.PrefixOpt">
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlNameSyntax">
	<summary>
 Represents an XML name of the form 'name' or 'namespace:name' appearing in
 source as part of an XML literal or member access expression or an XML
 namespace import clause.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlBracketedNameSyntax">
	<summary>
 Represents an XML name of the form &amp;lt;xml-name&amp;gt; appearing in source
 as part of an XML literal or member access expression or an XML namespace
 import clause.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlPrefixSyntax">
	<summary>
 Represents and XML namespace prefix of the form 'prefix:' as in xml:ns="".
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlCommentSyntax">
	<summary>
 Represents an XML comment of the form &amp;lt;-- Comment --&amp;gt; appearing
 in an XML literal expression.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlProcessingInstructionSyntax">
	<summary>
 Represents an XML processing instruction of the form '&amp;lt;?
 XMLProcessingTarget XMLProcessingValue ?&amp;gt;'.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlCDataSectionSyntax">
	<summary>
 Represents an XML CDATA section in an XML literal expression.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlEmbeddedExpressionSyntax">
	<summary>
 Represents an embedded expression in an XML literal e.g.
 '&amp;lt;name&amp;gt;&amp;lt;%= obj.Name =%&amp;gt;&amp;lt;/name&amp;gt;'.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeSyntax">
	<summary>
 Abstract node class that represents the textual description of a type, possibly
 include generic type arguments, qualified names, array specifiers, nullable
 specifier and the like.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ArrayTypeSyntax.ElementType">
	<summary>
 The type of the elements of the array.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ArrayTypeSyntax.RankSpecifiers">
	<summary>
 Represents the list of "()" or "(,,)" modifiers on the array type.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ArrayTypeSyntax">
	<summary>
 Represents an array type, such as "A() or "A(,)", without bounds specified for
 the array.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.NullableTypeSyntax.ElementType">
	<summary>
 The kind of type that is this type is a nullable of. Cannot be an array type or
 a nullable type.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.NullableTypeSyntax.QuestionMarkToken">
	<summary>
 The "?" token.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.NullableTypeSyntax">
	<summary>
 A type name that represents a nullable type, such as "Integer?".
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.PredefinedTypeSyntax.Keyword">
	<summary>
 The keyword that was used to describe the built-in type.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.PredefinedTypeSyntax">
	<summary>
 Represents an occurrence of a Visual Basic built-in type such as Integer or
 String in source code.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.NameSyntax">
	<summary>
 Abstract node class that represents a name, possibly include generic arguments
 and qualified names.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SimpleNameSyntax.Identifier">
	<summary>
 The identifier in the name.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.SimpleNameSyntax">
	<summary>
 Abstract node class that represents a name, possibly include generic arguments.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierNameSyntax">
	<summary>
 Represents a type name consisting of a single identifier (which might include
 brackets or a type character).
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.GenericNameSyntax.TypeArgumentList">
	<summary>
 The generic argument list.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.GenericNameSyntax">
	<summary>
 Represents a simple type name with one or more generic arguments, such as "X(Of
 Y, Z).
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.QualifiedNameSyntax.Left">
	<summary>
 The part of the name that appears to the left of the dot. This can itself be
 any name.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.QualifiedNameSyntax.DotToken">
	<summary>
 The "." token that seperates the names.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.QualifiedNameSyntax.Right">
	<summary>
 The part of the name that appears to the right of the dot. This must be a
 simple identifier.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.QualifiedNameSyntax">
	<summary>
 Represents a qualified type name, for example X.Y or X(Of Z).Y.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.GlobalNameSyntax.GlobalKeyword">
	<summary>
 The "Global" keyword.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.GlobalNameSyntax">
	<summary>
 Represents a name in the global namespace.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeArgumentListSyntax.OpenParenToken">
	<summary>
 The "(" token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeArgumentListSyntax.OfKeyword">
	<summary>
 The "Of" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeArgumentListSyntax.Arguments">
	<summary>
 A list of all the type arguments.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeArgumentListSyntax.CloseParenToken">
	<summary>
 The ")" token.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeArgumentListSyntax">
	<summary>
 Represents a parenthesized list of generic type arguments.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken">
	<summary>
 Represents a single syntactic token in a VB program. A token is a keyword,
 punctuator, literal, identifier or XML token. The type of keyword or punctuator
 can be determined from the Kind property.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlNameTokenSyntax">
	<summary>
 Represents an Xml NCName per Namespaces in XML 1.0
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlTextTokenSyntax.Value">
	<summary>
 The text of the attribute or pcdata after normalization.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlTextTokenSyntax">
	<summary>
 Represents character data in Xml content also known as PCData or in an Xml
 attribute value. All text is here for now even text that does not need
 normalizationsuch as comment, pi and cdata text.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.DecimalLiteralTokenSyntax.TypeSuffix">
	<summary>
 The type suffix or type character that was on the literal, if any. If no suffix
 was present, TypeCharacter.None is returned.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.DecimalLiteralTokenSyntax.Value">
	<summary>
 The value of the token.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.DecimalLiteralTokenSyntax">
	<summary>
 Represents a Decimal literal token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.DateLiteralTokenSyntax.Value">
	<summary>
 The value of the token.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.DateLiteralTokenSyntax">
	<summary>
 Represents an Date literal token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.StringLiteralTokenSyntax.Value">
	<summary>
 The value of the string, after removing the quotation marks and combining
 doubled quotation marks.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.StringLiteralTokenSyntax">
	<summary>
 Represents an string literal token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CharacterLiteralTokenSyntax.Value">
	<summary>
 The value of the character, after removing the quotation marks.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.CharacterLiteralTokenSyntax">
	<summary>
 Represents an string literal token.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.StructuredTriviaSyntax">
	<summary>
 Abstract class that represent structured trivia.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SkippedTokensSyntax.Tokens">
	<summary>
 The list of tokens that were skipped by the parser.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.SkippedTokensSyntax">
	<summary>
 Represents tokens that were skipped by the parser as part of error recovery,
 and thus are not part of any syntactic structure.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.DocumentationCommentSyntax.Content">
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.DocumentationCommentSyntax">
	<summary>
 Represents a documentation comment e.g. ''' &amp;lt;Summary&amp;gt; apearing in
 source.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.DirectiveSyntax.Terminator">
	<summary>
 The statement terminator token that ended the Directive.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.DirectiveSyntax">
	<summary>
 Represents a preprocessor directive
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxTrivia">
	<summary>
 Trivia nodes represents parts of the program text that are not parts of the
 syntactic grammar, such as spaces, newlines, comments, preprocessors
 directives, and disabled code.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.DirectiveStatementSyntax.HashToken">
	<summary>
 The "#" token in a preprocessor directive.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.DirectiveStatementSyntax">
	<summary>
 Represents a pre-processing directive (such as #If, #Const or #Region)
 appearing in source.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ConstDirectiveSyntax.ConstKeyword">
	<summary>
 The "Const" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ConstDirectiveSyntax.Name">
	<summary>
 The name of the pre-processing constant being defined.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ConstDirectiveSyntax.EqualsToken">
	<summary>
 The "=" token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ConstDirectiveSyntax.Value">
	<summary>
 An expression representing the value of the pre-processing constant being
 defined.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ConstDirectiveSyntax">
	<summary>
 Represents a #Const pre-processing constant declaration appearing in source.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.IfDirectiveSyntax.ElseKeywordOpt">
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.IfDirectiveSyntax.ThenKeywordOpt">
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.IfDirectiveSyntax">
	<summary>
 Represents the beginning of an #If pre-processing directive appearing in
 source.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ElseDirectiveSyntax">
	<summary>
 Represents an #Else pre-processing directive appearing in source.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.EndIfDirectiveSyntax">
	<summary>
 Represents an #End If pre-processing directive appearing in source.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.RegionDirectiveSyntax.RegionKeyword">
	<summary>
 The "Region" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.RegionDirectiveSyntax.Name">
	<summary>
 The label of the code region being defined.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.RegionDirectiveSyntax">
	<summary>
 Represents the beginning of a #Region directive appearing in source.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.EndRegionDirectiveSyntax.EndKeyword">
	<summary>
 The "End" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.EndRegionDirectiveSyntax.RegionKeyword">
	<summary>
 The "Region" keyword.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.EndRegionDirectiveSyntax">
	<summary>
 Represents an #End Region directive appearing in source.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ExternalSourceDirectiveSyntax">
	<summary>
 Represents the beginning of a #ExternalSource pre-processing directive
 appearing in source.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.EndExternalSourceDirective">
	<summary>
 Represents an #End ExternalSource pre-processing directive appearing in source.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ExternalChecksumDirectiveSyntax">
	<summary>
 Represents an #ExternalChecksum pre-processing directive appearing in source.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.BadDirectiveSyntax">
	<summary>
 Represents an unrecognized pre-processing directive. This occurs when the
 parser encounters a hash '#' token at the beginning of a physical line but does
 recognize the text that follows as a valid Visual Basic pre-processing
 directive.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EmptyStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 A class to represent an empty statement. This can occur when a colon is on a
 line without anything else.
 </summary>
	<param name="empty">
 An empty token because all non terminals must have a token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EndIfStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EndUsingStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EndWithStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EndSelectStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EndStructureStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EndEnumStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EndInterfaceStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EndClassStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EndModuleStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EndNamespaceStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EndSubStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EndFunctionStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EndGetStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EndSetStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EndPropertyStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EndOperatorStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EndEventStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EndAddHandlerStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EndRemoveHandlerStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EndRaiseEventStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EndWhileStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EndTryStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EndSyncLockStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EndBlockStatement(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="kind">
 A &amp;lt;cref c="SyntaxKind"/&amp;gt; representing the specific kind of
 EndBlockStatementSyntax. One of EndIfStatement, EndUsingStatement,
 EndWithStatement, EndSelectStatement, EndStructureStatement, EndEnumStatement,
 EndInterfaceStatement, EndClassStatement, EndModuleStatement,
 EndNamespaceStatement, EndSubStatement, EndFunctionStatement, EndGetStatement,
 EndSetStatement, EndPropertyStatement, EndOperatorStatement, EndEventStatement,
 EndAddHandlerStatement, EndRemoveHandlerStatement, EndRaiseEventStatement,
 EndWhileStatement, EndTryStatement, EndSyncLockStatement.
 </param>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.CompilationUnit(Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.OptionStatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.ImportsStatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.AttributesStatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents an entire source file of VB code.
 </summary>
	<param name="options">
 Represents the list of Option statements at the beginning of a source file.
 </param>
	<param name="imports">
 Represents the list of Imports statements at the beginning of a source file.
 </param>
	<param name="attributes">
 Represents the list of AttributeStatements at the beginning of a source file
 that contain the Assembly and Module attributes.
 </param>
	<param name="members">
 Represents the members of the default namespace for this source file: all the
 top-level type and namespace declarations in the file. May also contain
 Statements that are not valid
 </param>
	<param name="endOfFileToken">
 Represents the end of the source file. This token may have trivia (whitespace,
 comments, ...) attached to it.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.OptionStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents an Option statement, such as "Option Strict On".
 </summary>
	<param name="optionKeyword">
 The "Option" keyword.
 </param>
	<param name="nameKeyword">
 The keyword that identifies the option being set: Explicit, Strict, Compare or
 Infer.
 </param>
	<param name="valueKeywordOpt">
 The keyword that identifiers the value being set for the opition: On, Off, Text
 or Binary.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ImportsStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.ImportsClauseSyntax})">
	<summary>
 Represents an Imports statement, which has one or more imports clauses.
 </summary>
	<param name="importsKeyword">
 The "Imports" keyword.
 </param>
	<param name="importsClauses">
 A list of one or more import clauses. Each clause is either an alias, namespace
 or XML namespace import.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.AliasImportsClause(Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.NameSyntax)">
	<summary>
 Represents the clause of an Imports statement that defines an alias for a
 namespace or type.
 </summary>
	<param name="alias">
 The identifier that the alias is being defined for.
 </param>
	<param name="equalsToken">
 The equals sign token.
 </param>
	<param name="name">
 The namespace or type the alias refers to.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.MembersImportsClause(Roslyn.Compilers.VisualBasic.InternalSyntax.NameSyntax)">
	<summary>
 Represents the clause of an Imports statement that imports all members of a
 namespace.
 </summary>
	<param name="name">
 The namespace or type being imported.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.XmlNamespaceImportsClause(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.XmlAttributeSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Defines a XML namespace for XML expressions.
 </summary>
	<param name="xmlNamespace">
 Identifies the XML namespace alias and URI.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.NamespaceBlock(Roslyn.Compilers.VisualBasic.InternalSyntax.NamespaceStatementSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.EndBlockStatementSyntax)">
	<summary>
 Represents a Namespace statement, its contents and the End Namespace statement.
 </summary>
	<param name="begin">
 The statement that begins the NamespaceBlock.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="members">
 The declarations contained in the namespace statement.
 </param>
	<param name="end">
 The End Namespace statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.NamespaceStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.NameSyntax)">
	<summary>
 Represents the beginning statement of a namespace declaration. This node always
 appears as the Begin of a BlockStatement with Kind=NamespaceBlock.
 </summary>
	<param name="namespaceKeyword">
 The "Namespace" keyword.
 </param>
	<param name="name">
 A (possibly dotted) name denoting the namespace being declared.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ModuleBlock(Roslyn.Compilers.VisualBasic.InternalSyntax.TypeStatementSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.InheritsStatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.ImplementsStatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.EndBlockStatementSyntax)">
	<summary>
 Represents a declaration of Module, its contents and the End statement that
 ends it.
 </summary>
	<param name="begin">
 The statement that begins the type or module.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="inherits">
 A list of the Inherits declarations for the type.
 </param>
	<param name="implements">
 A list of the Implements declarations for the type.
 </param>
	<param name="members">
 The declarations contained in the type or module.
 </param>
	<param name="end">
 The End XXX statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.StructureBlock(Roslyn.Compilers.VisualBasic.InternalSyntax.TypeStatementSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.InheritsStatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.ImplementsStatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.EndBlockStatementSyntax)">
	<summary>
 Represents a declaration of a Structure, its contents and the End statement
 that ends it.
 </summary>
	<param name="begin">
 The statement that begins the type or module.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="inherits">
 A list of the Inherits declarations for the type.
 </param>
	<param name="implements">
 A list of the Implements declarations for the type.
 </param>
	<param name="members">
 The declarations contained in the type or module.
 </param>
	<param name="end">
 The End XXX statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.InterfaceBlock(Roslyn.Compilers.VisualBasic.InternalSyntax.TypeStatementSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.InheritsStatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.ImplementsStatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.EndBlockStatementSyntax)">
	<summary>
 Represents a declaration of a Interface, its contents and the End statement
 that ends it.
 </summary>
	<param name="begin">
 The statement that begins the type or module.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="inherits">
 A list of the Inherits declarations for the type.
 </param>
	<param name="implements">
 A list of the Implements declarations for the type.
 </param>
	<param name="members">
 The declarations contained in the type or module.
 </param>
	<param name="end">
 The End XXX statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ClassBlock(Roslyn.Compilers.VisualBasic.InternalSyntax.TypeStatementSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.InheritsStatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.ImplementsStatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.EndBlockStatementSyntax)">
	<summary>
 Represents a declaration of a Class its contents and the End statement that
 ends it.
 </summary>
	<param name="begin">
 The statement that begins the type or module.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="inherits">
 A list of the Inherits declarations for the type.
 </param>
	<param name="implements">
 A list of the Implements declarations for the type.
 </param>
	<param name="members">
 The declarations contained in the type or module.
 </param>
	<param name="end">
 The End XXX statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EnumBlock(Roslyn.Compilers.VisualBasic.InternalSyntax.EnumStatementSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.EnumMemberDeclarationSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.EndBlockStatementSyntax)">
	<summary>
 Represents a declaration of an Enum, its contents and the End Enum statement
 that ends it.
 </summary>
	<param name="begin">
 The statement that begins the type or module.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="members">
 The declarations contained in the enumeration.
 </param>
	<param name="end">
 The End XXX statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.InheritsStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.TypeSyntax})">
	<summary>
 Represents an Inherits statement in a Class, Structure or Interface.
 </summary>
	<param name="inheritsKeyword">
 The "Inherits" keyword.
 </param>
	<param name="types">
 A list of the types being inherited.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ImplementsStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.TypeSyntax})">
	<summary>
 Represents an Implements statement in a Class or Structure.
 </summary>
	<param name="implementsKeyword">
 The "Implements" keyword.
 </param>
	<param name="types">
 A list of the types being implemented.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ModuleStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.TypeParameterListSyntax)">
	<summary>
 Represents the beginning statement of a Module declaration. This node always
 appears as the Begin of a TypeBlock with Kind=ModuleDeclarationBlock.
 </summary>
	<param name="attributes">
 A list of all attribute blocks on this declaration. If no attributes were
 specified, an empty list is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </param>
	<param name="keyword">
 The "Module", "Class", "Interface" or "Structure" keyword.
 </param>
	<param name="identifier">
 The name of the type being declared.
 </param>
	<param name="typeParameterListOpt">
 If present, a type parameter list with generic parameters for this type. If no
 generic parameters were present, Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.StructureStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.TypeParameterListSyntax)">
	<summary>
 Represents the beginning statement of a Structure declaration. This node always
 appears as the Begin of a TypeBlock with Kind=StructureDeclarationBlock.
 </summary>
	<param name="attributes">
 A list of all attribute blocks on this declaration. If no attributes were
 specified, an empty list is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </param>
	<param name="keyword">
 The "Module", "Class", "Interface" or "Structure" keyword.
 </param>
	<param name="identifier">
 The name of the type being declared.
 </param>
	<param name="typeParameterListOpt">
 If present, a type parameter list with generic parameters for this type. If no
 generic parameters were present, Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.InterfaceStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.TypeParameterListSyntax)">
	<summary>
 Represents the beginning statement of a Interface declaration. This node always
 appears as the Begin of a TypeBlock with Kind=InterfaceDeclarationBlock.
 </summary>
	<param name="attributes">
 A list of all attribute blocks on this declaration. If no attributes were
 specified, an empty list is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </param>
	<param name="keyword">
 The "Module", "Class", "Interface" or "Structure" keyword.
 </param>
	<param name="identifier">
 The name of the type being declared.
 </param>
	<param name="typeParameterListOpt">
 If present, a type parameter list with generic parameters for this type. If no
 generic parameters were present, Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ClassStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.TypeParameterListSyntax)">
	<summary>
 Represents the beginning statement of a Class declaration. This node always
 appears as the Begin of a TypeBlock with Kind=ClassDeclarationBlock.
 </summary>
	<param name="attributes">
 A list of all attribute blocks on this declaration. If no attributes were
 specified, an empty list is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </param>
	<param name="keyword">
 The "Module", "Class", "Interface" or "Structure" keyword.
 </param>
	<param name="identifier">
 The name of the type being declared.
 </param>
	<param name="typeParameterListOpt">
 If present, a type parameter list with generic parameters for this type. If no
 generic parameters were present, Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EnumStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.AsClauseSyntax)">
	<summary>
 Represents the beginning statement of an Enum declaration. This node always
 appears as the Begin of an EnumBlock with Kind=EnumDeclarationBlock.
 </summary>
	<param name="attributes">
 A list of all attribute blocks on this declaration. If no attributes were
 specified, an empty list is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </param>
	<param name="enumKeyword">
 The "Enum" keyword.
 </param>
	<param name="identifier">
 The name of the enum being declared.
 </param>
	<param name="underlyingTypeOpt">
 Optional "As XXX" clause describing the underlying type of the enumeration. If
 no As clause was specified, Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.TypeParameterList(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.TypeParameterSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents the type parameter list in a declaration.
 </summary>
	<param name="openParenToken">
 The "(" token.
 </param>
	<param name="ofKeyword">
 The "Of" keyword.
 </param>
	<param name="parameters">
 A list of the type parameters. There must be at least one type parameter in the
 list.
 </param>
	<param name="closeParenToken">
 The ")" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.TypeParameter(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.TypeParameterConstraintClauseSyntax)">
	<summary>
 Represents a type parameter on a generic type declaration.
 </summary>
	<param name="varianceKeywordOpt">
 Represents the "In" or "Out" variance keyword on a type parameter, if present.
 If no variance modifier was present, Nothing is returned.
 </param>
	<param name="identifier">
 The name of the type parameter
 </param>
	<param name="typeParameterConstraintClauseOpt">
 The "As" keyword, if any type constraints were supplied. If no type constraints
 were supplied, Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.TypeParameterSingleConstraintClause(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ConstraintSyntax)">
	<summary>
 One of the type parameter constraints clauses. This represents a constraint
 clause in the form of "As Constraint".
 </summary>
	<param name="asKeyword">
 The "As" keyword, if any type constraints were supplied. If no type constraints
 were supplied, Nothing is returned.
 </param>
	<param name="constraint">
 A list of the supplied constraints. If no constraints were supplied, Nothing is
 returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.TypeParameterMultipleConstraintClause(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.ConstraintSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 One of the type parameter constraints clauses. This represents a constraint
 clause in the form of "As { Constraints }".
 </summary>
	<param name="asKeyword">
 The "As" keyword.
 </param>
	<param name="openBraceToken">
 The "{" token.
 </param>
	<param name="constraints">
 A list of the supplied constraints. If no constraints were supplied, an empty
 list is returned.
 </param>
	<param name="closeBraceToken">
 The "}" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.NewConstraint(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 One of the special type parameter constraints: New, Class or Structure. Which
 kind of special constraint it is can be obtained from the Kind property and is
 one of: NewConstraint, ReferenceConstraint or ValueConstraint.
 </summary>
	<param name="constraintKeyword">
 The "New", "Class" or "Structure" keyword that denotes the kind of special
 constraint.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ClassConstraint(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 One of the special type parameter constraints: New, Class or Structure. Which
 kind of special constraint it is can be obtained from the Kind property and is
 one of: NewConstraint, ReferenceConstraint or ValueConstraint.
 </summary>
	<param name="constraintKeyword">
 The "New", "Class" or "Structure" keyword that denotes the kind of special
 constraint.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.StructureConstraint(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 One of the special type parameter constraints: New, Class or Structure. Which
 kind of special constraint it is can be obtained from the Kind property and is
 one of: NewConstraint, ReferenceConstraint or ValueConstraint.
 </summary>
	<param name="constraintKeyword">
 The "New", "Class" or "Structure" keyword that denotes the kind of special
 constraint.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.SpecialConstraint(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 One of the special type parameter constraints: New, Class or Structure. Which
 kind of special constraint it is can be obtained from the Kind property and is
 one of: NewConstraint, ReferenceConstraint or ValueConstraint.
 </summary>
	<param name="kind">
 A &amp;lt;cref c="SyntaxKind"/&amp;gt; representing the specific kind of
 SpecialConstraintSyntax. One of NewConstraint, ClassConstraint,
 StructureConstraint.
 </param>
	<param name="constraintKeyword">
 The "New", "Class" or "Structure" keyword that denotes the kind of special
 constraint.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.TypeConstraint(Roslyn.Compilers.VisualBasic.InternalSyntax.TypeSyntax)">
	<summary>
 Represents a type parameter constraint that is a type.
 </summary>
	<param name="type">
 The type describing the constraint.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EnumMemberDeclaration(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.EqualsValueSyntax)">
	<summary>
 Represents a name and value in an EnumDeclarationBlock.
 </summary>
	<param name="initializerOpt">
 An optional value for the enum member.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.SubBlock(Roslyn.Compilers.VisualBasic.InternalSyntax.MethodBaseSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.EndBlockStatementSyntax)">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
	<param name="begin">
 The declaration that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The End XXX statement that ends the block declaration.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.FunctionBlock(Roslyn.Compilers.VisualBasic.InternalSyntax.MethodBaseSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.EndBlockStatementSyntax)">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
	<param name="begin">
 The declaration that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The End XXX statement that ends the block declaration.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ConstructorBlock(Roslyn.Compilers.VisualBasic.InternalSyntax.MethodBaseSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.EndBlockStatementSyntax)">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
	<param name="begin">
 The declaration that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The End XXX statement that ends the block declaration.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.OperatorBlock(Roslyn.Compilers.VisualBasic.InternalSyntax.MethodBaseSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.EndBlockStatementSyntax)">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
	<param name="begin">
 The declaration that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The End XXX statement that ends the block declaration.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.PropertyGetBlock(Roslyn.Compilers.VisualBasic.InternalSyntax.MethodBaseSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.EndBlockStatementSyntax)">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
	<param name="begin">
 The declaration that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The End XXX statement that ends the block declaration.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.PropertySetBlock(Roslyn.Compilers.VisualBasic.InternalSyntax.MethodBaseSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.EndBlockStatementSyntax)">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
	<param name="begin">
 The declaration that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The End XXX statement that ends the block declaration.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.AddHandlerBlock(Roslyn.Compilers.VisualBasic.InternalSyntax.MethodBaseSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.EndBlockStatementSyntax)">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
	<param name="begin">
 The declaration that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The End XXX statement that ends the block declaration.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.RemoveHandlerBlock(Roslyn.Compilers.VisualBasic.InternalSyntax.MethodBaseSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.EndBlockStatementSyntax)">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
	<param name="begin">
 The declaration that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The End XXX statement that ends the block declaration.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.RaiseEventBlock(Roslyn.Compilers.VisualBasic.InternalSyntax.MethodBaseSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.EndBlockStatementSyntax)">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
	<param name="begin">
 The declaration that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The End XXX statement that ends the block declaration.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.MethodBlock(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.InternalSyntax.MethodBaseSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.EndBlockStatementSyntax)">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
	<param name="kind">
 A &amp;lt;cref c="SyntaxKind"/&amp;gt; representing the specific kind of
 MethodBlockSyntax. One of SubBlock, FunctionBlock, ConstructorBlock,
 OperatorBlock, PropertyGetBlock, PropertySetBlock, AddHandlerBlock,
 RemoveHandlerBlock, RaiseEventBlock.
 </param>
	<param name="begin">
 The declaration that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The End XXX statement that ends the block declaration.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.PropertyBlock(Roslyn.Compilers.VisualBasic.InternalSyntax.PropertyStatementSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.MethodBlockSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.EndBlockStatementSyntax)">
	<summary>
 Represents a block property declaration: A declaration that has a beginning
 declaration, some get or set accessor blocks and an end statement.
 </summary>
	<param name="begin">
 The property declaration that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="accessors">
 The accessor blocks contained in the property, between the Property and the End
 Property statements.
 </param>
	<param name="end">
 The End Property statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EventBlock(Roslyn.Compilers.VisualBasic.InternalSyntax.EventStatementSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.MethodBlockSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.EndBlockStatementSyntax)">
	<summary>
 Represents a custom event declaration: A declaration that has a beginning event
 declaration, some accessor blocks and an end statement.
 </summary>
	<param name="begin">
 The event declaration that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="accessors">
 The accessor blocks contained in the custom event declaration, between the
 Event statement and the End Event statement.
 </param>
	<param name="end">
 The End Event statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ParameterList(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.ParameterSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents the parameter list in a method declaration.
 </summary>
	<param name="openParenToken">
 The "(" token that introduces the parameter list. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="parameters">
 The list of parameters. If no parameter list was present, Nothing is returned.
 </param>
	<param name="closeParenToken">
 The ")" token that concludes the parameter list. If no parameter list was
 present, Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.SubStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.TypeParameterListSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ParameterListSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.AsClauseSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.HandlesClauseSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ImplementsClauseSyntax)">
	<summary>
 The statement that declares a Sub or Function. If this method has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
	<param name="attributes">
 A list of all attribute blocks on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="identifier">
 The name of the method being declared.
 </param>
	<param name="typeParameterListOpt">
 If present, a type parameter list with generic type parameters for this method.
 If no generic type parameters were present, Nothing is returned.
 </param>
	<param name="parameterListOpt">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClauseOpt">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
	<param name="handlesClauseOpt">
 If present, a Handles clause indicated the events that this method handles.
 </param>
	<param name="implementsClauseOpt">
 If present, an Implements clause indicated the interface methods that this
 method implements.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.FunctionStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.TypeParameterListSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ParameterListSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.AsClauseSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.HandlesClauseSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ImplementsClauseSyntax)">
	<summary>
 The statement that declares a Sub or Function. If this method has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
	<param name="attributes">
 A list of all attribute blocks on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="identifier">
 The name of the method being declared.
 </param>
	<param name="typeParameterListOpt">
 If present, a type parameter list with generic type parameters for this method.
 If no generic type parameters were present, Nothing is returned.
 </param>
	<param name="parameterListOpt">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClauseOpt">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
	<param name="handlesClauseOpt">
 If present, a Handles clause indicated the events that this method handles.
 </param>
	<param name="implementsClauseOpt">
 If present, an Implements clause indicated the interface methods that this
 method implements.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.MethodStatement(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.TypeParameterListSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ParameterListSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.AsClauseSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.HandlesClauseSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ImplementsClauseSyntax)">
	<summary>
 The statement that declares a Sub or Function. If this method has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
	<param name="kind">
 A &amp;lt;cref c="SyntaxKind"/&amp;gt; representing the specific kind of
 MethodStatementSyntax. One of SubStatement, FunctionStatement.
 </param>
	<param name="attributes">
 A list of all attribute blocks on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="identifier">
 The name of the method being declared.
 </param>
	<param name="typeParameterListOpt">
 If present, a type parameter list with generic type parameters for this method.
 If no generic type parameters were present, Nothing is returned.
 </param>
	<param name="parameterListOpt">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClauseOpt">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
	<param name="handlesClauseOpt">
 If present, a Handles clause indicated the events that this method handles.
 </param>
	<param name="implementsClauseOpt">
 If present, an Implements clause indicated the interface methods that this
 method implements.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ConstructorStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ParameterListSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.AsClauseSyntax)">
	<summary>
 A statement that declares a constructor. This statement will be the Begin of a
 BlockStatement with Kind=MethodDeclarationBlock, and the body of the method
 will be the Body of that BlockStatement.
 </summary>
	<param name="attributes">
 A list of all attribute blocks on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="newKeyword">
 The "New" keyword in the constructor declaration.
 </param>
	<param name="parameterListOpt">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClauseOpt">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.DeclareSubStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.LiteralExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.LiteralExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ParameterListSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.AsClauseSyntax)">
	<summary>
 A Declare statement that declares an external DLL method.
 </summary>
	<param name="attributes">
 A list of all attribute blocks on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="declareKeyword">
 The "Declare" keyword.
 </param>
	<param name="charsetKeywordOpt">
 If present, the keyword that defines the string translation semantics of the
 external method.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="identifier">
 The name of the method being declared.
 </param>
	<param name="libKeyword">
 The "Lib" keyword.
 </param>
	<param name="libraryName">
 The string literal with the library name.
 </param>
	<param name="aliasKeywordOpt">
 If present, the "Alias" keyword. If not present, returns Nothing.
 </param>
	<param name="aliasNameOpt">
 The string literal with the alias. If not present, returns Nothing.
 </param>
	<param name="parameterListOpt">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClauseOpt">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.DeclareFunctionStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.LiteralExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.LiteralExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ParameterListSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.AsClauseSyntax)">
	<summary>
 A Declare statement that declares an external DLL method.
 </summary>
	<param name="attributes">
 A list of all attribute blocks on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="declareKeyword">
 The "Declare" keyword.
 </param>
	<param name="charsetKeywordOpt">
 If present, the keyword that defines the string translation semantics of the
 external method.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="identifier">
 The name of the method being declared.
 </param>
	<param name="libKeyword">
 The "Lib" keyword.
 </param>
	<param name="libraryName">
 The string literal with the library name.
 </param>
	<param name="aliasKeywordOpt">
 If present, the "Alias" keyword. If not present, returns Nothing.
 </param>
	<param name="aliasNameOpt">
 The string literal with the alias. If not present, returns Nothing.
 </param>
	<param name="parameterListOpt">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClauseOpt">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.DeclareStatement(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.LiteralExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.LiteralExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ParameterListSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.AsClauseSyntax)">
	<summary>
 A Declare statement that declares an external DLL method.
 </summary>
	<param name="kind">
 A &amp;lt;cref c="SyntaxKind"/&amp;gt; representing the specific kind of
 DeclareStatementSyntax. One of DeclareSubStatement, DeclareFunctionStatement.
 </param>
	<param name="attributes">
 A list of all attribute blocks on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="declareKeyword">
 The "Declare" keyword.
 </param>
	<param name="charsetKeywordOpt">
 If present, the keyword that defines the string translation semantics of the
 external method.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="identifier">
 The name of the method being declared.
 </param>
	<param name="libKeyword">
 The "Lib" keyword.
 </param>
	<param name="libraryName">
 The string literal with the library name.
 </param>
	<param name="aliasKeywordOpt">
 If present, the "Alias" keyword. If not present, returns Nothing.
 </param>
	<param name="aliasNameOpt">
 The string literal with the alias. If not present, returns Nothing.
 </param>
	<param name="parameterListOpt">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClauseOpt">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.DelegateSubStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.TypeParameterListSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ParameterListSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.AsClauseSyntax)">
	<summary>
 A statement that declares a delegate type.
 </summary>
	<param name="attributes">
 A list of all attribute blocks on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="delegateKeyword">
 The "Delegate" keyword.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="identifier">
 The name of the delegate being declared.
 </param>
	<param name="typeParameterListOpt">
 If present, a type parameter list with generic type parameters for this
 delegate. If no generic type parameters were present, Nothing is returned.
 </param>
	<param name="parameterListOpt">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClauseOpt">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.DelegateFunctionStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.TypeParameterListSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ParameterListSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.AsClauseSyntax)">
	<summary>
 A statement that declares a delegate type.
 </summary>
	<param name="attributes">
 A list of all attribute blocks on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="delegateKeyword">
 The "Delegate" keyword.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="identifier">
 The name of the delegate being declared.
 </param>
	<param name="typeParameterListOpt">
 If present, a type parameter list with generic type parameters for this
 delegate. If no generic type parameters were present, Nothing is returned.
 </param>
	<param name="parameterListOpt">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClauseOpt">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.DelegateStatement(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.TypeParameterListSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ParameterListSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.AsClauseSyntax)">
	<summary>
 A statement that declares a delegate type.
 </summary>
	<param name="kind">
 A &amp;lt;cref c="SyntaxKind"/&amp;gt; representing the specific kind of
 DelegateStatementSyntax. One of DelegateSubStatement,
 DelegateFunctionStatement.
 </param>
	<param name="attributes">
 A list of all attribute blocks on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="delegateKeyword">
 The "Delegate" keyword.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="identifier">
 The name of the delegate being declared.
 </param>
	<param name="typeParameterListOpt">
 If present, a type parameter list with generic type parameters for this
 delegate. If no generic type parameters were present, Nothing is returned.
 </param>
	<param name="parameterListOpt">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClauseOpt">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EventStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ParameterListSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.AsClauseSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ImplementsClauseSyntax)">
	<summary>
 A statement that declares an event. If the event being declared is a custom
 event, this statement will be the Begin of a PropertyOrEventBlock, and the
 accessors will be part of the Accessors of that node.
 </summary>
	<param name="attributes">
 A list of all attribute blocks on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="customKeywordOpt">
 The optional Custom keyword for custom event declarations.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="identifier">
 The name of the event being declared.
 </param>
	<param name="parameterListOpt">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClauseOpt">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
	<param name="implementsClauseOpt">
 If present, an Implements clause indicates the interface methods that this
 method implements.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.OperatorStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken,Roslyn.Compilers.VisualBasic.InternalSyntax.ParameterListSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.AsClauseSyntax)">
	<summary>
 A statement that declares an operator. If this operator has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
	<param name="attributes">
 A list of all attribute blocks on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="operator">
 The operator being defined.
 </param>
	<param name="parameterListOpt">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClauseOpt">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.PropertyStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ParameterListSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.AsClauseSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.EqualsValueSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ImplementsClauseSyntax)">
	<summary>
 Statement that declares a property. If this property has accessors declared,
 this statement will be the Begin of a BlockNode, and the accessors will be the
 Body of that node. Auto properties are property declarations without a
 PropertyBlock.
 </summary>
	<param name="attributes">
 A list of all attribute blocks on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="identifier">
 The name of the property being declared.
 </param>
	<param name="parameterListOpt">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClauseOpt">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
	<param name="initializerOpt">
 If present, an "= initial-value" clause describing the initial value of the
 property.
 </param>
	<param name="implementsClauseOpt">
 If present, an Implements clause indicated the interface methods that this
 method implements.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.GetAccessorStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ParameterListSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.AsClauseSyntax)">
	<summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
	<param name="attributes">
 A list of all attribute blocks on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="parameterListOpt">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClauseOpt">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.SetAccessorStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ParameterListSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.AsClauseSyntax)">
	<summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
	<param name="attributes">
 A list of all attribute blocks on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="parameterListOpt">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClauseOpt">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.AddHandlerAccessorStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ParameterListSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.AsClauseSyntax)">
	<summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
	<param name="attributes">
 A list of all attribute blocks on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="parameterListOpt">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClauseOpt">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.RemoveHandlerAccessorStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ParameterListSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.AsClauseSyntax)">
	<summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
	<param name="attributes">
 A list of all attribute blocks on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="parameterListOpt">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClauseOpt">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.RaiseEventHandlerAccessorStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ParameterListSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.AsClauseSyntax)">
	<summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
	<param name="attributes">
 A list of all attribute blocks on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="parameterListOpt">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClauseOpt">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.AccessorStatement(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ParameterListSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.AsClauseSyntax)">
	<summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
	<param name="kind">
 A &amp;lt;cref c="SyntaxKind"/&amp;gt; representing the specific kind of
 AccessorStatementSyntax. One of GetAccessorStatement, SetAccessorStatement,
 AddHandlerAccessorStatement, RemoveHandlerAccessorStatement,
 RaiseEventHandlerAccessorStatement.
 </param>
	<param name="attributes">
 A list of all attribute blocks on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="parameterListOpt">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClauseOpt">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ImplementsClause(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.QualifiedNameSyntax})">
	<summary>
 Represents the "Implements ..." clause on a type member, which describes which
 interface members this member implements.
 </summary>
	<param name="implementsKeyword">
 The "Implements" keyword.
 </param>
	<param name="interfaceMembers">
 The list of interface members being implemented.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.HandlesClause(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.HandlesClauseItemSyntax})">
	<summary>
 Represents the "Handles ..." clause on a method declaration that describes
 which events this method handles.
 </summary>
	<param name="handlesKeyword">
 The "Handles" keyword.
 </param>
	<param name="events">
 The list of event members being handled.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.HandlesClauseItem(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax)">
	<summary>
 Represents a single handled event in a "Handles ..." clause.
 </summary>
	<param name="eventContainer">
 The container of the event. This can either be an simple identifier
 (identifying a members of the containing type) or one of the special keywords
 "Me", "MyBase" or "MyClass".
 </param>
	<param name="dotToken">
 The "." token.
 </param>
	<param name="eventMember">
 The event being handled. This must be a simple identifier.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.IncompleteMember(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode})">
	<summary>
 Represents the beginning of a declaration. However, not enough syntax is
 detected to classify this as a field, method, property or event. This is node
 always represents a syntax error.
 </summary>
	<param name="attributes">
 A list of all attribute blocks on this declaration. If no attributes were
 specified, an empty list is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.FieldDeclaration(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.VariableDeclaratorSyntax})">
	<summary>
 Represents the declaration of one or more variables or constants, either as
 local variables or as class/structure members. In the case of a constant, it is
 represented by having "Const" in the Modifiers (although technically "Const" is
 not a modifier, it is represented as one in the parse trees.)
 </summary>
	<param name="attributes">
 A list of all attribute blocks on this declaration. If no attributes were
 specified, an empty list is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </param>
	<param name="declarators">
 The list of variable declarator. Each declarator specifies one or more variable
 names along with a type and/or initializer.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.VariableDeclarator(Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.ModifiedIdentifierSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.AsClauseSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.EqualsValueSyntax)">
	<summary>
 Represents the part of a variable or constant declaration statement that
 associated one or more variable names with a type.
 </summary>
	<param name="names">
 The names of the variables being declared. Each name might have a "?" or "()"
 modifier(s) attached.
 </param>
	<param name="asClauseOpt">
 The "As" clause that describes the return type, and possibly includes "New",
 "With" or "From". If no As clause was present, Nothing is returned.
 </param>
	<param name="initializerOpt">
 If present, an "= initial-value" clause describing the initial value of the
 variable or the value of the constant.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.SimpleAsClause(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.TypeSyntax)">
	<summary>
 Represents an "As {type-name}" clause that does not have an initializer or
 "New". The type has optional attributes associated with it, although attributes
 are not permitted in all possible places where this node occurs.
 </summary>
	<param name="asKeyword">
 The "As" keyword.
 </param>
	<param name="attributes">
 A list of all attribute blocks on the type. If no attributes were specified, an
 empty list is returned.
 </param>
	<param name="type">
 The type-name part of the As clause.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.AsNewClause(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.NewExpressionSyntax)">
	<summary>
 Represents an "As New {type-name} [arguments] [initializers]" clause in a
 declaration. The type has optional attributes associated with it, although
 attributes are not permitted in many places where this node occurs (they are
 permitted, for example, on automatically implemented properties.)
 </summary>
	<param name="asKeyword">
 The "As" keyword.
 </param>
	<param name="newExpression">
 The New expression
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ObjectMemberInitializer(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.FieldInitializerSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents a "With {...} clause used to initialize a new object's members.
 </summary>
	<param name="withKeyword">
 The "With" keyword.
 </param>
	<param name="openBraceToken">
 The "{" token.
 </param>
	<param name="initializers">
 The comma-separated list of field initializers.
 </param>
	<param name="closeBraceToken">
 The "}" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ObjectCollectionInitializer(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.CollectionInitializerSyntax)">
	<summary>
 Represents a "From {...} clause used to initialize a new collection object's
 elements.
 </summary>
	<param name="fromKeyword">
 The "From" keyword.
 </param>
	<param name="initializer">
 The initializer including the braces.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.InferredFieldInitializer(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represent a field initializer in a With {...} initializer where the field name
 is inferred from the initializer expression.
 </summary>
	<param name="keyKeywordOpt">
 The optional "Key" keyword.
 </param>
	<param name="expression">
 The value being assigned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.NamedFieldInitializer(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represent a named field initializer in a With {...} initializer, such as ".x =
 expr".
 </summary>
	<param name="keyKeywordOpt">
 The optional "Key" keyword.
 </param>
	<param name="dotToken">
 The "." token.
 </param>
	<param name="identifier">
 The name of the field being initialized.
 </param>
	<param name="equalsToken">
 The "=" token.
 </param>
	<param name="expression">
 The value being assigned to the field.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EqualsValue(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents an "= initializer" clause in a declaration for a variable,
 pararameter or automatic property.
 </summary>
	<param name="equalsToken">
 The "=" token.
 </param>
	<param name="value">
 The expression used as the initial value.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.Parameter(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.ModifiedIdentifierSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SimpleAsClauseSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.EqualsValueSyntax)">
	<summary>
 Represent a parameter to a method, property, constructor, etc.
 </summary>
	<param name="attributes">
 A list of all attribute blocks on this parameter. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of the modifier tokens "ByVal", "ByRef", "Optional" or "ParamArray" that
 modify this parameter.
 </param>
	<param name="identifier">
 The name of the parameter, including any "?" or "()" modifiers.
 </param>
	<param name="asClauseOpt">
 If present, the "As type-name" clause describing the type of the parameter. If
 no As clause is present, Nothing is returned.
 </param>
	<param name="defaultOpt">
 If present, an initializer with the default value of the parameter. If no
 default value is present, Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ModifiedIdentifier(Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ArgumentListSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode})">
	<summary>
 Represents an identifier with optional "?" or "()" or "(,,,)" modifiers, as
 used in parameter declarations and variable declarations.
 </summary>
	<param name="identifier">
 The identifier that names the item being declared.
 </param>
	<param name="nullableOpt">
 The "?" token that indicates a nullable type.
 </param>
	<param name="arrayBoundsOpt">
 The optional array bounds, such as "(4)" or "(0 to 5, 0 To 6)".
 </param>
	<param name="arrayRankSpecifiers">
 A list of array modifiers for the type. If no array modifiers were present, an
 empty list is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ArrayRankSpecifier(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents a modifier that describes an array type, without bounds, such as
 "()" or "(,)".
 </summary>
	<param name="openParenToken">
 The "(" token.
 </param>
	<param name="commaTokens">
 The comma tokens in the array type. There is one less comma than the rank.
 </param>
	<param name="closeParenToken">
 The ")" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.AttributeBlock(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.AttributeSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents a group of attributes within "&amp;lt;" and "&amp;gt;" brackets.
 </summary>
	<param name="lessThanToken">
 The "&amp;lt;" token.
 </param>
	<param name="attributes">
 A comma separated list of attribute declarations in this attribute block.
 </param>
	<param name="greaterThanToken">
 The "&amp;gt;" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.Attribute(Roslyn.Compilers.VisualBasic.InternalSyntax.AttributeTargetSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.TypeSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ArgumentListSyntax)">
	<summary>
 Represents a single attribute declaration within an attribute block.
 </summary>
	<param name="targetOpt">
 Optional attribute target. Assembly|Module :
 </param>
	<param name="name">
 The name of the attribute.
 </param>
	<param name="argumentListOpt">
 The argument list, if present. If no argument list was supplied, Nothing is
 returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.AttributeTarget(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents a single attribute declaration within an attribute block.
 </summary>
	<param name="attributeModifier">
 The "Assembly" or "Module" attribute modifier, is present. If no attribute
 modifier is present, Nothing is returned.
 </param>
	<param name="colonToken">
 The ":" token, if an attribute modifier is present. If no attribute modifier is
 present, Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.AttributesStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode})">
	<summary>
 Represents a file-level attribute, in which the attributes have no other
 syntactic element they are attached to.
 </summary>
	<param name="attributes">
 The list of attribute blocks.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.WhileBlock(Roslyn.Compilers.VisualBasic.InternalSyntax.WhileStatementSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.EndBlockStatementSyntax)">
	<summary>
 Represents a While...End While statement, including the While, body and End
 While.
 </summary>
	<param name="begin">
 The While statement that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the While...End While. This might be an empty list.
 </param>
	<param name="end">
 The End While statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.UsingBlock(Roslyn.Compilers.VisualBasic.InternalSyntax.UsingStatementSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.EndBlockStatementSyntax)">
	<summary>
 Represents an entire Using...End Using statement, including the Using, body and
 End Using statements.
 </summary>
	<param name="begin">
 The UsingStatement that begins the Using...End Using block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the Using...End Using block. This might be an empty
 list.
 </param>
	<param name="end">
 The End Using statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.SyncLockBlock(Roslyn.Compilers.VisualBasic.InternalSyntax.SyncLockStatementSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.EndBlockStatementSyntax)">
	<summary>
 Represents a entire SyncLock...End SyncLock block, including the SyncLock
 statement, the enclosed statements, and the End SyncLock statment.
 </summary>
	<param name="begin">
 The SyncLock statement that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the SyncLock...End SyncLock statement. This might
 be an empty list.
 </param>
	<param name="end">
 The End SyncLock statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.WithBlock(Roslyn.Compilers.VisualBasic.InternalSyntax.WithStatementSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.EndBlockStatementSyntax)">
	<summary>
 Represents a With...End With block, include the With statement, the body of the
 block and the End With statement.
 </summary>
	<param name="begin">
 The WithStatement that begins the With...End With block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the With...End With block. This might be an empty
 list.
 </param>
	<param name="end">
 The End With statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.LocalDeclaration(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.VariableDeclaratorSyntax})">
	<summary>
 Represents the declaration of one or more local variables or constants.
 </summary>
	<param name="modifiers">
 The modifier token (Static, Dim or Const) that introduces this local variable
 declaration.
 </param>
	<param name="declarators">
 The list of variable declarator. Each declarator specifies one or more variable
 names along with a type and/or initializer.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.LabelStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken)">
	<summary>
 Represents a label statement.
 </summary>
	<param name="labelName">
 The name of the label. If the label is a line number, returns an IntegerLiteral
 that is the line number, otherwise, returns an Identifier.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.GoToStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken)">
	<summary>
 Represents a "GoTo" statement.
 </summary>
	<param name="goToKeyword">
 The "GoTo" keyword.
 </param>
	<param name="labelName">
 The name of the label. If the label is a line number, returns an IntegerLiteral
 that is the line number, otherwise, returns an Identifier.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.StopStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents a "Stop" or "End" statement. The Kind can be used to determine which
 kind of statement this is.
 </summary>
	<param name="stopOrEndKeyword">
 The "Stop" or "End" keyword.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EndStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents a "Stop" or "End" statement. The Kind can be used to determine which
 kind of statement this is.
 </summary>
	<param name="stopOrEndKeyword">
 The "Stop" or "End" keyword.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.StopOrEndStatement(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents a "Stop" or "End" statement. The Kind can be used to determine which
 kind of statement this is.
 </summary>
	<param name="kind">
 A &amp;lt;cref c="SyntaxKind"/&amp;gt; representing the specific kind of
 StopOrEndStatementSyntax. One of StopStatement, EndStatement.
 </param>
	<param name="stopOrEndKeyword">
 The "Stop" or "End" keyword.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ExitDoStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
	<param name="exitKeyword">
 The "Exit" keyword.
 </param>
	<param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ExitForStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
	<param name="exitKeyword">
 The "Exit" keyword.
 </param>
	<param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ExitSubStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
	<param name="exitKeyword">
 The "Exit" keyword.
 </param>
	<param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ExitFunctionStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
	<param name="exitKeyword">
 The "Exit" keyword.
 </param>
	<param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ExitOperatorStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
	<param name="exitKeyword">
 The "Exit" keyword.
 </param>
	<param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ExitPropertyStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
	<param name="exitKeyword">
 The "Exit" keyword.
 </param>
	<param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ExitTryStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
	<param name="exitKeyword">
 The "Exit" keyword.
 </param>
	<param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ExitSelectStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
	<param name="exitKeyword">
 The "Exit" keyword.
 </param>
	<param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ExitWhileStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
	<param name="exitKeyword">
 The "Exit" keyword.
 </param>
	<param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ExitStatement(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
	<param name="kind">
 A &amp;lt;cref c="SyntaxKind"/&amp;gt; representing the specific kind of
 ExitStatementSyntax. One of ExitDoStatement, ExitForStatement,
 ExitSubStatement, ExitFunctionStatement, ExitOperatorStatement,
 ExitPropertyStatement, ExitTryStatement, ExitSelectStatement,
 ExitWhileStatement.
 </param>
	<param name="exitKeyword">
 The "Exit" keyword.
 </param>
	<param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ContinueWhileStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents a "Continue (block)" statement. THe kind of block referenced can be
 determined by examining the Kind.
 </summary>
	<param name="continueKeyword">
 The "Continue" keyword.
 </param>
	<param name="blockKeyword">
 The "Do", "For" or "While" keyword that identifies the kind of loop being
 continued.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ContinueDoStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents a "Continue (block)" statement. THe kind of block referenced can be
 determined by examining the Kind.
 </summary>
	<param name="continueKeyword">
 The "Continue" keyword.
 </param>
	<param name="blockKeyword">
 The "Do", "For" or "While" keyword that identifies the kind of loop being
 continued.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ContinueForStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents a "Continue (block)" statement. THe kind of block referenced can be
 determined by examining the Kind.
 </summary>
	<param name="continueKeyword">
 The "Continue" keyword.
 </param>
	<param name="blockKeyword">
 The "Do", "For" or "While" keyword that identifies the kind of loop being
 continued.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ContinueStatement(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents a "Continue (block)" statement. THe kind of block referenced can be
 determined by examining the Kind.
 </summary>
	<param name="kind">
 A &amp;lt;cref c="SyntaxKind"/&amp;gt; representing the specific kind of
 ContinueStatementSyntax. One of ContinueWhileStatement, ContinueDoStatement,
 ContinueForStatement.
 </param>
	<param name="continueKeyword">
 The "Continue" keyword.
 </param>
	<param name="blockKeyword">
 The "Do", "For" or "While" keyword that identifies the kind of loop being
 continued.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ReturnStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a "Return" statement.
 </summary>
	<param name="returnKeyword">
 The "Return" keyword.
 </param>
	<param name="expressionOpt">
 The expression being returned, if present.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.SingleLineIfStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.SingleLineIfPartSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SingleLineElsePartSyntax)">
	<summary>
 Represents a line If-Then-Else statement.
 </summary>
	<param name="ifPart">
 The If part of the statement.
 </param>
	<param name="elsePartOpt">
 The Else part of the statement. If there is no Else part, Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.SingleLineIfPart(Roslyn.Compilers.VisualBasic.InternalSyntax.IfStatementSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax})">
	<summary>
 Represents part of a single line If statement, consisting of a beginning
 if-statement, followed by a body of statement controlled by that beginning
 statement. The Kind property returns if this is an SingleLineIf.
 </summary>
	<param name="begin">
 The statement that introduces this part of the If...Then...Else...End If. This
 must be an IfStatement.
 </param>
	<param name="statements">
 The statements controlled by this If or Else If. This might be an empty list.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.SingleLineElsePart(Roslyn.Compilers.VisualBasic.InternalSyntax.ElseStatementSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax})">
	<summary>
 Represents the Else part of an If statement, consisting of a Else statement,
 followed by a body of statement controlled by that Else.
 </summary>
	<param name="begin">
 The Else statement that introduces this part.
 </param>
	<param name="statements">
 The statements controlled by the Else.This might be an empty list.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.MultiLineIfBlock(Roslyn.Compilers.VisualBasic.InternalSyntax.IfPartSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.ElsePartSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.EndBlockStatementSyntax)">
	<summary>
 Represents a block If...Then...Else...EndIf Statement. The Kind property can be
 used to determine if it is a block or line If.
 </summary>
	<param name="ifPart">
 The If part of the statement.
 </param>
	<param name="elseIfParts">
 A list of the "ElseIf" parts of the statement. If there are no ElseIf parts,
 then an empty list is returned.
 </param>
	<param name="elsePartOpt">
 The Else part of the statement. If there is no Else part, Nothing is returned.
 </param>
	<param name="endIf">
 If this is a block if, returns the "End If" statement.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.IfPart(Roslyn.Compilers.VisualBasic.InternalSyntax.IfStatementSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax})">
	<summary>
 Represents part of an If statement, consisting of a beginning statement (If or
 ElseIf), followed by a body of statement controlled by that beginning
 statement. The Kind property returns if this is an If or ElseIf.
 </summary>
	<param name="begin">
 The statement that introduces this part of the If...Then...Else...End If. This
 must be an IfStatement.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements controlled by this If or Else If. This might be an empty list.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ElseIfPart(Roslyn.Compilers.VisualBasic.InternalSyntax.IfStatementSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax})">
	<summary>
 Represents part of an If statement, consisting of a beginning statement (If or
 ElseIf), followed by a body of statement controlled by that beginning
 statement. The Kind property returns if this is an If or ElseIf.
 </summary>
	<param name="begin">
 The statement that introduces this part of the If...Then...Else...End If. This
 must be an IfStatement.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements controlled by this If or Else If. This might be an empty list.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ElsePart(Roslyn.Compilers.VisualBasic.InternalSyntax.ElseStatementSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax})">
	<summary>
 Represents the Else part of an If statement, consisting of a Else statement,
 followed by a body of statement controlled by that Else.
 </summary>
	<param name="begin">
 The Else statement that introduces this part.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements controlled by the Else. This might be an empty list.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.IfStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents the If part or ElseIf part of a If...End If block (or line If). This
 statement is always the Begin of a IfPart. The Kind can be examined to
 determine if this is an If or an ElseIf statement.
 </summary>
	<param name="elseKeywordOpt">
 If this ElseIf was written as "Else If", contains the "Else" keyword. Otherwise
 returns Nothing.
 </param>
	<param name="ifOrElseIfKeyword">
 The "If" or "ElseIf" keyword.
 </param>
	<param name="condition">
 The boolean expression that is being tested.
 </param>
	<param name="thenKeywordOpt">
 The "Then" keyword.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ElseIfStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents the If part or ElseIf part of a If...End If block (or line If). This
 statement is always the Begin of a IfPart. The Kind can be examined to
 determine if this is an If or an ElseIf statement.
 </summary>
	<param name="elseKeywordOpt">
 If this ElseIf was written as "Else If", contains the "Else" keyword. Otherwise
 returns Nothing.
 </param>
	<param name="ifOrElseIfKeyword">
 The "If" or "ElseIf" keyword.
 </param>
	<param name="condition">
 The boolean expression that is being tested.
 </param>
	<param name="thenKeywordOpt">
 The "Then" keyword.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ElseStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents the Else part of a If...End If block (or line If). This statement is
 always the Begin of a ElsePart.
 </summary>
	<param name="elseKeyword">
 The "Else" keyword
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.TryBlock(Roslyn.Compilers.VisualBasic.InternalSyntax.TryPartSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.FinallyPartSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.EndBlockStatementSyntax)">
	<summary>
 Represents an entire Try...Catch...Finally...End Try statement.
 </summary>
	<param name="tryPart">
 The Try part of the statement.
 </param>
	<param name="catchParts">
 A list of the Catch parts of the statement. If there are no Catch parts, then
 an empty list is returned.
 </param>
	<param name="finallyPartOpt">
 The Finally part of the statement, if present.
 </param>
	<param name="end">
 The "End Try" statement.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.TryPart(Roslyn.Compilers.VisualBasic.InternalSyntax.TryStatementSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax})">
	<summary>
 Represents part of an Try...Catch...Finally...End Try statement, consisting of
 a beginning statement (Try, Catch or Finally), followed by a body of statements
 controlled by that beginning statement. The Kind property returns which kind of
 part this is.
 </summary>
	<param name="begin">
 The TryStatement that introduces this part of the Try...Catch...Finally...End
 Try.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements inside the Try part of the Try...Catch...Finally...End Try. This
 might be an empty list.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.CatchPart(Roslyn.Compilers.VisualBasic.InternalSyntax.CatchStatementSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax})">
	<summary>
 Represents a Catch part of an Try...Catch...Finally...End Try statement,
 consisting of a Catch statement, followed by a body of statements controlled by
 that Catch statement. The Kind property returns which kind of part this is.
 </summary>
	<param name="begin">
 The CatchStatement that introduces this part.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements controlled by the Catch statement. This might be an empty list.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.FinallyPart(Roslyn.Compilers.VisualBasic.InternalSyntax.FinallyStatementSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax})">
	<summary>
 Represents the Finally part of an Try...Catch...Finally...End Try statement,
 consisting of a Finally statement, followed by a body of statements controlled
 by the Finally.
 </summary>
	<param name="begin">
 The FinallyStatement that introduces the Finally part of a Try.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements inside the Finally part of the Try...Catch...Finally...End Try.
 This might be an empty list.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.TryStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents the Try part part of a Try...Catch...Finally...End Try. This
 statement is always the Begin of a TryPart.
 </summary>
	<param name="tryKeyword">
 The "Try" keyword
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.CatchStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SimpleAsClauseSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.CatchFilterClauseSyntax)">
	<summary>
 Represents the Catch part part of a Try...Catch...Finally...End Try. This
 statement is always the Begin of a CatchPart.
 </summary>
	<param name="catchKeyword">
 The "Catch" keyword.
 </param>
	<param name="identifierOpt">
 The identifier representing the exception that was caught, if present.
 </param>
	<param name="asClauseOpt">
 The As clause that defines the type of exception being caught.
 </param>
	<param name="whenClauseOpt">
 The "When" clause, if present.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.CatchFilterClause(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents the When/Filter clause of a Catch statement
 </summary>
	<param name="whenKeyword">
 The "When" keyword
 </param>
	<param name="filter">
 The filter expression
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.FinallyStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents the Finally part part of a Try...Catch...Finally...End Try. This
 statement is always the Begin of a FinallyPart.
 </summary>
	<param name="finallyKeyword">
 The "Finally" keyword.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ErrorStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents the "Error" statement.
 </summary>
	<param name="errorKeyword">
 The "Error" keyword.
 </param>
	<param name="errorNumber">
 The expression that represents the error number.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.OnErrorGoToZeroStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken)">
	<summary>
 Represents an OnError Goto statement.
 </summary>
	<param name="onKeyword">
 The "On" keyword
 </param>
	<param name="errorKeyword">
 The "Error" keyword.
 </param>
	<param name="goToKeyword">
 The "GoTo" keyword
 </param>
	<param name="minusOpt">
 An optional minus for On Error Goto -1
 </param>
	<param name="label">
 The name of the label. If the label is a line number, 0 or -1, returns an
 IntegerLiteralToken that is the line number, otherwise, returns an Identifier.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.OnErrorGoToMinusOneStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken)">
	<summary>
 Represents an OnError Goto statement.
 </summary>
	<param name="onKeyword">
 The "On" keyword
 </param>
	<param name="errorKeyword">
 The "Error" keyword.
 </param>
	<param name="goToKeyword">
 The "GoTo" keyword
 </param>
	<param name="minusOpt">
 An optional minus for On Error Goto -1
 </param>
	<param name="label">
 The name of the label. If the label is a line number, 0 or -1, returns an
 IntegerLiteralToken that is the line number, otherwise, returns an Identifier.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.OnErrorGoToLabelStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken)">
	<summary>
 Represents an OnError Goto statement.
 </summary>
	<param name="onKeyword">
 The "On" keyword
 </param>
	<param name="errorKeyword">
 The "Error" keyword.
 </param>
	<param name="goToKeyword">
 The "GoTo" keyword
 </param>
	<param name="minusOpt">
 An optional minus for On Error Goto -1
 </param>
	<param name="label">
 The name of the label. If the label is a line number, 0 or -1, returns an
 IntegerLiteralToken that is the line number, otherwise, returns an Identifier.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.OnErrorGoToStatement(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken)">
	<summary>
 Represents an OnError Goto statement.
 </summary>
	<param name="kind">
 A &amp;lt;cref c="SyntaxKind"/&amp;gt; representing the specific kind of
 OnErrorGoToStatementSyntax. One of OnErrorGoToZeroStatement,
 OnErrorGoToMinusOneStatement, OnErrorGoToLabelStatement.
 </param>
	<param name="onKeyword">
 The "On" keyword
 </param>
	<param name="errorKeyword">
 The "Error" keyword.
 </param>
	<param name="goToKeyword">
 The "GoTo" keyword
 </param>
	<param name="minusOpt">
 An optional minus for On Error Goto -1
 </param>
	<param name="label">
 The name of the label. If the label is a line number, 0 or -1, returns an
 IntegerLiteralToken that is the line number, otherwise, returns an Identifier.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.OnErrorResumeNextStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents an OnError Resume Next statement.
 </summary>
	<param name="onKeyword">
 The "On" keyword
 </param>
	<param name="errorKeyword">
 The "Error" keyword.
 </param>
	<param name="resumeKeyword">
 The "Resume" keyword.
 </param>
	<param name="nextKeyword">
 The "Next"
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ResumeStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken)">
	<summary>
 Represents a "Resume" statement. The Kind property can be used to determine if
 this is a "Resume", "Resume Next" or "Resume label" statement.
 </summary>
	<param name="resumeKeyword">
 The "Resume" keyword.
 </param>
	<param name="labelOpt">
 The label. The value of this depends on the Kind. If Kind=Resume, returns
 Nothing. If Kind=ResumeNext, returns the keyword "Next", If Kind=ResumeLabel,
 returns an Identifier or IntegerLiteralToken with the label or line number.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ResumeLabelStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken)">
	<summary>
 Represents a "Resume" statement. The Kind property can be used to determine if
 this is a "Resume", "Resume Next" or "Resume label" statement.
 </summary>
	<param name="resumeKeyword">
 The "Resume" keyword.
 </param>
	<param name="labelOpt">
 The label. The value of this depends on the Kind. If Kind=Resume, returns
 Nothing. If Kind=ResumeNext, returns the keyword "Next", If Kind=ResumeLabel,
 returns an Identifier or IntegerLiteralToken with the label or line number.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ResumeNextStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken)">
	<summary>
 Represents a "Resume" statement. The Kind property can be used to determine if
 this is a "Resume", "Resume Next" or "Resume label" statement.
 </summary>
	<param name="resumeKeyword">
 The "Resume" keyword.
 </param>
	<param name="labelOpt">
 The label. The value of this depends on the Kind. If Kind=Resume, returns
 Nothing. If Kind=ResumeNext, returns the keyword "Next", If Kind=ResumeLabel,
 returns an Identifier or IntegerLiteralToken with the label or line number.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.SelectBlock(Roslyn.Compilers.VisualBasic.InternalSyntax.SelectStatementSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.EndBlockStatementSyntax)">
	<summary>
 Represents a Select Case block, including the Select Case that begins it, the
 contains Case blocks and the End Select.
 </summary>
	<param name="begin">
 The Select Case statement that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="caseBlocks">
 A list of the contained Case blocks.
 </param>
	<param name="end">
 The End Select statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.SelectStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a Select Case statement. This statement always occurs as the Begin
 of a SelectBlock.
 </summary>
	<param name="selectKeyword">
 The "Select" keyword.
 </param>
	<param name="caseKeywordOpt">
 The "Case" keyword, if present.
 </param>
	<param name="expression">
 The value that branching is based on.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.CaseBlock(Roslyn.Compilers.VisualBasic.InternalSyntax.CaseStatementSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax})">
	<summary>
 Represents a case statement and its subsequent block.
 </summary>
	<param name="begin">
 The statement that begins the case block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the case block. This might be an empty list.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.CaseElseBlock(Roslyn.Compilers.VisualBasic.InternalSyntax.CaseStatementSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax})">
	<summary>
 Represents a case statement and its subsequent block.
 </summary>
	<param name="begin">
 The statement that begins the case block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the case block. This might be an empty list.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.CaseStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.CaseClauseSyntax})">
	<summary>
 Represents a Case or Case Else statement. This statement is always the Begin of
 a CaseBlock. If this is a Case Else statement, the Kind=CaseElse, otherwise the
 Kind=Case.
 </summary>
	<param name="caseKeyword">
 The "Case" keyword
 </param>
	<param name="cases">
 A list of clauses associated with this Case. If Kind=CaseElse, then this list
 has exactly one child, which is a CaseElseClause.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.CaseElseStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.CaseClauseSyntax})">
	<summary>
 Represents a Case or Case Else statement. This statement is always the Begin of
 a CaseBlock. If this is a Case Else statement, the Kind=CaseElse, otherwise the
 Kind=Case.
 </summary>
	<param name="caseKeyword">
 The "Case" keyword
 </param>
	<param name="cases">
 A list of clauses associated with this Case. If Kind=CaseElse, then this list
 has exactly one child, which is a CaseElseClause.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.CaseElseClause(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 The "Else" part in a Case Else statement.
 </summary>
	<param name="elseKeyword">
 The "Else" keyword.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.CaseValueClause(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a single value in a Case.
 </summary>
	<param name="value">
 The expression that denotes the value being tested against.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.CaseRangeClause(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a range "expression To expression" in a Case.
 </summary>
	<param name="lowerBound">
 The lower bound of the range.
 </param>
	<param name="toKeyword">
 The "To" keyword
 </param>
	<param name="upperBound">
 The upper bound of the range.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.CaseEqualsClause(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a relation clause in a Case statement, such as "Is &amp;gt;
 expression".
 </summary>
	<param name="isKeywordOpt">
 The "Is" keyword, if present.
 </param>
	<param name="operatorToken">
 The operator in the relational clause. One of "=", "&amp;lt;", "&amp;gt;",
 "&amp;lt;=" or "&amp;gt;=".
 </param>
	<param name="value">
 The expression that denotes the value being tested against.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.CaseNotEqualsClause(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a relation clause in a Case statement, such as "Is &amp;gt;
 expression".
 </summary>
	<param name="isKeywordOpt">
 The "Is" keyword, if present.
 </param>
	<param name="operatorToken">
 The operator in the relational clause. One of "=", "&amp;lt;", "&amp;gt;",
 "&amp;lt;=" or "&amp;gt;=".
 </param>
	<param name="value">
 The expression that denotes the value being tested against.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.CaseLessThanClause(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a relation clause in a Case statement, such as "Is &amp;gt;
 expression".
 </summary>
	<param name="isKeywordOpt">
 The "Is" keyword, if present.
 </param>
	<param name="operatorToken">
 The operator in the relational clause. One of "=", "&amp;lt;", "&amp;gt;",
 "&amp;lt;=" or "&amp;gt;=".
 </param>
	<param name="value">
 The expression that denotes the value being tested against.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.CaseLessThanOrEqualClause(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a relation clause in a Case statement, such as "Is &amp;gt;
 expression".
 </summary>
	<param name="isKeywordOpt">
 The "Is" keyword, if present.
 </param>
	<param name="operatorToken">
 The operator in the relational clause. One of "=", "&amp;lt;", "&amp;gt;",
 "&amp;lt;=" or "&amp;gt;=".
 </param>
	<param name="value">
 The expression that denotes the value being tested against.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.CaseGreaterThanOrEqualClause(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a relation clause in a Case statement, such as "Is &amp;gt;
 expression".
 </summary>
	<param name="isKeywordOpt">
 The "Is" keyword, if present.
 </param>
	<param name="operatorToken">
 The operator in the relational clause. One of "=", "&amp;lt;", "&amp;gt;",
 "&amp;lt;=" or "&amp;gt;=".
 </param>
	<param name="value">
 The expression that denotes the value being tested against.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.CaseGreaterThanClause(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a relation clause in a Case statement, such as "Is &amp;gt;
 expression".
 </summary>
	<param name="isKeywordOpt">
 The "Is" keyword, if present.
 </param>
	<param name="operatorToken">
 The operator in the relational clause. One of "=", "&amp;lt;", "&amp;gt;",
 "&amp;lt;=" or "&amp;gt;=".
 </param>
	<param name="value">
 The expression that denotes the value being tested against.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.CaseRelationalClause(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a relation clause in a Case statement, such as "Is &amp;gt;
 expression".
 </summary>
	<param name="kind">
 A &amp;lt;cref c="SyntaxKind"/&amp;gt; representing the specific kind of
 CaseRelationalClauseSyntax. One of CaseEqualsClause, CaseNotEqualsClause,
 CaseLessThanClause, CaseLessThanOrEqualClause, CaseGreaterThanOrEqualClause,
 CaseGreaterThanClause.
 </param>
	<param name="isKeywordOpt">
 The "Is" keyword, if present.
 </param>
	<param name="operatorToken">
 The operator in the relational clause. One of "=", "&amp;lt;", "&amp;gt;",
 "&amp;lt;=" or "&amp;gt;=".
 </param>
	<param name="value">
 The expression that denotes the value being tested against.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.SyncLockStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents the "SyncLock" statement. This statement always occurs as the Begin
 of a SyncLockBlock.
 </summary>
	<param name="syncLockKeyword">
 The "SyncLock" keyword.
 </param>
	<param name="expression">
 The expression being synchronized on.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.DoLoopTopTestBlock(Roslyn.Compilers.VisualBasic.InternalSyntax.DoStatementSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.LoopStatementSyntax)">
	<summary>
 Represents a Do-Loop block. The Kind property can be used to determine if this
 is a top-test, bottom-test or infinite loop.
 </summary>
	<param name="begin">
 The Do statement that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The Loop statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.DoLoopBottomTestBlock(Roslyn.Compilers.VisualBasic.InternalSyntax.DoStatementSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.LoopStatementSyntax)">
	<summary>
 Represents a Do-Loop block. The Kind property can be used to determine if this
 is a top-test, bottom-test or infinite loop.
 </summary>
	<param name="begin">
 The Do statement that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The Loop statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.DoLoopForeverBlock(Roslyn.Compilers.VisualBasic.InternalSyntax.DoStatementSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.LoopStatementSyntax)">
	<summary>
 Represents a Do-Loop block. The Kind property can be used to determine if this
 is a top-test, bottom-test or infinite loop.
 </summary>
	<param name="begin">
 The Do statement that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The Loop statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.DoLoopBlock(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.InternalSyntax.DoStatementSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.LoopStatementSyntax)">
	<summary>
 Represents a Do-Loop block. The Kind property can be used to determine if this
 is a top-test, bottom-test or infinite loop.
 </summary>
	<param name="kind">
 A &amp;lt;cref c="SyntaxKind"/&amp;gt; representing the specific kind of
 DoLoopBlockSyntax. One of DoLoopTopTestBlock, DoLoopBottomTestBlock,
 DoLoopForeverBlock.
 </param>
	<param name="begin">
 The Do statement that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The Loop statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.DoStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.WhileUntilClauseSyntax)">
	<summary>
 The Do statement that begins a Do-Loop block. This statement always occurs as
 the Begin of a DoLoopBlock.
 </summary>
	<param name="doKeyword">
 The "Do" keyword.
 </param>
	<param name="whileUntilClauseOpt">
 The "While expression" or "Until expression" part of the Do statement, if
 present.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.LoopStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.WhileUntilClauseSyntax)">
	<summary>
 The Loop statement that ends a Do-Loop block. This statement always occurs as
 the End of a DoLoopBlock.
 </summary>
	<param name="loopKeyword">
 The "Loop" keyword.
 </param>
	<param name="whileUntilClauseOpt">
 The "While expression" or "Until expression" part of the Loop statement, if
 present.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.WhileClause(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a "While expression" or "Until expression" in a Do or Loop
 statement. The Kind of the clause can be "WhileClause" or "UntilClause" to
 indicate which kind of clause.
 </summary>
	<param name="whileOrUntilKeyword">
 The "While" or "Until" keyword.
 </param>
	<param name="condition">
 The boolean expression after the While or Until.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.UntilClause(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a "While expression" or "Until expression" in a Do or Loop
 statement. The Kind of the clause can be "WhileClause" or "UntilClause" to
 indicate which kind of clause.
 </summary>
	<param name="whileOrUntilKeyword">
 The "While" or "Until" keyword.
 </param>
	<param name="condition">
 The boolean expression after the While or Until.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.WhileUntilClause(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a "While expression" or "Until expression" in a Do or Loop
 statement. The Kind of the clause can be "WhileClause" or "UntilClause" to
 indicate which kind of clause.
 </summary>
	<param name="kind">
 A &amp;lt;cref c="SyntaxKind"/&amp;gt; representing the specific kind of
 WhileUntilClauseSyntax. One of WhileClause, UntilClause.
 </param>
	<param name="whileOrUntilKeyword">
 The "While" or "Until" keyword.
 </param>
	<param name="condition">
 The boolean expression after the While or Until.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.WhileStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 The While statement that begins a While...End While block. This statement
 always occurs as the Begin of a WhileBlock.
 </summary>
	<param name="whileKeyword">
 The "While" keyword.
 </param>
	<param name="condition">
 The boolean expression that controls the While loop.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ForBlock(Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.NextStatementSyntax)">
	<summary>
 Represents a For or For Each block, including the introducting statement, the
 body and the "Next" (which can be omitted if a containing For has a Next with
 multiple variables).
 </summary>
	<param name="begin">
 The For or For Each statement that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the For or For Each loop. This might be an empty
 list.
 </param>
	<param name="endOpt">
 The Next statement that ends the block. If two For statements are ended by a
 single Next statement, the inner For will not have an EndStatment.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ForEachBlock(Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.NextStatementSyntax)">
	<summary>
 Represents a For or For Each block, including the introducting statement, the
 body and the "Next" (which can be omitted if a containing For has a Next with
 multiple variables).
 </summary>
	<param name="begin">
 The For or For Each statement that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the For or For Each loop. This might be an empty
 list.
 </param>
	<param name="endOpt">
 The Next statement that ends the block. If two For statements are ended by a
 single Next statement, the inner For will not have an EndStatment.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ForStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ForStepClauseSyntax)">
	<summary>
 The For statement that begins a For-Next block. This statement always occurs as
 the Begin of a ForBlock. Most of the time, the End of that ForBlock is the
 corresponding Next statement. However, multiple nested For statements are ended
 by a single Next statement with multiple variables, then the inner For
 statements will have End set to Nothing, and the Next statement is the End of
 the outermost For statement that is being ended.
 </summary>
	<param name="forKeyword">
 The "For" keyword.
 </param>
	<param name="controlVariable">
 If the For or For Each statement is of a form that does not declare a new loop
 control variable, this is the expression that denotes the loop control
 variable. If this loop is of a form that does declare a new control variable,
 this is a VariableDeclarator that has the variable being declared.
 </param>
	<param name="equalsToken">
 The "=" token.
 </param>
	<param name="fromValue">
 The expression denoting the initial value of the iteration.
 </param>
	<param name="toKeyword">
 The "To" keyword.
 </param>
	<param name="toValue">
 The expression denoting the final value of the iteration.
 </param>
	<param name="stepClauseOpt">
 The optional Step clause.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ForStepClause(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 The Step clause in a For Statement.
 </summary>
	<param name="stepKeyword">
 The "Step" keyword.
 </param>
	<param name="stepValue">
 The expression denoting the step increment.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ForEachStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 The For Each statement that begins a For Each-Next block. This statement always
 occurs as the Begin of a ForBlock, and the body of the For Each-Next is the
 Body of that ForBlock. Most of the time, the End of that ForBlock is the
 corresponding Next statement. However, multiple nested For statements are ended
 by a single Next statement with multiple variables, then the inner For
 statements will have End set to Nothing, and the Next statement is the End of
 the outermost For statement that is being ended.
 </summary>
	<param name="forKeyword">
 The "For" keyword.
 </param>
	<param name="eachKeyword">
 The "Each" keyword.
 </param>
	<param name="controlVariable">
 If the For or For Each statement is of a form that does not declare a new loop
 control variable, this is the expression that denotes the loop control
 variable. If this loop is of a form that does declare a new control variable,
 this is a VariableDeclarator that has the variable being declared.
 </param>
	<param name="inKeyword">
 The "In" keyword.
 </param>
	<param name="expression">
 The expression denoting the collection to iterate over.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.NextStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax})">
	<summary>
 The Next statement that ends a For-Next or For Each-Next block. This statement
 always occurs as the End of a ForBlock (with Kind=ForBlock or ForEachBlock),
 and the body of the For-Next is the Body of that ForBlock. The Begin of that
 ForBlock has the corresponding For or For Each statement.
 </summary>
	<param name="nextKeyword">
 The "Next" keyword.
 </param>
	<param name="controlVariables">
 The variables in the Next statement, if present
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.UsingStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.VariableDeclaratorSyntax})">
	<summary>
 The Using statement that begins a Using block. This statement always occurs as
 the Begin of a UsingBlock, and the body of the Using is the Body of that
 UsingBlock.
 </summary>
	<param name="usingKeyword">
 The "Using" keyword.
 </param>
	<param name="expressionOpt">
 If the Using statement is of a form that does not declare a new variable, this
 is the expression used in the using. Otherwise, Nothing is returned.
 </param>
	<param name="variables">
 If the Using statement is of a form that declares one or more new variables,
 this is the list of variable declarations. Otherwise, Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ThrowStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a Throw statement.
 </summary>
	<param name="throwKeyword">
 The "Throw" keyword
 </param>
	<param name="expressionOpt">
 The expression denoting the value being thrown.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.AssignmentStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
	<param name="left">
 The target (left hand side) of the assignment.
 </param>
	<param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&amp;lt;&amp;lt;=" or "&amp;gt;&amp;gt;=".
 </param>
	<param name="right">
 The source (right hand side) of the assignment.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.MidAssignment(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
	<param name="left">
 The target (left hand side) of the assignment.
 </param>
	<param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&amp;lt;&amp;lt;=" or "&amp;gt;&amp;gt;=".
 </param>
	<param name="right">
 The source (right hand side) of the assignment.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.AddAssignment(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
	<param name="left">
 The target (left hand side) of the assignment.
 </param>
	<param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&amp;lt;&amp;lt;=" or "&amp;gt;&amp;gt;=".
 </param>
	<param name="right">
 The source (right hand side) of the assignment.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.SubtractAssignment(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
	<param name="left">
 The target (left hand side) of the assignment.
 </param>
	<param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&amp;lt;&amp;lt;=" or "&amp;gt;&amp;gt;=".
 </param>
	<param name="right">
 The source (right hand side) of the assignment.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.MultiplyAssignment(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
	<param name="left">
 The target (left hand side) of the assignment.
 </param>
	<param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&amp;lt;&amp;lt;=" or "&amp;gt;&amp;gt;=".
 </param>
	<param name="right">
 The source (right hand side) of the assignment.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.DivideAssignment(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
	<param name="left">
 The target (left hand side) of the assignment.
 </param>
	<param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&amp;lt;&amp;lt;=" or "&amp;gt;&amp;gt;=".
 </param>
	<param name="right">
 The source (right hand side) of the assignment.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.IntegerDivideAssignment(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
	<param name="left">
 The target (left hand side) of the assignment.
 </param>
	<param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&amp;lt;&amp;lt;=" or "&amp;gt;&amp;gt;=".
 </param>
	<param name="right">
 The source (right hand side) of the assignment.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.PowerAssignment(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
	<param name="left">
 The target (left hand side) of the assignment.
 </param>
	<param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&amp;lt;&amp;lt;=" or "&amp;gt;&amp;gt;=".
 </param>
	<param name="right">
 The source (right hand side) of the assignment.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.LeftShiftAssignment(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
	<param name="left">
 The target (left hand side) of the assignment.
 </param>
	<param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&amp;lt;&amp;lt;=" or "&amp;gt;&amp;gt;=".
 </param>
	<param name="right">
 The source (right hand side) of the assignment.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.RightShiftAssignment(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
	<param name="left">
 The target (left hand side) of the assignment.
 </param>
	<param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&amp;lt;&amp;lt;=" or "&amp;gt;&amp;gt;=".
 </param>
	<param name="right">
 The source (right hand side) of the assignment.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ConcatenateAssignment(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
	<param name="left">
 The target (left hand side) of the assignment.
 </param>
	<param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&amp;lt;&amp;lt;=" or "&amp;gt;&amp;gt;=".
 </param>
	<param name="right">
 The source (right hand side) of the assignment.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.CallStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represent an call statement (also known as a invocation statement).
 </summary>
	<param name="callKeywordOpt">
 The "Call" keyword, if present.
 </param>
	<param name="invocation">
 The expression denoting the call. This could be an Invocation or a MemberAccess
 (in the case where no parentheses were supplied.)
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.AddHandlerStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents an AddHandler or RemoveHandler statement. The Kind property
 determines which one.
 </summary>
	<param name="addHandlerOrRemoveHandlerKeyword">
 The "AddHandler" or "RemoveHandler" keyword.
 </param>
	<param name="eventExpression">
 The event being accessed.
 </param>
	<param name="commaToken">
 The "," token.
 </param>
	<param name="delegateExpression">
 The delegate being added or removed.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.RemoveHandlerStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents an AddHandler or RemoveHandler statement. The Kind property
 determines which one.
 </summary>
	<param name="addHandlerOrRemoveHandlerKeyword">
 The "AddHandler" or "RemoveHandler" keyword.
 </param>
	<param name="eventExpression">
 The event being accessed.
 </param>
	<param name="commaToken">
 The "," token.
 </param>
	<param name="delegateExpression">
 The delegate being added or removed.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.AddRemoveHandlerStatement(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents an AddHandler or RemoveHandler statement. The Kind property
 determines which one.
 </summary>
	<param name="kind">
 A &amp;lt;cref c="SyntaxKind"/&amp;gt; representing the specific kind of
 AddRemoveHandlerStatementSyntax. One of AddHandlerStatement,
 RemoveHandlerStatement.
 </param>
	<param name="addHandlerOrRemoveHandlerKeyword">
 The "AddHandler" or "RemoveHandler" keyword.
 </param>
	<param name="eventExpression">
 The event being accessed.
 </param>
	<param name="commaToken">
 The "," token.
 </param>
	<param name="delegateExpression">
 The delegate being added or removed.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.RaiseEventStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ArgumentListSyntax)">
	<summary>
 Represent a RaiseEvent statement.
 </summary>
	<param name="raiseEventKeyword">
 The "RaiseEvent" keyword
 </param>
	<param name="identifier">
 The name of the event being raised.
 </param>
	<param name="argumentListOpt">
 The argument list, if present.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.WithStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a "With" statement. This statement always occurs as the
 BeginStatement of a WithBlock, and the body of the With is the Body of that
 WithBlock.
 </summary>
	<param name="withKeyword">
 The "With" keyword.
 </param>
	<param name="expression">
 The expression that is the operand of the With statement.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ReDimStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.InvocationExpressionSyntax})">
	<summary>
 Represents a ReDim statement.
 </summary>
	<param name="reDimKeyword">
 The "ReDim" keyword.
 </param>
	<param name="preserveKeywordOpt">
 Returns Nothing if Kind=ReDim, returns the "Preserve" keyword if
 Kind=RedimPreserve.
 </param>
	<param name="clauses">
 The list of ReDim clauses. Each clause is a Invocation node with an argument
 list denoting the new bounds for the array.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ReDimPreserveStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.InvocationExpressionSyntax})">
	<summary>
 Represents a ReDim statement.
 </summary>
	<param name="reDimKeyword">
 The "ReDim" keyword.
 </param>
	<param name="preserveKeywordOpt">
 Returns Nothing if Kind=ReDim, returns the "Preserve" keyword if
 Kind=RedimPreserve.
 </param>
	<param name="clauses">
 The list of ReDim clauses. Each clause is a Invocation node with an argument
 list denoting the new bounds for the array.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EraseStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax})">
	<summary>
 Represents an "Erase" statement.
 </summary>
	<param name="eraseKeyword">
 The "Erase" keyword.
 </param>
	<param name="expressions">
 A list of expressions denoting the arrays to erase.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.CharacterLiteralExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken)">
	<summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
	<param name="token">
 The token that represents the literal. The Kind property determines what type
 this property returns: Kind=IntegerLiteral ==&amp;gt; Returns
 IntegerLiteralToken. Kind=CharacterLiteral ==&amp;gt; Returns
 CharacterLiteralToken. Kind=DecimalLiteral ==&amp;gt; Returns
 DecimalLiteralToken Kind=FloatingLiteral ==&amp;gt; Returns
 FloatingLiteralToken Kind=DateLiteral ==&amp;gt; Returns DateLiteralToken
 Kind=StringLiteral ==&amp;gt; Returns StringLiteralToken Kind=BooleanLiteral
 ==&amp;gt; Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
 Kind=NothingLiteral ==&amp;gt; Returns Keyword (with it's kind being
 NothingKeyword)
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.TrueLiteralExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken)">
	<summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
	<param name="token">
 The token that represents the literal. The Kind property determines what type
 this property returns: Kind=IntegerLiteral ==&amp;gt; Returns
 IntegerLiteralToken. Kind=CharacterLiteral ==&amp;gt; Returns
 CharacterLiteralToken. Kind=DecimalLiteral ==&amp;gt; Returns
 DecimalLiteralToken Kind=FloatingLiteral ==&amp;gt; Returns
 FloatingLiteralToken Kind=DateLiteral ==&amp;gt; Returns DateLiteralToken
 Kind=StringLiteral ==&amp;gt; Returns StringLiteralToken Kind=BooleanLiteral
 ==&amp;gt; Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
 Kind=NothingLiteral ==&amp;gt; Returns Keyword (with it's kind being
 NothingKeyword)
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.FalseLiteralExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken)">
	<summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
	<param name="token">
 The token that represents the literal. The Kind property determines what type
 this property returns: Kind=IntegerLiteral ==&amp;gt; Returns
 IntegerLiteralToken. Kind=CharacterLiteral ==&amp;gt; Returns
 CharacterLiteralToken. Kind=DecimalLiteral ==&amp;gt; Returns
 DecimalLiteralToken Kind=FloatingLiteral ==&amp;gt; Returns
 FloatingLiteralToken Kind=DateLiteral ==&amp;gt; Returns DateLiteralToken
 Kind=StringLiteral ==&amp;gt; Returns StringLiteralToken Kind=BooleanLiteral
 ==&amp;gt; Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
 Kind=NothingLiteral ==&amp;gt; Returns Keyword (with it's kind being
 NothingKeyword)
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.NumericLiteralExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken)">
	<summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
	<param name="token">
 The token that represents the literal. The Kind property determines what type
 this property returns: Kind=IntegerLiteral ==&amp;gt; Returns
 IntegerLiteralToken. Kind=CharacterLiteral ==&amp;gt; Returns
 CharacterLiteralToken. Kind=DecimalLiteral ==&amp;gt; Returns
 DecimalLiteralToken Kind=FloatingLiteral ==&amp;gt; Returns
 FloatingLiteralToken Kind=DateLiteral ==&amp;gt; Returns DateLiteralToken
 Kind=StringLiteral ==&amp;gt; Returns StringLiteralToken Kind=BooleanLiteral
 ==&amp;gt; Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
 Kind=NothingLiteral ==&amp;gt; Returns Keyword (with it's kind being
 NothingKeyword)
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.DateLiteralExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken)">
	<summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
	<param name="token">
 The token that represents the literal. The Kind property determines what type
 this property returns: Kind=IntegerLiteral ==&amp;gt; Returns
 IntegerLiteralToken. Kind=CharacterLiteral ==&amp;gt; Returns
 CharacterLiteralToken. Kind=DecimalLiteral ==&amp;gt; Returns
 DecimalLiteralToken Kind=FloatingLiteral ==&amp;gt; Returns
 FloatingLiteralToken Kind=DateLiteral ==&amp;gt; Returns DateLiteralToken
 Kind=StringLiteral ==&amp;gt; Returns StringLiteralToken Kind=BooleanLiteral
 ==&amp;gt; Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
 Kind=NothingLiteral ==&amp;gt; Returns Keyword (with it's kind being
 NothingKeyword)
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.StringLiteralExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken)">
	<summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
	<param name="token">
 The token that represents the literal. The Kind property determines what type
 this property returns: Kind=IntegerLiteral ==&amp;gt; Returns
 IntegerLiteralToken. Kind=CharacterLiteral ==&amp;gt; Returns
 CharacterLiteralToken. Kind=DecimalLiteral ==&amp;gt; Returns
 DecimalLiteralToken Kind=FloatingLiteral ==&amp;gt; Returns
 FloatingLiteralToken Kind=DateLiteral ==&amp;gt; Returns DateLiteralToken
 Kind=StringLiteral ==&amp;gt; Returns StringLiteralToken Kind=BooleanLiteral
 ==&amp;gt; Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
 Kind=NothingLiteral ==&amp;gt; Returns Keyword (with it's kind being
 NothingKeyword)
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.NothingLiteralExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken)">
	<summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
	<param name="token">
 The token that represents the literal. The Kind property determines what type
 this property returns: Kind=IntegerLiteral ==&amp;gt; Returns
 IntegerLiteralToken. Kind=CharacterLiteral ==&amp;gt; Returns
 CharacterLiteralToken. Kind=DecimalLiteral ==&amp;gt; Returns
 DecimalLiteralToken Kind=FloatingLiteral ==&amp;gt; Returns
 FloatingLiteralToken Kind=DateLiteral ==&amp;gt; Returns DateLiteralToken
 Kind=StringLiteral ==&amp;gt; Returns StringLiteralToken Kind=BooleanLiteral
 ==&amp;gt; Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
 Kind=NothingLiteral ==&amp;gt; Returns Keyword (with it's kind being
 NothingKeyword)
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.LiteralExpression(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken)">
	<summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
	<param name="kind">
 A &amp;lt;cref c="SyntaxKind"/&amp;gt; representing the specific kind of
 LiteralExpressionSyntax. One of CharacterLiteralExpression,
 TrueLiteralExpression, FalseLiteralExpression, NumericLiteralExpression,
 DateLiteralExpression, StringLiteralExpression, NothingLiteralExpression.
 </param>
	<param name="token">
 The token that represents the literal. The Kind property determines what type
 this property returns: Kind=IntegerLiteral ==&amp;gt; Returns
 IntegerLiteralToken. Kind=CharacterLiteral ==&amp;gt; Returns
 CharacterLiteralToken. Kind=DecimalLiteral ==&amp;gt; Returns
 DecimalLiteralToken Kind=FloatingLiteral ==&amp;gt; Returns
 FloatingLiteralToken Kind=DateLiteral ==&amp;gt; Returns DateLiteralToken
 Kind=StringLiteral ==&amp;gt; Returns StringLiteralToken Kind=BooleanLiteral
 ==&amp;gt; Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
 Kind=NothingLiteral ==&amp;gt; Returns Keyword (with it's kind being
 NothingKeyword)
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ParenthesizedExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents a parenthesized expression.
 </summary>
	<param name="openParenToken">
 The "(" token
 </param>
	<param name="expression">
 The expression inside the parentheses.
 </param>
	<param name="closeParenToken">
 The ")" token
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.MeExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Identifies the special instance "Me"
 </summary>
	<param name="keyword">
 The "Me", "MyClass" or "MyBase" keyword.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.MyBaseExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Identifies the special instance "MyBase"
 </summary>
	<param name="keyword">
 The "Me", "MyClass" or "MyBase" keyword.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.MyClassExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Identifies the special instance "MyClass"
 </summary>
	<param name="keyword">
 The "Me", "MyClass" or "MyBase" keyword.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.GetTypeExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.TypeSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents a GetType expression.
 </summary>
	<param name="getTypeKeyword">
 The "GetType" keyword.
 </param>
	<param name="openParenToken">
 The "(" token.
 </param>
	<param name="type">
 The type to get the Type object for. This can be an open generic type.
 </param>
	<param name="closeParenToken">
 The ")" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.TypeOfIsExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.TypeSyntax)">
	<summary>
 Represents a TypeOf...Is expression.
 </summary>
	<param name="typeOfKeyword">
 The "TypeOf" keyword.
 </param>
	<param name="expression">
 The expression being tested.
 </param>
	<param name="isKeyword">
 The "Is" keyword.
 </param>
	<param name="type">
 The name of the type being tested against.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.GetXmlNamespaceExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.XmlNameTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents a GetXmlNamespace expression.
 </summary>
	<param name="getXmlNamespaceKeyword">
 The "GetXmlNamespace" keyword.
 </param>
	<param name="openParenToken">
 The "(" token.
 </param>
	<param name="nameOpt">
 The Xml namespace name being referenced.
 </param>
	<param name="closeParenToken">
 The ")" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.MemberAccessExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SimpleNameSyntax)">
	<summary>
 Represents member access (.name) or dictionary access (!name). The Kind
 property determines which kind of access.
 </summary>
	<param name="leftOpt">
 The expression on the left-hand-side of the "." or "!" token.
 </param>
	<param name="token">
 The "." or "!" token.
 </param>
	<param name="name">
 The identifier after the "." or "!" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.DictionaryAccess(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SimpleNameSyntax)">
	<summary>
 Represents member access (.name) or dictionary access (!name). The Kind
 property determines which kind of access.
 </summary>
	<param name="leftOpt">
 The expression on the left-hand-side of the "." or "!" token.
 </param>
	<param name="token">
 The "." or "!" token.
 </param>
	<param name="name">
 The identifier after the "." or "!" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.XmlElementAccessExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.XmlNodeSyntax)">
	<summary>
 Represents an XML member element access (node.&amp;lt;Element&amp;gt;),
 attribute access (node.@Attribute) or descendents access
 (node...&amp;lt;Descendent&amp;gt;). The Kind property determines which kind of
 access.
 </summary>
	<param name="baseOpt">
 The expression on the left-hand-side of the ".", ".@" or "..." .
 </param>
	<param name="token1">
 The initial dot "." part of the separator.
 </param>
	<param name="token2Opt">
 The "@" part of .@ or the second "." of "...".
 </param>
	<param name="token3Opt">
 The third "." in a "..." separator.
 </param>
	<param name="name">
 The identifier after the ".", ".@" or "..."
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.XmlDescendantAccessExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.XmlNodeSyntax)">
	<summary>
 Represents an XML member element access (node.&amp;lt;Element&amp;gt;),
 attribute access (node.@Attribute) or descendents access
 (node...&amp;lt;Descendent&amp;gt;). The Kind property determines which kind of
 access.
 </summary>
	<param name="baseOpt">
 The expression on the left-hand-side of the ".", ".@" or "..." .
 </param>
	<param name="token1">
 The initial dot "." part of the separator.
 </param>
	<param name="token2Opt">
 The "@" part of .@ or the second "." of "...".
 </param>
	<param name="token3Opt">
 The third "." in a "..." separator.
 </param>
	<param name="name">
 The identifier after the ".", ".@" or "..."
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.XmlAttributeAccessExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.XmlNodeSyntax)">
	<summary>
 Represents an XML member element access (node.&amp;lt;Element&amp;gt;),
 attribute access (node.@Attribute) or descendents access
 (node...&amp;lt;Descendent&amp;gt;). The Kind property determines which kind of
 access.
 </summary>
	<param name="baseOpt">
 The expression on the left-hand-side of the ".", ".@" or "..." .
 </param>
	<param name="token1">
 The initial dot "." part of the separator.
 </param>
	<param name="token2Opt">
 The "@" part of .@ or the second "." of "...".
 </param>
	<param name="token3Opt">
 The third "." in a "..." separator.
 </param>
	<param name="name">
 The identifier after the ".", ".@" or "..."
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.XmlMemberAccessExpression(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.XmlNodeSyntax)">
	<summary>
 Represents an XML member element access (node.&amp;lt;Element&amp;gt;),
 attribute access (node.@Attribute) or descendents access
 (node...&amp;lt;Descendent&amp;gt;). The Kind property determines which kind of
 access.
 </summary>
	<param name="kind">
 A &amp;lt;cref c="SyntaxKind"/&amp;gt; representing the specific kind of
 XmlMemberAccessExpressionSyntax. One of XmlElementAccessExpression,
 XmlDescendantAccessExpression, XmlAttributeAccessExpression.
 </param>
	<param name="baseOpt">
 The expression on the left-hand-side of the ".", ".@" or "..." .
 </param>
	<param name="token1">
 The initial dot "." part of the separator.
 </param>
	<param name="token2Opt">
 The "@" part of .@ or the second "." of "...".
 </param>
	<param name="token3Opt">
 The third "." in a "..." separator.
 </param>
	<param name="name">
 The identifier after the ".", ".@" or "..."
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.InvocationExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ArgumentListSyntax)">
	<summary>
 Represents an invocation expression consisting of an invocation target and an
 optional argument list or an array, parameterized property or object default
 property index.
 </summary>
	<param name="expression">
 The target of the call or index expression.
 </param>
	<param name="argumentListOpt">
 The argument list.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ObjectCreationExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.TypeSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ArgumentListSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ObjectCreationInitializerSyntax)">
	<summary>
 Represents a New expression that creates a new non-array object, possibly with
 a "With" or "From" clause.
 </summary>
	<param name="newKeyword">
 The "New" keyword.
 </param>
	<param name="attributes">
 A list of all attribute blocks on the type. If no attributes were specified, an
 empty list is returned.
 </param>
	<param name="type">
 The type of the object being initialized.
 </param>
	<param name="argumentListOpt">
 The argument list, if present. If no argument list was supplied, Nothing is
 returned.
 </param>
	<param name="initializerOpt">
 An optional From or With clause to initialize the new object.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.AnonymousObjectCreationExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.ObjectMemberInitializerSyntax)">
	<summary>
 Represents a New expression that create an object of anonymous type.
 </summary>
	<param name="newKeyword">
 The "New" keyword.
 </param>
	<param name="attributes">
 A list of all attribute blocks on the type. If no attributes were specified, an
 empty list is returned.
 </param>
	<param name="initializer">
 The With clause to initialize the new object.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ArrayCreationExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.TypeSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ArgumentListSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.CollectionInitializerSyntax)">
	<summary>
 Represents an expression that creates a new array.
 </summary>
	<param name="newKeyword">
 The "New" keyword.
 </param>
	<param name="attributes">
 A list of all attribute blocks on the type. If no attributes were specified, an
 empty list is returned.
 </param>
	<param name="type">
 The element type of the array being created.
 </param>
	<param name="arrayBoundsOpt">
 The optional array bounds, such as "(4)" or "(0 to 5, 0 To 6)".
 </param>
	<param name="rankSpecifiers">
 A list of array modifiers such as "()" or "(,)". If no array modifiers were
 present, an empty list is returned.
 </param>
	<param name="initializer">
 The initializer including the braces.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.CollectionInitializer(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents an expression that creates a new array wihout naming the element
 type.
 </summary>
	<param name="openBraceToken">
 The "{" token.
 </param>
	<param name="initializers">
 The list of initializers between the braces.
 </param>
	<param name="closeBraceToken">
 The "}" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.CTypeExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.TypeSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents a CType, DirectCast or TryCast conversion expression. The Kind
 property determines which kind of cast it is.
 </summary>
	<param name="keyword">
 The "CType", "DirectCast" or "TryCast" keyword.
 </param>
	<param name="openParenToken">
 The "(" token.
 </param>
	<param name="expression">
 The expression being cast.
 </param>
	<param name="commaToken">
 The "," token.
 </param>
	<param name="type">
 The type the expression is being cast to.
 </param>
	<param name="closeParenToken">
 The ")" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.DirectCastExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.TypeSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents a CType, DirectCast or TryCast conversion expression. The Kind
 property determines which kind of cast it is.
 </summary>
	<param name="keyword">
 The "CType", "DirectCast" or "TryCast" keyword.
 </param>
	<param name="openParenToken">
 The "(" token.
 </param>
	<param name="expression">
 The expression being cast.
 </param>
	<param name="commaToken">
 The "," token.
 </param>
	<param name="type">
 The type the expression is being cast to.
 </param>
	<param name="closeParenToken">
 The ")" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.TryCastExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.TypeSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents a CType, DirectCast or TryCast conversion expression. The Kind
 property determines which kind of cast it is.
 </summary>
	<param name="keyword">
 The "CType", "DirectCast" or "TryCast" keyword.
 </param>
	<param name="openParenToken">
 The "(" token.
 </param>
	<param name="expression">
 The expression being cast.
 </param>
	<param name="commaToken">
 The "," token.
 </param>
	<param name="type">
 The type the expression is being cast to.
 </param>
	<param name="closeParenToken">
 The ")" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.CastExpression(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.TypeSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents a CType, DirectCast or TryCast conversion expression. The Kind
 property determines which kind of cast it is.
 </summary>
	<param name="kind">
 A &amp;lt;cref c="SyntaxKind"/&amp;gt; representing the specific kind of
 CastExpressionSyntax. One of CTypeExpression, DirectCastExpression,
 TryCastExpression.
 </param>
	<param name="keyword">
 The "CType", "DirectCast" or "TryCast" keyword.
 </param>
	<param name="openParenToken">
 The "(" token.
 </param>
	<param name="expression">
 The expression being cast.
 </param>
	<param name="commaToken">
 The "," token.
 </param>
	<param name="type">
 The type the expression is being cast to.
 </param>
	<param name="closeParenToken">
 The ")" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.PredefinedCastExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents a cast to a pre-defined type using a pre-defined cast expression,
 such as CInt or CLng.
 </summary>
	<param name="keyword">
 The keyword that was used in the cast operation.
 </param>
	<param name="openParenToken">
 The "(" token.
 </param>
	<param name="expression">
 The expression being cast.
 </param>
	<param name="closeParenToken">
 The ")" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.AddExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.SubtractExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.MultiplyExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.DivideExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.IntegerDivideExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.PowerExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.LeftShiftExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.RightShiftExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ConcatenateExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ModuloExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EqualsExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.NotEqualsExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.LessThanExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.LessThanOrEqualExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.GreaterThanOrEqualExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.GreaterThanExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.IsExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.IsNotExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.LikeExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.OrExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.XorExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.AndExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.OrElseExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.AndAlsoExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.BinaryExpression(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="kind">
 A &amp;lt;cref c="SyntaxKind"/&amp;gt; representing the specific kind of
 BinaryExpressionSyntax. One of AddExpression, SubtractExpression,
 MultiplyExpression, DivideExpression, IntegerDivideExpression, PowerExpression,
 LeftShiftExpression, RightShiftExpression, ConcatenateExpression,
 ModuloExpression, EqualsExpression, NotEqualsExpression, LessThanExpression,
 LessThanOrEqualExpression, GreaterThanOrEqualExpression, GreaterThanExpression,
 IsExpression, IsNotExpression, LikeExpression, OrExpression, XorExpression,
 AndExpression, OrElseExpression, AndAlsoExpression.
 </param>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.PlusExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Describes a unary operator: Plus, Negate, Not or AddressOf.
 </summary>
	<param name="operatorToken">
 The token that is the operator.
 </param>
	<param name="operand">
 The expression being operated on.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.NegateExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Describes a unary operator: Plus, Negate, Not or AddressOf.
 </summary>
	<param name="operatorToken">
 The token that is the operator.
 </param>
	<param name="operand">
 The expression being operated on.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.NotExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Describes a unary operator: Plus, Negate, Not or AddressOf.
 </summary>
	<param name="operatorToken">
 The token that is the operator.
 </param>
	<param name="operand">
 The expression being operated on.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.AddressOfExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Describes a unary operator: Plus, Negate, Not or AddressOf.
 </summary>
	<param name="operatorToken">
 The token that is the operator.
 </param>
	<param name="operand">
 The expression being operated on.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.UnaryExpression(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Describes a unary operator: Plus, Negate, Not or AddressOf.
 </summary>
	<param name="kind">
 A &amp;lt;cref c="SyntaxKind"/&amp;gt; representing the specific kind of
 UnaryExpressionSyntax. One of PlusExpression, NegateExpression, NotExpression,
 AddressOfExpression.
 </param>
	<param name="operatorToken">
 The token that is the operator.
 </param>
	<param name="operand">
 The expression being operated on.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.BinaryConditionalExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents a conditional expression, If(condition, true-expr, false-expr) or
 If(expr, nothing-expr).
 </summary>
	<param name="ifKeyword">
 The "If" keyword
 </param>
	<param name="openParenToken">
 The "(" token
 </param>
	<param name="firstExpression">
 The first expression inside the parentheses.
 </param>
	<param name="commaToken">
 The "," token.
 </param>
	<param name="secondExpression">
 The second expression inside the parentheses.
 </param>
	<param name="closeParenToken">
 The ")" token
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.TernaryConditionalExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents a conditional expression, If(condition, true-expr, false-expr) or
 If(expr, nothing-expr).
 </summary>
	<param name="ifKeyword">
 The "If" keyword
 </param>
	<param name="openParenToken">
 The "(" token
 </param>
	<param name="condition">
 The first expression inside the parentheses.
 </param>
	<param name="firstCommaToken">
 The "," token.
 </param>
	<param name="whenTrue">
 The second expression inside the parentheses.
 </param>
	<param name="secondCommaToken">
 The "," token.
 </param>
	<param name="whenFalse">
 The second expression inside the parentheses.
 </param>
	<param name="closeParenToken">
 The ")" token
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.SingleLineFunctionLambdaExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.LambdaHeaderSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode)">
	<summary>
 Represents a single line lambda expression.
 </summary>
	<param name="begin">
 The header part of the lambda that includes the "Sub" or "Function" keyword,
 the argument list and return type.
 </param>
	<param name="beginTerminatorOpt">
 The statement terminator token that ended the Begin statement. Optional only
 for single line lambdas.
 </param>
	<param name="body">
 The body of the lambda. Depending on the kind of lambda, this is either a
 Statement (single-line Sub lambda) or Expression (single-line Function).
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.SingleLineSubLambdaExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.LambdaHeaderSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode)">
	<summary>
 Represents a single line lambda expression.
 </summary>
	<param name="begin">
 The header part of the lambda that includes the "Sub" or "Function" keyword,
 the argument list and return type.
 </param>
	<param name="beginTerminatorOpt">
 The statement terminator token that ended the Begin statement. Optional only
 for single line lambdas.
 </param>
	<param name="body">
 The body of the lambda. Depending on the kind of lambda, this is either a
 Statement (single-line Sub lambda) or Expression (single-line Function).
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.SingleLineLambdaExpression(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.InternalSyntax.LambdaHeaderSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode)">
	<summary>
 Represents a single line lambda expression.
 </summary>
	<param name="kind">
 A &amp;lt;cref c="SyntaxKind"/&amp;gt; representing the specific kind of
 SingleLineLambdaExpressionSyntax. One of SingleLineFunctionLambdaExpression,
 SingleLineSubLambdaExpression.
 </param>
	<param name="begin">
 The header part of the lambda that includes the "Sub" or "Function" keyword,
 the argument list and return type.
 </param>
	<param name="beginTerminatorOpt">
 The statement terminator token that ended the Begin statement. Optional only
 for single line lambdas.
 </param>
	<param name="body">
 The body of the lambda. Depending on the kind of lambda, this is either a
 Statement (single-line Sub lambda) or Expression (single-line Function).
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.MultiLineFunctionLambdaExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.LambdaHeaderSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.EndBlockStatementSyntax)">
	<summary>
 Represents a multi-line lambda expression.
 </summary>
	<param name="begin">
 The header part of the lambda that includes the "Sub" or "Function" keyword,
 the argument list and return type.
 </param>
	<param name="beginTerminatorOpt">
 The statement terminator token that ended the Begin statement. Optional only
 for single line lambdas.
 </param>
	<param name="statements">
 The body of the lambda. Depending on the kind of lambda, this is either a
 StatementBody (multi-line lambda), Statement (single-line Sub lambda) or
 Expression (single-line Function). This might be an empty list.
 </param>
	<param name="end">
 Returns the "End Sub" or "End Function" statement if this is a multi-line
 lambda.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.MultiLineSubLambdaExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.LambdaHeaderSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.EndBlockStatementSyntax)">
	<summary>
 Represents a multi-line lambda expression.
 </summary>
	<param name="begin">
 The header part of the lambda that includes the "Sub" or "Function" keyword,
 the argument list and return type.
 </param>
	<param name="beginTerminatorOpt">
 The statement terminator token that ended the Begin statement. Optional only
 for single line lambdas.
 </param>
	<param name="statements">
 The body of the lambda. Depending on the kind of lambda, this is either a
 StatementBody (multi-line lambda), Statement (single-line Sub lambda) or
 Expression (single-line Function). This might be an empty list.
 </param>
	<param name="end">
 Returns the "End Sub" or "End Function" statement if this is a multi-line
 lambda.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.MultiLineLambdaExpression(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.InternalSyntax.LambdaHeaderSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.EndBlockStatementSyntax)">
	<summary>
 Represents a multi-line lambda expression.
 </summary>
	<param name="kind">
 A &amp;lt;cref c="SyntaxKind"/&amp;gt; representing the specific kind of
 MultiLineLambdaExpressionSyntax. One of MultiLineFunctionLambdaExpression,
 MultiLineSubLambdaExpression.
 </param>
	<param name="begin">
 The header part of the lambda that includes the "Sub" or "Function" keyword,
 the argument list and return type.
 </param>
	<param name="beginTerminatorOpt">
 The statement terminator token that ended the Begin statement. Optional only
 for single line lambdas.
 </param>
	<param name="statements">
 The body of the lambda. Depending on the kind of lambda, this is either a
 StatementBody (multi-line lambda), Statement (single-line Sub lambda) or
 Expression (single-line Function). This might be an empty list.
 </param>
	<param name="end">
 Returns the "End Sub" or "End Function" statement if this is a multi-line
 lambda.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.SubLambdaHeader(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ParameterListSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.AsClauseSyntax)">
	<summary>
 Represents the header part of a lambda expression
 </summary>
	<param name="attributes">
 A list of all attribute blocks on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="parameterListOpt">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClauseOpt">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.FunctionLambdaHeader(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ParameterListSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.AsClauseSyntax)">
	<summary>
 Represents the header part of a lambda expression
 </summary>
	<param name="attributes">
 A list of all attribute blocks on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="parameterListOpt">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClauseOpt">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.LambdaHeader(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ParameterListSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.AsClauseSyntax)">
	<summary>
 Represents the header part of a lambda expression
 </summary>
	<param name="kind">
 A &amp;lt;cref c="SyntaxKind"/&amp;gt; representing the specific kind of
 LambdaHeaderSyntax. One of SubLambdaHeader, FunctionLambdaHeader.
 </param>
	<param name="attributes">
 A list of all attribute blocks on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="parameterListOpt">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClauseOpt">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ArgumentList(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.ArgumentSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents a parenthesized argument list.
 </summary>
	<param name="openParenToken">
 The "(" token.
 </param>
	<param name="arguments">
 The list of arguments. This may be empty. Ommitted argument are represented by
 an OmittedArgumentSyntax node.
 </param>
	<param name="closeParenToken">
 The ")" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.OmittedArgument(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents an omitted argument in an argument list. An omitted argument is not
 considered a syntax error but a valid case when no argument is required.
 </summary>
	<param name="empty">
 An empty token because all non terminals must have a token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.SimpleArgument(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a simple argument that is just an expression.
 </summary>
	<param name="expression">
 The expression that is the argument.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.NamedArgument(Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a named argument, such as "Value:=7".
 </summary>
	<param name="identifier">
 The name used to identify the named argument.
 </param>
	<param name="colonEqualsToken">
 The ":=" token.
 </param>
	<param name="expression">
 The expression that is the named argument.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.RangeArgument(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a range argument, such as "0 to 5", used in array bounds. The
 "Value" property represents the upper bound of the range.
 </summary>
	<param name="lowerBound">
 The lower bound of the range. This is typically the integer constant zero.
 </param>
	<param name="toKeyword">
 The "To" keyword.
 </param>
	<param name="upperBound">
 The upper bound of the range.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.QueryExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode})">
	<summary>
 This class represents a query expression. A query expression is composed of one
 or more query operators in a row. The first query operator must be a From or
 Aggregate.
 </summary>
	<param name="queryOperators">
 A list of all the query operators in this query expression. This list always
 contains at least one operator.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.CollectionRangeVariable(Roslyn.Compilers.VisualBasic.InternalSyntax.ModifiedIdentifierSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SimpleAsClauseSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Describes a single variable of the form "x [As Type] In expression" for use in
 query expressions.
 </summary>
	<param name="identifier">
 The name of the range variable being defined.
 </param>
	<param name="asClauseOpt">
 Describes the type of the variable being defined.
 </param>
	<param name="inKeyword">
 The "In" keyword.
 </param>
	<param name="expression">
 The expression that serves as the source of items for the range variable.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ExpressionRangeVariable(Roslyn.Compilers.VisualBasic.InternalSyntax.VariableNameEqualsSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Describes a single variable of the form "[x [As Type] =] expression" for use in
 query expressions.
 </summary>
	<param name="nameEqualsOpt">
 The optional name and type of the expression range variable. If ommitted, the
 name of the expression range variable is inferred from the expression.
 </param>
	<param name="expression">
 The expression used to initialize the expression variable.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.AggregationRangeVariable(Roslyn.Compilers.VisualBasic.InternalSyntax.VariableNameEqualsSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.AggregationSyntax)">
	<summary>
 Describes a single variable of the form "[x [As Type] =] aggregation-function"
 for use in the Into clause of Aggregate or Group By or Group Join query
 operators.
 </summary>
	<param name="nameEqualsOpt">
 The optional name and type of the expression range variable. If ommitted, the
 name of the expression range variable is inferred from the aggregation
 expression.
 </param>
	<param name="aggregation">
 The name of the aggregation function. The "Group" aggregation function is
 represented by the identifier "Group".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.VariableNameEquals(Roslyn.Compilers.VisualBasic.InternalSyntax.ModifiedIdentifierSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SimpleAsClauseSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents the name and optional type of an expression range variable.
 </summary>
	<param name="identifier">
 The name of the variable being defined.
 </param>
	<param name="asClauseOpt">
 Describes the type of the variable being defined.
 </param>
	<param name="equalsToken">
 The "=" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.FunctionAggregation(Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents an invocation of an Aggregation function in the aggregation range
 variable declaration of a Group By, Group Join or Aggregate query operator.
 </summary>
	<param name="functionName">
 The name of the aggregation function.
 </param>
	<param name="openParenTokenOpt">
 The "(" token if present.
 </param>
	<param name="argumentOpt">
 The argument to the aggregation function.
 </param>
	<param name="closeParenTokenOpt">
 The ")" token, if present.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.GroupAggregation(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents the use of "Group" as the aggregation function in the in the
 aggregation range variable declaration of a Group By or Group Join query
 operator.
 </summary>
	<param name="groupKeyword">
 The "Group" keyword.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.FromQueryOperator(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.CollectionRangeVariableSyntax})">
	<summary>
 Represents a "From" query operator. If this is the beginning of a query, the
 Source will be Nothing. Otherwise, the Source will be the part of the query to
 the left of the From.
 </summary>
	<param name="fromKeyword">
 The "From" keyword.
 </param>
	<param name="variables">
 The list of collection variables declared by this From operator.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.LetQueryOperator(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionRangeVariableSyntax})">
	<summary>
 Represents a "Let" query operator.
 </summary>
	<param name="letKeyword">
 The "Let" keyword.
 </param>
	<param name="variables">
 The list of expression range variable being defined by the Let operator.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.AggregateQueryOperator(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.CollectionRangeVariableSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.AggregationRangeVariableSyntax})">
	<summary>
 Represents an Aggregate query operator.
 </summary>
	<param name="aggregateKeyword">
 The "Aggregate" keyword.
 </param>
	<param name="variables">
 The list of collection range variables declared by this Aggregate operator.
 </param>
	<param name="additionalQueryOperators">
 A list of additional query operators. It may be empty.
 </param>
	<param name="intoKeyword">
 The "Into" keyword.
 </param>
	<param name="aggregationVariables">
 The list of new variables being defined by the aggregation.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.DistinctQueryOperator(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents the "Distinct" query operator.
 </summary>
	<param name="distinctKeyword">
 The "Distinct" keyword.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.WhereQueryOperator(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a "Where" query operator.
 </summary>
	<param name="whereKeyword">
 The "Where" keyword.
 </param>
	<param name="condition">
 The boolean expression used for filtering.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.SkipWhileQueryOperator(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a "Skip While" or "Take While" query operator. The Kind property
 tells which.
 </summary>
	<param name="skipOrTakeKeyword">
 The "Skip" or "Take" keyword.
 </param>
	<param name="whileKeyword">
 The "While" keyword.
 </param>
	<param name="condition">
 The boolean expression used for partitioning.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.TakeWhileQueryOperator(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a "Skip While" or "Take While" query operator. The Kind property
 tells which.
 </summary>
	<param name="skipOrTakeKeyword">
 The "Skip" or "Take" keyword.
 </param>
	<param name="whileKeyword">
 The "While" keyword.
 </param>
	<param name="condition">
 The boolean expression used for partitioning.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.PartitionWhileQueryOperator(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a "Skip While" or "Take While" query operator. The Kind property
 tells which.
 </summary>
	<param name="kind">
 A &amp;lt;cref c="SyntaxKind"/&amp;gt; representing the specific kind of
 PartitionWhileQueryOperatorSyntax. One of SkipWhileQueryOperator,
 TakeWhileQueryOperator.
 </param>
	<param name="skipOrTakeKeyword">
 The "Skip" or "Take" keyword.
 </param>
	<param name="whileKeyword">
 The "While" keyword.
 </param>
	<param name="condition">
 The boolean expression used for partitioning.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.SkipQueryOperator(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a "Skip" or "Take" query operator. The Kind property tells which.
 </summary>
	<param name="skipOrTakeKeyword">
 The "Skip" or "Take" keyword.
 </param>
	<param name="count">
 Represents the expression with the number of items to take or skip.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.TakeQueryOperator(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a "Skip" or "Take" query operator. The Kind property tells which.
 </summary>
	<param name="skipOrTakeKeyword">
 The "Skip" or "Take" keyword.
 </param>
	<param name="count">
 Represents the expression with the number of items to take or skip.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.PartitionQueryOperator(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a "Skip" or "Take" query operator. The Kind property tells which.
 </summary>
	<param name="kind">
 A &amp;lt;cref c="SyntaxKind"/&amp;gt; representing the specific kind of
 PartitionQueryOperatorSyntax. One of SkipQueryOperator, TakeQueryOperator.
 </param>
	<param name="skipOrTakeKeyword">
 The "Skip" or "Take" keyword.
 </param>
	<param name="count">
 Represents the expression with the number of items to take or skip.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.GroupByQueryOperator(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionRangeVariableSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionRangeVariableSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.AggregationRangeVariableSyntax})">
	<summary>
 Represents the "Group By" query operator.
 </summary>
	<param name="groupKeyword">
 The "Group" keyword.
 </param>
	<param name="items">
 The optional list of variables being grouped; the contents of the Group clause.
 If none were specified, an empty list is returned.
 </param>
	<param name="byKeyword">
 The "By" keyword.
 </param>
	<param name="keys">
 The key values being used for grouping.
 </param>
	<param name="aggregationVariables">
 The list of new variables that calculate aggregations.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.JoinQueryOperator(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.CollectionRangeVariableSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.JoinConditionSyntax})">
	<summary>
 Represents a Join query operator.
 </summary>
	<param name="joinKeyword">
 The "Join" keyword.
 </param>
	<param name="joinedVariables">
 Defines the collection range variables being joined to.
 </param>
	<param name="additionalJoins">
 An additional Join or Group Join query operator.
 </param>
	<param name="onKeyword">
 The "On" keyword.
 </param>
	<param name="joinConditions">
 The conditions indicating what expressions to compare during the join. Each
 condition is a JoinCondition, and the separators are "And" keywords.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.JoinCondition(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents the "expression Equals expression" condition in a Join.
 </summary>
	<param name="left">
 The left expression in the Join condition.
 </param>
	<param name="equalsKeyword">
 The "Equals" keyword.
 </param>
	<param name="right">
 The right expression in the Join condition.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.GroupJoinQueryOperator(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.CollectionRangeVariableSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.JoinConditionSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.AggregationRangeVariableSyntax})">
	<summary>
 Represents the "Group Join" query operator.
 </summary>
	<param name="groupKeyword">
 The "Group" keyword.
 </param>
	<param name="joinKeyword">
 The "Join" keyword.
 </param>
	<param name="joinedVariables">
 Defines the collection range variables being joined to.
 </param>
	<param name="additionalJoins">
 An additional Join or Group Join query operator.
 </param>
	<param name="onKeyword">
 The "On" keyword.
 </param>
	<param name="joinConditions">
 The conditions indicating what expressions to compare during the join. Each
 condition is a JoinCondition, and the separators are "And" keywords.
 </param>
	<param name="intoKeyword">
 The "Into" keyword.
 </param>
	<param name="aggregationVariables">
 The list of new variables that calculate aggregations.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.OrderByQueryOperator(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.OrderingSyntax})">
	<summary>
 Represents the "Order By" query operator.
 </summary>
	<param name="orderKeyword">
 The "Order" keyword
 </param>
	<param name="byKeyword">
 The "By" keyword.
 </param>
	<param name="orderings">
 The list of OrderExpression's to sort by.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.AscendingOrdering(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 An expression to order by, plus an optional ordering. The Kind indicates
 whether to order in ascending or descending order.
 </summary>
	<param name="expression">
 The expression to sort by.
 </param>
	<param name="ascendingOrDescendingKeywordOpt">
 The "Ascending" or "Descending" keyword, if present. To determine whether to
 sort in ascending or descending order, checking the Kind property is easier.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.DescendingOrdering(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 An expression to order by, plus an optional ordering. The Kind indicates
 whether to order in ascending or descending order.
 </summary>
	<param name="expression">
 The expression to sort by.
 </param>
	<param name="ascendingOrDescendingKeywordOpt">
 The "Ascending" or "Descending" keyword, if present. To determine whether to
 sort in ascending or descending order, checking the Kind property is easier.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.Ordering(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 An expression to order by, plus an optional ordering. The Kind indicates
 whether to order in ascending or descending order.
 </summary>
	<param name="kind">
 A &amp;lt;cref c="SyntaxKind"/&amp;gt; representing the specific kind of
 OrderingSyntax. One of AscendingOrdering, DescendingOrdering.
 </param>
	<param name="expression">
 The expression to sort by.
 </param>
	<param name="ascendingOrDescendingKeywordOpt">
 The "Ascending" or "Descending" keyword, if present. To determine whether to
 sort in ascending or descending order, checking the Kind property is easier.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.SelectQueryOperator(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionRangeVariableSyntax})">
	<summary>
 Represents the "Select" query operator.
 </summary>
	<param name="selectKeyword">
 The "Select" keyword.
 </param>
	<param name="variables">
 The list of expression range variables being defined by the Select query
 operator.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.XmlDocument(Roslyn.Compilers.VisualBasic.InternalSyntax.XmlDeclarationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.XmlNodeSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode})">
	<summary>
 Represents and XML Document literal expression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.XmlDeclaration(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.XmlDeclarationOptionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.XmlDeclarationOptionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.XmlDeclarationOptionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents the XML declaration prologue in an XML literal expression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.XmlDeclarationOption(Roslyn.Compilers.VisualBasic.InternalSyntax.XmlNameTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.XmlStringSyntax)">
	<summary>
 Represents an XML document prologue option - version, encoding, standalone or
 whitespace in an XML literal expression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.XmlElement(Roslyn.Compilers.VisualBasic.InternalSyntax.XmlElementStartTagSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.XmlElementEndTagSyntax)">
	<summary>
 Represents an XML element with content in an XML literal expression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.XmlText(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode})">
	<summary>
 Represents Xml text.
 </summary>
	<param name="textTokens">
 A list of all the text tokens in the Xml text. This list always contains at
 least one token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.XmlElementStartTag(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.XmlNodeSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents the start tag of an XML element of the form &amp;lt;element&amp;gt;.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.XmlElementEndTag(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.XmlNameSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents the end tag of an XML element of the form &amp;lt;/element&amp;gt;.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.XmlEmptyElement(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.XmlNodeSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents an empty XML element of the form &amp;lt;element /&amp;gt;
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.XmlAttribute(Roslyn.Compilers.VisualBasic.InternalSyntax.XmlNodeSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.XmlNodeSyntax)">
	<summary>
 Represents an XML attribute in an XML literal expression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.XmlString(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents a string of XML characters embedded as the content of an XML
 element.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.XmlName(Roslyn.Compilers.VisualBasic.InternalSyntax.XmlPrefixSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.XmlNameTokenSyntax)">
	<summary>
 Represents an XML name of the form 'name' or 'namespace:name' appearing in
 source as part of an XML literal or member access expression or an XML
 namespace import clause.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.XmlBracketedName(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.XmlNameSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents an XML name of the form &amp;lt;xml-name&amp;gt; appearing in source
 as part of an XML literal or member access expression or an XML namespace
 import clause.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.XmlPrefix(Roslyn.Compilers.VisualBasic.InternalSyntax.XmlNameTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents and XML namespace prefix of the form 'prefix:' as in xml:ns="".
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.XmlComment(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents an XML comment of the form &amp;lt;-- Comment --&amp;gt; appearing
 in an XML literal expression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.XmlProcessingInstruction(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.XmlNameTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents an XML processing instruction of the form '&amp;lt;?
 XMLProcessingTarget XMLProcessingValue ?&amp;gt;'.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.XmlCDataSection(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents an XML CDATA section in an XML literal expression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.XmlEmbeddedExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents an embedded expression in an XML literal e.g.
 '&amp;lt;name&amp;gt;&amp;lt;%= obj.Name =%&amp;gt;&amp;lt;/name&amp;gt;'.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ArrayType(Roslyn.Compilers.VisualBasic.InternalSyntax.TypeSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode})">
	<summary>
 Represents an array type, such as "A() or "A(,)", without bounds specified for
 the array.
 </summary>
	<param name="elementType">
 The type of the elements of the array.
 </param>
	<param name="rankSpecifiers">
 Represents the list of "()" or "(,,)" modifiers on the array type.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.NullableType(Roslyn.Compilers.VisualBasic.InternalSyntax.TypeSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 A type name that represents a nullable type, such as "Integer?".
 </summary>
	<param name="elementType">
 The kind of type that is this type is a nullable of. Cannot be an array type or
 a nullable type.
 </param>
	<param name="questionMarkToken">
 The "?" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.PredefinedType(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents an occurrence of a Visual Basic built-in type such as Integer or
 String in source code.
 </summary>
	<param name="keyword">
 The keyword that was used to describe the built-in type.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.IdentifierName(Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax)">
	<summary>
 Represents a type name consisting of a single identifier (which might include
 brackets or a type character).
 </summary>
	<param name="identifier">
 The identifier in the name.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.GenericName(Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.TypeArgumentListSyntax)">
	<summary>
 Represents a simple type name with one or more generic arguments, such as "X(Of
 Y, Z).
 </summary>
	<param name="identifier">
 The identifier in the name.
 </param>
	<param name="typeArgumentList">
 The generic argument list.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.QualifiedName(Roslyn.Compilers.VisualBasic.InternalSyntax.NameSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SimpleNameSyntax)">
	<summary>
 Represents a qualified type name, for example X.Y or X(Of Z).Y.
 </summary>
	<param name="left">
 The part of the name that appears to the left of the dot. This can itself be
 any name.
 </param>
	<param name="dotToken">
 The "." token that seperates the names.
 </param>
	<param name="right">
 The part of the name that appears to the right of the dot. This must be a
 simple identifier.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.GlobalName(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents a name in the global namespace.
 </summary>
	<param name="globalKeyword">
 The "Global" keyword.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.TypeArgumentList(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.TypeSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents a parenthesized list of generic type arguments.
 </summary>
	<param name="openParenToken">
 The "(" token.
 </param>
	<param name="ofKeyword">
 The "Of" keyword.
 </param>
	<param name="arguments">
 A list of all the type arguments.
 </param>
	<param name="closeParenToken">
 The ")" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.XmlNameToken(System.String,Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode)">
	<summary>
 Represents an Xml NCName per Namespaces in XML 1.0
 </summary>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.XmlTextLiteralToken(System.String,System.String,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode)">
	<summary>
 Represents character data in Xml content also known as PCData or in an Xml
 attribute value. All text is here for now even text that does not need
 normalizationsuch as comment, pi and cdata text.
 </summary>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.XmlEntityLiteralToken(System.String,System.String,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode)">
	<summary>
 Represents character data in Xml content also known as PCData or in an Xml
 attribute value. All text is here for now even text that does not need
 normalizationsuch as comment, pi and cdata text.
 </summary>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.XmlTextToken(Roslyn.Compilers.VisualBasic.SyntaxKind,System.String,System.String,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode)">
	<summary>
 Represents character data in Xml content also known as PCData or in an Xml
 attribute value. All text is here for now even text that does not need
 normalizationsuch as comment, pi and cdata text.
 </summary>
	<param name="kind">
 A &amp;lt;cref c="SyntaxKind"/&amp;gt; representing the specific kind of
 XmlTextTokenSyntax. One of XmlTextLiteralToken, XmlEntityLiteralToken.
 </param>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.DecimalLiteralToken(System.String,Roslyn.Compilers.VisualBasic.TypeCharacter,System.Decimal,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode)">
	<summary>
 Represents a Decimal literal token.
 </summary>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.DateLiteralToken(System.String,System.DateTime,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode)">
	<summary>
 Represents an Date literal token.
 </summary>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.StringLiteralToken(System.String,System.String,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode)">
	<summary>
 Represents an string literal token.
 </summary>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.CharacterLiteralToken(System.String,System.Char,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode)">
	<summary>
 Represents an string literal token.
 </summary>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.SkippedTokens(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode})">
	<summary>
 Represents tokens that were skipped by the parser as part of error recovery,
 and thus are not part of any syntactic structure.
 </summary>
	<param name="tokens">
 The list of tokens that were skipped by the parser.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.DocumentationComment(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode})">
	<summary>
 Represents a documentation comment e.g. ''' &amp;lt;Summary&amp;gt; apearing in
 source.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.Directive(Roslyn.Compilers.VisualBasic.InternalSyntax.DirectiveStatementSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents a preprocessor directive
 </summary>
	<param name="terminator">
 The statement terminator token that ended the Directive.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.WhitespaceTrivia(System.String)">
	<summary>
 Trivia nodes represents parts of the program text that are not parts of the
 syntactic grammar, such as spaces, newlines, comments, preprocessors
 directives, and disabled code.
 </summary>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EndOfLineTrivia(System.String)">
	<summary>
 Trivia nodes represents parts of the program text that are not parts of the
 syntactic grammar, such as spaces, newlines, comments, preprocessors
 directives, and disabled code.
 </summary>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ColonTrivia(System.String)">
	<summary>
 Trivia nodes represents parts of the program text that are not parts of the
 syntactic grammar, such as spaces, newlines, comments, preprocessors
 directives, and disabled code.
 </summary>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.CommentTrivia(System.String)">
	<summary>
 Trivia nodes represents parts of the program text that are not parts of the
 syntactic grammar, such as spaces, newlines, comments, preprocessors
 directives, and disabled code.
 </summary>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.LineContinuationTrivia(System.String)">
	<summary>
 Trivia nodes represents parts of the program text that are not parts of the
 syntactic grammar, such as spaces, newlines, comments, preprocessors
 directives, and disabled code.
 </summary>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ImplicitLineContinuationTrivia(System.String)">
	<summary>
 Trivia nodes represents parts of the program text that are not parts of the
 syntactic grammar, such as spaces, newlines, comments, preprocessors
 directives, and disabled code.
 </summary>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.DocumentationCommentExteriorTrivia(System.String)">
	<summary>
 Trivia nodes represents parts of the program text that are not parts of the
 syntactic grammar, such as spaces, newlines, comments, preprocessors
 directives, and disabled code.
 </summary>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.DisabledTextTrivia(System.String)">
	<summary>
 Trivia nodes represents parts of the program text that are not parts of the
 syntactic grammar, such as spaces, newlines, comments, preprocessors
 directives, and disabled code.
 </summary>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.SkippedTextTrivia(System.String)">
	<summary>
 Trivia nodes represents parts of the program text that are not parts of the
 syntactic grammar, such as spaces, newlines, comments, preprocessors
 directives, and disabled code.
 </summary>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.SyntaxTrivia(Roslyn.Compilers.VisualBasic.SyntaxKind,System.String)">
	<summary>
 Trivia nodes represents parts of the program text that are not parts of the
 syntactic grammar, such as spaces, newlines, comments, preprocessors
 directives, and disabled code.
 </summary>
	<param name="kind">
 A &amp;lt;cref c="SyntaxKind"/&amp;gt; representing the specific kind of
 SyntaxTrivia. One of WhitespaceTrivia, EndOfLineTrivia, ColonTrivia,
 CommentTrivia, LineContinuationTrivia, ImplicitLineContinuationTrivia,
 DocumentationCommentExteriorTrivia, DisabledTextTrivia, SkippedTextTrivia.
 </param>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ConstDirective(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a #Const pre-processing constant declaration appearing in source.
 </summary>
	<param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
	<param name="constKeyword">
 The "Const" keyword.
 </param>
	<param name="name">
 The name of the pre-processing constant being defined.
 </param>
	<param name="equalsToken">
 The "=" token.
 </param>
	<param name="value">
 An expression representing the value of the pre-processing constant being
 defined.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.IfDirective(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents the beginning of an #If pre-processing directive appearing in
 source.
 </summary>
	<param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ElseIfDirective(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents the beginning of an #If pre-processing directive appearing in
 source.
 </summary>
	<param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ElseDirective(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents an #Else pre-processing directive appearing in source.
 </summary>
	<param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EndIfDirective(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents an #End If pre-processing directive appearing in source.
 </summary>
	<param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.RegionDirective(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.StringLiteralTokenSyntax)">
	<summary>
 Represents the beginning of a #Region directive appearing in source.
 </summary>
	<param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
	<param name="regionKeyword">
 The "Region" keyword.
 </param>
	<param name="name">
 The label of the code region being defined.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EndRegionDirective(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents an #End Region directive appearing in source.
 </summary>
	<param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
	<param name="endKeyword">
 The "End" keyword.
 </param>
	<param name="regionKeyword">
 The "Region" keyword.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ExternalSourceDirective(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.StringLiteralTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.IntegerLiteralTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents the beginning of a #ExternalSource pre-processing directive
 appearing in source.
 </summary>
	<param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EndExternalSourceDirective(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents an #End ExternalSource pre-processing directive appearing in source.
 </summary>
	<param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ExternalChecksumDirective(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.StringLiteralTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.StringLiteralTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.StringLiteralTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents an #ExternalChecksum pre-processing directive appearing in source.
 </summary>
	<param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.BadDirective(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents an unrecognized pre-processing directive. This occurs when the
 parser encounters a hash '#' token at the beginning of a physical line but does
 recognize the text that follows as a valid Visual Basic pre-processing
 directive.
 </summary>
	<param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ComplexIdentifierSyntax.PossibleKeywordKind">
	<summary>
 Contextual Nodekind
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ComplexIdentifierSyntax.IsBracketed">
	<summary>
 If true, the identifier was enclosed in brackets, such as "[End]".
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ComplexIdentifierSyntax.IdentifierText">
	<summary>
 The text of the identifier, not including the brackets or type character.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ComplexIdentifierSyntax.TypeCharacter">
	<summary>
 The type character suffix, if present. Returns TypeCharacter.None if no type
 character was present. The only allowed values are None, Integer, Long,
 Decimal, Single, Double, and String.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxFacts.IsKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Determine if the token instance represents a reserved or contextual keyword
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxFacts.IsReservedKeyword(Roslyn.Compilers.VisualBasic.SyntaxKind)">
	<summary>
 Determine if the kind represents a reserved keyword
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxFacts.IsReservedKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Determine if the token instance represents a reserved keyword
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxFacts.IsContextualKeyword(Roslyn.Compilers.VisualBasic.SyntaxKind)">
	<summary>
 Determine if the kind represents a contextual keyword
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxFacts.IsContextualKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Determine if the token instance represents a contextual keyword
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxFacts.IsPreprocessorKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Determine if the token instance represents a preprocessor keyword
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxFacts.IsPreprocessorKeyword(Roslyn.Compilers.VisualBasic.SyntaxKind)">
	<summary>
 Determine if the token instance represents a preprocessor keyword
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxFacts.GetKeywordKinds">
	<summary>
 Get all reserved and contextual keywords
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxFacts.GetReservedKeywordKinds">
	<summary>
 Get all reserved keywords
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxFacts.GetContextualKeywordKinds">
	<summary>
 Get contextual keywords
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxFacts.GetPunctuationKinds">
	<summary>
 Get punctuations
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxFacts.GetPreprocessorKeywordKinds">
	<summary>
 Get preprocessor keywords
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxFacts.IsPredefinedType(Roslyn.Compilers.VisualBasic.SyntaxKind)">
	<summary>
 Helper to check whether the token is a predefined type
 </summary>
	<returns>True if it is a predefined type</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxFacts.IsPredefinedTypeOrVariant(Roslyn.Compilers.VisualBasic.SyntaxKind)">
	<summary>
 Helper to check whether the token is a predefined type OR Variant keyword
 </summary>
	<returns>True if it is a predefined type OR Variant keyword</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxFacts.IsInvoked(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Returns true if the node is the object of an invocation expression
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxFacts.IsAddressOfOperand(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Returns true if the node is the operand of an AddressOf expression
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxFacts.IsInvocationOrAddressOfOperand(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Returns true if the node is the operand of an AddressOf expression, or the object
 of an invocation. This is used for special binding rules around the return value variable 
 inside Functions and Property Get accessors.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxFacts.InLambdaInterior(Roslyn.Compilers.VisualBasic.SyntaxNode,System.Int32)">
	<summary>
 Determines if possibleLambda is a lambda expression and position is in the interior.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxFacts.GetText(Roslyn.Compilers.VisualBasic.SyntaxKind)">
	<summary>
 Return keyword or punctuation text based on SyntaxKind
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EmptyStatement">
	<summary>
 A class to represent an empty statement. This can occur when a colon is on a
 line without anything else.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EndIfStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EndUsingStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EndWithStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EndSelectStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EndStructureStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EndEnumStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EndInterfaceStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EndClassStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EndModuleStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EndNamespaceStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EndSubStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EndFunctionStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EndGetStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EndSetStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EndPropertyStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EndOperatorStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EndEventStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EndAddHandlerStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EndRemoveHandlerStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EndRaiseEventStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EndWhileStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EndTryStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EndSyncLockStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CompilationUnit">
	<summary>
 Represents an entire source file of VB code.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.OptionStatement">
	<summary>
 Represents an Option statement, such as "Option Strict On".
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ImportsStatement">
	<summary>
 Represents an Imports statement, which has one or more imports clauses.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AliasImportsClause">
	<summary>
 Represents the clause of an Imports statement that defines an alias for a
 namespace or type.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.MembersImportsClause">
	<summary>
 Represents the clause of an Imports statement that imports all members of a
 namespace.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.XmlNamespaceImportsClause">
	<summary>
 Defines a XML namespace for XML expressions.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.NamespaceBlock">
	<summary>
 Represents a Namespace statement, its contents and the End Namespace statement.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.NamespaceStatement">
	<summary>
 Represents the beginning statement of a namespace declaration. This node always
 appears as the Begin of a BlockStatement with Kind=NamespaceBlock.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ModuleBlock">
	<summary>
 Represents a declaration of Module, its contents and the End statement that
 ends it.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.StructureBlock">
	<summary>
 Represents a declaration of a Structure, its contents and the End statement
 that ends it.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.InterfaceBlock">
	<summary>
 Represents a declaration of a Interface, its contents and the End statement
 that ends it.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ClassBlock">
	<summary>
 Represents a declaration of a Class its contents and the End statement that
 ends it.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EnumBlock">
	<summary>
 Represents a declaration of an Enum, its contents and the End Enum statement
 that ends it.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.InheritsStatement">
	<summary>
 Represents an Inherits statement in a Class, Structure or Interface.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ImplementsStatement">
	<summary>
 Represents an Implements statement in a Class or Structure.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ModuleStatement">
	<summary>
 Represents the beginning statement of a Module declaration. This node always
 appears as the Begin of a TypeBlock with Kind=ModuleDeclarationBlock.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.StructureStatement">
	<summary>
 Represents the beginning statement of a Structure declaration. This node always
 appears as the Begin of a TypeBlock with Kind=StructureDeclarationBlock.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.InterfaceStatement">
	<summary>
 Represents the beginning statement of a Interface declaration. This node always
 appears as the Begin of a TypeBlock with Kind=InterfaceDeclarationBlock.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ClassStatement">
	<summary>
 Represents the beginning statement of a Class declaration. This node always
 appears as the Begin of a TypeBlock with Kind=ClassDeclarationBlock.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EnumStatement">
	<summary>
 Represents the beginning statement of an Enum declaration. This node always
 appears as the Begin of an EnumBlock with Kind=EnumDeclarationBlock.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.TypeParameterList">
	<summary>
 Represents the type parameter list in a declaration.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.TypeParameter">
	<summary>
 Represents a type parameter on a generic type declaration.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.TypeParameterSingleConstraintClause">
	<summary>
 One of the type parameter constraints clauses. This represents a constraint
 clause in the form of "As Constraint".
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.TypeParameterMultipleConstraintClause">
	<summary>
 One of the type parameter constraints clauses. This represents a constraint
 clause in the form of "As { Constraints }".
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.NewConstraint">
	<summary>
 One of the special type parameter constraints: New, Class or Structure. Which
 kind of special constraint it is can be obtained from the Kind property and is
 one of: NewConstraint, ReferenceConstraint or ValueConstraint.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ClassConstraint">
	<summary>
 One of the special type parameter constraints: New, Class or Structure. Which
 kind of special constraint it is can be obtained from the Kind property and is
 one of: NewConstraint, ReferenceConstraint or ValueConstraint.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.StructureConstraint">
	<summary>
 One of the special type parameter constraints: New, Class or Structure. Which
 kind of special constraint it is can be obtained from the Kind property and is
 one of: NewConstraint, ReferenceConstraint or ValueConstraint.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.TypeConstraint">
	<summary>
 Represents a type parameter constraint that is a type.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EnumMemberDeclaration">
	<summary>
 Represents a name and value in an EnumDeclarationBlock.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SubBlock">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.FunctionBlock">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ConstructorBlock">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.OperatorBlock">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.PropertyGetBlock">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.PropertySetBlock">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AddHandlerBlock">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.RemoveHandlerBlock">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.RaiseEventBlock">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.PropertyBlock">
	<summary>
 Represents a block property declaration: A declaration that has a beginning
 declaration, some get or set accessor blocks and an end statement.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EventBlock">
	<summary>
 Represents a custom event declaration: A declaration that has a beginning event
 declaration, some accessor blocks and an end statement.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ParameterList">
	<summary>
 Represents the parameter list in a method declaration.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SubStatement">
	<summary>
 The statement that declares a Sub or Function. If this method has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.FunctionStatement">
	<summary>
 The statement that declares a Sub or Function. If this method has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ConstructorStatement">
	<summary>
 A statement that declares a constructor. This statement will be the Begin of a
 BlockStatement with Kind=MethodDeclarationBlock, and the body of the method
 will be the Body of that BlockStatement.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DeclareSubStatement">
	<summary>
 A Declare statement that declares an external DLL method.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DeclareFunctionStatement">
	<summary>
 A Declare statement that declares an external DLL method.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DelegateSubStatement">
	<summary>
 A statement that declares a delegate type.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DelegateFunctionStatement">
	<summary>
 A statement that declares a delegate type.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EventStatement">
	<summary>
 A statement that declares an event. If the event being declared is a custom
 event, this statement will be the Begin of a PropertyOrEventBlock, and the
 accessors will be part of the Accessors of that node.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.OperatorStatement">
	<summary>
 A statement that declares an operator. If this operator has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.PropertyStatement">
	<summary>
 Statement that declares a property. If this property has accessors declared,
 this statement will be the Begin of a BlockNode, and the accessors will be the
 Body of that node. Auto properties are property declarations without a
 PropertyBlock.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.GetAccessorStatement">
	<summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SetAccessorStatement">
	<summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AddHandlerAccessorStatement">
	<summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.RemoveHandlerAccessorStatement">
	<summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.RaiseEventHandlerAccessorStatement">
	<summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ImplementsClause">
	<summary>
 Represents the "Implements ..." clause on a type member, which describes which
 interface members this member implements.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.HandlesClause">
	<summary>
 Represents the "Handles ..." clause on a method declaration that describes
 which events this method handles.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.HandlesClauseItem">
	<summary>
 Represents a single handled event in a "Handles ..." clause.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.IncompleteMember">
	<summary>
 Represents the beginning of a declaration. However, not enough syntax is
 detected to classify this as a field, method, property or event. This is node
 always represents a syntax error.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.FieldDeclaration">
	<summary>
 Represents the declaration of one or more variables or constants, either as
 local variables or as class/structure members. In the case of a constant, it is
 represented by having "Const" in the Modifiers (although technically "Const" is
 not a modifier, it is represented as one in the parse trees.)
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.VariableDeclarator">
	<summary>
 Represents the part of a variable or constant declaration statement that
 associated one or more variable names with a type.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SimpleAsClause">
	<summary>
 Represents an "As {type-name}" clause that does not have an initializer or
 "New". The type has optional attributes associated with it, although attributes
 are not permitted in all possible places where this node occurs.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AsNewClause">
	<summary>
 Represents an "As New {type-name} [arguments] [initializers]" clause in a
 declaration. The type has optional attributes associated with it, although
 attributes are not permitted in many places where this node occurs (they are
 permitted, for example, on automatically implemented properties.)
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ObjectMemberInitializer">
	<summary>
 Represents a "With {...} clause used to initialize a new object's members.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ObjectCollectionInitializer">
	<summary>
 Represents a "From {...} clause used to initialize a new collection object's
 elements.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.InferredFieldInitializer">
	<summary>
 Represent a field initializer in a With {...} initializer where the field name
 is inferred from the initializer expression.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.NamedFieldInitializer">
	<summary>
 Represent a named field initializer in a With {...} initializer, such as ".x =
 expr".
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EqualsValue">
	<summary>
 Represents an "= initializer" clause in a declaration for a variable,
 pararameter or automatic property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.Parameter">
	<summary>
 Represent a parameter to a method, property, constructor, etc.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ModifiedIdentifier">
	<summary>
 Represents an identifier with optional "?" or "()" or "(,,,)" modifiers, as
 used in parameter declarations and variable declarations.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ArrayRankSpecifier">
	<summary>
 Represents a modifier that describes an array type, without bounds, such as
 "()" or "(,)".
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AttributeBlock">
	<summary>
 Represents a group of attributes within "&amp;lt;" and "&amp;gt;" brackets.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.Attribute">
	<summary>
 Represents a single attribute declaration within an attribute block.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AttributeTarget">
	<summary>
 Represents a single attribute declaration within an attribute block.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AttributesStatement">
	<summary>
 Represents a file-level attribute, in which the attributes have no other
 syntactic element they are attached to.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.WhileBlock">
	<summary>
 Represents a While...End While statement, including the While, body and End
 While.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.UsingBlock">
	<summary>
 Represents an entire Using...End Using statement, including the Using, body and
 End Using statements.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SyncLockBlock">
	<summary>
 Represents a entire SyncLock...End SyncLock block, including the SyncLock
 statement, the enclosed statements, and the End SyncLock statment.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.WithBlock">
	<summary>
 Represents a With...End With block, include the With statement, the body of the
 block and the End With statement.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.LocalDeclaration">
	<summary>
 Represents the declaration of one or more local variables or constants.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.LabelStatement">
	<summary>
 Represents a label statement.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.GoToStatement">
	<summary>
 Represents a "GoTo" statement.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.StopStatement">
	<summary>
 Represents a "Stop" or "End" statement. The Kind can be used to determine which
 kind of statement this is.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EndStatement">
	<summary>
 Represents a "Stop" or "End" statement. The Kind can be used to determine which
 kind of statement this is.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ExitDoStatement">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ExitForStatement">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ExitSubStatement">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ExitFunctionStatement">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ExitOperatorStatement">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ExitPropertyStatement">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ExitTryStatement">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ExitSelectStatement">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ExitWhileStatement">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ContinueWhileStatement">
	<summary>
 Represents a "Continue (block)" statement. THe kind of block referenced can be
 determined by examining the Kind.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ContinueDoStatement">
	<summary>
 Represents a "Continue (block)" statement. THe kind of block referenced can be
 determined by examining the Kind.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ContinueForStatement">
	<summary>
 Represents a "Continue (block)" statement. THe kind of block referenced can be
 determined by examining the Kind.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ReturnStatement">
	<summary>
 Represents a "Return" statement.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SingleLineIfStatement">
	<summary>
 Represents a line If-Then-Else statement.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SingleLineIfPart">
	<summary>
 Represents part of a single line If statement, consisting of a beginning
 if-statement, followed by a body of statement controlled by that beginning
 statement. The Kind property returns if this is an SingleLineIf.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SingleLineElsePart">
	<summary>
 Represents the Else part of an If statement, consisting of a Else statement,
 followed by a body of statement controlled by that Else.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.MultiLineIfBlock">
	<summary>
 Represents a block If...Then...Else...EndIf Statement. The Kind property can be
 used to determine if it is a block or line If.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.IfPart">
	<summary>
 Represents part of an If statement, consisting of a beginning statement (If or
 ElseIf), followed by a body of statement controlled by that beginning
 statement. The Kind property returns if this is an If or ElseIf.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ElseIfPart">
	<summary>
 Represents part of an If statement, consisting of a beginning statement (If or
 ElseIf), followed by a body of statement controlled by that beginning
 statement. The Kind property returns if this is an If or ElseIf.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ElsePart">
	<summary>
 Represents the Else part of an If statement, consisting of a Else statement,
 followed by a body of statement controlled by that Else.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.IfStatement">
	<summary>
 Represents the If part or ElseIf part of a If...End If block (or line If). This
 statement is always the Begin of a IfPart. The Kind can be examined to
 determine if this is an If or an ElseIf statement.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ElseIfStatement">
	<summary>
 Represents the If part or ElseIf part of a If...End If block (or line If). This
 statement is always the Begin of a IfPart. The Kind can be examined to
 determine if this is an If or an ElseIf statement.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ElseStatement">
	<summary>
 Represents the Else part of a If...End If block (or line If). This statement is
 always the Begin of a ElsePart.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.TryBlock">
	<summary>
 Represents an entire Try...Catch...Finally...End Try statement.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.TryPart">
	<summary>
 Represents part of an Try...Catch...Finally...End Try statement, consisting of
 a beginning statement (Try, Catch or Finally), followed by a body of statements
 controlled by that beginning statement. The Kind property returns which kind of
 part this is.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CatchPart">
	<summary>
 Represents a Catch part of an Try...Catch...Finally...End Try statement,
 consisting of a Catch statement, followed by a body of statements controlled by
 that Catch statement. The Kind property returns which kind of part this is.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.FinallyPart">
	<summary>
 Represents the Finally part of an Try...Catch...Finally...End Try statement,
 consisting of a Finally statement, followed by a body of statements controlled
 by the Finally.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.TryStatement">
	<summary>
 Represents the Try part part of a Try...Catch...Finally...End Try. This
 statement is always the Begin of a TryPart.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CatchStatement">
	<summary>
 Represents the Catch part part of a Try...Catch...Finally...End Try. This
 statement is always the Begin of a CatchPart.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CatchFilterClause">
	<summary>
 Represents the When/Filter clause of a Catch statement
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.FinallyStatement">
	<summary>
 Represents the Finally part part of a Try...Catch...Finally...End Try. This
 statement is always the Begin of a FinallyPart.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ErrorStatement">
	<summary>
 Represents the "Error" statement.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.OnErrorGoToZeroStatement">
	<summary>
 Represents an OnError Goto statement.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.OnErrorGoToMinusOneStatement">
	<summary>
 Represents an OnError Goto statement.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.OnErrorGoToLabelStatement">
	<summary>
 Represents an OnError Goto statement.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.OnErrorResumeNextStatement">
	<summary>
 Represents an OnError Resume Next statement.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ResumeStatement">
	<summary>
 Represents a "Resume" statement. The Kind property can be used to determine if
 this is a "Resume", "Resume Next" or "Resume label" statement.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ResumeLabelStatement">
	<summary>
 Represents a "Resume" statement. The Kind property can be used to determine if
 this is a "Resume", "Resume Next" or "Resume label" statement.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ResumeNextStatement">
	<summary>
 Represents a "Resume" statement. The Kind property can be used to determine if
 this is a "Resume", "Resume Next" or "Resume label" statement.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SelectBlock">
	<summary>
 Represents a Select Case block, including the Select Case that begins it, the
 contains Case blocks and the End Select.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SelectStatement">
	<summary>
 Represents a Select Case statement. This statement always occurs as the Begin
 of a SelectBlock.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CaseBlock">
	<summary>
 Represents a case statement and its subsequent block.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CaseElseBlock">
	<summary>
 Represents a case statement and its subsequent block.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CaseStatement">
	<summary>
 Represents a Case or Case Else statement. This statement is always the Begin of
 a CaseBlock. If this is a Case Else statement, the Kind=CaseElse, otherwise the
 Kind=Case.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CaseElseStatement">
	<summary>
 Represents a Case or Case Else statement. This statement is always the Begin of
 a CaseBlock. If this is a Case Else statement, the Kind=CaseElse, otherwise the
 Kind=Case.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CaseElseClause">
	<summary>
 The "Else" part in a Case Else statement.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CaseValueClause">
	<summary>
 Represents a single value in a Case.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CaseRangeClause">
	<summary>
 Represents a range "expression To expression" in a Case.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CaseEqualsClause">
	<summary>
 Represents a relation clause in a Case statement, such as "Is &amp;gt;
 expression".
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CaseNotEqualsClause">
	<summary>
 Represents a relation clause in a Case statement, such as "Is &amp;gt;
 expression".
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CaseLessThanClause">
	<summary>
 Represents a relation clause in a Case statement, such as "Is &amp;gt;
 expression".
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CaseLessThanOrEqualClause">
	<summary>
 Represents a relation clause in a Case statement, such as "Is &amp;gt;
 expression".
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CaseGreaterThanOrEqualClause">
	<summary>
 Represents a relation clause in a Case statement, such as "Is &amp;gt;
 expression".
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CaseGreaterThanClause">
	<summary>
 Represents a relation clause in a Case statement, such as "Is &amp;gt;
 expression".
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SyncLockStatement">
	<summary>
 Represents the "SyncLock" statement. This statement always occurs as the Begin
 of a SyncLockBlock.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DoLoopTopTestBlock">
	<summary>
 Represents a Do-Loop block. The Kind property can be used to determine if this
 is a top-test, bottom-test or infinite loop.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DoLoopBottomTestBlock">
	<summary>
 Represents a Do-Loop block. The Kind property can be used to determine if this
 is a top-test, bottom-test or infinite loop.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DoLoopForeverBlock">
	<summary>
 Represents a Do-Loop block. The Kind property can be used to determine if this
 is a top-test, bottom-test or infinite loop.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DoStatement">
	<summary>
 The Do statement that begins a Do-Loop block. This statement always occurs as
 the Begin of a DoLoopBlock.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.LoopStatement">
	<summary>
 The Loop statement that ends a Do-Loop block. This statement always occurs as
 the End of a DoLoopBlock.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.WhileClause">
	<summary>
 Represents a "While expression" or "Until expression" in a Do or Loop
 statement. The Kind of the clause can be "WhileClause" or "UntilClause" to
 indicate which kind of clause.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.UntilClause">
	<summary>
 Represents a "While expression" or "Until expression" in a Do or Loop
 statement. The Kind of the clause can be "WhileClause" or "UntilClause" to
 indicate which kind of clause.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.WhileStatement">
	<summary>
 The While statement that begins a While...End While block. This statement
 always occurs as the Begin of a WhileBlock.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ForBlock">
	<summary>
 Represents a For or For Each block, including the introducting statement, the
 body and the "Next" (which can be omitted if a containing For has a Next with
 multiple variables).
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ForEachBlock">
	<summary>
 Represents a For or For Each block, including the introducting statement, the
 body and the "Next" (which can be omitted if a containing For has a Next with
 multiple variables).
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ForStatement">
	<summary>
 The For statement that begins a For-Next block. This statement always occurs as
 the Begin of a ForBlock. Most of the time, the End of that ForBlock is the
 corresponding Next statement. However, multiple nested For statements are ended
 by a single Next statement with multiple variables, then the inner For
 statements will have End set to Nothing, and the Next statement is the End of
 the outermost For statement that is being ended.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ForStepClause">
	<summary>
 The Step clause in a For Statement.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ForEachStatement">
	<summary>
 The For Each statement that begins a For Each-Next block. This statement always
 occurs as the Begin of a ForBlock, and the body of the For Each-Next is the
 Body of that ForBlock. Most of the time, the End of that ForBlock is the
 corresponding Next statement. However, multiple nested For statements are ended
 by a single Next statement with multiple variables, then the inner For
 statements will have End set to Nothing, and the Next statement is the End of
 the outermost For statement that is being ended.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.NextStatement">
	<summary>
 The Next statement that ends a For-Next or For Each-Next block. This statement
 always occurs as the End of a ForBlock (with Kind=ForBlock or ForEachBlock),
 and the body of the For-Next is the Body of that ForBlock. The Begin of that
 ForBlock has the corresponding For or For Each statement.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.UsingStatement">
	<summary>
 The Using statement that begins a Using block. This statement always occurs as
 the Begin of a UsingBlock, and the body of the Using is the Body of that
 UsingBlock.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ThrowStatement">
	<summary>
 Represents a Throw statement.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AssignmentStatement">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.MidAssignment">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AddAssignment">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SubtractAssignment">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.MultiplyAssignment">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DivideAssignment">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.IntegerDivideAssignment">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.PowerAssignment">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.LeftShiftAssignment">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.RightShiftAssignment">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ConcatenateAssignment">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CallStatement">
	<summary>
 Represent an call statement (also known as a invocation statement).
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AddHandlerStatement">
	<summary>
 Represents an AddHandler or RemoveHandler statement. The Kind property
 determines which one.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.RemoveHandlerStatement">
	<summary>
 Represents an AddHandler or RemoveHandler statement. The Kind property
 determines which one.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.RaiseEventStatement">
	<summary>
 Represent a RaiseEvent statement.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.WithStatement">
	<summary>
 Represents a "With" statement. This statement always occurs as the
 BeginStatement of a WithBlock, and the body of the With is the Body of that
 WithBlock.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ReDimStatement">
	<summary>
 Represents a ReDim statement.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ReDimPreserveStatement">
	<summary>
 Represents a ReDim statement.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EraseStatement">
	<summary>
 Represents an "Erase" statement.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CharacterLiteralExpression">
	<summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.TrueLiteralExpression">
	<summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.FalseLiteralExpression">
	<summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.NumericLiteralExpression">
	<summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DateLiteralExpression">
	<summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.StringLiteralExpression">
	<summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.NothingLiteralExpression">
	<summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ParenthesizedExpression">
	<summary>
 Represents a parenthesized expression.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.MeExpression">
	<summary>
 Identifies the special instance "Me"
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.MyBaseExpression">
	<summary>
 Identifies the special instance "MyBase"
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.MyClassExpression">
	<summary>
 Identifies the special instance "MyClass"
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.GetTypeExpression">
	<summary>
 Represents a GetType expression.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.TypeOfIsExpression">
	<summary>
 Represents a TypeOf...Is expression.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.GetXmlNamespaceExpression">
	<summary>
 Represents a GetXmlNamespace expression.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.MemberAccessExpression">
	<summary>
 Represents member access (.name) or dictionary access (!name). The Kind
 property determines which kind of access.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DictionaryAccess">
	<summary>
 Represents member access (.name) or dictionary access (!name). The Kind
 property determines which kind of access.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.XmlElementAccessExpression">
	<summary>
 Represents an XML member element access (node.&amp;lt;Element&amp;gt;),
 attribute access (node.@Attribute) or descendents access
 (node...&amp;lt;Descendent&amp;gt;). The Kind property determines which kind of
 access.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.XmlDescendantAccessExpression">
	<summary>
 Represents an XML member element access (node.&amp;lt;Element&amp;gt;),
 attribute access (node.@Attribute) or descendents access
 (node...&amp;lt;Descendent&amp;gt;). The Kind property determines which kind of
 access.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.XmlAttributeAccessExpression">
	<summary>
 Represents an XML member element access (node.&amp;lt;Element&amp;gt;),
 attribute access (node.@Attribute) or descendents access
 (node...&amp;lt;Descendent&amp;gt;). The Kind property determines which kind of
 access.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.InvocationExpression">
	<summary>
 Represents an invocation expression consisting of an invocation target and an
 optional argument list or an array, parameterized property or object default
 property index.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ObjectCreationExpression">
	<summary>
 Represents a New expression that creates a new non-array object, possibly with
 a "With" or "From" clause.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AnonymousObjectCreationExpression">
	<summary>
 Represents a New expression that create an object of anonymous type.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ArrayCreationExpression">
	<summary>
 Represents an expression that creates a new array.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CollectionInitializer">
	<summary>
 Represents an expression that creates a new array wihout naming the element
 type.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CTypeExpression">
	<summary>
 Represents a CType, DirectCast or TryCast conversion expression. The Kind
 property determines which kind of cast it is.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DirectCastExpression">
	<summary>
 Represents a CType, DirectCast or TryCast conversion expression. The Kind
 property determines which kind of cast it is.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.TryCastExpression">
	<summary>
 Represents a CType, DirectCast or TryCast conversion expression. The Kind
 property determines which kind of cast it is.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.PredefinedCastExpression">
	<summary>
 Represents a cast to a pre-defined type using a pre-defined cast expression,
 such as CInt or CLng.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AddExpression">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SubtractExpression">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.MultiplyExpression">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DivideExpression">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.IntegerDivideExpression">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.PowerExpression">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.LeftShiftExpression">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.RightShiftExpression">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ConcatenateExpression">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ModuloExpression">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EqualsExpression">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.NotEqualsExpression">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.LessThanExpression">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.LessThanOrEqualExpression">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.GreaterThanOrEqualExpression">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.GreaterThanExpression">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.IsExpression">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.IsNotExpression">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.LikeExpression">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.OrExpression">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.XorExpression">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AndExpression">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.OrElseExpression">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AndAlsoExpression">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.PlusExpression">
	<summary>
 Describes a unary operator: Plus, Negate, Not or AddressOf.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.NegateExpression">
	<summary>
 Describes a unary operator: Plus, Negate, Not or AddressOf.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.NotExpression">
	<summary>
 Describes a unary operator: Plus, Negate, Not or AddressOf.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AddressOfExpression">
	<summary>
 Describes a unary operator: Plus, Negate, Not or AddressOf.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.BinaryConditionalExpression">
	<summary>
 Represents a conditional expression, If(condition, true-expr, false-expr) or
 If(expr, nothing-expr).
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.TernaryConditionalExpression">
	<summary>
 Represents a conditional expression, If(condition, true-expr, false-expr) or
 If(expr, nothing-expr).
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SingleLineFunctionLambdaExpression">
	<summary>
 Represents a single line lambda expression.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SingleLineSubLambdaExpression">
	<summary>
 Represents a single line lambda expression.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.MultiLineFunctionLambdaExpression">
	<summary>
 Represents a multi-line lambda expression.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.MultiLineSubLambdaExpression">
	<summary>
 Represents a multi-line lambda expression.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SubLambdaHeader">
	<summary>
 Represents the header part of a lambda expression
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.FunctionLambdaHeader">
	<summary>
 Represents the header part of a lambda expression
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ArgumentList">
	<summary>
 Represents a parenthesized argument list.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.OmittedArgument">
	<summary>
 Represents an omitted argument in an argument list. An omitted argument is not
 considered a syntax error but a valid case when no argument is required.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SimpleArgument">
	<summary>
 Represents a simple argument that is just an expression.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.NamedArgument">
	<summary>
 Represents a named argument, such as "Value:=7".
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.RangeArgument">
	<summary>
 Represents a range argument, such as "0 to 5", used in array bounds. The
 "Value" property represents the upper bound of the range.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.QueryExpression">
	<summary>
 This class represents a query expression. A query expression is composed of one
 or more query operators in a row. The first query operator must be a From or
 Aggregate.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CollectionRangeVariable">
	<summary>
 Describes a single variable of the form "x [As Type] In expression" for use in
 query expressions.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ExpressionRangeVariable">
	<summary>
 Describes a single variable of the form "[x [As Type] =] expression" for use in
 query expressions.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AggregationRangeVariable">
	<summary>
 Describes a single variable of the form "[x [As Type] =] aggregation-function"
 for use in the Into clause of Aggregate or Group By or Group Join query
 operators.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.VariableNameEquals">
	<summary>
 Represents the name and optional type of an expression range variable.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.FunctionAggregation">
	<summary>
 Represents an invocation of an Aggregation function in the aggregation range
 variable declaration of a Group By, Group Join or Aggregate query operator.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.GroupAggregation">
	<summary>
 Represents the use of "Group" as the aggregation function in the in the
 aggregation range variable declaration of a Group By or Group Join query
 operator.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.FromQueryOperator">
	<summary>
 Represents a "From" query operator. If this is the beginning of a query, the
 Source will be Nothing. Otherwise, the Source will be the part of the query to
 the left of the From.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.LetQueryOperator">
	<summary>
 Represents a "Let" query operator.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AggregateQueryOperator">
	<summary>
 Represents an Aggregate query operator.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DistinctQueryOperator">
	<summary>
 Represents the "Distinct" query operator.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.WhereQueryOperator">
	<summary>
 Represents a "Where" query operator.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SkipWhileQueryOperator">
	<summary>
 Represents a "Skip While" or "Take While" query operator. The Kind property
 tells which.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.TakeWhileQueryOperator">
	<summary>
 Represents a "Skip While" or "Take While" query operator. The Kind property
 tells which.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SkipQueryOperator">
	<summary>
 Represents a "Skip" or "Take" query operator. The Kind property tells which.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.TakeQueryOperator">
	<summary>
 Represents a "Skip" or "Take" query operator. The Kind property tells which.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.GroupByQueryOperator">
	<summary>
 Represents the "Group By" query operator.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.JoinQueryOperator">
	<summary>
 Represents a Join query operator.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.JoinCondition">
	<summary>
 Represents the "expression Equals expression" condition in a Join.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.GroupJoinQueryOperator">
	<summary>
 Represents the "Group Join" query operator.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.OrderByQueryOperator">
	<summary>
 Represents the "Order By" query operator.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AscendingOrdering">
	<summary>
 An expression to order by, plus an optional ordering. The Kind indicates
 whether to order in ascending or descending order.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DescendingOrdering">
	<summary>
 An expression to order by, plus an optional ordering. The Kind indicates
 whether to order in ascending or descending order.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SelectQueryOperator">
	<summary>
 Represents the "Select" query operator.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.XmlDocument">
	<summary>
 Represents and XML Document literal expression.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.XmlDeclaration">
	<summary>
 Represents the XML declaration prologue in an XML literal expression.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.XmlDeclarationOption">
	<summary>
 Represents an XML document prologue option - version, encoding, standalone or
 whitespace in an XML literal expression.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.XmlElement">
	<summary>
 Represents an XML element with content in an XML literal expression.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.XmlText">
	<summary>
 Represents Xml text.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.XmlElementStartTag">
	<summary>
 Represents the start tag of an XML element of the form &amp;lt;element&amp;gt;.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.XmlElementEndTag">
	<summary>
 Represents the end tag of an XML element of the form &amp;lt;/element&amp;gt;.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.XmlEmptyElement">
	<summary>
 Represents an empty XML element of the form &amp;lt;element /&amp;gt;
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.XmlAttribute">
	<summary>
 Represents an XML attribute in an XML literal expression.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.XmlString">
	<summary>
 Represents a string of XML characters embedded as the content of an XML
 element.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.XmlName">
	<summary>
 Represents an XML name of the form 'name' or 'namespace:name' appearing in
 source as part of an XML literal or member access expression or an XML
 namespace import clause.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.XmlBracketedName">
	<summary>
 Represents an XML name of the form &amp;lt;xml-name&amp;gt; appearing in source
 as part of an XML literal or member access expression or an XML namespace
 import clause.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.XmlPrefix">
	<summary>
 Represents and XML namespace prefix of the form 'prefix:' as in xml:ns="".
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.XmlComment">
	<summary>
 Represents an XML comment of the form &amp;lt;-- Comment --&amp;gt; appearing
 in an XML literal expression.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.XmlProcessingInstruction">
	<summary>
 Represents an XML processing instruction of the form '&amp;lt;?
 XMLProcessingTarget XMLProcessingValue ?&amp;gt;'.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.XmlCDataSection">
	<summary>
 Represents an XML CDATA section in an XML literal expression.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.XmlEmbeddedExpression">
	<summary>
 Represents an embedded expression in an XML literal e.g.
 '&amp;lt;name&amp;gt;&amp;lt;%= obj.Name =%&amp;gt;&amp;lt;/name&amp;gt;'.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ArrayType">
	<summary>
 Represents an array type, such as "A() or "A(,)", without bounds specified for
 the array.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.NullableType">
	<summary>
 A type name that represents a nullable type, such as "Integer?".
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.PredefinedType">
	<summary>
 Represents an occurrence of a Visual Basic built-in type such as Integer or
 String in source code.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.IdentifierName">
	<summary>
 Represents a type name consisting of a single identifier (which might include
 brackets or a type character).
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.GenericName">
	<summary>
 Represents a simple type name with one or more generic arguments, such as "X(Of
 Y, Z).
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.QualifiedName">
	<summary>
 Represents a qualified type name, for example X.Y or X(Of Z).Y.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.GlobalName">
	<summary>
 Represents a name in the global namespace.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.TypeArgumentList">
	<summary>
 Represents a parenthesized list of generic type arguments.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AddHandlerKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AddressOfKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AliasKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AndKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AndAlsoKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AsKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.BooleanKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ByRefKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ByteKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ByValKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CallKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CaseKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CatchKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CBoolKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CByteKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CCharKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CDateKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CDecKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CDblKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CharKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CIntKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ClassKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CLngKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CObjKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ConstKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ContinueKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CSByteKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CShortKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CSngKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CStrKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CTypeKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CUIntKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CULngKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CUShortKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DateKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DecimalKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DeclareKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DefaultKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DelegateKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DimKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DirectCastKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DoKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DoubleKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EachKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ElseKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ElseIfKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EndKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EnumKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EraseKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ErrorKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EventKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ExitKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.FalseKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.FinallyKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ForKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.FriendKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.FunctionKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.GetKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.GetTypeKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.GetXmlNamespaceKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.GlobalKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.GoToKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.HandlesKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.IfKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ImplementsKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ImportsKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.InKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.InheritsKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.IntegerKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.InterfaceKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.IsKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.IsNotKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.LetKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.LibKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.LikeKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.LongKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.LoopKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.MeKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ModKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ModuleKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.MustInheritKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.MustOverrideKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.MyBaseKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.MyClassKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.NamespaceKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.NarrowingKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.NextKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.NewKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.NotKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.NothingKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.NotInheritableKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.NotOverridableKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ObjectKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.OfKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.OnKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.OperatorKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.OptionKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.OptionalKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.OrKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.OrElseKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.OverloadsKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.OverridableKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.OverridesKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ParamArrayKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.PartialKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.PrivateKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.PropertyKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ProtectedKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.PublicKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.RaiseEventKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ReadOnlyKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ReDimKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.REMKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.RemoveHandlerKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ResumeKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ReturnKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SByteKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SelectKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SetKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ShadowsKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SharedKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ShortKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SingleKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.StaticKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.StepKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.StopKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.StringKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.StructureKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SubKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SyncLockKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ThenKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ThrowKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ToKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.TrueKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.TryKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.TryCastKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.TypeOfKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.UIntegerKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ULongKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.UShortKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.UsingKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.WhenKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.WhileKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.WideningKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.WithKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.WithEventsKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.WriteOnlyKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.XorKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EndIfKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.GosubKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.VariantKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.WendKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AggregateKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AllKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AnsiKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AscendingKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AssemblyKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AutoKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.BinaryKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ByKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CompareKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CustomKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DescendingKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DistinctKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EqualsKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ExplicitKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ExternalSourceKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ExternalChecksumKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.FromKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.GroupKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.InferKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.IntoKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.IsFalseKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.IsTrueKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.JoinKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.KeyKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.MidKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.OffKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.OrderKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.OutKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.PreserveKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.RegionKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SkipKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.StrictKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.TakeKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.TextKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.UnicodeKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.UntilKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.WhereKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.TypeKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.XmlKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ExclamationToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AtToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CommaToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.HashToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AmpersandToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SingleQuoteToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.OpenParenToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CloseParenToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.OpenBraceToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CloseBraceToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SemicolonToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AsteriskToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.PlusToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.MinusToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DotToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SlashToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ColonToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.LessThanToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.LessThanEqualsToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.LessThanGreaterThanToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EqualsToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.GreaterThanToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.GreaterThanEqualsToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.BackslashToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CaretToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ColonEqualsToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AmpersandEqualsToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AsteriskEqualsToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.PlusEqualsToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.MinusEqualsToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SlashEqualsToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.BackslashEqualsToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CaretEqualsToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.LessThanLessThanToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.GreaterThanGreaterThanToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.LessThanLessThanEqualsToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.GreaterThanGreaterThanEqualsToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.QuestionToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DoubleQuoteToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.StatementTerminatorToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EndOfFileToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EmptyToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SlashGreaterThanToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.LessThanSlashToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.LessThanMinusMinusToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.MinusMinusGreaterThanToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.LessThanQuestionToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.QuestionGreaterThanToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.LessThanPercentEqualsToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.PercentGreaterThanToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.BeginCDataToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EndCDataToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EndOfXmlToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.BadToken">
	<summary>
 Represents a sequence of characters appearing in source with no possible
 meaning in the Visual Basic language (e.g. the semicolon ';'). This token
 should only appear in SkippedTokenTrivia as an artifact of parsing error
 recovery.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.XmlNameToken">
	<summary>
 Represents an Xml NCName per Namespaces in XML 1.0
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.XmlTextLiteralToken">
	<summary>
 Represents character data in Xml content also known as PCData or in an Xml
 attribute value. All text is here for now even text that does not need
 normalizationsuch as comment, pi and cdata text.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.XmlEntityLiteralToken">
	<summary>
 Represents character data in Xml content also known as PCData or in an Xml
 attribute value. All text is here for now even text that does not need
 normalizationsuch as comment, pi and cdata text.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.IdentifierToken">
	<summary>
 Represents an identifier token. This might include brackets around the name and
 a type character.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.IntegerLiteralToken">
	<summary>
 Represents an integer literal token.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.FloatingLiteralToken">
	<summary>
 Represents an floating literal token.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DecimalLiteralToken">
	<summary>
 Represents a Decimal literal token.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DateLiteralToken">
	<summary>
 Represents an Date literal token.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.StringLiteralToken">
	<summary>
 Represents an string literal token.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CharacterLiteralToken">
	<summary>
 Represents an string literal token.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SkippedTokens">
	<summary>
 Represents tokens that were skipped by the parser as part of error recovery,
 and thus are not part of any syntactic structure.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DocumentationComment">
	<summary>
 Represents a documentation comment e.g. ''' &amp;lt;Summary&amp;gt; apearing in
 source.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.Directive">
	<summary>
 Represents a preprocessor directive
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.WhitespaceTrivia">
	<summary>
 Represents true whitespace: spaces, tabs, newlines and the like.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EndOfLineTrivia">
	<summary>
 Represents line breaks that are syntactically insignificant.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ColonTrivia">
	<summary>
 Represents colons that are syntactically insignificant.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CommentTrivia">
	<summary>
 Represents a comment.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.LineContinuationTrivia">
	<summary>
 Represents an explicit line continuation character at the end of a line, i.e.,
 _
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ImplicitLineContinuationTrivia">
	<summary>
 Represents an implicit line continuation.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DocumentationCommentExteriorTrivia">
	<summary>
 Represents a ''' prefix for a DocComment.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DisabledTextTrivia">
	<summary>
 Represents text in a false preprocessor block
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SkippedTextTrivia">
	<summary>
 Represents text skipped by the parser during error recovery
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ConstDirective">
	<summary>
 Represents a #Const pre-processing constant declaration appearing in source.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.IfDirective">
	<summary>
 Represents the beginning of an #If pre-processing directive appearing in
 source.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ElseIfDirective">
	<summary>
 Represents the beginning of an #If pre-processing directive appearing in
 source.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ElseDirective">
	<summary>
 Represents an #Else pre-processing directive appearing in source.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EndIfDirective">
	<summary>
 Represents an #End If pre-processing directive appearing in source.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.RegionDirective">
	<summary>
 Represents the beginning of a #Region directive appearing in source.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EndRegionDirective">
	<summary>
 Represents an #End Region directive appearing in source.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ExternalSourceDirective">
	<summary>
 Represents the beginning of a #ExternalSource pre-processing directive
 appearing in source.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EndExternalSourceDirective">
	<summary>
 Represents an #End ExternalSource pre-processing directive appearing in source.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ExternalChecksumDirective">
	<summary>
 Represents an #ExternalChecksum pre-processing directive appearing in source.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.BadDirective">
	<summary>
 Represents an unrecognized pre-processing directive. This occurs when the
 parser encounters a hash '#' token at the beginning of a physical line but does
 recognize the text that follows as a valid Visual Basic pre-processing
 directive.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SyntaxKind">
	<summary>
 Enumeration with all Visual Basic syntax node kinds.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.TypeCharacter.Integer">
	<summary>
 The "%" type character."
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.TypeCharacter.Long">
	<summary>
 The "&amp;" type character."
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.TypeCharacter.Decimal">
	<summary>
 The "@" type character."
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.TypeCharacter.Single">
	<summary>
 The "!" type character."
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.TypeCharacter.Double">
	<summary>
 The "#" type character."
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.TypeCharacter.String">
	<summary>
 The "$" type character."
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.TypeCharacter.ShortLiteral">
	<summary>
 The "S" literal suffix denoting "Short"
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.TypeCharacter.UShortLiteral">
	<summary>
 The "US" literal suffix denoting "UShort"
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.TypeCharacter.IntegerLiteral">
	<summary>
 The "I" literal suffix denoting "Integer"
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.TypeCharacter.UIntegerLiteral">
	<summary>
 The "UI" literal suffix denoting "UInteger"
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.TypeCharacter.LongLiteral">
	<summary>
 The "L" literal suffix denoting "Long"
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.TypeCharacter.ULongLiteral">
	<summary>
 The "UL" literal suffix denoting "ULong"
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.TypeCharacter.SingleLiteral">
	<summary>
 The "F" literal suffix denoting "Single"
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.TypeCharacter.DoubleLiteral">
	<summary>
 The "R" literal suffix denoting "Double"
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.TypeCharacter.DecimalLiteral">
	<summary>
 The "D" literal suffix denoting "Decimal"
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.TypeCharacter">
	<summary>
 Represents one of the type characters or literal suffixes of VB. Used to
 describe a) the type character suffixes that can be placed on identifers, and
 b) the suffixes that can be placed on integer literals.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.LiteralBase">
	<summary>
 The three possible number bases that a literal can be written in.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SyntaxNode">
	<summary>
 The base class for all nodes in the VB syntax tree.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.StatementSyntax">
	<summary>
 The base class for all nodes that represent statements. This includes both
 declaration statements, such as class declarations as well as executable
 statements.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.EmptyStatementSyntax.Empty">
	<summary>
 An empty token because all non terminals must have a token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.EmptyStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new EmptyStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="empty">
 The new Empty to update this EmptyStatementSyntaxSyntax node with. If not
 specified the current Empty will be used in the new EmptyStatementSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.EmptyStatementSyntax">
	<summary>
 A class to represent an empty statement. This can occur when a colon is on a
 line without anything else.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax.EndKeyword">
	<summary>
 The "End" keyword
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax.BlockKeyword">
	<summary>
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new EndBlockStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="endKeyword">
 The new EndKeyword to update this EndBlockStatementSyntaxSyntax node with. If
 not specified the current EndKeyword will be used in the new
 EndBlockStatementSyntaxSyntax node.
 </param>
	<param name="blockKeyword">
 The new BlockKeyword to update this EndBlockStatementSyntaxSyntax node with. If
 not specified the current BlockKeyword will be used in the new
 EndBlockStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CompilationUnitSyntax.Options">
	<summary>
 Represents the list of Option statements at the beginning of a source file.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.CompilationUnitSyntax.Imports">
	<summary>
 Represents the list of Imports statements at the beginning of a source file.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.CompilationUnitSyntax.Attributes">
	<summary>
 Represents the list of AttributeStatements at the beginning of a source file
 that contain the Assembly and Module attributes.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.CompilationUnitSyntax.Members">
	<summary>
 Represents the members of the default namespace for this source file: all the
 top-level type and namespace declarations in the file. May also contain
 Statements that are not valid
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.CompilationUnitSyntax.EndOfFileToken">
	<summary>
 Represents the end of the source file. This token may have trivia (whitespace,
 comments, ...) attached to it.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CompilationUnitSyntax.Update(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.OptionStatementSyntax},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ImportsStatementSyntax},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.AttributesStatementSyntax},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new CompilationUnitSyntaxSyntax node with the specified changes.
 </summary>
	<param name="options">
 The new Options to update this CompilationUnitSyntaxSyntax node with. If not
 specified the current Options will be used in the new
 CompilationUnitSyntaxSyntax node.
 </param>
	<param name="imports">
 The new Imports to update this CompilationUnitSyntaxSyntax node with. If not
 specified the current Imports will be used in the new
 CompilationUnitSyntaxSyntax node.
 </param>
	<param name="attributes">
 The new Attributes to update this CompilationUnitSyntaxSyntax node with. If not
 specified the current Attributes will be used in the new
 CompilationUnitSyntaxSyntax node.
 </param>
	<param name="members">
 The new Members to update this CompilationUnitSyntaxSyntax node with. If not
 specified the current Members will be used in the new
 CompilationUnitSyntaxSyntax node.
 </param>
	<param name="endOfFileToken">
 The new EndOfFileToken to update this CompilationUnitSyntaxSyntax node with. If
 not specified the current EndOfFileToken will be used in the new
 CompilationUnitSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.CompilationUnitSyntax">
	<summary>
 Represents an entire source file of VB code.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.OptionStatementSyntax.OptionKeyword">
	<summary>
 The "Option" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.OptionStatementSyntax.NameKeyword">
	<summary>
 The keyword that identifies the option being set: Explicit, Strict, Compare or
 Infer.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.OptionStatementSyntax.ValueKeywordOpt">
	<summary>
 The keyword that identifiers the value being set for the opition: On, Off, Text
 or Binary.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.OptionStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new OptionStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="optionKeyword">
 The new OptionKeyword to update this OptionStatementSyntaxSyntax node with. If
 not specified the current OptionKeyword will be used in the new
 OptionStatementSyntaxSyntax node.
 </param>
	<param name="nameKeyword">
 The new NameKeyword to update this OptionStatementSyntaxSyntax node with. If
 not specified the current NameKeyword will be used in the new
 OptionStatementSyntaxSyntax node.
 </param>
	<param name="valueKeywordOpt">
 The new ValueKeyword to update this OptionStatementSyntaxSyntax node with. If
 not specified the current ValueKeyword will be used in the new
 OptionStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.OptionStatementSyntax">
	<summary>
 Represents an Option statement, such as "Option Strict On".
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ImportsStatementSyntax.ImportsKeyword">
	<summary>
 The "Imports" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ImportsStatementSyntax.ImportsClauses">
	<summary>
 A list of one or more import clauses. Each clause is either an alias, namespace
 or XML namespace import.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ImportsStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ImportsClauseSyntax})">
	<summary>
 Creates a new ImportsStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="importsKeyword">
 The new ImportsKeyword to update this ImportsStatementSyntaxSyntax node with.
 If not specified the current ImportsKeyword will be used in the new
 ImportsStatementSyntaxSyntax node.
 </param>
	<param name="importsClauses">
 The new ImportsClauses to update this ImportsStatementSyntaxSyntax node with.
 If not specified the current ImportsClauses will be used in the new
 ImportsStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ImportsStatementSyntax">
	<summary>
 Represents an Imports statement, which has one or more imports clauses.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.ImportsClauseSyntax">
	<summary>
 The base class for the possible clauses of an Imports statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AliasImportsClauseSyntax.Alias">
	<summary>
 The identifier that the alias is being defined for.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AliasImportsClauseSyntax.EqualsToken">
	<summary>
 The equals sign token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AliasImportsClauseSyntax.Name">
	<summary>
 The namespace or type the alias refers to.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AliasImportsClauseSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.NameSyntax)">
	<summary>
 Creates a new AliasImportsClauseSyntaxSyntax node with the specified changes.
 </summary>
	<param name="alias">
 The new Alias to update this AliasImportsClauseSyntaxSyntax node with. If not
 specified the current Alias will be used in the new
 AliasImportsClauseSyntaxSyntax node.
 </param>
	<param name="equalsToken">
 The new EqualsToken to update this AliasImportsClauseSyntaxSyntax node with. If
 not specified the current EqualsToken will be used in the new
 AliasImportsClauseSyntaxSyntax node.
 </param>
	<param name="name">
 The new Name to update this AliasImportsClauseSyntaxSyntax node with. If not
 specified the current Name will be used in the new
 AliasImportsClauseSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.AliasImportsClauseSyntax">
	<summary>
 Represents the clause of an Imports statement that defines an alias for a
 namespace or type.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MembersImportsClauseSyntax.Name">
	<summary>
 The namespace or type being imported.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MembersImportsClauseSyntax.Update(Roslyn.Compilers.VisualBasic.NameSyntax)">
	<summary>
 Creates a new MembersImportsClauseSyntaxSyntax node with the specified changes.
 </summary>
	<param name="name">
 The new Name to update this MembersImportsClauseSyntaxSyntax node with. If not
 specified the current Name will be used in the new
 MembersImportsClauseSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.MembersImportsClauseSyntax">
	<summary>
 Represents the clause of an Imports statement that imports all members of a
 namespace.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.XmlNamespaceImportsClauseSyntax.XmlNamespace">
	<summary>
 Identifies the XML namespace alias and URI.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlNamespaceImportsClauseSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.XmlAttributeSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new XmlNamespaceImportsClauseSyntaxSyntax node with the specified
 changes.
 </summary>
	<param name="lessThanToken">
 The new LessThanToken to update this XmlNamespaceImportsClauseSyntaxSyntax node
 with. If not specified the current LessThanToken will be used in the new
 XmlNamespaceImportsClauseSyntaxSyntax node.
 </param>
	<param name="xmlNamespace">
 The new XmlNamespace to update this XmlNamespaceImportsClauseSyntaxSyntax node
 with. If not specified the current XmlNamespace will be used in the new
 XmlNamespaceImportsClauseSyntaxSyntax node.
 </param>
	<param name="greaterThanToken">
 The new GreaterThanToken to update this XmlNamespaceImportsClauseSyntaxSyntax
 node with. If not specified the current GreaterThanToken will be used in the
 new XmlNamespaceImportsClauseSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.XmlNamespaceImportsClauseSyntax">
	<summary>
 Defines a XML namespace for XML expressions.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamespaceBlockSyntax.Begin">
	<summary>
 The statement that begins the NamespaceBlock.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamespaceBlockSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamespaceBlockSyntax.Members">
	<summary>
 The declarations contained in the namespace statement.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamespaceBlockSyntax.End">
	<summary>
 The End Namespace statement that ends the block.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamespaceBlockSyntax.Update(Roslyn.Compilers.VisualBasic.NamespaceStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Creates a new NamespaceBlockSyntaxSyntax node with the specified changes.
 </summary>
	<param name="begin">
 The new Begin to update this NamespaceBlockSyntaxSyntax node with. If not
 specified the current Begin will be used in the new NamespaceBlockSyntaxSyntax
 node.
 </param>
	<param name="beginTerminator">
 The new BeginTerminator to update this NamespaceBlockSyntaxSyntax node with. If
 not specified the current BeginTerminator will be used in the new
 NamespaceBlockSyntaxSyntax node.
 </param>
	<param name="members">
 The new Members to update this NamespaceBlockSyntaxSyntax node with. If not
 specified the current Members will be used in the new
 NamespaceBlockSyntaxSyntax node.
 </param>
	<param name="end">
 The new End to update this NamespaceBlockSyntaxSyntax node with. If not
 specified the current End will be used in the new NamespaceBlockSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.NamespaceBlockSyntax">
	<summary>
 Represents a Namespace statement, its contents and the End Namespace statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamespaceStatementSyntax.NamespaceKeyword">
	<summary>
 The "Namespace" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamespaceStatementSyntax.Name">
	<summary>
 A (possibly dotted) name denoting the namespace being declared.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamespaceStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.NameSyntax)">
	<summary>
 Creates a new NamespaceStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="namespaceKeyword">
 The new NamespaceKeyword to update this NamespaceStatementSyntaxSyntax node
 with. If not specified the current NamespaceKeyword will be used in the new
 NamespaceStatementSyntaxSyntax node.
 </param>
	<param name="name">
 The new Name to update this NamespaceStatementSyntaxSyntax node with. If not
 specified the current Name will be used in the new
 NamespaceStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.NamespaceStatementSyntax">
	<summary>
 Represents the beginning statement of a namespace declaration. This node always
 appears as the Begin of a BlockStatement with Kind=NamespaceBlock.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeBlockSyntax.Begin">
	<summary>
 The statement that begins the type or module.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeBlockSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeBlockSyntax.Inherits">
	<summary>
 A list of the Inherits declarations for the type.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeBlockSyntax.Implements">
	<summary>
 A list of the Implements declarations for the type.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeBlockSyntax.Members">
	<summary>
 The declarations contained in the type or module.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeBlockSyntax.End">
	<summary>
 The End XXX statement that ends the block.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.TypeBlockSyntax">
	<summary>
 Represents a declaration of a Class, Interface, Structure, Module, its contents
 and the End statement that ends it.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ModuleBlockSyntax.Begin">
	<summary>
 The statement that begins the type or module.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ModuleBlockSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ModuleBlockSyntax.Inherits">
	<summary>
 A list of the Inherits declarations for the type.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ModuleBlockSyntax.Implements">
	<summary>
 A list of the Implements declarations for the type.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ModuleBlockSyntax.Members">
	<summary>
 The declarations contained in the type or module.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ModuleBlockSyntax.End">
	<summary>
 The End XXX statement that ends the block.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ModuleBlockSyntax.Update(Roslyn.Compilers.VisualBasic.TypeStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InheritsStatementSyntax},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ImplementsStatementSyntax},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Creates a new ModuleBlockSyntaxSyntax node with the specified changes.
 </summary>
	<param name="begin">
 The new Begin to update this ModuleBlockSyntaxSyntax node with. If not
 specified the current Begin will be used in the new ModuleBlockSyntaxSyntax
 node.
 </param>
	<param name="beginTerminator">
 The new BeginTerminator to update this ModuleBlockSyntaxSyntax node with. If
 not specified the current BeginTerminator will be used in the new
 ModuleBlockSyntaxSyntax node.
 </param>
	<param name="inherits">
 The new Inherits to update this ModuleBlockSyntaxSyntax node with. If not
 specified the current Inherits will be used in the new ModuleBlockSyntaxSyntax
 node.
 </param>
	<param name="implements">
 The new Implements to update this ModuleBlockSyntaxSyntax node with. If not
 specified the current Implements will be used in the new
 ModuleBlockSyntaxSyntax node.
 </param>
	<param name="members">
 The new Members to update this ModuleBlockSyntaxSyntax node with. If not
 specified the current Members will be used in the new ModuleBlockSyntaxSyntax
 node.
 </param>
	<param name="end">
 The new End to update this ModuleBlockSyntaxSyntax node with. If not specified
 the current End will be used in the new ModuleBlockSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ModuleBlockSyntax">
	<summary>
 Represents a declaration of Module, its contents and the End statement that
 ends it.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.StructureBlockSyntax.Begin">
	<summary>
 The statement that begins the type or module.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.StructureBlockSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.StructureBlockSyntax.Inherits">
	<summary>
 A list of the Inherits declarations for the type.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.StructureBlockSyntax.Implements">
	<summary>
 A list of the Implements declarations for the type.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.StructureBlockSyntax.Members">
	<summary>
 The declarations contained in the type or module.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.StructureBlockSyntax.End">
	<summary>
 The End XXX statement that ends the block.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.StructureBlockSyntax.Update(Roslyn.Compilers.VisualBasic.TypeStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InheritsStatementSyntax},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ImplementsStatementSyntax},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Creates a new StructureBlockSyntaxSyntax node with the specified changes.
 </summary>
	<param name="begin">
 The new Begin to update this StructureBlockSyntaxSyntax node with. If not
 specified the current Begin will be used in the new StructureBlockSyntaxSyntax
 node.
 </param>
	<param name="beginTerminator">
 The new BeginTerminator to update this StructureBlockSyntaxSyntax node with. If
 not specified the current BeginTerminator will be used in the new
 StructureBlockSyntaxSyntax node.
 </param>
	<param name="inherits">
 The new Inherits to update this StructureBlockSyntaxSyntax node with. If not
 specified the current Inherits will be used in the new
 StructureBlockSyntaxSyntax node.
 </param>
	<param name="implements">
 The new Implements to update this StructureBlockSyntaxSyntax node with. If not
 specified the current Implements will be used in the new
 StructureBlockSyntaxSyntax node.
 </param>
	<param name="members">
 The new Members to update this StructureBlockSyntaxSyntax node with. If not
 specified the current Members will be used in the new
 StructureBlockSyntaxSyntax node.
 </param>
	<param name="end">
 The new End to update this StructureBlockSyntaxSyntax node with. If not
 specified the current End will be used in the new StructureBlockSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.StructureBlockSyntax">
	<summary>
 Represents a declaration of a Structure, its contents and the End statement
 that ends it.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InterfaceBlockSyntax.Begin">
	<summary>
 The statement that begins the type or module.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InterfaceBlockSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InterfaceBlockSyntax.Inherits">
	<summary>
 A list of the Inherits declarations for the type.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InterfaceBlockSyntax.Implements">
	<summary>
 A list of the Implements declarations for the type.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InterfaceBlockSyntax.Members">
	<summary>
 The declarations contained in the type or module.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InterfaceBlockSyntax.End">
	<summary>
 The End XXX statement that ends the block.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InterfaceBlockSyntax.Update(Roslyn.Compilers.VisualBasic.TypeStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InheritsStatementSyntax},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ImplementsStatementSyntax},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Creates a new InterfaceBlockSyntaxSyntax node with the specified changes.
 </summary>
	<param name="begin">
 The new Begin to update this InterfaceBlockSyntaxSyntax node with. If not
 specified the current Begin will be used in the new InterfaceBlockSyntaxSyntax
 node.
 </param>
	<param name="beginTerminator">
 The new BeginTerminator to update this InterfaceBlockSyntaxSyntax node with. If
 not specified the current BeginTerminator will be used in the new
 InterfaceBlockSyntaxSyntax node.
 </param>
	<param name="inherits">
 The new Inherits to update this InterfaceBlockSyntaxSyntax node with. If not
 specified the current Inherits will be used in the new
 InterfaceBlockSyntaxSyntax node.
 </param>
	<param name="implements">
 The new Implements to update this InterfaceBlockSyntaxSyntax node with. If not
 specified the current Implements will be used in the new
 InterfaceBlockSyntaxSyntax node.
 </param>
	<param name="members">
 The new Members to update this InterfaceBlockSyntaxSyntax node with. If not
 specified the current Members will be used in the new
 InterfaceBlockSyntaxSyntax node.
 </param>
	<param name="end">
 The new End to update this InterfaceBlockSyntaxSyntax node with. If not
 specified the current End will be used in the new InterfaceBlockSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.InterfaceBlockSyntax">
	<summary>
 Represents a declaration of a Interface, its contents and the End statement
 that ends it.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ClassBlockSyntax.Begin">
	<summary>
 The statement that begins the type or module.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ClassBlockSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ClassBlockSyntax.Inherits">
	<summary>
 A list of the Inherits declarations for the type.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ClassBlockSyntax.Implements">
	<summary>
 A list of the Implements declarations for the type.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ClassBlockSyntax.Members">
	<summary>
 The declarations contained in the type or module.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ClassBlockSyntax.End">
	<summary>
 The End XXX statement that ends the block.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ClassBlockSyntax.Update(Roslyn.Compilers.VisualBasic.TypeStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InheritsStatementSyntax},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ImplementsStatementSyntax},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Creates a new ClassBlockSyntaxSyntax node with the specified changes.
 </summary>
	<param name="begin">
 The new Begin to update this ClassBlockSyntaxSyntax node with. If not specified
 the current Begin will be used in the new ClassBlockSyntaxSyntax node.
 </param>
	<param name="beginTerminator">
 The new BeginTerminator to update this ClassBlockSyntaxSyntax node with. If not
 specified the current BeginTerminator will be used in the new
 ClassBlockSyntaxSyntax node.
 </param>
	<param name="inherits">
 The new Inherits to update this ClassBlockSyntaxSyntax node with. If not
 specified the current Inherits will be used in the new ClassBlockSyntaxSyntax
 node.
 </param>
	<param name="implements">
 The new Implements to update this ClassBlockSyntaxSyntax node with. If not
 specified the current Implements will be used in the new ClassBlockSyntaxSyntax
 node.
 </param>
	<param name="members">
 The new Members to update this ClassBlockSyntaxSyntax node with. If not
 specified the current Members will be used in the new ClassBlockSyntaxSyntax
 node.
 </param>
	<param name="end">
 The new End to update this ClassBlockSyntaxSyntax node with. If not specified
 the current End will be used in the new ClassBlockSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ClassBlockSyntax">
	<summary>
 Represents a declaration of a Class its contents and the End statement that
 ends it.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.EnumBlockSyntax.Begin">
	<summary>
 The statement that begins the type or module.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.EnumBlockSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.EnumBlockSyntax.Members">
	<summary>
 The declarations contained in the enumeration.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.EnumBlockSyntax.End">
	<summary>
 The End XXX statement that ends the block.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.EnumBlockSyntax.Update(Roslyn.Compilers.VisualBasic.EnumStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.EnumMemberDeclarationSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Creates a new EnumBlockSyntaxSyntax node with the specified changes.
 </summary>
	<param name="begin">
 The new Begin to update this EnumBlockSyntaxSyntax node with. If not specified
 the current Begin will be used in the new EnumBlockSyntaxSyntax node.
 </param>
	<param name="beginTerminator">
 The new BeginTerminator to update this EnumBlockSyntaxSyntax node with. If not
 specified the current BeginTerminator will be used in the new
 EnumBlockSyntaxSyntax node.
 </param>
	<param name="members">
 The new Members to update this EnumBlockSyntaxSyntax node with. If not
 specified the current Members will be used in the new EnumBlockSyntaxSyntax
 node.
 </param>
	<param name="end">
 The new End to update this EnumBlockSyntaxSyntax node with. If not specified
 the current End will be used in the new EnumBlockSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.EnumBlockSyntax">
	<summary>
 Represents a declaration of an Enum, its contents and the End Enum statement
 that ends it.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InheritsOrImplementsStatementSyntax">
	<summary>
 Represents an Inherits or Implements statement in a Class, Structure or
 Interface.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InheritsStatementSyntax.InheritsKeyword">
	<summary>
 The "Inherits" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InheritsStatementSyntax.Types">
	<summary>
 A list of the types being inherited.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InheritsStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.TypeSyntax})">
	<summary>
 Creates a new InheritsStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="inheritsKeyword">
 The new InheritsKeyword to update this InheritsStatementSyntaxSyntax node with.
 If not specified the current InheritsKeyword will be used in the new
 InheritsStatementSyntaxSyntax node.
 </param>
	<param name="types">
 The new Types to update this InheritsStatementSyntaxSyntax node with. If not
 specified the current Types will be used in the new
 InheritsStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.InheritsStatementSyntax">
	<summary>
 Represents an Inherits statement in a Class, Structure or Interface.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ImplementsStatementSyntax.ImplementsKeyword">
	<summary>
 The "Implements" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ImplementsStatementSyntax.Types">
	<summary>
 A list of the types being implemented.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ImplementsStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.TypeSyntax})">
	<summary>
 Creates a new ImplementsStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="implementsKeyword">
 The new ImplementsKeyword to update this ImplementsStatementSyntaxSyntax node
 with. If not specified the current ImplementsKeyword will be used in the new
 ImplementsStatementSyntaxSyntax node.
 </param>
	<param name="types">
 The new Types to update this ImplementsStatementSyntaxSyntax node with. If not
 specified the current Types will be used in the new
 ImplementsStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ImplementsStatementSyntax">
	<summary>
 Represents an Implements statement in a Class or Structure.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeStatementSyntax.Attributes">
	<summary>
 A list of all attribute blocks on this declaration. If no attributes were
 specified, an empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeStatementSyntax.Modifiers">
	<summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeStatementSyntax.Keyword">
	<summary>
 The "Module", "Class", "Interface" or "Structure" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeStatementSyntax.Identifier">
	<summary>
 The name of the type being declared.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeStatementSyntax.TypeParameterListOpt">
	<summary>
 If present, a type parameter list with generic parameters for this type. If no
 generic parameters were present, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.TypeStatementSyntax">
	<summary>
 Abstract class for the beginning statement of a Module, Class, Interface or
 Structure declaration. This node always appears as the Begin of a TypeBlock
 with Kind=ModuleDeclarationBlock, ClassDeclarationBlock,
 InterfaceDeclarationBlock or StructureDeclarationBlock.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ModuleStatementSyntax.Attributes">
	<summary>
 A list of all attribute blocks on this declaration. If no attributes were
 specified, an empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ModuleStatementSyntax.Modifiers">
	<summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ModuleStatementSyntax.Keyword">
	<summary>
 The "Module", "Class", "Interface" or "Structure" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ModuleStatementSyntax.Identifier">
	<summary>
 The name of the type being declared.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ModuleStatementSyntax.TypeParameterListOpt">
	<summary>
 If present, a type parameter list with generic parameters for this type. If no
 generic parameters were present, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ModuleStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeBlockSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeParameterListSyntax)">
	<summary>
 Creates a new ModuleStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="attributes">
 The new Attributes to update this ModuleStatementSyntaxSyntax node with. If not
 specified the current Attributes will be used in the new
 ModuleStatementSyntaxSyntax node.
 </param>
	<param name="modifiers">
 The new Modifiers to update this ModuleStatementSyntaxSyntax node with. If not
 specified the current Modifiers will be used in the new
 ModuleStatementSyntaxSyntax node.
 </param>
	<param name="keyword">
 The new Keyword to update this ModuleStatementSyntaxSyntax node with. If not
 specified the current Keyword will be used in the new
 ModuleStatementSyntaxSyntax node.
 </param>
	<param name="identifier">
 The new Identifier to update this ModuleStatementSyntaxSyntax node with. If not
 specified the current Identifier will be used in the new
 ModuleStatementSyntaxSyntax node.
 </param>
	<param name="typeParameterListOpt">
 The new TypeParameterList to update this ModuleStatementSyntaxSyntax node with.
 If not specified the current TypeParameterList will be used in the new
 ModuleStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ModuleStatementSyntax">
	<summary>
 Represents the beginning statement of a Module declaration. This node always
 appears as the Begin of a TypeBlock with Kind=ModuleDeclarationBlock.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.StructureStatementSyntax.Attributes">
	<summary>
 A list of all attribute blocks on this declaration. If no attributes were
 specified, an empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.StructureStatementSyntax.Modifiers">
	<summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.StructureStatementSyntax.Keyword">
	<summary>
 The "Module", "Class", "Interface" or "Structure" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.StructureStatementSyntax.Identifier">
	<summary>
 The name of the type being declared.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.StructureStatementSyntax.TypeParameterListOpt">
	<summary>
 If present, a type parameter list with generic parameters for this type. If no
 generic parameters were present, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.StructureStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeBlockSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeParameterListSyntax)">
	<summary>
 Creates a new StructureStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="attributes">
 The new Attributes to update this StructureStatementSyntaxSyntax node with. If
 not specified the current Attributes will be used in the new
 StructureStatementSyntaxSyntax node.
 </param>
	<param name="modifiers">
 The new Modifiers to update this StructureStatementSyntaxSyntax node with. If
 not specified the current Modifiers will be used in the new
 StructureStatementSyntaxSyntax node.
 </param>
	<param name="keyword">
 The new Keyword to update this StructureStatementSyntaxSyntax node with. If not
 specified the current Keyword will be used in the new
 StructureStatementSyntaxSyntax node.
 </param>
	<param name="identifier">
 The new Identifier to update this StructureStatementSyntaxSyntax node with. If
 not specified the current Identifier will be used in the new
 StructureStatementSyntaxSyntax node.
 </param>
	<param name="typeParameterListOpt">
 The new TypeParameterList to update this StructureStatementSyntaxSyntax node
 with. If not specified the current TypeParameterList will be used in the new
 StructureStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.StructureStatementSyntax">
	<summary>
 Represents the beginning statement of a Structure declaration. This node always
 appears as the Begin of a TypeBlock with Kind=StructureDeclarationBlock.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InterfaceStatementSyntax.Attributes">
	<summary>
 A list of all attribute blocks on this declaration. If no attributes were
 specified, an empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InterfaceStatementSyntax.Modifiers">
	<summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InterfaceStatementSyntax.Keyword">
	<summary>
 The "Module", "Class", "Interface" or "Structure" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InterfaceStatementSyntax.Identifier">
	<summary>
 The name of the type being declared.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InterfaceStatementSyntax.TypeParameterListOpt">
	<summary>
 If present, a type parameter list with generic parameters for this type. If no
 generic parameters were present, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.InterfaceStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeBlockSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeParameterListSyntax)">
	<summary>
 Creates a new InterfaceStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="attributes">
 The new Attributes to update this InterfaceStatementSyntaxSyntax node with. If
 not specified the current Attributes will be used in the new
 InterfaceStatementSyntaxSyntax node.
 </param>
	<param name="modifiers">
 The new Modifiers to update this InterfaceStatementSyntaxSyntax node with. If
 not specified the current Modifiers will be used in the new
 InterfaceStatementSyntaxSyntax node.
 </param>
	<param name="keyword">
 The new Keyword to update this InterfaceStatementSyntaxSyntax node with. If not
 specified the current Keyword will be used in the new
 InterfaceStatementSyntaxSyntax node.
 </param>
	<param name="identifier">
 The new Identifier to update this InterfaceStatementSyntaxSyntax node with. If
 not specified the current Identifier will be used in the new
 InterfaceStatementSyntaxSyntax node.
 </param>
	<param name="typeParameterListOpt">
 The new TypeParameterList to update this InterfaceStatementSyntaxSyntax node
 with. If not specified the current TypeParameterList will be used in the new
 InterfaceStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.InterfaceStatementSyntax">
	<summary>
 Represents the beginning statement of a Interface declaration. This node always
 appears as the Begin of a TypeBlock with Kind=InterfaceDeclarationBlock.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ClassStatementSyntax.Attributes">
	<summary>
 A list of all attribute blocks on this declaration. If no attributes were
 specified, an empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ClassStatementSyntax.Modifiers">
	<summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ClassStatementSyntax.Keyword">
	<summary>
 The "Module", "Class", "Interface" or "Structure" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ClassStatementSyntax.Identifier">
	<summary>
 The name of the type being declared.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ClassStatementSyntax.TypeParameterListOpt">
	<summary>
 If present, a type parameter list with generic parameters for this type. If no
 generic parameters were present, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ClassStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeBlockSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeParameterListSyntax)">
	<summary>
 Creates a new ClassStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="attributes">
 The new Attributes to update this ClassStatementSyntaxSyntax node with. If not
 specified the current Attributes will be used in the new
 ClassStatementSyntaxSyntax node.
 </param>
	<param name="modifiers">
 The new Modifiers to update this ClassStatementSyntaxSyntax node with. If not
 specified the current Modifiers will be used in the new
 ClassStatementSyntaxSyntax node.
 </param>
	<param name="keyword">
 The new Keyword to update this ClassStatementSyntaxSyntax node with. If not
 specified the current Keyword will be used in the new
 ClassStatementSyntaxSyntax node.
 </param>
	<param name="identifier">
 The new Identifier to update this ClassStatementSyntaxSyntax node with. If not
 specified the current Identifier will be used in the new
 ClassStatementSyntaxSyntax node.
 </param>
	<param name="typeParameterListOpt">
 The new TypeParameterList to update this ClassStatementSyntaxSyntax node with.
 If not specified the current TypeParameterList will be used in the new
 ClassStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ClassStatementSyntax">
	<summary>
 Represents the beginning statement of a Class declaration. This node always
 appears as the Begin of a TypeBlock with Kind=ClassDeclarationBlock.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.EnumStatementSyntax.Attributes">
	<summary>
 A list of all attribute blocks on this declaration. If no attributes were
 specified, an empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.EnumStatementSyntax.Modifiers">
	<summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.EnumStatementSyntax.EnumKeyword">
	<summary>
 The "Enum" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.EnumStatementSyntax.Identifier">
	<summary>
 The name of the enum being declared.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.EnumStatementSyntax.UnderlyingTypeOpt">
	<summary>
 Optional "As XXX" clause describing the underlying type of the enumeration. If
 no As clause was specified, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.EnumStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeBlockSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 Creates a new EnumStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="attributes">
 The new Attributes to update this EnumStatementSyntaxSyntax node with. If not
 specified the current Attributes will be used in the new
 EnumStatementSyntaxSyntax node.
 </param>
	<param name="modifiers">
 The new Modifiers to update this EnumStatementSyntaxSyntax node with. If not
 specified the current Modifiers will be used in the new
 EnumStatementSyntaxSyntax node.
 </param>
	<param name="enumKeyword">
 The new EnumKeyword to update this EnumStatementSyntaxSyntax node with. If not
 specified the current EnumKeyword will be used in the new
 EnumStatementSyntaxSyntax node.
 </param>
	<param name="identifier">
 The new Identifier to update this EnumStatementSyntaxSyntax node with. If not
 specified the current Identifier will be used in the new
 EnumStatementSyntaxSyntax node.
 </param>
	<param name="underlyingTypeOpt">
 The new UnderlyingType to update this EnumStatementSyntaxSyntax node with. If
 not specified the current UnderlyingType will be used in the new
 EnumStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.EnumStatementSyntax">
	<summary>
 Represents the beginning statement of an Enum declaration. This node always
 appears as the Begin of an EnumBlock with Kind=EnumDeclarationBlock.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeParameterListSyntax.OpenParenToken">
	<summary>
 The "(" token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeParameterListSyntax.OfKeyword">
	<summary>
 The "Of" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeParameterListSyntax.Parameters">
	<summary>
 A list of the type parameters. There must be at least one type parameter in the
 list.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeParameterListSyntax.CloseParenToken">
	<summary>
 The ")" token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeParameterListSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.TypeParameterSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new TypeParameterListSyntaxSyntax node with the specified changes.
 </summary>
	<param name="openParenToken">
 The new OpenParenToken to update this TypeParameterListSyntaxSyntax node with.
 If not specified the current OpenParenToken will be used in the new
 TypeParameterListSyntaxSyntax node.
 </param>
	<param name="ofKeyword">
 The new OfKeyword to update this TypeParameterListSyntaxSyntax node with. If
 not specified the current OfKeyword will be used in the new
 TypeParameterListSyntaxSyntax node.
 </param>
	<param name="parameters">
 The new Parameters to update this TypeParameterListSyntaxSyntax node with. If
 not specified the current Parameters will be used in the new
 TypeParameterListSyntaxSyntax node.
 </param>
	<param name="closeParenToken">
 The new CloseParenToken to update this TypeParameterListSyntaxSyntax node with.
 If not specified the current CloseParenToken will be used in the new
 TypeParameterListSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.TypeParameterListSyntax">
	<summary>
 Represents the type parameter list in a declaration.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeParameterSyntax.VarianceKeywordOpt">
	<summary>
 Represents the "In" or "Out" variance keyword on a type parameter, if present.
 If no variance modifier was present, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeParameterSyntax.Identifier">
	<summary>
 The name of the type parameter
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeParameterSyntax.TypeParameterConstraintClauseOpt">
	<summary>
 The "As" keyword, if any type constraints were supplied. If no type constraints
 were supplied, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeParameterSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeParameterConstraintClauseSyntax)">
	<summary>
 Creates a new TypeParameterSyntaxSyntax node with the specified changes.
 </summary>
	<param name="varianceKeywordOpt">
 The new VarianceKeyword to update this TypeParameterSyntaxSyntax node with. If
 not specified the current VarianceKeyword will be used in the new
 TypeParameterSyntaxSyntax node.
 </param>
	<param name="identifier">
 The new Identifier to update this TypeParameterSyntaxSyntax node with. If not
 specified the current Identifier will be used in the new
 TypeParameterSyntaxSyntax node.
 </param>
	<param name="typeParameterConstraintClauseOpt">
 The new TypeParameterConstraintClause to update this TypeParameterSyntaxSyntax
 node with. If not specified the current TypeParameterConstraintClause will be
 used in the new TypeParameterSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.TypeParameterSyntax">
	<summary>
 Represents a type parameter on a generic type declaration.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.TypeParameterConstraintClauseSyntax">
	<summary>
 An abstract node class that is the parent of classes that describe type
 parameter constraint clauses.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeParameterSingleConstraintClauseSyntax.AsKeyword">
	<summary>
 The "As" keyword, if any type constraints were supplied. If no type constraints
 were supplied, Nothing is returned.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeParameterSingleConstraintClauseSyntax.Constraint">
	<summary>
 A list of the supplied constraints. If no constraints were supplied, Nothing is
 returned.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeParameterSingleConstraintClauseSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ConstraintSyntax)">
	<summary>
 Creates a new TypeParameterSingleConstraintClauseSyntaxSyntax node with the
 specified changes.
 </summary>
	<param name="asKeyword">
 The new AsKeyword to update this
 TypeParameterSingleConstraintClauseSyntaxSyntax node with. If not specified the
 current AsKeyword will be used in the new
 TypeParameterSingleConstraintClauseSyntaxSyntax node.
 </param>
	<param name="constraint">
 The new Constraint to update this
 TypeParameterSingleConstraintClauseSyntaxSyntax node with. If not specified the
 current Constraint will be used in the new
 TypeParameterSingleConstraintClauseSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.TypeParameterSingleConstraintClauseSyntax">
	<summary>
 One of the type parameter constraints clauses. This represents a constraint
 clause in the form of "As Constraint".
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeParameterMultipleConstraintClauseSyntax.AsKeyword">
	<summary>
 The "As" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeParameterMultipleConstraintClauseSyntax.OpenBraceToken">
	<summary>
 The "{" token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeParameterMultipleConstraintClauseSyntax.Constraints">
	<summary>
 A list of the supplied constraints. If no constraints were supplied, an empty
 list is returned.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeParameterMultipleConstraintClauseSyntax.CloseBraceToken">
	<summary>
 The "}" token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeParameterMultipleConstraintClauseSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ConstraintSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new TypeParameterMultipleConstraintClauseSyntaxSyntax node with the
 specified changes.
 </summary>
	<param name="asKeyword">
 The new AsKeyword to update this
 TypeParameterMultipleConstraintClauseSyntaxSyntax node with. If not specified
 the current AsKeyword will be used in the new
 TypeParameterMultipleConstraintClauseSyntaxSyntax node.
 </param>
	<param name="openBraceToken">
 The new OpenBraceToken to update this
 TypeParameterMultipleConstraintClauseSyntaxSyntax node with. If not specified
 the current OpenBraceToken will be used in the new
 TypeParameterMultipleConstraintClauseSyntaxSyntax node.
 </param>
	<param name="constraints">
 The new Constraints to update this
 TypeParameterMultipleConstraintClauseSyntaxSyntax node with. If not specified
 the current Constraints will be used in the new
 TypeParameterMultipleConstraintClauseSyntaxSyntax node.
 </param>
	<param name="closeBraceToken">
 The new CloseBraceToken to update this
 TypeParameterMultipleConstraintClauseSyntaxSyntax node with. If not specified
 the current CloseBraceToken will be used in the new
 TypeParameterMultipleConstraintClauseSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.TypeParameterMultipleConstraintClauseSyntax">
	<summary>
 One of the type parameter constraints clauses. This represents a constraint
 clause in the form of "As { Constraints }".
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.ConstraintSyntax">
	<summary>
 An abstract node class that is the parent of classes that describe type
 parameter constraints.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SpecialConstraintSyntax.ConstraintKeyword">
	<summary>
 The "New", "Class" or "Structure" keyword that denotes the kind of special
 constraint.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SpecialConstraintSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new SpecialConstraintSyntaxSyntax node with the specified changes.
 </summary>
	<param name="constraintKeyword">
 The new ConstraintKeyword to update this SpecialConstraintSyntaxSyntax node
 with. If not specified the current ConstraintKeyword will be used in the new
 SpecialConstraintSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.SpecialConstraintSyntax">
	<summary>
 One of the special type parameter constraints: New, Class or Structure. Which
 kind of special constraint it is can be obtained from the Kind property and is
 one of: NewConstraint, ReferenceConstraint or ValueConstraint.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeConstraintSyntax.Type">
	<summary>
 The type describing the constraint.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeConstraintSyntax.Update(Roslyn.Compilers.VisualBasic.TypeSyntax)">
	<summary>
 Creates a new TypeConstraintSyntaxSyntax node with the specified changes.
 </summary>
	<param name="type">
 The new Type to update this TypeConstraintSyntaxSyntax node with. If not
 specified the current Type will be used in the new TypeConstraintSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.TypeConstraintSyntax">
	<summary>
 Represents a type parameter constraint that is a type.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.EnumMemberDeclarationSyntax.Attributes">
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.EnumMemberDeclarationSyntax.InitializerOpt">
	<summary>
 An optional value for the enum member.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.EnumMemberDeclarationSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeBlockSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.EqualsValueSyntax)">
	<summary>
 Creates a new EnumMemberDeclarationSyntaxSyntax node with the specified
 changes.
 </summary>
	<param name="attributes">
 The new Attributes to update this EnumMemberDeclarationSyntaxSyntax node with.
 If not specified the current Attributes will be used in the new
 EnumMemberDeclarationSyntaxSyntax node.
 </param>
	<param name="identifier">
 The new Identifier to update this EnumMemberDeclarationSyntaxSyntax node with.
 If not specified the current Identifier will be used in the new
 EnumMemberDeclarationSyntaxSyntax node.
 </param>
	<param name="initializerOpt">
 The new Initializer to update this EnumMemberDeclarationSyntaxSyntax node with.
 If not specified the current Initializer will be used in the new
 EnumMemberDeclarationSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.EnumMemberDeclarationSyntax">
	<summary>
 Represents a name and value in an EnumDeclarationBlock.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodBlockSyntax.Begin">
	<summary>
 The declaration that begins the block.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodBlockSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodBlockSyntax.Statements">
	<summary>
 The statements contained in the block statement. This might be an empty list.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodBlockSyntax.End">
	<summary>
 The End XXX statement that ends the block declaration.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MethodBlockSyntax.Update(Roslyn.Compilers.VisualBasic.MethodBaseSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Creates a new MethodBlockSyntaxSyntax node with the specified changes.
 </summary>
	<param name="begin">
 The new Begin to update this MethodBlockSyntaxSyntax node with. If not
 specified the current Begin will be used in the new MethodBlockSyntaxSyntax
 node.
 </param>
	<param name="beginTerminator">
 The new BeginTerminator to update this MethodBlockSyntaxSyntax node with. If
 not specified the current BeginTerminator will be used in the new
 MethodBlockSyntaxSyntax node.
 </param>
	<param name="statements">
 The new Statements to update this MethodBlockSyntaxSyntax node with. If not
 specified the current Statements will be used in the new
 MethodBlockSyntaxSyntax node.
 </param>
	<param name="end">
 The new End to update this MethodBlockSyntaxSyntax node with. If not specified
 the current End will be used in the new MethodBlockSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.MethodBlockSyntax">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.PropertyBlockSyntax.Begin">
	<summary>
 The property declaration that begins the block.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.PropertyBlockSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.PropertyBlockSyntax.Accessors">
	<summary>
 The accessor blocks contained in the property, between the Property and the End
 Property statements.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.PropertyBlockSyntax.End">
	<summary>
 The End Property statement that ends the block.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.PropertyBlockSyntax.Update(Roslyn.Compilers.VisualBasic.PropertyStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.MethodBlockSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Creates a new PropertyBlockSyntaxSyntax node with the specified changes.
 </summary>
	<param name="begin">
 The new Begin to update this PropertyBlockSyntaxSyntax node with. If not
 specified the current Begin will be used in the new PropertyBlockSyntaxSyntax
 node.
 </param>
	<param name="beginTerminator">
 The new BeginTerminator to update this PropertyBlockSyntaxSyntax node with. If
 not specified the current BeginTerminator will be used in the new
 PropertyBlockSyntaxSyntax node.
 </param>
	<param name="accessors">
 The new Accessors to update this PropertyBlockSyntaxSyntax node with. If not
 specified the current Accessors will be used in the new
 PropertyBlockSyntaxSyntax node.
 </param>
	<param name="end">
 The new End to update this PropertyBlockSyntaxSyntax node with. If not
 specified the current End will be used in the new PropertyBlockSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.PropertyBlockSyntax">
	<summary>
 Represents a block property declaration: A declaration that has a beginning
 declaration, some get or set accessor blocks and an end statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.EventBlockSyntax.Begin">
	<summary>
 The event declaration that begins the block.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.EventBlockSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.EventBlockSyntax.Accessors">
	<summary>
 The accessor blocks contained in the custom event declaration, between the
 Event statement and the End Event statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.EventBlockSyntax.End">
	<summary>
 The End Event statement that ends the block.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.EventBlockSyntax.Update(Roslyn.Compilers.VisualBasic.EventStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.MethodBlockSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Creates a new EventBlockSyntaxSyntax node with the specified changes.
 </summary>
	<param name="begin">
 The new Begin to update this EventBlockSyntaxSyntax node with. If not specified
 the current Begin will be used in the new EventBlockSyntaxSyntax node.
 </param>
	<param name="beginTerminator">
 The new BeginTerminator to update this EventBlockSyntaxSyntax node with. If not
 specified the current BeginTerminator will be used in the new
 EventBlockSyntaxSyntax node.
 </param>
	<param name="accessors">
 The new Accessors to update this EventBlockSyntaxSyntax node with. If not
 specified the current Accessors will be used in the new EventBlockSyntaxSyntax
 node.
 </param>
	<param name="end">
 The new End to update this EventBlockSyntaxSyntax node with. If not specified
 the current End will be used in the new EventBlockSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.EventBlockSyntax">
	<summary>
 Represents a custom event declaration: A declaration that has a beginning event
 declaration, some accessor blocks and an end statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodBaseSyntax.Attributes">
	<summary>
 A list of all attribute blocks on this declaration. If no attributes were
 specified, Nothing is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodBaseSyntax.Modifiers">
	<summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodBaseSyntax.Keyword">
	<summary>
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodBaseSyntax.ParameterListOpt">
	<summary>
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodBaseSyntax.AsClauseOpt">
	<summary>
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.MethodBaseSyntax">
	<summary>
 An abstract node class that is the parent for declarations that are
 "method-like"; i.e., that have a parameter list and return type. This includes
 methods, constructors, properties, events, operators, declares, delegates,
 property accessors and custom event accessors.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ParameterListSyntax.OpenParenToken">
	<summary>
 The "(" token that introduces the parameter list. If no parameter list was
 present, Nothing is returned.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ParameterListSyntax.Parameters">
	<summary>
 The list of parameters. If no parameter list was present, Nothing is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ParameterListSyntax.CloseParenToken">
	<summary>
 The ")" token that concludes the parameter list. If no parameter list was
 present, Nothing is returned.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ParameterListSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ParameterSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new ParameterListSyntaxSyntax node with the specified changes.
 </summary>
	<param name="openParenToken">
 The new OpenParenToken to update this ParameterListSyntaxSyntax node with. If
 not specified the current OpenParenToken will be used in the new
 ParameterListSyntaxSyntax node.
 </param>
	<param name="parameters">
 The new Parameters to update this ParameterListSyntaxSyntax node with. If not
 specified the current Parameters will be used in the new
 ParameterListSyntaxSyntax node.
 </param>
	<param name="closeParenToken">
 The new CloseParenToken to update this ParameterListSyntaxSyntax node with. If
 not specified the current CloseParenToken will be used in the new
 ParameterListSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ParameterListSyntax">
	<summary>
 Represents the parameter list in a method declaration.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodStatementSyntax.Attributes">
	<summary>
 A list of all attribute blocks on this declaration. If no attributes were
 specified, Nothing is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodStatementSyntax.Modifiers">
	<summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodStatementSyntax.Keyword">
	<summary>
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodStatementSyntax.Identifier">
	<summary>
 The name of the method being declared.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodStatementSyntax.TypeParameterListOpt">
	<summary>
 If present, a type parameter list with generic type parameters for this method.
 If no generic type parameters were present, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodStatementSyntax.ParameterListOpt">
	<summary>
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodStatementSyntax.AsClauseOpt">
	<summary>
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodStatementSyntax.HandlesClauseOpt">
	<summary>
 If present, a Handles clause indicated the events that this method handles.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodStatementSyntax.ImplementsClauseOpt">
	<summary>
 If present, an Implements clause indicated the interface methods that this
 method implements.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.MethodStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeBlockSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeParameterListSyntax,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax,Roslyn.Compilers.VisualBasic.HandlesClauseSyntax,Roslyn.Compilers.VisualBasic.ImplementsClauseSyntax)">
	<summary>
 Creates a new MethodStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="attributes">
 The new Attributes to update this MethodStatementSyntaxSyntax node with. If not
 specified the current Attributes will be used in the new
 MethodStatementSyntaxSyntax node.
 </param>
	<param name="modifiers">
 The new Modifiers to update this MethodStatementSyntaxSyntax node with. If not
 specified the current Modifiers will be used in the new
 MethodStatementSyntaxSyntax node.
 </param>
	<param name="keyword">
 The new Keyword to update this MethodStatementSyntaxSyntax node with. If not
 specified the current Keyword will be used in the new
 MethodStatementSyntaxSyntax node.
 </param>
	<param name="identifier">
 The new Identifier to update this MethodStatementSyntaxSyntax node with. If not
 specified the current Identifier will be used in the new
 MethodStatementSyntaxSyntax node.
 </param>
	<param name="typeParameterListOpt">
 The new TypeParameterList to update this MethodStatementSyntaxSyntax node with.
 If not specified the current TypeParameterList will be used in the new
 MethodStatementSyntaxSyntax node.
 </param>
	<param name="parameterListOpt">
 The new ParameterList to update this MethodStatementSyntaxSyntax node with. If
 not specified the current ParameterList will be used in the new
 MethodStatementSyntaxSyntax node.
 </param>
	<param name="asClauseOpt">
 The new AsClause to update this MethodStatementSyntaxSyntax node with. If not
 specified the current AsClause will be used in the new
 MethodStatementSyntaxSyntax node.
 </param>
	<param name="handlesClauseOpt">
 The new HandlesClause to update this MethodStatementSyntaxSyntax node with. If
 not specified the current HandlesClause will be used in the new
 MethodStatementSyntaxSyntax node.
 </param>
	<param name="implementsClauseOpt">
 The new ImplementsClause to update this MethodStatementSyntaxSyntax node with.
 If not specified the current ImplementsClause will be used in the new
 MethodStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.MethodStatementSyntax">
	<summary>
 The statement that declares a Sub or Function. If this method has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ConstructorStatementSyntax.Attributes">
	<summary>
 A list of all attribute blocks on this declaration. If no attributes were
 specified, Nothing is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ConstructorStatementSyntax.Modifiers">
	<summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ConstructorStatementSyntax.Keyword">
	<summary>
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ConstructorStatementSyntax.NewKeyword">
	<summary>
 The "New" keyword in the constructor declaration.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ConstructorStatementSyntax.ParameterListOpt">
	<summary>
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ConstructorStatementSyntax.AsClauseOpt">
	<summary>
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ConstructorStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeBlockSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 Creates a new ConstructorStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="attributes">
 The new Attributes to update this ConstructorStatementSyntaxSyntax node with.
 If not specified the current Attributes will be used in the new
 ConstructorStatementSyntaxSyntax node.
 </param>
	<param name="modifiers">
 The new Modifiers to update this ConstructorStatementSyntaxSyntax node with. If
 not specified the current Modifiers will be used in the new
 ConstructorStatementSyntaxSyntax node.
 </param>
	<param name="keyword">
 The new Keyword to update this ConstructorStatementSyntaxSyntax node with. If
 not specified the current Keyword will be used in the new
 ConstructorStatementSyntaxSyntax node.
 </param>
	<param name="newKeyword">
 The new NewKeyword to update this ConstructorStatementSyntaxSyntax node with.
 If not specified the current NewKeyword will be used in the new
 ConstructorStatementSyntaxSyntax node.
 </param>
	<param name="parameterListOpt">
 The new ParameterList to update this ConstructorStatementSyntaxSyntax node
 with. If not specified the current ParameterList will be used in the new
 ConstructorStatementSyntaxSyntax node.
 </param>
	<param name="asClauseOpt">
 The new AsClause to update this ConstructorStatementSyntaxSyntax node with. If
 not specified the current AsClause will be used in the new
 ConstructorStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ConstructorStatementSyntax">
	<summary>
 A statement that declares a constructor. This statement will be the Begin of a
 BlockStatement with Kind=MethodDeclarationBlock, and the body of the method
 will be the Body of that BlockStatement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.DeclareStatementSyntax.Attributes">
	<summary>
 A list of all attribute blocks on this declaration. If no attributes were
 specified, Nothing is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.DeclareStatementSyntax.Modifiers">
	<summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.DeclareStatementSyntax.DeclareKeyword">
	<summary>
 The "Declare" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.DeclareStatementSyntax.CharsetKeywordOpt">
	<summary>
 If present, the keyword that defines the string translation semantics of the
 external method.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.DeclareStatementSyntax.Keyword">
	<summary>
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.DeclareStatementSyntax.Identifier">
	<summary>
 The name of the method being declared.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.DeclareStatementSyntax.LibKeyword">
	<summary>
 The "Lib" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.DeclareStatementSyntax.LibraryName">
	<summary>
 The string literal with the library name.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.DeclareStatementSyntax.AliasKeywordOpt">
	<summary>
 If present, the "Alias" keyword. If not present, returns Nothing.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.DeclareStatementSyntax.AliasNameOpt">
	<summary>
 The string literal with the alias. If not present, returns Nothing.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.DeclareStatementSyntax.ParameterListOpt">
	<summary>
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.DeclareStatementSyntax.AsClauseOpt">
	<summary>
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.DeclareStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeBlockSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.LiteralExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.LiteralExpressionSyntax,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 Creates a new DeclareStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="attributes">
 The new Attributes to update this DeclareStatementSyntaxSyntax node with. If
 not specified the current Attributes will be used in the new
 DeclareStatementSyntaxSyntax node.
 </param>
	<param name="modifiers">
 The new Modifiers to update this DeclareStatementSyntaxSyntax node with. If not
 specified the current Modifiers will be used in the new
 DeclareStatementSyntaxSyntax node.
 </param>
	<param name="declareKeyword">
 The new DeclareKeyword to update this DeclareStatementSyntaxSyntax node with.
 If not specified the current DeclareKeyword will be used in the new
 DeclareStatementSyntaxSyntax node.
 </param>
	<param name="charsetKeywordOpt">
 The new CharsetKeyword to update this DeclareStatementSyntaxSyntax node with.
 If not specified the current CharsetKeyword will be used in the new
 DeclareStatementSyntaxSyntax node.
 </param>
	<param name="keyword">
 The new Keyword to update this DeclareStatementSyntaxSyntax node with. If not
 specified the current Keyword will be used in the new
 DeclareStatementSyntaxSyntax node.
 </param>
	<param name="identifier">
 The new Identifier to update this DeclareStatementSyntaxSyntax node with. If
 not specified the current Identifier will be used in the new
 DeclareStatementSyntaxSyntax node.
 </param>
	<param name="libKeyword">
 The new LibKeyword to update this DeclareStatementSyntaxSyntax node with. If
 not specified the current LibKeyword will be used in the new
 DeclareStatementSyntaxSyntax node.
 </param>
	<param name="libraryName">
 The new LibraryName to update this DeclareStatementSyntaxSyntax node with. If
 not specified the current LibraryName will be used in the new
 DeclareStatementSyntaxSyntax node.
 </param>
	<param name="aliasKeywordOpt">
 The new AliasKeyword to update this DeclareStatementSyntaxSyntax node with. If
 not specified the current AliasKeyword will be used in the new
 DeclareStatementSyntaxSyntax node.
 </param>
	<param name="aliasNameOpt">
 The new AliasName to update this DeclareStatementSyntaxSyntax node with. If not
 specified the current AliasName will be used in the new
 DeclareStatementSyntaxSyntax node.
 </param>
	<param name="parameterListOpt">
 The new ParameterList to update this DeclareStatementSyntaxSyntax node with. If
 not specified the current ParameterList will be used in the new
 DeclareStatementSyntaxSyntax node.
 </param>
	<param name="asClauseOpt">
 The new AsClause to update this DeclareStatementSyntaxSyntax node with. If not
 specified the current AsClause will be used in the new
 DeclareStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.DeclareStatementSyntax">
	<summary>
 A Declare statement that declares an external DLL method.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.DelegateStatementSyntax.Attributes">
	<summary>
 A list of all attribute blocks on this declaration. If no attributes were
 specified, Nothing is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.DelegateStatementSyntax.Modifiers">
	<summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.DelegateStatementSyntax.DelegateKeyword">
	<summary>
 The "Delegate" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.DelegateStatementSyntax.Keyword">
	<summary>
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.DelegateStatementSyntax.Identifier">
	<summary>
 The name of the delegate being declared.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.DelegateStatementSyntax.TypeParameterListOpt">
	<summary>
 If present, a type parameter list with generic type parameters for this
 delegate. If no generic type parameters were present, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.DelegateStatementSyntax.ParameterListOpt">
	<summary>
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.DelegateStatementSyntax.AsClauseOpt">
	<summary>
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.DelegateStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeBlockSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeParameterListSyntax,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 Creates a new DelegateStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="attributes">
 The new Attributes to update this DelegateStatementSyntaxSyntax node with. If
 not specified the current Attributes will be used in the new
 DelegateStatementSyntaxSyntax node.
 </param>
	<param name="modifiers">
 The new Modifiers to update this DelegateStatementSyntaxSyntax node with. If
 not specified the current Modifiers will be used in the new
 DelegateStatementSyntaxSyntax node.
 </param>
	<param name="delegateKeyword">
 The new DelegateKeyword to update this DelegateStatementSyntaxSyntax node with.
 If not specified the current DelegateKeyword will be used in the new
 DelegateStatementSyntaxSyntax node.
 </param>
	<param name="keyword">
 The new Keyword to update this DelegateStatementSyntaxSyntax node with. If not
 specified the current Keyword will be used in the new
 DelegateStatementSyntaxSyntax node.
 </param>
	<param name="identifier">
 The new Identifier to update this DelegateStatementSyntaxSyntax node with. If
 not specified the current Identifier will be used in the new
 DelegateStatementSyntaxSyntax node.
 </param>
	<param name="typeParameterListOpt">
 The new TypeParameterList to update this DelegateStatementSyntaxSyntax node
 with. If not specified the current TypeParameterList will be used in the new
 DelegateStatementSyntaxSyntax node.
 </param>
	<param name="parameterListOpt">
 The new ParameterList to update this DelegateStatementSyntaxSyntax node with.
 If not specified the current ParameterList will be used in the new
 DelegateStatementSyntaxSyntax node.
 </param>
	<param name="asClauseOpt">
 The new AsClause to update this DelegateStatementSyntaxSyntax node with. If not
 specified the current AsClause will be used in the new
 DelegateStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.DelegateStatementSyntax">
	<summary>
 A statement that declares a delegate type.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.EventStatementSyntax.Attributes">
	<summary>
 A list of all attribute blocks on this declaration. If no attributes were
 specified, Nothing is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.EventStatementSyntax.Modifiers">
	<summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.EventStatementSyntax.CustomKeywordOpt">
	<summary>
 The optional Custom keyword for custom event declarations.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.EventStatementSyntax.Keyword">
	<summary>
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.EventStatementSyntax.Identifier">
	<summary>
 The name of the event being declared.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.EventStatementSyntax.ParameterListOpt">
	<summary>
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.EventStatementSyntax.AsClauseOpt">
	<summary>
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.EventStatementSyntax.ImplementsClauseOpt">
	<summary>
 If present, an Implements clause indicates the interface methods that this
 method implements.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.EventStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeBlockSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax,Roslyn.Compilers.VisualBasic.ImplementsClauseSyntax)">
	<summary>
 Creates a new EventStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="attributes">
 The new Attributes to update this EventStatementSyntaxSyntax node with. If not
 specified the current Attributes will be used in the new
 EventStatementSyntaxSyntax node.
 </param>
	<param name="modifiers">
 The new Modifiers to update this EventStatementSyntaxSyntax node with. If not
 specified the current Modifiers will be used in the new
 EventStatementSyntaxSyntax node.
 </param>
	<param name="customKeywordOpt">
 The new CustomKeyword to update this EventStatementSyntaxSyntax node with. If
 not specified the current CustomKeyword will be used in the new
 EventStatementSyntaxSyntax node.
 </param>
	<param name="keyword">
 The new Keyword to update this EventStatementSyntaxSyntax node with. If not
 specified the current Keyword will be used in the new
 EventStatementSyntaxSyntax node.
 </param>
	<param name="identifier">
 The new Identifier to update this EventStatementSyntaxSyntax node with. If not
 specified the current Identifier will be used in the new
 EventStatementSyntaxSyntax node.
 </param>
	<param name="parameterListOpt">
 The new ParameterList to update this EventStatementSyntaxSyntax node with. If
 not specified the current ParameterList will be used in the new
 EventStatementSyntaxSyntax node.
 </param>
	<param name="asClauseOpt">
 The new AsClause to update this EventStatementSyntaxSyntax node with. If not
 specified the current AsClause will be used in the new
 EventStatementSyntaxSyntax node.
 </param>
	<param name="implementsClauseOpt">
 The new ImplementsClause to update this EventStatementSyntaxSyntax node with.
 If not specified the current ImplementsClause will be used in the new
 EventStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.EventStatementSyntax">
	<summary>
 A statement that declares an event. If the event being declared is a custom
 event, this statement will be the Begin of a PropertyOrEventBlock, and the
 accessors will be part of the Accessors of that node.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.OperatorStatementSyntax.Attributes">
	<summary>
 A list of all attribute blocks on this declaration. If no attributes were
 specified, Nothing is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.OperatorStatementSyntax.Modifiers">
	<summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.OperatorStatementSyntax.Keyword">
	<summary>
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.OperatorStatementSyntax.Operator">
	<summary>
 The operator being defined.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.OperatorStatementSyntax.ParameterListOpt">
	<summary>
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.OperatorStatementSyntax.AsClauseOpt">
	<summary>
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.OperatorStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeBlockSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 Creates a new OperatorStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="attributes">
 The new Attributes to update this OperatorStatementSyntaxSyntax node with. If
 not specified the current Attributes will be used in the new
 OperatorStatementSyntaxSyntax node.
 </param>
	<param name="modifiers">
 The new Modifiers to update this OperatorStatementSyntaxSyntax node with. If
 not specified the current Modifiers will be used in the new
 OperatorStatementSyntaxSyntax node.
 </param>
	<param name="keyword">
 The new Keyword to update this OperatorStatementSyntaxSyntax node with. If not
 specified the current Keyword will be used in the new
 OperatorStatementSyntaxSyntax node.
 </param>
	<param name="operator">
 The new Operator to update this OperatorStatementSyntaxSyntax node with. If not
 specified the current Operator will be used in the new
 OperatorStatementSyntaxSyntax node.
 </param>
	<param name="parameterListOpt">
 The new ParameterList to update this OperatorStatementSyntaxSyntax node with.
 If not specified the current ParameterList will be used in the new
 OperatorStatementSyntaxSyntax node.
 </param>
	<param name="asClauseOpt">
 The new AsClause to update this OperatorStatementSyntaxSyntax node with. If not
 specified the current AsClause will be used in the new
 OperatorStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.OperatorStatementSyntax">
	<summary>
 A statement that declares an operator. If this operator has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.PropertyStatementSyntax.Attributes">
	<summary>
 A list of all attribute blocks on this declaration. If no attributes were
 specified, Nothing is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.PropertyStatementSyntax.Modifiers">
	<summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.PropertyStatementSyntax.Keyword">
	<summary>
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.PropertyStatementSyntax.Identifier">
	<summary>
 The name of the property being declared.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.PropertyStatementSyntax.ParameterListOpt">
	<summary>
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.PropertyStatementSyntax.AsClauseOpt">
	<summary>
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.PropertyStatementSyntax.InitializerOpt">
	<summary>
 If present, an "= initial-value" clause describing the initial value of the
 property.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.PropertyStatementSyntax.ImplementsClauseOpt">
	<summary>
 If present, an Implements clause indicated the interface methods that this
 method implements.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.PropertyStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeBlockSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax,Roslyn.Compilers.VisualBasic.EqualsValueSyntax,Roslyn.Compilers.VisualBasic.ImplementsClauseSyntax)">
	<summary>
 Creates a new PropertyStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="attributes">
 The new Attributes to update this PropertyStatementSyntaxSyntax node with. If
 not specified the current Attributes will be used in the new
 PropertyStatementSyntaxSyntax node.
 </param>
	<param name="modifiers">
 The new Modifiers to update this PropertyStatementSyntaxSyntax node with. If
 not specified the current Modifiers will be used in the new
 PropertyStatementSyntaxSyntax node.
 </param>
	<param name="keyword">
 The new Keyword to update this PropertyStatementSyntaxSyntax node with. If not
 specified the current Keyword will be used in the new
 PropertyStatementSyntaxSyntax node.
 </param>
	<param name="identifier">
 The new Identifier to update this PropertyStatementSyntaxSyntax node with. If
 not specified the current Identifier will be used in the new
 PropertyStatementSyntaxSyntax node.
 </param>
	<param name="parameterListOpt">
 The new ParameterList to update this PropertyStatementSyntaxSyntax node with.
 If not specified the current ParameterList will be used in the new
 PropertyStatementSyntaxSyntax node.
 </param>
	<param name="asClauseOpt">
 The new AsClause to update this PropertyStatementSyntaxSyntax node with. If not
 specified the current AsClause will be used in the new
 PropertyStatementSyntaxSyntax node.
 </param>
	<param name="initializerOpt">
 The new Initializer to update this PropertyStatementSyntaxSyntax node with. If
 not specified the current Initializer will be used in the new
 PropertyStatementSyntaxSyntax node.
 </param>
	<param name="implementsClauseOpt">
 The new ImplementsClause to update this PropertyStatementSyntaxSyntax node
 with. If not specified the current ImplementsClause will be used in the new
 PropertyStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.PropertyStatementSyntax">
	<summary>
 Statement that declares a property. If this property has accessors declared,
 this statement will be the Begin of a BlockNode, and the accessors will be the
 Body of that node. Auto properties are property declarations without a
 PropertyBlock.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AccessorStatementSyntax.Attributes">
	<summary>
 A list of all attribute blocks on this declaration. If no attributes were
 specified, Nothing is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.AccessorStatementSyntax.Modifiers">
	<summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.AccessorStatementSyntax.Keyword">
	<summary>
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AccessorStatementSyntax.ParameterListOpt">
	<summary>
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.AccessorStatementSyntax.AsClauseOpt">
	<summary>
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.AccessorStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeBlockSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 Creates a new AccessorStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="attributes">
 The new Attributes to update this AccessorStatementSyntaxSyntax node with. If
 not specified the current Attributes will be used in the new
 AccessorStatementSyntaxSyntax node.
 </param>
	<param name="modifiers">
 The new Modifiers to update this AccessorStatementSyntaxSyntax node with. If
 not specified the current Modifiers will be used in the new
 AccessorStatementSyntaxSyntax node.
 </param>
	<param name="keyword">
 The new Keyword to update this AccessorStatementSyntaxSyntax node with. If not
 specified the current Keyword will be used in the new
 AccessorStatementSyntaxSyntax node.
 </param>
	<param name="parameterListOpt">
 The new ParameterList to update this AccessorStatementSyntaxSyntax node with.
 If not specified the current ParameterList will be used in the new
 AccessorStatementSyntaxSyntax node.
 </param>
	<param name="asClauseOpt">
 The new AsClause to update this AccessorStatementSyntaxSyntax node with. If not
 specified the current AsClause will be used in the new
 AccessorStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.AccessorStatementSyntax">
	<summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ImplementsClauseSyntax.ImplementsKeyword">
	<summary>
 The "Implements" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ImplementsClauseSyntax.InterfaceMembers">
	<summary>
 The list of interface members being implemented.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ImplementsClauseSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.QualifiedNameSyntax})">
	<summary>
 Creates a new ImplementsClauseSyntaxSyntax node with the specified changes.
 </summary>
	<param name="implementsKeyword">
 The new ImplementsKeyword to update this ImplementsClauseSyntaxSyntax node
 with. If not specified the current ImplementsKeyword will be used in the new
 ImplementsClauseSyntaxSyntax node.
 </param>
	<param name="interfaceMembers">
 The new InterfaceMembers to update this ImplementsClauseSyntaxSyntax node with.
 If not specified the current InterfaceMembers will be used in the new
 ImplementsClauseSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ImplementsClauseSyntax">
	<summary>
 Represents the "Implements ..." clause on a type member, which describes which
 interface members this member implements.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.HandlesClauseSyntax.HandlesKeyword">
	<summary>
 The "Handles" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.HandlesClauseSyntax.Events">
	<summary>
 The list of event members being handled.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.HandlesClauseSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.HandlesClauseItemSyntax})">
	<summary>
 Creates a new HandlesClauseSyntaxSyntax node with the specified changes.
 </summary>
	<param name="handlesKeyword">
 The new HandlesKeyword to update this HandlesClauseSyntaxSyntax node with. If
 not specified the current HandlesKeyword will be used in the new
 HandlesClauseSyntaxSyntax node.
 </param>
	<param name="events">
 The new Events to update this HandlesClauseSyntaxSyntax node with. If not
 specified the current Events will be used in the new HandlesClauseSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.HandlesClauseSyntax">
	<summary>
 Represents the "Handles ..." clause on a method declaration that describes
 which events this method handles.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.HandlesClauseItemSyntax.EventContainer">
	<summary>
 The container of the event. This can either be an simple identifier
 (identifying a members of the containing type) or one of the special keywords
 "Me", "MyBase" or "MyClass".
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.HandlesClauseItemSyntax.DotToken">
	<summary>
 The "." token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.HandlesClauseItemSyntax.EventMember">
	<summary>
 The event being handled. This must be a simple identifier.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.HandlesClauseItemSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new HandlesClauseItemSyntaxSyntax node with the specified changes.
 </summary>
	<param name="eventContainer">
 The new EventContainer to update this HandlesClauseItemSyntaxSyntax node with.
 If not specified the current EventContainer will be used in the new
 HandlesClauseItemSyntaxSyntax node.
 </param>
	<param name="dotToken">
 The new DotToken to update this HandlesClauseItemSyntaxSyntax node with. If not
 specified the current DotToken will be used in the new
 HandlesClauseItemSyntaxSyntax node.
 </param>
	<param name="eventMember">
 The new EventMember to update this HandlesClauseItemSyntaxSyntax node with. If
 not specified the current EventMember will be used in the new
 HandlesClauseItemSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.HandlesClauseItemSyntax">
	<summary>
 Represents a single handled event in a "Handles ..." clause.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.IncompleteMemberSyntax.Attributes">
	<summary>
 A list of all attribute blocks on this declaration. If no attributes were
 specified, an empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.IncompleteMemberSyntax.Modifiers">
	<summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.IncompleteMemberSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeBlockSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList)">
	<summary>
 Creates a new IncompleteMemberSyntaxSyntax node with the specified changes.
 </summary>
	<param name="attributes">
 The new Attributes to update this IncompleteMemberSyntaxSyntax node with. If
 not specified the current Attributes will be used in the new
 IncompleteMemberSyntaxSyntax node.
 </param>
	<param name="modifiers">
 The new Modifiers to update this IncompleteMemberSyntaxSyntax node with. If not
 specified the current Modifiers will be used in the new
 IncompleteMemberSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.IncompleteMemberSyntax">
	<summary>
 Represents the beginning of a declaration. However, not enough syntax is
 detected to classify this as a field, method, property or event. This is node
 always represents a syntax error.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.FieldDeclarationSyntax.Attributes">
	<summary>
 A list of all attribute blocks on this declaration. If no attributes were
 specified, an empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.FieldDeclarationSyntax.Modifiers">
	<summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.FieldDeclarationSyntax.Declarators">
	<summary>
 The list of variable declarator. Each declarator specifies one or more variable
 names along with a type and/or initializer.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.FieldDeclarationSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeBlockSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.VariableDeclaratorSyntax})">
	<summary>
 Creates a new FieldDeclarationSyntaxSyntax node with the specified changes.
 </summary>
	<param name="attributes">
 The new Attributes to update this FieldDeclarationSyntaxSyntax node with. If
 not specified the current Attributes will be used in the new
 FieldDeclarationSyntaxSyntax node.
 </param>
	<param name="modifiers">
 The new Modifiers to update this FieldDeclarationSyntaxSyntax node with. If not
 specified the current Modifiers will be used in the new
 FieldDeclarationSyntaxSyntax node.
 </param>
	<param name="declarators">
 The new Declarators to update this FieldDeclarationSyntaxSyntax node with. If
 not specified the current Declarators will be used in the new
 FieldDeclarationSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.FieldDeclarationSyntax">
	<summary>
 Represents the declaration of one or more variables or constants, either as
 local variables or as class/structure members. In the case of a constant, it is
 represented by having "Const" in the Modifiers (although technically "Const" is
 not a modifier, it is represented as one in the parse trees.)
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.VariableDeclaratorSyntax.Names">
	<summary>
 The names of the variables being declared. Each name might have a "?" or "()"
 modifier(s) attached.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.VariableDeclaratorSyntax.AsClauseOpt">
	<summary>
 The "As" clause that describes the return type, and possibly includes "New",
 "With" or "From". If no As clause was present, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.VariableDeclaratorSyntax.InitializerOpt">
	<summary>
 If present, an "= initial-value" clause describing the initial value of the
 variable or the value of the constant.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.VariableDeclaratorSyntax.Update(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ModifiedIdentifierSyntax},Roslyn.Compilers.VisualBasic.AsClauseSyntax,Roslyn.Compilers.VisualBasic.EqualsValueSyntax)">
	<summary>
 Creates a new VariableDeclaratorSyntaxSyntax node with the specified changes.
 </summary>
	<param name="names">
 The new Names to update this VariableDeclaratorSyntaxSyntax node with. If not
 specified the current Names will be used in the new
 VariableDeclaratorSyntaxSyntax node.
 </param>
	<param name="asClauseOpt">
 The new AsClause to update this VariableDeclaratorSyntaxSyntax node with. If
 not specified the current AsClause will be used in the new
 VariableDeclaratorSyntaxSyntax node.
 </param>
	<param name="initializerOpt">
 The new Initializer to update this VariableDeclaratorSyntaxSyntax node with. If
 not specified the current Initializer will be used in the new
 VariableDeclaratorSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.VariableDeclaratorSyntax">
	<summary>
 Represents the part of a variable or constant declaration statement that
 associated one or more variable names with a type.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AsClauseSyntax.AsKeyword">
	<summary>
 The "As" keyword.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.AsClauseSyntax">
	<summary>
 Abstract node class that represents the different kinds of "As {type-name}"
 clauses in a declaration: simple "As" clauses and "As New" clauses. The type
 has optional attributes associated with it, although attributes are not
 permitted in all possible places where this node occurs.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SimpleAsClauseSyntax.AsKeyword">
	<summary>
 The "As" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SimpleAsClauseSyntax.Attributes">
	<summary>
 A list of all attribute blocks on the type. If no attributes were specified, an
 empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.SimpleAsClauseSyntax.Type">
	<summary>
 The type-name part of the As clause.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SimpleAsClauseSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeBlockSyntax},Roslyn.Compilers.VisualBasic.TypeSyntax)">
	<summary>
 Creates a new SimpleAsClauseSyntaxSyntax node with the specified changes.
 </summary>
	<param name="asKeyword">
 The new AsKeyword to update this SimpleAsClauseSyntaxSyntax node with. If not
 specified the current AsKeyword will be used in the new
 SimpleAsClauseSyntaxSyntax node.
 </param>
	<param name="attributes">
 The new Attributes to update this SimpleAsClauseSyntaxSyntax node with. If not
 specified the current Attributes will be used in the new
 SimpleAsClauseSyntaxSyntax node.
 </param>
	<param name="type">
 The new Type to update this SimpleAsClauseSyntaxSyntax node with. If not
 specified the current Type will be used in the new SimpleAsClauseSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.SimpleAsClauseSyntax">
	<summary>
 Represents an "As {type-name}" clause that does not have an initializer or
 "New". The type has optional attributes associated with it, although attributes
 are not permitted in all possible places where this node occurs.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AsNewClauseSyntax.AsKeyword">
	<summary>
 The "As" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AsNewClauseSyntax.NewExpression">
	<summary>
 The New expression
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AsNewClauseSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.NewExpressionSyntax)">
	<summary>
 Creates a new AsNewClauseSyntaxSyntax node with the specified changes.
 </summary>
	<param name="asKeyword">
 The new AsKeyword to update this AsNewClauseSyntaxSyntax node with. If not
 specified the current AsKeyword will be used in the new AsNewClauseSyntaxSyntax
 node.
 </param>
	<param name="newExpression">
 The new NewExpression to update this AsNewClauseSyntaxSyntax node with. If not
 specified the current NewExpression will be used in the new
 AsNewClauseSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.AsNewClauseSyntax">
	<summary>
 Represents an "As New {type-name} [arguments] [initializers]" clause in a
 declaration. The type has optional attributes associated with it, although
 attributes are not permitted in many places where this node occurs (they are
 permitted, for example, on automatically implemented properties.)
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.ObjectCreationInitializerSyntax">
	<summary>
 An abstract node class that represents a "With" or "From" clause used to
 initializer an new object.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ObjectMemberInitializerSyntax.WithKeyword">
	<summary>
 The "With" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ObjectMemberInitializerSyntax.OpenBraceToken">
	<summary>
 The "{" token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ObjectMemberInitializerSyntax.Initializers">
	<summary>
 The comma-separated list of field initializers.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ObjectMemberInitializerSyntax.CloseBraceToken">
	<summary>
 The "}" token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ObjectMemberInitializerSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.FieldInitializerSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new ObjectMemberInitializerSyntaxSyntax node with the specified
 changes.
 </summary>
	<param name="withKeyword">
 The new WithKeyword to update this ObjectMemberInitializerSyntaxSyntax node
 with. If not specified the current WithKeyword will be used in the new
 ObjectMemberInitializerSyntaxSyntax node.
 </param>
	<param name="openBraceToken">
 The new OpenBraceToken to update this ObjectMemberInitializerSyntaxSyntax node
 with. If not specified the current OpenBraceToken will be used in the new
 ObjectMemberInitializerSyntaxSyntax node.
 </param>
	<param name="initializers">
 The new Initializers to update this ObjectMemberInitializerSyntaxSyntax node
 with. If not specified the current Initializers will be used in the new
 ObjectMemberInitializerSyntaxSyntax node.
 </param>
	<param name="closeBraceToken">
 The new CloseBraceToken to update this ObjectMemberInitializerSyntaxSyntax node
 with. If not specified the current CloseBraceToken will be used in the new
 ObjectMemberInitializerSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ObjectMemberInitializerSyntax">
	<summary>
 Represents a "With {...} clause used to initialize a new object's members.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ObjectCollectionInitializerSyntax.FromKeyword">
	<summary>
 The "From" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ObjectCollectionInitializerSyntax.Initializer">
	<summary>
 The initializer including the braces.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ObjectCollectionInitializerSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.CollectionInitializerSyntax)">
	<summary>
 Creates a new ObjectCollectionInitializerSyntaxSyntax node with the specified
 changes.
 </summary>
	<param name="fromKeyword">
 The new FromKeyword to update this ObjectCollectionInitializerSyntaxSyntax node
 with. If not specified the current FromKeyword will be used in the new
 ObjectCollectionInitializerSyntaxSyntax node.
 </param>
	<param name="initializer">
 The new Initializer to update this ObjectCollectionInitializerSyntaxSyntax node
 with. If not specified the current Initializer will be used in the new
 ObjectCollectionInitializerSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ObjectCollectionInitializerSyntax">
	<summary>
 Represents a "From {...} clause used to initialize a new collection object's
 elements.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.FieldInitializerSyntax.KeyKeywordOpt">
	<summary>
 The optional "Key" keyword.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.FieldInitializerSyntax">
	<summary>
 Abstract class that represent a single field initializer used in a "With {...}"
 field initializer list.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InferredFieldInitializerSyntax.KeyKeywordOpt">
	<summary>
 The optional "Key" keyword.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InferredFieldInitializerSyntax.Expression">
	<summary>
 The value being assigned.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InferredFieldInitializerSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new InferredFieldInitializerSyntaxSyntax node with the specified
 changes.
 </summary>
	<param name="keyKeywordOpt">
 The new KeyKeyword to update this InferredFieldInitializerSyntaxSyntax node
 with. If not specified the current KeyKeyword will be used in the new
 InferredFieldInitializerSyntaxSyntax node.
 </param>
	<param name="expression">
 The new Expression to update this InferredFieldInitializerSyntaxSyntax node
 with. If not specified the current Expression will be used in the new
 InferredFieldInitializerSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.InferredFieldInitializerSyntax">
	<summary>
 Represent a field initializer in a With {...} initializer where the field name
 is inferred from the initializer expression.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedFieldInitializerSyntax.KeyKeywordOpt">
	<summary>
 The optional "Key" keyword.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedFieldInitializerSyntax.DotToken">
	<summary>
 The "." token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedFieldInitializerSyntax.Identifier">
	<summary>
 The name of the field being initialized.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedFieldInitializerSyntax.EqualsToken">
	<summary>
 The "=" token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedFieldInitializerSyntax.Expression">
	<summary>
 The value being assigned to the field.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedFieldInitializerSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new NamedFieldInitializerSyntaxSyntax node with the specified
 changes.
 </summary>
	<param name="keyKeywordOpt">
 The new KeyKeyword to update this NamedFieldInitializerSyntaxSyntax node with.
 If not specified the current KeyKeyword will be used in the new
 NamedFieldInitializerSyntaxSyntax node.
 </param>
	<param name="dotToken">
 The new DotToken to update this NamedFieldInitializerSyntaxSyntax node with. If
 not specified the current DotToken will be used in the new
 NamedFieldInitializerSyntaxSyntax node.
 </param>
	<param name="identifier">
 The new Identifier to update this NamedFieldInitializerSyntaxSyntax node with.
 If not specified the current Identifier will be used in the new
 NamedFieldInitializerSyntaxSyntax node.
 </param>
	<param name="equalsToken">
 The new EqualsToken to update this NamedFieldInitializerSyntaxSyntax node with.
 If not specified the current EqualsToken will be used in the new
 NamedFieldInitializerSyntaxSyntax node.
 </param>
	<param name="expression">
 The new Expression to update this NamedFieldInitializerSyntaxSyntax node with.
 If not specified the current Expression will be used in the new
 NamedFieldInitializerSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.NamedFieldInitializerSyntax">
	<summary>
 Represent a named field initializer in a With {...} initializer, such as ".x =
 expr".
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.EqualsValueSyntax.EqualsToken">
	<summary>
 The "=" token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.EqualsValueSyntax.Value">
	<summary>
 The expression used as the initial value.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.EqualsValueSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new EqualsValueSyntaxSyntax node with the specified changes.
 </summary>
	<param name="equalsToken">
 The new EqualsToken to update this EqualsValueSyntaxSyntax node with. If not
 specified the current EqualsToken will be used in the new
 EqualsValueSyntaxSyntax node.
 </param>
	<param name="value">
 The new Value to update this EqualsValueSyntaxSyntax node with. If not
 specified the current Value will be used in the new EqualsValueSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.EqualsValueSyntax">
	<summary>
 Represents an "= initializer" clause in a declaration for a variable,
 pararameter or automatic property.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ParameterSyntax.Attributes">
	<summary>
 A list of all attribute blocks on this parameter. If no attributes were
 specified, Nothing is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ParameterSyntax.Modifiers">
	<summary>
 A list of the modifier tokens "ByVal", "ByRef", "Optional" or "ParamArray" that
 modify this parameter.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ParameterSyntax.Identifier">
	<summary>
 The name of the parameter, including any "?" or "()" modifiers.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ParameterSyntax.AsClauseOpt">
	<summary>
 If present, the "As type-name" clause describing the type of the parameter. If
 no As clause is present, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ParameterSyntax.DefaultOpt">
	<summary>
 If present, an initializer with the default value of the parameter. If no
 default value is present, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ParameterSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeBlockSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.ModifiedIdentifierSyntax,Roslyn.Compilers.VisualBasic.SimpleAsClauseSyntax,Roslyn.Compilers.VisualBasic.EqualsValueSyntax)">
	<summary>
 Creates a new ParameterSyntaxSyntax node with the specified changes.
 </summary>
	<param name="attributes">
 The new Attributes to update this ParameterSyntaxSyntax node with. If not
 specified the current Attributes will be used in the new ParameterSyntaxSyntax
 node.
 </param>
	<param name="modifiers">
 The new Modifiers to update this ParameterSyntaxSyntax node with. If not
 specified the current Modifiers will be used in the new ParameterSyntaxSyntax
 node.
 </param>
	<param name="identifier">
 The new Identifier to update this ParameterSyntaxSyntax node with. If not
 specified the current Identifier will be used in the new ParameterSyntaxSyntax
 node.
 </param>
	<param name="asClauseOpt">
 The new AsClause to update this ParameterSyntaxSyntax node with. If not
 specified the current AsClause will be used in the new ParameterSyntaxSyntax
 node.
 </param>
	<param name="defaultOpt">
 The new Default to update this ParameterSyntaxSyntax node with. If not
 specified the current Default will be used in the new ParameterSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ParameterSyntax">
	<summary>
 Represent a parameter to a method, property, constructor, etc.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ModifiedIdentifierSyntax.Identifier">
	<summary>
 The identifier that names the item being declared.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ModifiedIdentifierSyntax.NullableOpt">
	<summary>
 The "?" token that indicates a nullable type.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ModifiedIdentifierSyntax.ArrayBoundsOpt">
	<summary>
 The optional array bounds, such as "(4)" or "(0 to 5, 0 To 6)".
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ModifiedIdentifierSyntax.ArrayRankSpecifiers">
	<summary>
 A list of array modifiers for the type. If no array modifiers were present, an
 empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ModifiedIdentifierSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ArgumentListSyntax,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.ArrayRankSpecifierSyntax})">
	<summary>
 Creates a new ModifiedIdentifierSyntaxSyntax node with the specified changes.
 </summary>
	<param name="identifier">
 The new Identifier to update this ModifiedIdentifierSyntaxSyntax node with. If
 not specified the current Identifier will be used in the new
 ModifiedIdentifierSyntaxSyntax node.
 </param>
	<param name="nullableOpt">
 The new Nullable to update this ModifiedIdentifierSyntaxSyntax node with. If
 not specified the current Nullable will be used in the new
 ModifiedIdentifierSyntaxSyntax node.
 </param>
	<param name="arrayBoundsOpt">
 The new ArrayBounds to update this ModifiedIdentifierSyntaxSyntax node with. If
 not specified the current ArrayBounds will be used in the new
 ModifiedIdentifierSyntaxSyntax node.
 </param>
	<param name="arrayRankSpecifiers">
 The new ArrayRankSpecifiers to update this ModifiedIdentifierSyntaxSyntax node
 with. If not specified the current ArrayRankSpecifiers will be used in the new
 ModifiedIdentifierSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ModifiedIdentifierSyntax">
	<summary>
 Represents an identifier with optional "?" or "()" or "(,,,)" modifiers, as
 used in parameter declarations and variable declarations.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ArrayRankSpecifierSyntax.OpenParenToken">
	<summary>
 The "(" token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ArrayRankSpecifierSyntax.CommaTokens">
	<summary>
 The comma tokens in the array type. There is one less comma than the rank.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ArrayRankSpecifierSyntax.CloseParenToken">
	<summary>
 The ")" token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ArrayRankSpecifierSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new ArrayRankSpecifierSyntaxSyntax node with the specified changes.
 </summary>
	<param name="openParenToken">
 The new OpenParenToken to update this ArrayRankSpecifierSyntaxSyntax node with.
 If not specified the current OpenParenToken will be used in the new
 ArrayRankSpecifierSyntaxSyntax node.
 </param>
	<param name="commaTokens">
 The new CommaTokens to update this ArrayRankSpecifierSyntaxSyntax node with. If
 not specified the current CommaTokens will be used in the new
 ArrayRankSpecifierSyntaxSyntax node.
 </param>
	<param name="closeParenToken">
 The new CloseParenToken to update this ArrayRankSpecifierSyntaxSyntax node
 with. If not specified the current CloseParenToken will be used in the new
 ArrayRankSpecifierSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ArrayRankSpecifierSyntax">
	<summary>
 Represents a modifier that describes an array type, without bounds, such as
 "()" or "(,)".
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AttributeBlockSyntax.LessThanToken">
	<summary>
 The "&amp;lt;" token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AttributeBlockSyntax.Attributes">
	<summary>
 A comma separated list of attribute declarations in this attribute block.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.AttributeBlockSyntax.GreaterThanToken">
	<summary>
 The "&amp;gt;" token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AttributeBlockSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.AttributeSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new AttributeBlockSyntaxSyntax node with the specified changes.
 </summary>
	<param name="lessThanToken">
 The new LessThanToken to update this AttributeBlockSyntaxSyntax node with. If
 not specified the current LessThanToken will be used in the new
 AttributeBlockSyntaxSyntax node.
 </param>
	<param name="attributes">
 The new Attributes to update this AttributeBlockSyntaxSyntax node with. If not
 specified the current Attributes will be used in the new
 AttributeBlockSyntaxSyntax node.
 </param>
	<param name="greaterThanToken">
 The new GreaterThanToken to update this AttributeBlockSyntaxSyntax node with.
 If not specified the current GreaterThanToken will be used in the new
 AttributeBlockSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.AttributeBlockSyntax">
	<summary>
 Represents a group of attributes within "&amp;lt;" and "&amp;gt;" brackets.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AttributeSyntax.TargetOpt">
	<summary>
 Optional attribute target. Assembly|Module :
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.AttributeSyntax.Name">
	<summary>
 The name of the attribute.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AttributeSyntax.ArgumentListOpt">
	<summary>
 The argument list, if present. If no argument list was supplied, Nothing is
 returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.AttributeSyntax.Update(Roslyn.Compilers.VisualBasic.AttributeTargetSyntax,Roslyn.Compilers.VisualBasic.TypeSyntax,Roslyn.Compilers.VisualBasic.ArgumentListSyntax)">
	<summary>
 Creates a new AttributeSyntaxSyntax node with the specified changes.
 </summary>
	<param name="targetOpt">
 The new Target to update this AttributeSyntaxSyntax node with. If not specified
 the current Target will be used in the new AttributeSyntaxSyntax node.
 </param>
	<param name="name">
 The new Name to update this AttributeSyntaxSyntax node with. If not specified
 the current Name will be used in the new AttributeSyntaxSyntax node.
 </param>
	<param name="argumentListOpt">
 The new ArgumentList to update this AttributeSyntaxSyntax node with. If not
 specified the current ArgumentList will be used in the new
 AttributeSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.AttributeSyntax">
	<summary>
 Represents a single attribute declaration within an attribute block.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AttributeTargetSyntax.AttributeModifier">
	<summary>
 The "Assembly" or "Module" attribute modifier, is present. If no attribute
 modifier is present, Nothing is returned.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AttributeTargetSyntax.ColonToken">
	<summary>
 The ":" token, if an attribute modifier is present. If no attribute modifier is
 present, Nothing is returned.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AttributeTargetSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new AttributeTargetSyntaxSyntax node with the specified changes.
 </summary>
	<param name="attributeModifier">
 The new AttributeModifier to update this AttributeTargetSyntaxSyntax node with.
 If not specified the current AttributeModifier will be used in the new
 AttributeTargetSyntaxSyntax node.
 </param>
	<param name="colonToken">
 The new ColonToken to update this AttributeTargetSyntaxSyntax node with. If not
 specified the current ColonToken will be used in the new
 AttributeTargetSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.AttributeTargetSyntax">
	<summary>
 Represents a single attribute declaration within an attribute block.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AttributesStatementSyntax.Attributes">
	<summary>
 The list of attribute blocks.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.AttributesStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeBlockSyntax})">
	<summary>
 Creates a new AttributesStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="attributes">
 The new Attributes to update this AttributesStatementSyntaxSyntax node with. If
 not specified the current Attributes will be used in the new
 AttributesStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.AttributesStatementSyntax">
	<summary>
 Represents a file-level attribute, in which the attributes have no other
 syntactic element they are attached to.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.WhileBlockSyntax.Begin">
	<summary>
 The While statement that begins the block.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.WhileBlockSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.WhileBlockSyntax.Statements">
	<summary>
 The statements contained in the While...End While. This might be an empty list.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.WhileBlockSyntax.End">
	<summary>
 The End While statement that ends the block.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.WhileBlockSyntax.Update(Roslyn.Compilers.VisualBasic.WhileStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Creates a new WhileBlockSyntaxSyntax node with the specified changes.
 </summary>
	<param name="begin">
 The new Begin to update this WhileBlockSyntaxSyntax node with. If not specified
 the current Begin will be used in the new WhileBlockSyntaxSyntax node.
 </param>
	<param name="beginTerminator">
 The new BeginTerminator to update this WhileBlockSyntaxSyntax node with. If not
 specified the current BeginTerminator will be used in the new
 WhileBlockSyntaxSyntax node.
 </param>
	<param name="statements">
 The new Statements to update this WhileBlockSyntaxSyntax node with. If not
 specified the current Statements will be used in the new WhileBlockSyntaxSyntax
 node.
 </param>
	<param name="end">
 The new End to update this WhileBlockSyntaxSyntax node with. If not specified
 the current End will be used in the new WhileBlockSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.WhileBlockSyntax">
	<summary>
 Represents a While...End While statement, including the While, body and End
 While.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.UsingBlockSyntax.Begin">
	<summary>
 The UsingStatement that begins the Using...End Using block.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.UsingBlockSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.UsingBlockSyntax.Statements">
	<summary>
 The statements contained in the Using...End Using block. This might be an empty
 list.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.UsingBlockSyntax.End">
	<summary>
 The End Using statement that ends the block.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.UsingBlockSyntax.Update(Roslyn.Compilers.VisualBasic.UsingStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Creates a new UsingBlockSyntaxSyntax node with the specified changes.
 </summary>
	<param name="begin">
 The new Begin to update this UsingBlockSyntaxSyntax node with. If not specified
 the current Begin will be used in the new UsingBlockSyntaxSyntax node.
 </param>
	<param name="beginTerminator">
 The new BeginTerminator to update this UsingBlockSyntaxSyntax node with. If not
 specified the current BeginTerminator will be used in the new
 UsingBlockSyntaxSyntax node.
 </param>
	<param name="statements">
 The new Statements to update this UsingBlockSyntaxSyntax node with. If not
 specified the current Statements will be used in the new UsingBlockSyntaxSyntax
 node.
 </param>
	<param name="end">
 The new End to update this UsingBlockSyntaxSyntax node with. If not specified
 the current End will be used in the new UsingBlockSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.UsingBlockSyntax">
	<summary>
 Represents an entire Using...End Using statement, including the Using, body and
 End Using statements.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SyncLockBlockSyntax.Begin">
	<summary>
 The SyncLock statement that begins the block.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SyncLockBlockSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SyncLockBlockSyntax.Statements">
	<summary>
 The statements contained in the SyncLock...End SyncLock statement. This might
 be an empty list.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.SyncLockBlockSyntax.End">
	<summary>
 The End SyncLock statement that ends the block.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyncLockBlockSyntax.Update(Roslyn.Compilers.VisualBasic.SyncLockStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Creates a new SyncLockBlockSyntaxSyntax node with the specified changes.
 </summary>
	<param name="begin">
 The new Begin to update this SyncLockBlockSyntaxSyntax node with. If not
 specified the current Begin will be used in the new SyncLockBlockSyntaxSyntax
 node.
 </param>
	<param name="beginTerminator">
 The new BeginTerminator to update this SyncLockBlockSyntaxSyntax node with. If
 not specified the current BeginTerminator will be used in the new
 SyncLockBlockSyntaxSyntax node.
 </param>
	<param name="statements">
 The new Statements to update this SyncLockBlockSyntaxSyntax node with. If not
 specified the current Statements will be used in the new
 SyncLockBlockSyntaxSyntax node.
 </param>
	<param name="end">
 The new End to update this SyncLockBlockSyntaxSyntax node with. If not
 specified the current End will be used in the new SyncLockBlockSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.SyncLockBlockSyntax">
	<summary>
 Represents a entire SyncLock...End SyncLock block, including the SyncLock
 statement, the enclosed statements, and the End SyncLock statment.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.WithBlockSyntax.Begin">
	<summary>
 The WithStatement that begins the With...End With block.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.WithBlockSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.WithBlockSyntax.Statements">
	<summary>
 The statements contained in the With...End With block. This might be an empty
 list.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.WithBlockSyntax.End">
	<summary>
 The End With statement that ends the block.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.WithBlockSyntax.Update(Roslyn.Compilers.VisualBasic.WithStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Creates a new WithBlockSyntaxSyntax node with the specified changes.
 </summary>
	<param name="begin">
 The new Begin to update this WithBlockSyntaxSyntax node with. If not specified
 the current Begin will be used in the new WithBlockSyntaxSyntax node.
 </param>
	<param name="beginTerminator">
 The new BeginTerminator to update this WithBlockSyntaxSyntax node with. If not
 specified the current BeginTerminator will be used in the new
 WithBlockSyntaxSyntax node.
 </param>
	<param name="statements">
 The new Statements to update this WithBlockSyntaxSyntax node with. If not
 specified the current Statements will be used in the new WithBlockSyntaxSyntax
 node.
 </param>
	<param name="end">
 The new End to update this WithBlockSyntaxSyntax node with. If not specified
 the current End will be used in the new WithBlockSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.WithBlockSyntax">
	<summary>
 Represents a With...End With block, include the With statement, the body of the
 block and the End With statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.LocalDeclarationSyntax.Modifiers">
	<summary>
 The modifier token (Static, Dim or Const) that introduces this local variable
 declaration.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.LocalDeclarationSyntax.Declarators">
	<summary>
 The list of variable declarator. Each declarator specifies one or more variable
 names along with a type and/or initializer.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LocalDeclarationSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.VariableDeclaratorSyntax})">
	<summary>
 Creates a new LocalDeclarationSyntaxSyntax node with the specified changes.
 </summary>
	<param name="modifiers">
 The new Modifiers to update this LocalDeclarationSyntaxSyntax node with. If not
 specified the current Modifiers will be used in the new
 LocalDeclarationSyntaxSyntax node.
 </param>
	<param name="declarators">
 The new Declarators to update this LocalDeclarationSyntaxSyntax node with. If
 not specified the current Declarators will be used in the new
 LocalDeclarationSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.LocalDeclarationSyntax">
	<summary>
 Represents the declaration of one or more local variables or constants.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.LabelStatementSyntax.LabelName">
	<summary>
 The name of the label. If the label is a line number, returns an IntegerLiteral
 that is the line number, otherwise, returns an Identifier.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LabelStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new LabelStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="labelName">
 The new LabelName to update this LabelStatementSyntaxSyntax node with. If not
 specified the current LabelName will be used in the new
 LabelStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.LabelStatementSyntax">
	<summary>
 Represents a label statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.GoToStatementSyntax.GoToKeyword">
	<summary>
 The "GoTo" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.GoToStatementSyntax.LabelName">
	<summary>
 The name of the label. If the label is a line number, returns an IntegerLiteral
 that is the line number, otherwise, returns an Identifier.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.GoToStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new GoToStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="goToKeyword">
 The new GoToKeyword to update this GoToStatementSyntaxSyntax node with. If not
 specified the current GoToKeyword will be used in the new
 GoToStatementSyntaxSyntax node.
 </param>
	<param name="labelName">
 The new LabelName to update this GoToStatementSyntaxSyntax node with. If not
 specified the current LabelName will be used in the new
 GoToStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.GoToStatementSyntax">
	<summary>
 Represents a "GoTo" statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.StopOrEndStatementSyntax.StopOrEndKeyword">
	<summary>
 The "Stop" or "End" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.StopOrEndStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new StopOrEndStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="stopOrEndKeyword">
 The new StopOrEndKeyword to update this StopOrEndStatementSyntaxSyntax node
 with. If not specified the current StopOrEndKeyword will be used in the new
 StopOrEndStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.StopOrEndStatementSyntax">
	<summary>
 Represents a "Stop" or "End" statement. The Kind can be used to determine which
 kind of statement this is.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ExitStatementSyntax.ExitKeyword">
	<summary>
 The "Exit" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ExitStatementSyntax.BlockKeyword">
	<summary>
 The keyword describing the block to exit.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ExitStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new ExitStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="exitKeyword">
 The new ExitKeyword to update this ExitStatementSyntaxSyntax node with. If not
 specified the current ExitKeyword will be used in the new
 ExitStatementSyntaxSyntax node.
 </param>
	<param name="blockKeyword">
 The new BlockKeyword to update this ExitStatementSyntaxSyntax node with. If not
 specified the current BlockKeyword will be used in the new
 ExitStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ExitStatementSyntax">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ContinueStatementSyntax.ContinueKeyword">
	<summary>
 The "Continue" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ContinueStatementSyntax.BlockKeyword">
	<summary>
 The "Do", "For" or "While" keyword that identifies the kind of loop being
 continued.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ContinueStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new ContinueStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="continueKeyword">
 The new ContinueKeyword to update this ContinueStatementSyntaxSyntax node with.
 If not specified the current ContinueKeyword will be used in the new
 ContinueStatementSyntaxSyntax node.
 </param>
	<param name="blockKeyword">
 The new BlockKeyword to update this ContinueStatementSyntaxSyntax node with. If
 not specified the current BlockKeyword will be used in the new
 ContinueStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ContinueStatementSyntax">
	<summary>
 Represents a "Continue (block)" statement. THe kind of block referenced can be
 determined by examining the Kind.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ReturnStatementSyntax.ReturnKeyword">
	<summary>
 The "Return" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ReturnStatementSyntax.ExpressionOpt">
	<summary>
 The expression being returned, if present.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ReturnStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new ReturnStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="returnKeyword">
 The new ReturnKeyword to update this ReturnStatementSyntaxSyntax node with. If
 not specified the current ReturnKeyword will be used in the new
 ReturnStatementSyntaxSyntax node.
 </param>
	<param name="expressionOpt">
 The new Expression to update this ReturnStatementSyntaxSyntax node with. If not
 specified the current Expression will be used in the new
 ReturnStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ReturnStatementSyntax">
	<summary>
 Represents a "Return" statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SingleLineIfStatementSyntax.IfPart">
	<summary>
 The If part of the statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SingleLineIfStatementSyntax.ElsePartOpt">
	<summary>
 The Else part of the statement. If there is no Else part, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SingleLineIfStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SingleLineIfPartSyntax,Roslyn.Compilers.VisualBasic.SingleLineElsePartSyntax)">
	<summary>
 Creates a new SingleLineIfStatementSyntaxSyntax node with the specified
 changes.
 </summary>
	<param name="ifPart">
 The new IfPart to update this SingleLineIfStatementSyntaxSyntax node with. If
 not specified the current IfPart will be used in the new
 SingleLineIfStatementSyntaxSyntax node.
 </param>
	<param name="elsePartOpt">
 The new ElsePart to update this SingleLineIfStatementSyntaxSyntax node with. If
 not specified the current ElsePart will be used in the new
 SingleLineIfStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.SingleLineIfStatementSyntax">
	<summary>
 Represents a line If-Then-Else statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SingleLineIfPartSyntax.Begin">
	<summary>
 The statement that introduces this part of the If...Then...Else...End If. This
 must be an IfStatement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SingleLineIfPartSyntax.Statements">
	<summary>
 The statements controlled by this If or Else If. This might be an empty list.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SingleLineIfPartSyntax.Update(Roslyn.Compilers.VisualBasic.IfStatementSyntax,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Creates a new SingleLineIfPartSyntaxSyntax node with the specified changes.
 </summary>
	<param name="begin">
 The new Begin to update this SingleLineIfPartSyntaxSyntax node with. If not
 specified the current Begin will be used in the new
 SingleLineIfPartSyntaxSyntax node.
 </param>
	<param name="statements">
 The new Statements to update this SingleLineIfPartSyntaxSyntax node with. If
 not specified the current Statements will be used in the new
 SingleLineIfPartSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.SingleLineIfPartSyntax">
	<summary>
 Represents part of a single line If statement, consisting of a beginning
 if-statement, followed by a body of statement controlled by that beginning
 statement. The Kind property returns if this is an SingleLineIf.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SingleLineElsePartSyntax.Begin">
	<summary>
 The Else statement that introduces this part.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SingleLineElsePartSyntax.Statements">
	<summary>
 The statements controlled by the Else.This might be an empty list.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SingleLineElsePartSyntax.Update(Roslyn.Compilers.VisualBasic.ElseStatementSyntax,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Creates a new SingleLineElsePartSyntaxSyntax node with the specified changes.
 </summary>
	<param name="begin">
 The new Begin to update this SingleLineElsePartSyntaxSyntax node with. If not
 specified the current Begin will be used in the new
 SingleLineElsePartSyntaxSyntax node.
 </param>
	<param name="statements">
 The new Statements to update this SingleLineElsePartSyntaxSyntax node with. If
 not specified the current Statements will be used in the new
 SingleLineElsePartSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.SingleLineElsePartSyntax">
	<summary>
 Represents the Else part of an If statement, consisting of a Else statement,
 followed by a body of statement controlled by that Else.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MultiLineIfBlockSyntax.IfPart">
	<summary>
 The If part of the statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MultiLineIfBlockSyntax.ElseIfParts">
	<summary>
 A list of the "ElseIf" parts of the statement. If there are no ElseIf parts,
 then an empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.MultiLineIfBlockSyntax.ElsePartOpt">
	<summary>
 The Else part of the statement. If there is no Else part, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.MultiLineIfBlockSyntax.EndIf">
	<summary>
 If this is a block if, returns the "End If" statement.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MultiLineIfBlockSyntax.Update(Roslyn.Compilers.VisualBasic.IfPartSyntax,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.IfPartSyntax},Roslyn.Compilers.VisualBasic.ElsePartSyntax,Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Creates a new MultiLineIfBlockSyntaxSyntax node with the specified changes.
 </summary>
	<param name="ifPart">
 The new IfPart to update this MultiLineIfBlockSyntaxSyntax node with. If not
 specified the current IfPart will be used in the new
 MultiLineIfBlockSyntaxSyntax node.
 </param>
	<param name="elseIfParts">
 The new ElseIfParts to update this MultiLineIfBlockSyntaxSyntax node with. If
 not specified the current ElseIfParts will be used in the new
 MultiLineIfBlockSyntaxSyntax node.
 </param>
	<param name="elsePartOpt">
 The new ElsePart to update this MultiLineIfBlockSyntaxSyntax node with. If not
 specified the current ElsePart will be used in the new
 MultiLineIfBlockSyntaxSyntax node.
 </param>
	<param name="endIf">
 The new EndIf to update this MultiLineIfBlockSyntaxSyntax node with. If not
 specified the current EndIf will be used in the new
 MultiLineIfBlockSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.MultiLineIfBlockSyntax">
	<summary>
 Represents a block If...Then...Else...EndIf Statement. The Kind property can be
 used to determine if it is a block or line If.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.IfPartSyntax.Begin">
	<summary>
 The statement that introduces this part of the If...Then...Else...End If. This
 must be an IfStatement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.IfPartSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.IfPartSyntax.Statements">
	<summary>
 The statements controlled by this If or Else If. This might be an empty list.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.IfPartSyntax.Update(Roslyn.Compilers.VisualBasic.IfStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Creates a new IfPartSyntaxSyntax node with the specified changes.
 </summary>
	<param name="begin">
 The new Begin to update this IfPartSyntaxSyntax node with. If not specified the
 current Begin will be used in the new IfPartSyntaxSyntax node.
 </param>
	<param name="beginTerminator">
 The new BeginTerminator to update this IfPartSyntaxSyntax node with. If not
 specified the current BeginTerminator will be used in the new
 IfPartSyntaxSyntax node.
 </param>
	<param name="statements">
 The new Statements to update this IfPartSyntaxSyntax node with. If not
 specified the current Statements will be used in the new IfPartSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.IfPartSyntax">
	<summary>
 Represents part of an If statement, consisting of a beginning statement (If or
 ElseIf), followed by a body of statement controlled by that beginning
 statement. The Kind property returns if this is an If or ElseIf.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ElsePartSyntax.Begin">
	<summary>
 The Else statement that introduces this part.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ElsePartSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ElsePartSyntax.Statements">
	<summary>
 The statements controlled by the Else. This might be an empty list.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ElsePartSyntax.Update(Roslyn.Compilers.VisualBasic.ElseStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Creates a new ElsePartSyntaxSyntax node with the specified changes.
 </summary>
	<param name="begin">
 The new Begin to update this ElsePartSyntaxSyntax node with. If not specified
 the current Begin will be used in the new ElsePartSyntaxSyntax node.
 </param>
	<param name="beginTerminator">
 The new BeginTerminator to update this ElsePartSyntaxSyntax node with. If not
 specified the current BeginTerminator will be used in the new
 ElsePartSyntaxSyntax node.
 </param>
	<param name="statements">
 The new Statements to update this ElsePartSyntaxSyntax node with. If not
 specified the current Statements will be used in the new ElsePartSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ElsePartSyntax">
	<summary>
 Represents the Else part of an If statement, consisting of a Else statement,
 followed by a body of statement controlled by that Else.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.IfStatementSyntax.ElseKeywordOpt">
	<summary>
 If this ElseIf was written as "Else If", contains the "Else" keyword. Otherwise
 returns Nothing.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.IfStatementSyntax.IfOrElseIfKeyword">
	<summary>
 The "If" or "ElseIf" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.IfStatementSyntax.Condition">
	<summary>
 The boolean expression that is being tested.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.IfStatementSyntax.ThenKeywordOpt">
	<summary>
 The "Then" keyword.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.IfStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new IfStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="elseKeywordOpt">
 The new ElseKeyword to update this IfStatementSyntaxSyntax node with. If not
 specified the current ElseKeyword will be used in the new
 IfStatementSyntaxSyntax node.
 </param>
	<param name="ifOrElseIfKeyword">
 The new IfOrElseIfKeyword to update this IfStatementSyntaxSyntax node with. If
 not specified the current IfOrElseIfKeyword will be used in the new
 IfStatementSyntaxSyntax node.
 </param>
	<param name="condition">
 The new Condition to update this IfStatementSyntaxSyntax node with. If not
 specified the current Condition will be used in the new IfStatementSyntaxSyntax
 node.
 </param>
	<param name="thenKeywordOpt">
 The new ThenKeyword to update this IfStatementSyntaxSyntax node with. If not
 specified the current ThenKeyword will be used in the new
 IfStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.IfStatementSyntax">
	<summary>
 Represents the If part or ElseIf part of a If...End If block (or line If). This
 statement is always the Begin of a IfPart. The Kind can be examined to
 determine if this is an If or an ElseIf statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ElseStatementSyntax.ElseKeyword">
	<summary>
 The "Else" keyword
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ElseStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new ElseStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="elseKeyword">
 The new ElseKeyword to update this ElseStatementSyntaxSyntax node with. If not
 specified the current ElseKeyword will be used in the new
 ElseStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ElseStatementSyntax">
	<summary>
 Represents the Else part of a If...End If block (or line If). This statement is
 always the Begin of a ElsePart.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TryBlockSyntax.TryPart">
	<summary>
 The Try part of the statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TryBlockSyntax.CatchParts">
	<summary>
 A list of the Catch parts of the statement. If there are no Catch parts, then
 an empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.TryBlockSyntax.FinallyPartOpt">
	<summary>
 The Finally part of the statement, if present.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.TryBlockSyntax.End">
	<summary>
 The "End Try" statement.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TryBlockSyntax.Update(Roslyn.Compilers.VisualBasic.TryPartSyntax,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.CatchPartSyntax},Roslyn.Compilers.VisualBasic.FinallyPartSyntax,Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Creates a new TryBlockSyntaxSyntax node with the specified changes.
 </summary>
	<param name="tryPart">
 The new TryPart to update this TryBlockSyntaxSyntax node with. If not specified
 the current TryPart will be used in the new TryBlockSyntaxSyntax node.
 </param>
	<param name="catchParts">
 The new CatchParts to update this TryBlockSyntaxSyntax node with. If not
 specified the current CatchParts will be used in the new TryBlockSyntaxSyntax
 node.
 </param>
	<param name="finallyPartOpt">
 The new FinallyPart to update this TryBlockSyntaxSyntax node with. If not
 specified the current FinallyPart will be used in the new TryBlockSyntaxSyntax
 node.
 </param>
	<param name="end">
 The new End to update this TryBlockSyntaxSyntax node with. If not specified the
 current End will be used in the new TryBlockSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.TryBlockSyntax">
	<summary>
 Represents an entire Try...Catch...Finally...End Try statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TryPartSyntax.Begin">
	<summary>
 The TryStatement that introduces this part of the Try...Catch...Finally...End
 Try.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TryPartSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TryPartSyntax.Statements">
	<summary>
 The statements inside the Try part of the Try...Catch...Finally...End Try. This
 might be an empty list.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.TryPartSyntax.Update(Roslyn.Compilers.VisualBasic.TryStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Creates a new TryPartSyntaxSyntax node with the specified changes.
 </summary>
	<param name="begin">
 The new Begin to update this TryPartSyntaxSyntax node with. If not specified
 the current Begin will be used in the new TryPartSyntaxSyntax node.
 </param>
	<param name="beginTerminator">
 The new BeginTerminator to update this TryPartSyntaxSyntax node with. If not
 specified the current BeginTerminator will be used in the new
 TryPartSyntaxSyntax node.
 </param>
	<param name="statements">
 The new Statements to update this TryPartSyntaxSyntax node with. If not
 specified the current Statements will be used in the new TryPartSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.TryPartSyntax">
	<summary>
 Represents part of an Try...Catch...Finally...End Try statement, consisting of
 a beginning statement (Try, Catch or Finally), followed by a body of statements
 controlled by that beginning statement. The Kind property returns which kind of
 part this is.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CatchPartSyntax.Begin">
	<summary>
 The CatchStatement that introduces this part.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CatchPartSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CatchPartSyntax.Statements">
	<summary>
 The statements controlled by the Catch statement. This might be an empty list.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.CatchPartSyntax.Update(Roslyn.Compilers.VisualBasic.CatchStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Creates a new CatchPartSyntaxSyntax node with the specified changes.
 </summary>
	<param name="begin">
 The new Begin to update this CatchPartSyntaxSyntax node with. If not specified
 the current Begin will be used in the new CatchPartSyntaxSyntax node.
 </param>
	<param name="beginTerminator">
 The new BeginTerminator to update this CatchPartSyntaxSyntax node with. If not
 specified the current BeginTerminator will be used in the new
 CatchPartSyntaxSyntax node.
 </param>
	<param name="statements">
 The new Statements to update this CatchPartSyntaxSyntax node with. If not
 specified the current Statements will be used in the new CatchPartSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.CatchPartSyntax">
	<summary>
 Represents a Catch part of an Try...Catch...Finally...End Try statement,
 consisting of a Catch statement, followed by a body of statements controlled by
 that Catch statement. The Kind property returns which kind of part this is.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.FinallyPartSyntax.Begin">
	<summary>
 The FinallyStatement that introduces the Finally part of a Try.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.FinallyPartSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.FinallyPartSyntax.Statements">
	<summary>
 The statements inside the Finally part of the Try...Catch...Finally...End Try.
 This might be an empty list.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.FinallyPartSyntax.Update(Roslyn.Compilers.VisualBasic.FinallyStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Creates a new FinallyPartSyntaxSyntax node with the specified changes.
 </summary>
	<param name="begin">
 The new Begin to update this FinallyPartSyntaxSyntax node with. If not
 specified the current Begin will be used in the new FinallyPartSyntaxSyntax
 node.
 </param>
	<param name="beginTerminator">
 The new BeginTerminator to update this FinallyPartSyntaxSyntax node with. If
 not specified the current BeginTerminator will be used in the new
 FinallyPartSyntaxSyntax node.
 </param>
	<param name="statements">
 The new Statements to update this FinallyPartSyntaxSyntax node with. If not
 specified the current Statements will be used in the new
 FinallyPartSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.FinallyPartSyntax">
	<summary>
 Represents the Finally part of an Try...Catch...Finally...End Try statement,
 consisting of a Finally statement, followed by a body of statements controlled
 by the Finally.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TryStatementSyntax.TryKeyword">
	<summary>
 The "Try" keyword
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TryStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new TryStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="tryKeyword">
 The new TryKeyword to update this TryStatementSyntaxSyntax node with. If not
 specified the current TryKeyword will be used in the new
 TryStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.TryStatementSyntax">
	<summary>
 Represents the Try part part of a Try...Catch...Finally...End Try. This
 statement is always the Begin of a TryPart.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CatchStatementSyntax.CatchKeyword">
	<summary>
 The "Catch" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CatchStatementSyntax.IdentifierOpt">
	<summary>
 The identifier representing the exception that was caught, if present.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.CatchStatementSyntax.AsClauseOpt">
	<summary>
 The As clause that defines the type of exception being caught.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.CatchStatementSyntax.WhenClauseOpt">
	<summary>
 The "When" clause, if present.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.CatchStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SimpleAsClauseSyntax,Roslyn.Compilers.VisualBasic.CatchFilterClauseSyntax)">
	<summary>
 Creates a new CatchStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="catchKeyword">
 The new CatchKeyword to update this CatchStatementSyntaxSyntax node with. If
 not specified the current CatchKeyword will be used in the new
 CatchStatementSyntaxSyntax node.
 </param>
	<param name="identifierOpt">
 The new Identifier to update this CatchStatementSyntaxSyntax node with. If not
 specified the current Identifier will be used in the new
 CatchStatementSyntaxSyntax node.
 </param>
	<param name="asClauseOpt">
 The new AsClause to update this CatchStatementSyntaxSyntax node with. If not
 specified the current AsClause will be used in the new
 CatchStatementSyntaxSyntax node.
 </param>
	<param name="whenClauseOpt">
 The new WhenClause to update this CatchStatementSyntaxSyntax node with. If not
 specified the current WhenClause will be used in the new
 CatchStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.CatchStatementSyntax">
	<summary>
 Represents the Catch part part of a Try...Catch...Finally...End Try. This
 statement is always the Begin of a CatchPart.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CatchFilterClauseSyntax.WhenKeyword">
	<summary>
 The "When" keyword
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CatchFilterClauseSyntax.Filter">
	<summary>
 The filter expression
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CatchFilterClauseSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new CatchFilterClauseSyntaxSyntax node with the specified changes.
 </summary>
	<param name="whenKeyword">
 The new WhenKeyword to update this CatchFilterClauseSyntaxSyntax node with. If
 not specified the current WhenKeyword will be used in the new
 CatchFilterClauseSyntaxSyntax node.
 </param>
	<param name="filter">
 The new Filter to update this CatchFilterClauseSyntaxSyntax node with. If not
 specified the current Filter will be used in the new
 CatchFilterClauseSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.CatchFilterClauseSyntax">
	<summary>
 Represents the When/Filter clause of a Catch statement
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.FinallyStatementSyntax.FinallyKeyword">
	<summary>
 The "Finally" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.FinallyStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new FinallyStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="finallyKeyword">
 The new FinallyKeyword to update this FinallyStatementSyntaxSyntax node with.
 If not specified the current FinallyKeyword will be used in the new
 FinallyStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.FinallyStatementSyntax">
	<summary>
 Represents the Finally part part of a Try...Catch...Finally...End Try. This
 statement is always the Begin of a FinallyPart.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ErrorStatementSyntax.ErrorKeyword">
	<summary>
 The "Error" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ErrorStatementSyntax.ErrorNumber">
	<summary>
 The expression that represents the error number.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ErrorStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new ErrorStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="errorKeyword">
 The new ErrorKeyword to update this ErrorStatementSyntaxSyntax node with. If
 not specified the current ErrorKeyword will be used in the new
 ErrorStatementSyntaxSyntax node.
 </param>
	<param name="errorNumber">
 The new ErrorNumber to update this ErrorStatementSyntaxSyntax node with. If not
 specified the current ErrorNumber will be used in the new
 ErrorStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ErrorStatementSyntax">
	<summary>
 Represents the "Error" statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.OnErrorGoToStatementSyntax.OnKeyword">
	<summary>
 The "On" keyword
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.OnErrorGoToStatementSyntax.ErrorKeyword">
	<summary>
 The "Error" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.OnErrorGoToStatementSyntax.GoToKeyword">
	<summary>
 The "GoTo" keyword
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.OnErrorGoToStatementSyntax.MinusOpt">
	<summary>
 An optional minus for On Error Goto -1
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.OnErrorGoToStatementSyntax.Label">
	<summary>
 The name of the label. If the label is a line number, 0 or -1, returns an
 IntegerLiteralToken that is the line number, otherwise, returns an Identifier.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OnErrorGoToStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new OnErrorGoToStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="onKeyword">
 The new OnKeyword to update this OnErrorGoToStatementSyntaxSyntax node with. If
 not specified the current OnKeyword will be used in the new
 OnErrorGoToStatementSyntaxSyntax node.
 </param>
	<param name="errorKeyword">
 The new ErrorKeyword to update this OnErrorGoToStatementSyntaxSyntax node with.
 If not specified the current ErrorKeyword will be used in the new
 OnErrorGoToStatementSyntaxSyntax node.
 </param>
	<param name="goToKeyword">
 The new GoToKeyword to update this OnErrorGoToStatementSyntaxSyntax node with.
 If not specified the current GoToKeyword will be used in the new
 OnErrorGoToStatementSyntaxSyntax node.
 </param>
	<param name="minusOpt">
 The new Minus to update this OnErrorGoToStatementSyntaxSyntax node with. If not
 specified the current Minus will be used in the new
 OnErrorGoToStatementSyntaxSyntax node.
 </param>
	<param name="label">
 The new Label to update this OnErrorGoToStatementSyntaxSyntax node with. If not
 specified the current Label will be used in the new
 OnErrorGoToStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.OnErrorGoToStatementSyntax">
	<summary>
 Represents an OnError Goto statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.OnErrorResumeNextStatementSyntax.OnKeyword">
	<summary>
 The "On" keyword
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.OnErrorResumeNextStatementSyntax.ErrorKeyword">
	<summary>
 The "Error" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.OnErrorResumeNextStatementSyntax.ResumeKeyword">
	<summary>
 The "Resume" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.OnErrorResumeNextStatementSyntax.NextKeyword">
	<summary>
 The "Next"
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OnErrorResumeNextStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new OnErrorResumeNextStatementSyntaxSyntax node with the specified
 changes.
 </summary>
	<param name="onKeyword">
 The new OnKeyword to update this OnErrorResumeNextStatementSyntaxSyntax node
 with. If not specified the current OnKeyword will be used in the new
 OnErrorResumeNextStatementSyntaxSyntax node.
 </param>
	<param name="errorKeyword">
 The new ErrorKeyword to update this OnErrorResumeNextStatementSyntaxSyntax node
 with. If not specified the current ErrorKeyword will be used in the new
 OnErrorResumeNextStatementSyntaxSyntax node.
 </param>
	<param name="resumeKeyword">
 The new ResumeKeyword to update this OnErrorResumeNextStatementSyntaxSyntax
 node with. If not specified the current ResumeKeyword will be used in the new
 OnErrorResumeNextStatementSyntaxSyntax node.
 </param>
	<param name="nextKeyword">
 The new NextKeyword to update this OnErrorResumeNextStatementSyntaxSyntax node
 with. If not specified the current NextKeyword will be used in the new
 OnErrorResumeNextStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.OnErrorResumeNextStatementSyntax">
	<summary>
 Represents an OnError Resume Next statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ResumeStatementSyntax.ResumeKeyword">
	<summary>
 The "Resume" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ResumeStatementSyntax.LabelOpt">
	<summary>
 The label. The value of this depends on the Kind. If Kind=Resume, returns
 Nothing. If Kind=ResumeNext, returns the keyword "Next", If Kind=ResumeLabel,
 returns an Identifier or IntegerLiteralToken with the label or line number.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ResumeStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new ResumeStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="resumeKeyword">
 The new ResumeKeyword to update this ResumeStatementSyntaxSyntax node with. If
 not specified the current ResumeKeyword will be used in the new
 ResumeStatementSyntaxSyntax node.
 </param>
	<param name="labelOpt">
 The new Label to update this ResumeStatementSyntaxSyntax node with. If not
 specified the current Label will be used in the new ResumeStatementSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ResumeStatementSyntax">
	<summary>
 Represents a "Resume" statement. The Kind property can be used to determine if
 this is a "Resume", "Resume Next" or "Resume label" statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SelectBlockSyntax.Begin">
	<summary>
 The Select Case statement that begins the block.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SelectBlockSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SelectBlockSyntax.CaseBlocks">
	<summary>
 A list of the contained Case blocks.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.SelectBlockSyntax.End">
	<summary>
 The End Select statement that ends the block.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SelectBlockSyntax.Update(Roslyn.Compilers.VisualBasic.SelectStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.CaseBlockSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Creates a new SelectBlockSyntaxSyntax node with the specified changes.
 </summary>
	<param name="begin">
 The new Begin to update this SelectBlockSyntaxSyntax node with. If not
 specified the current Begin will be used in the new SelectBlockSyntaxSyntax
 node.
 </param>
	<param name="beginTerminator">
 The new BeginTerminator to update this SelectBlockSyntaxSyntax node with. If
 not specified the current BeginTerminator will be used in the new
 SelectBlockSyntaxSyntax node.
 </param>
	<param name="caseBlocks">
 The new CaseBlocks to update this SelectBlockSyntaxSyntax node with. If not
 specified the current CaseBlocks will be used in the new
 SelectBlockSyntaxSyntax node.
 </param>
	<param name="end">
 The new End to update this SelectBlockSyntaxSyntax node with. If not specified
 the current End will be used in the new SelectBlockSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.SelectBlockSyntax">
	<summary>
 Represents a Select Case block, including the Select Case that begins it, the
 contains Case blocks and the End Select.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SelectStatementSyntax.SelectKeyword">
	<summary>
 The "Select" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SelectStatementSyntax.CaseKeywordOpt">
	<summary>
 The "Case" keyword, if present.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.SelectStatementSyntax.Expression">
	<summary>
 The value that branching is based on.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SelectStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new SelectStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="selectKeyword">
 The new SelectKeyword to update this SelectStatementSyntaxSyntax node with. If
 not specified the current SelectKeyword will be used in the new
 SelectStatementSyntaxSyntax node.
 </param>
	<param name="caseKeywordOpt">
 The new CaseKeyword to update this SelectStatementSyntaxSyntax node with. If
 not specified the current CaseKeyword will be used in the new
 SelectStatementSyntaxSyntax node.
 </param>
	<param name="expression">
 The new Expression to update this SelectStatementSyntaxSyntax node with. If not
 specified the current Expression will be used in the new
 SelectStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.SelectStatementSyntax">
	<summary>
 Represents a Select Case statement. This statement always occurs as the Begin
 of a SelectBlock.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CaseBlockSyntax.Begin">
	<summary>
 The statement that begins the case block.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CaseBlockSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CaseBlockSyntax.Statements">
	<summary>
 The statements contained in the case block. This might be an empty list.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.CaseBlockSyntax.Update(Roslyn.Compilers.VisualBasic.CaseStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Creates a new CaseBlockSyntaxSyntax node with the specified changes.
 </summary>
	<param name="begin">
 The new Begin to update this CaseBlockSyntaxSyntax node with. If not specified
 the current Begin will be used in the new CaseBlockSyntaxSyntax node.
 </param>
	<param name="beginTerminator">
 The new BeginTerminator to update this CaseBlockSyntaxSyntax node with. If not
 specified the current BeginTerminator will be used in the new
 CaseBlockSyntaxSyntax node.
 </param>
	<param name="statements">
 The new Statements to update this CaseBlockSyntaxSyntax node with. If not
 specified the current Statements will be used in the new CaseBlockSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.CaseBlockSyntax">
	<summary>
 Represents a case statement and its subsequent block.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CaseStatementSyntax.CaseKeyword">
	<summary>
 The "Case" keyword
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CaseStatementSyntax.Cases">
	<summary>
 A list of clauses associated with this Case. If Kind=CaseElse, then this list
 has exactly one child, which is a CaseElseClause.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CaseStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.CaseClauseSyntax})">
	<summary>
 Creates a new CaseStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="caseKeyword">
 The new CaseKeyword to update this CaseStatementSyntaxSyntax node with. If not
 specified the current CaseKeyword will be used in the new
 CaseStatementSyntaxSyntax node.
 </param>
	<param name="cases">
 The new Cases to update this CaseStatementSyntaxSyntax node with. If not
 specified the current Cases will be used in the new CaseStatementSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.CaseStatementSyntax">
	<summary>
 Represents a Case or Case Else statement. This statement is always the Begin of
 a CaseBlock. If this is a Case Else statement, the Kind=CaseElse, otherwise the
 Kind=Case.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.CaseClauseSyntax">
	<summary>
 Represents a single clause in a case statement. An abstract node that is the
 parent of different kinds of Case clauses.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CaseElseClauseSyntax.ElseKeyword">
	<summary>
 The "Else" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CaseElseClauseSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new CaseElseClauseSyntaxSyntax node with the specified changes.
 </summary>
	<param name="elseKeyword">
 The new ElseKeyword to update this CaseElseClauseSyntaxSyntax node with. If not
 specified the current ElseKeyword will be used in the new
 CaseElseClauseSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.CaseElseClauseSyntax">
	<summary>
 The "Else" part in a Case Else statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CaseValueClauseSyntax.Value">
	<summary>
 The expression that denotes the value being tested against.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CaseValueClauseSyntax.Update(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new CaseValueClauseSyntaxSyntax node with the specified changes.
 </summary>
	<param name="value">
 The new Value to update this CaseValueClauseSyntaxSyntax node with. If not
 specified the current Value will be used in the new CaseValueClauseSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.CaseValueClauseSyntax">
	<summary>
 Represents a single value in a Case.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CaseRangeClauseSyntax.LowerBound">
	<summary>
 The lower bound of the range.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CaseRangeClauseSyntax.ToKeyword">
	<summary>
 The "To" keyword
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CaseRangeClauseSyntax.UpperBound">
	<summary>
 The upper bound of the range.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CaseRangeClauseSyntax.Update(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new CaseRangeClauseSyntaxSyntax node with the specified changes.
 </summary>
	<param name="lowerBound">
 The new LowerBound to update this CaseRangeClauseSyntaxSyntax node with. If not
 specified the current LowerBound will be used in the new
 CaseRangeClauseSyntaxSyntax node.
 </param>
	<param name="toKeyword">
 The new ToKeyword to update this CaseRangeClauseSyntaxSyntax node with. If not
 specified the current ToKeyword will be used in the new
 CaseRangeClauseSyntaxSyntax node.
 </param>
	<param name="upperBound">
 The new UpperBound to update this CaseRangeClauseSyntaxSyntax node with. If not
 specified the current UpperBound will be used in the new
 CaseRangeClauseSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.CaseRangeClauseSyntax">
	<summary>
 Represents a range "expression To expression" in a Case.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CaseRelationalClauseSyntax.IsKeywordOpt">
	<summary>
 The "Is" keyword, if present.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.CaseRelationalClauseSyntax.OperatorToken">
	<summary>
 The operator in the relational clause. One of "=", "&amp;lt;", "&amp;gt;",
 "&amp;lt;=" or "&amp;gt;=".
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CaseRelationalClauseSyntax.Value">
	<summary>
 The expression that denotes the value being tested against.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CaseRelationalClauseSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new CaseRelationalClauseSyntaxSyntax node with the specified changes.
 </summary>
	<param name="isKeywordOpt">
 The new IsKeyword to update this CaseRelationalClauseSyntaxSyntax node with. If
 not specified the current IsKeyword will be used in the new
 CaseRelationalClauseSyntaxSyntax node.
 </param>
	<param name="operatorToken">
 The new OperatorToken to update this CaseRelationalClauseSyntaxSyntax node
 with. If not specified the current OperatorToken will be used in the new
 CaseRelationalClauseSyntaxSyntax node.
 </param>
	<param name="value">
 The new Value to update this CaseRelationalClauseSyntaxSyntax node with. If not
 specified the current Value will be used in the new
 CaseRelationalClauseSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.CaseRelationalClauseSyntax">
	<summary>
 Represents a relation clause in a Case statement, such as "Is &amp;gt;
 expression".
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SyncLockStatementSyntax.SyncLockKeyword">
	<summary>
 The "SyncLock" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SyncLockStatementSyntax.Expression">
	<summary>
 The expression being synchronized on.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyncLockStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new SyncLockStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="syncLockKeyword">
 The new SyncLockKeyword to update this SyncLockStatementSyntaxSyntax node with.
 If not specified the current SyncLockKeyword will be used in the new
 SyncLockStatementSyntaxSyntax node.
 </param>
	<param name="expression">
 The new Expression to update this SyncLockStatementSyntaxSyntax node with. If
 not specified the current Expression will be used in the new
 SyncLockStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.SyncLockStatementSyntax">
	<summary>
 Represents the "SyncLock" statement. This statement always occurs as the Begin
 of a SyncLockBlock.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.DoLoopBlockSyntax.Begin">
	<summary>
 The Do statement that begins the block.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.DoLoopBlockSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.DoLoopBlockSyntax.Statements">
	<summary>
 The statements contained in the block statement. This might be an empty list.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.DoLoopBlockSyntax.End">
	<summary>
 The Loop statement that ends the block.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.DoLoopBlockSyntax.Update(Roslyn.Compilers.VisualBasic.DoStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.LoopStatementSyntax)">
	<summary>
 Creates a new DoLoopBlockSyntaxSyntax node with the specified changes.
 </summary>
	<param name="begin">
 The new Begin to update this DoLoopBlockSyntaxSyntax node with. If not
 specified the current Begin will be used in the new DoLoopBlockSyntaxSyntax
 node.
 </param>
	<param name="beginTerminator">
 The new BeginTerminator to update this DoLoopBlockSyntaxSyntax node with. If
 not specified the current BeginTerminator will be used in the new
 DoLoopBlockSyntaxSyntax node.
 </param>
	<param name="statements">
 The new Statements to update this DoLoopBlockSyntaxSyntax node with. If not
 specified the current Statements will be used in the new
 DoLoopBlockSyntaxSyntax node.
 </param>
	<param name="end">
 The new End to update this DoLoopBlockSyntaxSyntax node with. If not specified
 the current End will be used in the new DoLoopBlockSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.DoLoopBlockSyntax">
	<summary>
 Represents a Do-Loop block. The Kind property can be used to determine if this
 is a top-test, bottom-test or infinite loop.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.DoStatementSyntax.DoKeyword">
	<summary>
 The "Do" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.DoStatementSyntax.WhileUntilClauseOpt">
	<summary>
 The "While expression" or "Until expression" part of the Do statement, if
 present.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.DoStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.WhileUntilClauseSyntax)">
	<summary>
 Creates a new DoStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="doKeyword">
 The new DoKeyword to update this DoStatementSyntaxSyntax node with. If not
 specified the current DoKeyword will be used in the new DoStatementSyntaxSyntax
 node.
 </param>
	<param name="whileUntilClauseOpt">
 The new WhileUntilClause to update this DoStatementSyntaxSyntax node with. If
 not specified the current WhileUntilClause will be used in the new
 DoStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.DoStatementSyntax">
	<summary>
 The Do statement that begins a Do-Loop block. This statement always occurs as
 the Begin of a DoLoopBlock.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.LoopStatementSyntax.LoopKeyword">
	<summary>
 The "Loop" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.LoopStatementSyntax.WhileUntilClauseOpt">
	<summary>
 The "While expression" or "Until expression" part of the Loop statement, if
 present.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.LoopStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.WhileUntilClauseSyntax)">
	<summary>
 Creates a new LoopStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="loopKeyword">
 The new LoopKeyword to update this LoopStatementSyntaxSyntax node with. If not
 specified the current LoopKeyword will be used in the new
 LoopStatementSyntaxSyntax node.
 </param>
	<param name="whileUntilClauseOpt">
 The new WhileUntilClause to update this LoopStatementSyntaxSyntax node with. If
 not specified the current WhileUntilClause will be used in the new
 LoopStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.LoopStatementSyntax">
	<summary>
 The Loop statement that ends a Do-Loop block. This statement always occurs as
 the End of a DoLoopBlock.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.WhileUntilClauseSyntax.WhileOrUntilKeyword">
	<summary>
 The "While" or "Until" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.WhileUntilClauseSyntax.Condition">
	<summary>
 The boolean expression after the While or Until.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.WhileUntilClauseSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new WhileUntilClauseSyntaxSyntax node with the specified changes.
 </summary>
	<param name="whileOrUntilKeyword">
 The new WhileOrUntilKeyword to update this WhileUntilClauseSyntaxSyntax node
 with. If not specified the current WhileOrUntilKeyword will be used in the new
 WhileUntilClauseSyntaxSyntax node.
 </param>
	<param name="condition">
 The new Condition to update this WhileUntilClauseSyntaxSyntax node with. If not
 specified the current Condition will be used in the new
 WhileUntilClauseSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.WhileUntilClauseSyntax">
	<summary>
 Represents a "While expression" or "Until expression" in a Do or Loop
 statement. The Kind of the clause can be "WhileClause" or "UntilClause" to
 indicate which kind of clause.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.WhileStatementSyntax.WhileKeyword">
	<summary>
 The "While" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.WhileStatementSyntax.Condition">
	<summary>
 The boolean expression that controls the While loop.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.WhileStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new WhileStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="whileKeyword">
 The new WhileKeyword to update this WhileStatementSyntaxSyntax node with. If
 not specified the current WhileKeyword will be used in the new
 WhileStatementSyntaxSyntax node.
 </param>
	<param name="condition">
 The new Condition to update this WhileStatementSyntaxSyntax node with. If not
 specified the current Condition will be used in the new
 WhileStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.WhileStatementSyntax">
	<summary>
 The While statement that begins a While...End While block. This statement
 always occurs as the Begin of a WhileBlock.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ForBlockSyntax.Begin">
	<summary>
 The For or For Each statement that begins the block.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ForBlockSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ForBlockSyntax.Statements">
	<summary>
 The statements contained in the For or For Each loop. This might be an empty
 list.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ForBlockSyntax.EndOpt">
	<summary>
 The Next statement that ends the block. If two For statements are ended by a
 single Next statement, the inner For will not have an EndStatment.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ForBlockSyntax.Update(Roslyn.Compilers.VisualBasic.StatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.NextStatementSyntax)">
	<summary>
 Creates a new ForBlockSyntaxSyntax node with the specified changes.
 </summary>
	<param name="begin">
 The new Begin to update this ForBlockSyntaxSyntax node with. If not specified
 the current Begin will be used in the new ForBlockSyntaxSyntax node.
 </param>
	<param name="beginTerminator">
 The new BeginTerminator to update this ForBlockSyntaxSyntax node with. If not
 specified the current BeginTerminator will be used in the new
 ForBlockSyntaxSyntax node.
 </param>
	<param name="statements">
 The new Statements to update this ForBlockSyntaxSyntax node with. If not
 specified the current Statements will be used in the new ForBlockSyntaxSyntax
 node.
 </param>
	<param name="endOpt">
 The new End to update this ForBlockSyntaxSyntax node with. If not specified the
 current End will be used in the new ForBlockSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ForBlockSyntax">
	<summary>
 Represents a For or For Each block, including the introducting statement, the
 body and the "Next" (which can be omitted if a containing For has a Next with
 multiple variables).
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ForStatementSyntax.ForKeyword">
	<summary>
 The "For" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ForStatementSyntax.ControlVariable">
	<summary>
 If the For or For Each statement is of a form that does not declare a new loop
 control variable, this is the expression that denotes the loop control
 variable. If this loop is of a form that does declare a new control variable,
 this is a VariableDeclarator that has the variable being declared.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ForStatementSyntax.EqualsToken">
	<summary>
 The "=" token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ForStatementSyntax.FromValue">
	<summary>
 The expression denoting the initial value of the iteration.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ForStatementSyntax.ToKeyword">
	<summary>
 The "To" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ForStatementSyntax.ToValue">
	<summary>
 The expression denoting the final value of the iteration.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ForStatementSyntax.StepClauseOpt">
	<summary>
 The optional Step clause.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ForStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.ForStepClauseSyntax)">
	<summary>
 Creates a new ForStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="forKeyword">
 The new ForKeyword to update this ForStatementSyntaxSyntax node with. If not
 specified the current ForKeyword will be used in the new
 ForStatementSyntaxSyntax node.
 </param>
	<param name="controlVariable">
 The new ControlVariable to update this ForStatementSyntaxSyntax node with. If
 not specified the current ControlVariable will be used in the new
 ForStatementSyntaxSyntax node.
 </param>
	<param name="equalsToken">
 The new EqualsToken to update this ForStatementSyntaxSyntax node with. If not
 specified the current EqualsToken will be used in the new
 ForStatementSyntaxSyntax node.
 </param>
	<param name="fromValue">
 The new FromValue to update this ForStatementSyntaxSyntax node with. If not
 specified the current FromValue will be used in the new
 ForStatementSyntaxSyntax node.
 </param>
	<param name="toKeyword">
 The new ToKeyword to update this ForStatementSyntaxSyntax node with. If not
 specified the current ToKeyword will be used in the new
 ForStatementSyntaxSyntax node.
 </param>
	<param name="toValue">
 The new ToValue to update this ForStatementSyntaxSyntax node with. If not
 specified the current ToValue will be used in the new ForStatementSyntaxSyntax
 node.
 </param>
	<param name="stepClauseOpt">
 The new StepClause to update this ForStatementSyntaxSyntax node with. If not
 specified the current StepClause will be used in the new
 ForStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ForStatementSyntax">
	<summary>
 The For statement that begins a For-Next block. This statement always occurs as
 the Begin of a ForBlock. Most of the time, the End of that ForBlock is the
 corresponding Next statement. However, multiple nested For statements are ended
 by a single Next statement with multiple variables, then the inner For
 statements will have End set to Nothing, and the Next statement is the End of
 the outermost For statement that is being ended.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ForStepClauseSyntax.StepKeyword">
	<summary>
 The "Step" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ForStepClauseSyntax.StepValue">
	<summary>
 The expression denoting the step increment.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ForStepClauseSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new ForStepClauseSyntaxSyntax node with the specified changes.
 </summary>
	<param name="stepKeyword">
 The new StepKeyword to update this ForStepClauseSyntaxSyntax node with. If not
 specified the current StepKeyword will be used in the new
 ForStepClauseSyntaxSyntax node.
 </param>
	<param name="stepValue">
 The new StepValue to update this ForStepClauseSyntaxSyntax node with. If not
 specified the current StepValue will be used in the new
 ForStepClauseSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ForStepClauseSyntax">
	<summary>
 The Step clause in a For Statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ForEachStatementSyntax.ForKeyword">
	<summary>
 The "For" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ForEachStatementSyntax.EachKeyword">
	<summary>
 The "Each" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ForEachStatementSyntax.ControlVariable">
	<summary>
 If the For or For Each statement is of a form that does not declare a new loop
 control variable, this is the expression that denotes the loop control
 variable. If this loop is of a form that does declare a new control variable,
 this is a VariableDeclarator that has the variable being declared.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ForEachStatementSyntax.InKeyword">
	<summary>
 The "In" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ForEachStatementSyntax.Expression">
	<summary>
 The expression denoting the collection to iterate over.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ForEachStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new ForEachStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="forKeyword">
 The new ForKeyword to update this ForEachStatementSyntaxSyntax node with. If
 not specified the current ForKeyword will be used in the new
 ForEachStatementSyntaxSyntax node.
 </param>
	<param name="eachKeyword">
 The new EachKeyword to update this ForEachStatementSyntaxSyntax node with. If
 not specified the current EachKeyword will be used in the new
 ForEachStatementSyntaxSyntax node.
 </param>
	<param name="controlVariable">
 The new ControlVariable to update this ForEachStatementSyntaxSyntax node with.
 If not specified the current ControlVariable will be used in the new
 ForEachStatementSyntaxSyntax node.
 </param>
	<param name="inKeyword">
 The new InKeyword to update this ForEachStatementSyntaxSyntax node with. If not
 specified the current InKeyword will be used in the new
 ForEachStatementSyntaxSyntax node.
 </param>
	<param name="expression">
 The new Expression to update this ForEachStatementSyntaxSyntax node with. If
 not specified the current Expression will be used in the new
 ForEachStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ForEachStatementSyntax">
	<summary>
 The For Each statement that begins a For Each-Next block. This statement always
 occurs as the Begin of a ForBlock, and the body of the For Each-Next is the
 Body of that ForBlock. Most of the time, the End of that ForBlock is the
 corresponding Next statement. However, multiple nested For statements are ended
 by a single Next statement with multiple variables, then the inner For
 statements will have End set to Nothing, and the Next statement is the End of
 the outermost For statement that is being ended.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NextStatementSyntax.NextKeyword">
	<summary>
 The "Next" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NextStatementSyntax.ControlVariables">
	<summary>
 The variables in the Next statement, if present
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.NextStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ExpressionSyntax})">
	<summary>
 Creates a new NextStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="nextKeyword">
 The new NextKeyword to update this NextStatementSyntaxSyntax node with. If not
 specified the current NextKeyword will be used in the new
 NextStatementSyntaxSyntax node.
 </param>
	<param name="controlVariables">
 The new ControlVariables to update this NextStatementSyntaxSyntax node with. If
 not specified the current ControlVariables will be used in the new
 NextStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.NextStatementSyntax">
	<summary>
 The Next statement that ends a For-Next or For Each-Next block. This statement
 always occurs as the End of a ForBlock (with Kind=ForBlock or ForEachBlock),
 and the body of the For-Next is the Body of that ForBlock. The Begin of that
 ForBlock has the corresponding For or For Each statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.UsingStatementSyntax.UsingKeyword">
	<summary>
 The "Using" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.UsingStatementSyntax.ExpressionOpt">
	<summary>
 If the Using statement is of a form that does not declare a new variable, this
 is the expression used in the using. Otherwise, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.UsingStatementSyntax.Variables">
	<summary>
 If the Using statement is of a form that declares one or more new variables,
 this is the list of variable declarations. Otherwise, Nothing is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.UsingStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.VariableDeclaratorSyntax})">
	<summary>
 Creates a new UsingStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="usingKeyword">
 The new UsingKeyword to update this UsingStatementSyntaxSyntax node with. If
 not specified the current UsingKeyword will be used in the new
 UsingStatementSyntaxSyntax node.
 </param>
	<param name="expressionOpt">
 The new Expression to update this UsingStatementSyntaxSyntax node with. If not
 specified the current Expression will be used in the new
 UsingStatementSyntaxSyntax node.
 </param>
	<param name="variables">
 The new Variables to update this UsingStatementSyntaxSyntax node with. If not
 specified the current Variables will be used in the new
 UsingStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.UsingStatementSyntax">
	<summary>
 The Using statement that begins a Using block. This statement always occurs as
 the Begin of a UsingBlock, and the body of the Using is the Body of that
 UsingBlock.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ThrowStatementSyntax.ThrowKeyword">
	<summary>
 The "Throw" keyword
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ThrowStatementSyntax.ExpressionOpt">
	<summary>
 The expression denoting the value being thrown.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ThrowStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new ThrowStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="throwKeyword">
 The new ThrowKeyword to update this ThrowStatementSyntaxSyntax node with. If
 not specified the current ThrowKeyword will be used in the new
 ThrowStatementSyntaxSyntax node.
 </param>
	<param name="expressionOpt">
 The new Expression to update this ThrowStatementSyntaxSyntax node with. If not
 specified the current Expression will be used in the new
 ThrowStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ThrowStatementSyntax">
	<summary>
 Represents a Throw statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AssignmentStatementSyntax.Left">
	<summary>
 The target (left hand side) of the assignment.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AssignmentStatementSyntax.OperatorToken">
	<summary>
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&amp;lt;&amp;lt;=" or "&amp;gt;&amp;gt;=".
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AssignmentStatementSyntax.Right">
	<summary>
 The source (right hand side) of the assignment.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AssignmentStatementSyntax.Update(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new AssignmentStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="left">
 The new Left to update this AssignmentStatementSyntaxSyntax node with. If not
 specified the current Left will be used in the new
 AssignmentStatementSyntaxSyntax node.
 </param>
	<param name="operatorToken">
 The new OperatorToken to update this AssignmentStatementSyntaxSyntax node with.
 If not specified the current OperatorToken will be used in the new
 AssignmentStatementSyntaxSyntax node.
 </param>
	<param name="right">
 The new Right to update this AssignmentStatementSyntaxSyntax node with. If not
 specified the current Right will be used in the new
 AssignmentStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.AssignmentStatementSyntax">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CallStatementSyntax.CallKeywordOpt">
	<summary>
 The "Call" keyword, if present.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.CallStatementSyntax.Invocation">
	<summary>
 The expression denoting the call. This could be an Invocation or a MemberAccess
 (in the case where no parentheses were supplied.)
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CallStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new CallStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="callKeywordOpt">
 The new CallKeyword to update this CallStatementSyntaxSyntax node with. If not
 specified the current CallKeyword will be used in the new
 CallStatementSyntaxSyntax node.
 </param>
	<param name="invocation">
 The new Invocation to update this CallStatementSyntaxSyntax node with. If not
 specified the current Invocation will be used in the new
 CallStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.CallStatementSyntax">
	<summary>
 Represent an call statement (also known as a invocation statement).
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AddRemoveHandlerStatementSyntax.AddHandlerOrRemoveHandlerKeyword">
	<summary>
 The "AddHandler" or "RemoveHandler" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AddRemoveHandlerStatementSyntax.EventExpression">
	<summary>
 The event being accessed.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AddRemoveHandlerStatementSyntax.CommaToken">
	<summary>
 The "," token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AddRemoveHandlerStatementSyntax.DelegateExpression">
	<summary>
 The delegate being added or removed.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AddRemoveHandlerStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new AddRemoveHandlerStatementSyntaxSyntax node with the specified
 changes.
 </summary>
	<param name="addHandlerOrRemoveHandlerKeyword">
 The new AddHandlerOrRemoveHandlerKeyword to update this
 AddRemoveHandlerStatementSyntaxSyntax node with. If not specified the current
 AddHandlerOrRemoveHandlerKeyword will be used in the new
 AddRemoveHandlerStatementSyntaxSyntax node.
 </param>
	<param name="eventExpression">
 The new EventExpression to update this AddRemoveHandlerStatementSyntaxSyntax
 node with. If not specified the current EventExpression will be used in the new
 AddRemoveHandlerStatementSyntaxSyntax node.
 </param>
	<param name="commaToken">
 The new CommaToken to update this AddRemoveHandlerStatementSyntaxSyntax node
 with. If not specified the current CommaToken will be used in the new
 AddRemoveHandlerStatementSyntaxSyntax node.
 </param>
	<param name="delegateExpression">
 The new DelegateExpression to update this AddRemoveHandlerStatementSyntaxSyntax
 node with. If not specified the current DelegateExpression will be used in the
 new AddRemoveHandlerStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.AddRemoveHandlerStatementSyntax">
	<summary>
 Represents an AddHandler or RemoveHandler statement. The Kind property
 determines which one.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.RaiseEventStatementSyntax.RaiseEventKeyword">
	<summary>
 The "RaiseEvent" keyword
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.RaiseEventStatementSyntax.Identifier">
	<summary>
 The name of the event being raised.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.RaiseEventStatementSyntax.ArgumentListOpt">
	<summary>
 The argument list, if present.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.RaiseEventStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ArgumentListSyntax)">
	<summary>
 Creates a new RaiseEventStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="raiseEventKeyword">
 The new RaiseEventKeyword to update this RaiseEventStatementSyntaxSyntax node
 with. If not specified the current RaiseEventKeyword will be used in the new
 RaiseEventStatementSyntaxSyntax node.
 </param>
	<param name="identifier">
 The new Identifier to update this RaiseEventStatementSyntaxSyntax node with. If
 not specified the current Identifier will be used in the new
 RaiseEventStatementSyntaxSyntax node.
 </param>
	<param name="argumentListOpt">
 The new ArgumentList to update this RaiseEventStatementSyntaxSyntax node with.
 If not specified the current ArgumentList will be used in the new
 RaiseEventStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.RaiseEventStatementSyntax">
	<summary>
 Represent a RaiseEvent statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.WithStatementSyntax.WithKeyword">
	<summary>
 The "With" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.WithStatementSyntax.Expression">
	<summary>
 The expression that is the operand of the With statement.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.WithStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new WithStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="withKeyword">
 The new WithKeyword to update this WithStatementSyntaxSyntax node with. If not
 specified the current WithKeyword will be used in the new
 WithStatementSyntaxSyntax node.
 </param>
	<param name="expression">
 The new Expression to update this WithStatementSyntaxSyntax node with. If not
 specified the current Expression will be used in the new
 WithStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.WithStatementSyntax">
	<summary>
 Represents a "With" statement. This statement always occurs as the
 BeginStatement of a WithBlock, and the body of the With is the Body of that
 WithBlock.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ReDimStatementSyntax.ReDimKeyword">
	<summary>
 The "ReDim" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ReDimStatementSyntax.PreserveKeywordOpt">
	<summary>
 Returns Nothing if Kind=ReDim, returns the "Preserve" keyword if
 Kind=RedimPreserve.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ReDimStatementSyntax.Clauses">
	<summary>
 The list of ReDim clauses. Each clause is a Invocation node with an argument
 list denoting the new bounds for the array.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ReDimStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InvocationExpressionSyntax})">
	<summary>
 Creates a new ReDimStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="reDimKeyword">
 The new ReDimKeyword to update this ReDimStatementSyntaxSyntax node with. If
 not specified the current ReDimKeyword will be used in the new
 ReDimStatementSyntaxSyntax node.
 </param>
	<param name="preserveKeywordOpt">
 The new PreserveKeyword to update this ReDimStatementSyntaxSyntax node with. If
 not specified the current PreserveKeyword will be used in the new
 ReDimStatementSyntaxSyntax node.
 </param>
	<param name="clauses">
 The new Clauses to update this ReDimStatementSyntaxSyntax node with. If not
 specified the current Clauses will be used in the new
 ReDimStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ReDimStatementSyntax">
	<summary>
 Represents a ReDim statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.EraseStatementSyntax.EraseKeyword">
	<summary>
 The "Erase" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.EraseStatementSyntax.Expressions">
	<summary>
 A list of expressions denoting the arrays to erase.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.EraseStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ExpressionSyntax})">
	<summary>
 Creates a new EraseStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="eraseKeyword">
 The new EraseKeyword to update this EraseStatementSyntaxSyntax node with. If
 not specified the current EraseKeyword will be used in the new
 EraseStatementSyntaxSyntax node.
 </param>
	<param name="expressions">
 The new Expressions to update this EraseStatementSyntaxSyntax node with. If not
 specified the current Expressions will be used in the new
 EraseStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.EraseStatementSyntax">
	<summary>
 Represents an "Erase" statement.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.ExpressionSyntax">
	<summary>
 An abstract base class for all node classes that define expressions.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.LiteralExpressionSyntax.Token">
	<summary>
 The token that represents the literal. The Kind property determines what type
 this property returns: Kind=IntegerLiteral ==&amp;gt; Returns
 IntegerLiteralToken. Kind=CharacterLiteral ==&amp;gt; Returns
 CharacterLiteralToken. Kind=DecimalLiteral ==&amp;gt; Returns
 DecimalLiteralToken Kind=FloatingLiteral ==&amp;gt; Returns
 FloatingLiteralToken Kind=DateLiteral ==&amp;gt; Returns DateLiteralToken
 Kind=StringLiteral ==&amp;gt; Returns StringLiteralToken Kind=BooleanLiteral
 ==&amp;gt; Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
 Kind=NothingLiteral ==&amp;gt; Returns Keyword (with it's kind being
 NothingKeyword)
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LiteralExpressionSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new LiteralExpressionSyntaxSyntax node with the specified changes.
 </summary>
	<param name="token">
 The new Token to update this LiteralExpressionSyntaxSyntax node with. If not
 specified the current Token will be used in the new
 LiteralExpressionSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.LiteralExpressionSyntax">
	<summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ParenthesizedExpressionSyntax.OpenParenToken">
	<summary>
 The "(" token
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ParenthesizedExpressionSyntax.Expression">
	<summary>
 The expression inside the parentheses.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ParenthesizedExpressionSyntax.CloseParenToken">
	<summary>
 The ")" token
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ParenthesizedExpressionSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new ParenthesizedExpressionSyntaxSyntax node with the specified
 changes.
 </summary>
	<param name="openParenToken">
 The new OpenParenToken to update this ParenthesizedExpressionSyntaxSyntax node
 with. If not specified the current OpenParenToken will be used in the new
 ParenthesizedExpressionSyntaxSyntax node.
 </param>
	<param name="expression">
 The new Expression to update this ParenthesizedExpressionSyntaxSyntax node
 with. If not specified the current Expression will be used in the new
 ParenthesizedExpressionSyntaxSyntax node.
 </param>
	<param name="closeParenToken">
 The new CloseParenToken to update this ParenthesizedExpressionSyntaxSyntax node
 with. If not specified the current CloseParenToken will be used in the new
 ParenthesizedExpressionSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ParenthesizedExpressionSyntax">
	<summary>
 Represents a parenthesized expression.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InstanceExpressionSyntax.Keyword">
	<summary>
 The "Me", "MyClass" or "MyBase" keyword.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InstanceExpressionSyntax">
	<summary>
 Identifies one of the special instances "Me", "MyClass" or "MyBase". The Kind
 property identifies which.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MeExpressionSyntax.Keyword">
	<summary>
 The "Me", "MyClass" or "MyBase" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MeExpressionSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new MeExpressionSyntaxSyntax node with the specified changes.
 </summary>
	<param name="keyword">
 The new Keyword to update this MeExpressionSyntaxSyntax node with. If not
 specified the current Keyword will be used in the new MeExpressionSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.MeExpressionSyntax">
	<summary>
 Identifies the special instance "Me"
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MyBaseExpressionSyntax.Keyword">
	<summary>
 The "Me", "MyClass" or "MyBase" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MyBaseExpressionSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new MyBaseExpressionSyntaxSyntax node with the specified changes.
 </summary>
	<param name="keyword">
 The new Keyword to update this MyBaseExpressionSyntaxSyntax node with. If not
 specified the current Keyword will be used in the new
 MyBaseExpressionSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.MyBaseExpressionSyntax">
	<summary>
 Identifies the special instance "MyBase"
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MyClassExpressionSyntax.Keyword">
	<summary>
 The "Me", "MyClass" or "MyBase" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MyClassExpressionSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new MyClassExpressionSyntaxSyntax node with the specified changes.
 </summary>
	<param name="keyword">
 The new Keyword to update this MyClassExpressionSyntaxSyntax node with. If not
 specified the current Keyword will be used in the new
 MyClassExpressionSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.MyClassExpressionSyntax">
	<summary>
 Identifies the special instance "MyClass"
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.GetTypeExpressionSyntax.GetTypeKeyword">
	<summary>
 The "GetType" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.GetTypeExpressionSyntax.OpenParenToken">
	<summary>
 The "(" token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.GetTypeExpressionSyntax.Type">
	<summary>
 The type to get the Type object for. This can be an open generic type.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.GetTypeExpressionSyntax.CloseParenToken">
	<summary>
 The ")" token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.GetTypeExpressionSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new GetTypeExpressionSyntaxSyntax node with the specified changes.
 </summary>
	<param name="getTypeKeyword">
 The new GetTypeKeyword to update this GetTypeExpressionSyntaxSyntax node with.
 If not specified the current GetTypeKeyword will be used in the new
 GetTypeExpressionSyntaxSyntax node.
 </param>
	<param name="openParenToken">
 The new OpenParenToken to update this GetTypeExpressionSyntaxSyntax node with.
 If not specified the current OpenParenToken will be used in the new
 GetTypeExpressionSyntaxSyntax node.
 </param>
	<param name="type">
 The new Type to update this GetTypeExpressionSyntaxSyntax node with. If not
 specified the current Type will be used in the new
 GetTypeExpressionSyntaxSyntax node.
 </param>
	<param name="closeParenToken">
 The new CloseParenToken to update this GetTypeExpressionSyntaxSyntax node with.
 If not specified the current CloseParenToken will be used in the new
 GetTypeExpressionSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.GetTypeExpressionSyntax">
	<summary>
 Represents a GetType expression.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeOfIsExpressionSyntax.TypeOfKeyword">
	<summary>
 The "TypeOf" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeOfIsExpressionSyntax.Expression">
	<summary>
 The expression being tested.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeOfIsExpressionSyntax.IsKeyword">
	<summary>
 The "Is" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeOfIsExpressionSyntax.Type">
	<summary>
 The name of the type being tested against.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeOfIsExpressionSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeSyntax)">
	<summary>
 Creates a new TypeOfIsExpressionSyntaxSyntax node with the specified changes.
 </summary>
	<param name="typeOfKeyword">
 The new TypeOfKeyword to update this TypeOfIsExpressionSyntaxSyntax node with.
 If not specified the current TypeOfKeyword will be used in the new
 TypeOfIsExpressionSyntaxSyntax node.
 </param>
	<param name="expression">
 The new Expression to update this TypeOfIsExpressionSyntaxSyntax node with. If
 not specified the current Expression will be used in the new
 TypeOfIsExpressionSyntaxSyntax node.
 </param>
	<param name="isKeyword">
 The new IsKeyword to update this TypeOfIsExpressionSyntaxSyntax node with. If
 not specified the current IsKeyword will be used in the new
 TypeOfIsExpressionSyntaxSyntax node.
 </param>
	<param name="type">
 The new Type to update this TypeOfIsExpressionSyntaxSyntax node with. If not
 specified the current Type will be used in the new
 TypeOfIsExpressionSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.TypeOfIsExpressionSyntax">
	<summary>
 Represents a TypeOf...Is expression.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.GetXmlNamespaceExpressionSyntax.GetXmlNamespaceKeyword">
	<summary>
 The "GetXmlNamespace" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.GetXmlNamespaceExpressionSyntax.OpenParenToken">
	<summary>
 The "(" token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.GetXmlNamespaceExpressionSyntax.NameOpt">
	<summary>
 The Xml namespace name being referenced.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.GetXmlNamespaceExpressionSyntax.CloseParenToken">
	<summary>
 The ")" token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.GetXmlNamespaceExpressionSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new GetXmlNamespaceExpressionSyntaxSyntax node with the specified
 changes.
 </summary>
	<param name="getXmlNamespaceKeyword">
 The new GetXmlNamespaceKeyword to update this
 GetXmlNamespaceExpressionSyntaxSyntax node with. If not specified the current
 GetXmlNamespaceKeyword will be used in the new
 GetXmlNamespaceExpressionSyntaxSyntax node.
 </param>
	<param name="openParenToken">
 The new OpenParenToken to update this GetXmlNamespaceExpressionSyntaxSyntax
 node with. If not specified the current OpenParenToken will be used in the new
 GetXmlNamespaceExpressionSyntaxSyntax node.
 </param>
	<param name="nameOpt">
 The new Name to update this GetXmlNamespaceExpressionSyntaxSyntax node with. If
 not specified the current Name will be used in the new
 GetXmlNamespaceExpressionSyntaxSyntax node.
 </param>
	<param name="closeParenToken">
 The new CloseParenToken to update this GetXmlNamespaceExpressionSyntaxSyntax
 node with. If not specified the current CloseParenToken will be used in the new
 GetXmlNamespaceExpressionSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.GetXmlNamespaceExpressionSyntax">
	<summary>
 Represents a GetXmlNamespace expression.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MemberAccessExpressionSyntax.LeftOpt">
	<summary>
 The expression on the left-hand-side of the "." or "!" token.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.MemberAccessExpressionSyntax.Token">
	<summary>
 The "." or "!" token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MemberAccessExpressionSyntax.Name">
	<summary>
 The identifier after the "." or "!" token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MemberAccessExpressionSyntax.Update(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SimpleNameSyntax)">
	<summary>
 Creates a new MemberAccessExpressionSyntaxSyntax node with the specified
 changes.
 </summary>
	<param name="leftOpt">
 The new Left to update this MemberAccessExpressionSyntaxSyntax node with. If
 not specified the current Left will be used in the new
 MemberAccessExpressionSyntaxSyntax node.
 </param>
	<param name="token">
 The new Token to update this MemberAccessExpressionSyntaxSyntax node with. If
 not specified the current Token will be used in the new
 MemberAccessExpressionSyntaxSyntax node.
 </param>
	<param name="name">
 The new Name to update this MemberAccessExpressionSyntaxSyntax node with. If
 not specified the current Name will be used in the new
 MemberAccessExpressionSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.MemberAccessExpressionSyntax">
	<summary>
 Represents member access (.name) or dictionary access (!name). The Kind
 property determines which kind of access.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.XmlMemberAccessExpressionSyntax.BaseOpt">
	<summary>
 The expression on the left-hand-side of the ".", ".@" or "..." .
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.XmlMemberAccessExpressionSyntax.Token1">
	<summary>
 The initial dot "." part of the separator.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.XmlMemberAccessExpressionSyntax.Token2Opt">
	<summary>
 The "@" part of .@ or the second "." of "...".
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.XmlMemberAccessExpressionSyntax.Token3Opt">
	<summary>
 The third "." in a "..." separator.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.XmlMemberAccessExpressionSyntax.Name">
	<summary>
 The identifier after the ".", ".@" or "..."
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlMemberAccessExpressionSyntax.Update(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.XmlNodeSyntax)">
	<summary>
 Creates a new XmlMemberAccessExpressionSyntaxSyntax node with the specified
 changes.
 </summary>
	<param name="baseOpt">
 The new Base to update this XmlMemberAccessExpressionSyntaxSyntax node with. If
 not specified the current Base will be used in the new
 XmlMemberAccessExpressionSyntaxSyntax node.
 </param>
	<param name="token1">
 The new Token1 to update this XmlMemberAccessExpressionSyntaxSyntax node with.
 If not specified the current Token1 will be used in the new
 XmlMemberAccessExpressionSyntaxSyntax node.
 </param>
	<param name="token2Opt">
 The new Token2 to update this XmlMemberAccessExpressionSyntaxSyntax node with.
 If not specified the current Token2 will be used in the new
 XmlMemberAccessExpressionSyntaxSyntax node.
 </param>
	<param name="token3Opt">
 The new Token3 to update this XmlMemberAccessExpressionSyntaxSyntax node with.
 If not specified the current Token3 will be used in the new
 XmlMemberAccessExpressionSyntaxSyntax node.
 </param>
	<param name="name">
 The new Name to update this XmlMemberAccessExpressionSyntaxSyntax node with. If
 not specified the current Name will be used in the new
 XmlMemberAccessExpressionSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.XmlMemberAccessExpressionSyntax">
	<summary>
 Represents an XML member element access (node.&amp;lt;Element&amp;gt;),
 attribute access (node.@Attribute) or descendents access
 (node...&amp;lt;Descendent&amp;gt;). The Kind property determines which kind of
 access.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InvocationExpressionSyntax.Expression">
	<summary>
 The target of the call or index expression.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InvocationExpressionSyntax.ArgumentListOpt">
	<summary>
 The argument list.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.InvocationExpressionSyntax.Update(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.ArgumentListSyntax)">
	<summary>
 Creates a new InvocationExpressionSyntaxSyntax node with the specified changes.
 </summary>
	<param name="expression">
 The new Expression to update this InvocationExpressionSyntaxSyntax node with.
 If not specified the current Expression will be used in the new
 InvocationExpressionSyntaxSyntax node.
 </param>
	<param name="argumentListOpt">
 The new ArgumentList to update this InvocationExpressionSyntaxSyntax node with.
 If not specified the current ArgumentList will be used in the new
 InvocationExpressionSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.InvocationExpressionSyntax">
	<summary>
 Represents an invocation expression consisting of an invocation target and an
 optional argument list or an array, parameterized property or object default
 property index.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NewExpressionSyntax.NewKeyword">
	<summary>
 The "New" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NewExpressionSyntax.Attributes">
	<summary>
 A list of all attribute blocks on the type. If no attributes were specified, an
 empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.NewExpressionSyntax">
	<summary>
 Base class for object, array and anonymous object creation expressions
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ObjectCreationExpressionSyntax.NewKeyword">
	<summary>
 The "New" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ObjectCreationExpressionSyntax.Attributes">
	<summary>
 A list of all attribute blocks on the type. If no attributes were specified, an
 empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ObjectCreationExpressionSyntax.Type">
	<summary>
 The type of the object being initialized.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ObjectCreationExpressionSyntax.ArgumentListOpt">
	<summary>
 The argument list, if present. If no argument list was supplied, Nothing is
 returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ObjectCreationExpressionSyntax.InitializerOpt">
	<summary>
 An optional From or With clause to initialize the new object.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ObjectCreationExpressionSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeBlockSyntax},Roslyn.Compilers.VisualBasic.TypeSyntax,Roslyn.Compilers.VisualBasic.ArgumentListSyntax,Roslyn.Compilers.VisualBasic.ObjectCreationInitializerSyntax)">
	<summary>
 Creates a new ObjectCreationExpressionSyntaxSyntax node with the specified
 changes.
 </summary>
	<param name="newKeyword">
 The new NewKeyword to update this ObjectCreationExpressionSyntaxSyntax node
 with. If not specified the current NewKeyword will be used in the new
 ObjectCreationExpressionSyntaxSyntax node.
 </param>
	<param name="attributes">
 The new Attributes to update this ObjectCreationExpressionSyntaxSyntax node
 with. If not specified the current Attributes will be used in the new
 ObjectCreationExpressionSyntaxSyntax node.
 </param>
	<param name="type">
 The new Type to update this ObjectCreationExpressionSyntaxSyntax node with. If
 not specified the current Type will be used in the new
 ObjectCreationExpressionSyntaxSyntax node.
 </param>
	<param name="argumentListOpt">
 The new ArgumentList to update this ObjectCreationExpressionSyntaxSyntax node
 with. If not specified the current ArgumentList will be used in the new
 ObjectCreationExpressionSyntaxSyntax node.
 </param>
	<param name="initializerOpt">
 The new Initializer to update this ObjectCreationExpressionSyntaxSyntax node
 with. If not specified the current Initializer will be used in the new
 ObjectCreationExpressionSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ObjectCreationExpressionSyntax">
	<summary>
 Represents a New expression that creates a new non-array object, possibly with
 a "With" or "From" clause.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AnonymousObjectCreationExpressionSyntax.NewKeyword">
	<summary>
 The "New" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AnonymousObjectCreationExpressionSyntax.Attributes">
	<summary>
 A list of all attribute blocks on the type. If no attributes were specified, an
 empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.AnonymousObjectCreationExpressionSyntax.Initializer">
	<summary>
 The With clause to initialize the new object.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AnonymousObjectCreationExpressionSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeBlockSyntax},Roslyn.Compilers.VisualBasic.ObjectMemberInitializerSyntax)">
	<summary>
 Creates a new AnonymousObjectCreationExpressionSyntaxSyntax node with the
 specified changes.
 </summary>
	<param name="newKeyword">
 The new NewKeyword to update this AnonymousObjectCreationExpressionSyntaxSyntax
 node with. If not specified the current NewKeyword will be used in the new
 AnonymousObjectCreationExpressionSyntaxSyntax node.
 </param>
	<param name="attributes">
 The new Attributes to update this AnonymousObjectCreationExpressionSyntaxSyntax
 node with. If not specified the current Attributes will be used in the new
 AnonymousObjectCreationExpressionSyntaxSyntax node.
 </param>
	<param name="initializer">
 The new Initializer to update this
 AnonymousObjectCreationExpressionSyntaxSyntax node with. If not specified the
 current Initializer will be used in the new
 AnonymousObjectCreationExpressionSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.AnonymousObjectCreationExpressionSyntax">
	<summary>
 Represents a New expression that create an object of anonymous type.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ArrayCreationExpressionSyntax.NewKeyword">
	<summary>
 The "New" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ArrayCreationExpressionSyntax.Attributes">
	<summary>
 A list of all attribute blocks on the type. If no attributes were specified, an
 empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ArrayCreationExpressionSyntax.Type">
	<summary>
 The element type of the array being created.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ArrayCreationExpressionSyntax.ArrayBoundsOpt">
	<summary>
 The optional array bounds, such as "(4)" or "(0 to 5, 0 To 6)".
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ArrayCreationExpressionSyntax.RankSpecifiers">
	<summary>
 A list of array modifiers such as "()" or "(,)". If no array modifiers were
 present, an empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ArrayCreationExpressionSyntax.Initializer">
	<summary>
 The initializer including the braces.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ArrayCreationExpressionSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeBlockSyntax},Roslyn.Compilers.VisualBasic.TypeSyntax,Roslyn.Compilers.VisualBasic.ArgumentListSyntax,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.ArrayRankSpecifierSyntax},Roslyn.Compilers.VisualBasic.CollectionInitializerSyntax)">
	<summary>
 Creates a new ArrayCreationExpressionSyntaxSyntax node with the specified
 changes.
 </summary>
	<param name="newKeyword">
 The new NewKeyword to update this ArrayCreationExpressionSyntaxSyntax node
 with. If not specified the current NewKeyword will be used in the new
 ArrayCreationExpressionSyntaxSyntax node.
 </param>
	<param name="attributes">
 The new Attributes to update this ArrayCreationExpressionSyntaxSyntax node
 with. If not specified the current Attributes will be used in the new
 ArrayCreationExpressionSyntaxSyntax node.
 </param>
	<param name="type">
 The new Type to update this ArrayCreationExpressionSyntaxSyntax node with. If
 not specified the current Type will be used in the new
 ArrayCreationExpressionSyntaxSyntax node.
 </param>
	<param name="arrayBoundsOpt">
 The new ArrayBounds to update this ArrayCreationExpressionSyntaxSyntax node
 with. If not specified the current ArrayBounds will be used in the new
 ArrayCreationExpressionSyntaxSyntax node.
 </param>
	<param name="rankSpecifiers">
 The new RankSpecifiers to update this ArrayCreationExpressionSyntaxSyntax node
 with. If not specified the current RankSpecifiers will be used in the new
 ArrayCreationExpressionSyntaxSyntax node.
 </param>
	<param name="initializer">
 The new Initializer to update this ArrayCreationExpressionSyntaxSyntax node
 with. If not specified the current Initializer will be used in the new
 ArrayCreationExpressionSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ArrayCreationExpressionSyntax">
	<summary>
 Represents an expression that creates a new array.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CollectionInitializerSyntax.OpenBraceToken">
	<summary>
 The "{" token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CollectionInitializerSyntax.Initializers">
	<summary>
 The list of initializers between the braces.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.CollectionInitializerSyntax.CloseBraceToken">
	<summary>
 The "}" token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CollectionInitializerSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ExpressionSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new CollectionInitializerSyntaxSyntax node with the specified
 changes.
 </summary>
	<param name="openBraceToken">
 The new OpenBraceToken to update this CollectionInitializerSyntaxSyntax node
 with. If not specified the current OpenBraceToken will be used in the new
 CollectionInitializerSyntaxSyntax node.
 </param>
	<param name="initializers">
 The new Initializers to update this CollectionInitializerSyntaxSyntax node
 with. If not specified the current Initializers will be used in the new
 CollectionInitializerSyntaxSyntax node.
 </param>
	<param name="closeBraceToken">
 The new CloseBraceToken to update this CollectionInitializerSyntaxSyntax node
 with. If not specified the current CloseBraceToken will be used in the new
 CollectionInitializerSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.CollectionInitializerSyntax">
	<summary>
 Represents an expression that creates a new array wihout naming the element
 type.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CastExpressionSyntax.Keyword">
	<summary>
 The "CType", "DirectCast" or "TryCast" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CastExpressionSyntax.OpenParenToken">
	<summary>
 The "(" token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CastExpressionSyntax.Expression">
	<summary>
 The expression being cast.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CastExpressionSyntax.CommaToken">
	<summary>
 The "," token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CastExpressionSyntax.Type">
	<summary>
 The type the expression is being cast to.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CastExpressionSyntax.CloseParenToken">
	<summary>
 The ")" token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CastExpressionSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new CastExpressionSyntaxSyntax node with the specified changes.
 </summary>
	<param name="keyword">
 The new Keyword to update this CastExpressionSyntaxSyntax node with. If not
 specified the current Keyword will be used in the new
 CastExpressionSyntaxSyntax node.
 </param>
	<param name="openParenToken">
 The new OpenParenToken to update this CastExpressionSyntaxSyntax node with. If
 not specified the current OpenParenToken will be used in the new
 CastExpressionSyntaxSyntax node.
 </param>
	<param name="expression">
 The new Expression to update this CastExpressionSyntaxSyntax node with. If not
 specified the current Expression will be used in the new
 CastExpressionSyntaxSyntax node.
 </param>
	<param name="commaToken">
 The new CommaToken to update this CastExpressionSyntaxSyntax node with. If not
 specified the current CommaToken will be used in the new
 CastExpressionSyntaxSyntax node.
 </param>
	<param name="type">
 The new Type to update this CastExpressionSyntaxSyntax node with. If not
 specified the current Type will be used in the new CastExpressionSyntaxSyntax
 node.
 </param>
	<param name="closeParenToken">
 The new CloseParenToken to update this CastExpressionSyntaxSyntax node with. If
 not specified the current CloseParenToken will be used in the new
 CastExpressionSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.CastExpressionSyntax">
	<summary>
 Represents a CType, DirectCast or TryCast conversion expression. The Kind
 property determines which kind of cast it is.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.PredefinedCastExpressionSyntax.Keyword">
	<summary>
 The keyword that was used in the cast operation.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.PredefinedCastExpressionSyntax.OpenParenToken">
	<summary>
 The "(" token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.PredefinedCastExpressionSyntax.Expression">
	<summary>
 The expression being cast.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.PredefinedCastExpressionSyntax.CloseParenToken">
	<summary>
 The ")" token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.PredefinedCastExpressionSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new PredefinedCastExpressionSyntaxSyntax node with the specified
 changes.
 </summary>
	<param name="keyword">
 The new Keyword to update this PredefinedCastExpressionSyntaxSyntax node with.
 If not specified the current Keyword will be used in the new
 PredefinedCastExpressionSyntaxSyntax node.
 </param>
	<param name="openParenToken">
 The new OpenParenToken to update this PredefinedCastExpressionSyntaxSyntax node
 with. If not specified the current OpenParenToken will be used in the new
 PredefinedCastExpressionSyntaxSyntax node.
 </param>
	<param name="expression">
 The new Expression to update this PredefinedCastExpressionSyntaxSyntax node
 with. If not specified the current Expression will be used in the new
 PredefinedCastExpressionSyntaxSyntax node.
 </param>
	<param name="closeParenToken">
 The new CloseParenToken to update this PredefinedCastExpressionSyntaxSyntax
 node with. If not specified the current CloseParenToken will be used in the new
 PredefinedCastExpressionSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.PredefinedCastExpressionSyntax">
	<summary>
 Represents a cast to a pre-defined type using a pre-defined cast expression,
 such as CInt or CLng.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.BinaryExpressionSyntax.Left">
	<summary>
 The left operand.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.BinaryExpressionSyntax.Right">
	<summary>
 The right operand.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.BinaryExpressionSyntax.Update(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new BinaryExpressionSyntaxSyntax node with the specified changes.
 </summary>
	<param name="left">
 The new Left to update this BinaryExpressionSyntaxSyntax node with. If not
 specified the current Left will be used in the new BinaryExpressionSyntaxSyntax
 node.
 </param>
	<param name="operatorToken">
 The new OperatorToken to update this BinaryExpressionSyntaxSyntax node with. If
 not specified the current OperatorToken will be used in the new
 BinaryExpressionSyntaxSyntax node.
 </param>
	<param name="right">
 The new Right to update this BinaryExpressionSyntaxSyntax node with. If not
 specified the current Right will be used in the new
 BinaryExpressionSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.BinaryExpressionSyntax">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.UnaryExpressionSyntax.OperatorToken">
	<summary>
 The token that is the operator.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.UnaryExpressionSyntax.Operand">
	<summary>
 The expression being operated on.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.UnaryExpressionSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new UnaryExpressionSyntaxSyntax node with the specified changes.
 </summary>
	<param name="operatorToken">
 The new OperatorToken to update this UnaryExpressionSyntaxSyntax node with. If
 not specified the current OperatorToken will be used in the new
 UnaryExpressionSyntaxSyntax node.
 </param>
	<param name="operand">
 The new Operand to update this UnaryExpressionSyntaxSyntax node with. If not
 specified the current Operand will be used in the new
 UnaryExpressionSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.UnaryExpressionSyntax">
	<summary>
 Describes a unary operator: Plus, Negate, Not or AddressOf.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.BinaryConditionalExpressionSyntax.IfKeyword">
	<summary>
 The "If" keyword
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.BinaryConditionalExpressionSyntax.OpenParenToken">
	<summary>
 The "(" token
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.BinaryConditionalExpressionSyntax.FirstExpression">
	<summary>
 The first expression inside the parentheses.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.BinaryConditionalExpressionSyntax.CommaToken">
	<summary>
 The "," token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.BinaryConditionalExpressionSyntax.SecondExpression">
	<summary>
 The second expression inside the parentheses.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.BinaryConditionalExpressionSyntax.CloseParenToken">
	<summary>
 The ")" token
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.BinaryConditionalExpressionSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new BinaryConditionalExpressionSyntaxSyntax node with the specified
 changes.
 </summary>
	<param name="ifKeyword">
 The new IfKeyword to update this BinaryConditionalExpressionSyntaxSyntax node
 with. If not specified the current IfKeyword will be used in the new
 BinaryConditionalExpressionSyntaxSyntax node.
 </param>
	<param name="openParenToken">
 The new OpenParenToken to update this BinaryConditionalExpressionSyntaxSyntax
 node with. If not specified the current OpenParenToken will be used in the new
 BinaryConditionalExpressionSyntaxSyntax node.
 </param>
	<param name="firstExpression">
 The new FirstExpression to update this BinaryConditionalExpressionSyntaxSyntax
 node with. If not specified the current FirstExpression will be used in the new
 BinaryConditionalExpressionSyntaxSyntax node.
 </param>
	<param name="commaToken">
 The new CommaToken to update this BinaryConditionalExpressionSyntaxSyntax node
 with. If not specified the current CommaToken will be used in the new
 BinaryConditionalExpressionSyntaxSyntax node.
 </param>
	<param name="secondExpression">
 The new SecondExpression to update this BinaryConditionalExpressionSyntaxSyntax
 node with. If not specified the current SecondExpression will be used in the
 new BinaryConditionalExpressionSyntaxSyntax node.
 </param>
	<param name="closeParenToken">
 The new CloseParenToken to update this BinaryConditionalExpressionSyntaxSyntax
 node with. If not specified the current CloseParenToken will be used in the new
 BinaryConditionalExpressionSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.BinaryConditionalExpressionSyntax">
	<summary>
 Represents a conditional expression, If(condition, true-expr, false-expr) or
 If(expr, nothing-expr).
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TernaryConditionalExpressionSyntax.IfKeyword">
	<summary>
 The "If" keyword
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TernaryConditionalExpressionSyntax.OpenParenToken">
	<summary>
 The "(" token
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TernaryConditionalExpressionSyntax.Condition">
	<summary>
 The first expression inside the parentheses.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TernaryConditionalExpressionSyntax.FirstCommaToken">
	<summary>
 The "," token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TernaryConditionalExpressionSyntax.WhenTrue">
	<summary>
 The second expression inside the parentheses.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TernaryConditionalExpressionSyntax.SecondCommaToken">
	<summary>
 The "," token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TernaryConditionalExpressionSyntax.WhenFalse">
	<summary>
 The second expression inside the parentheses.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TernaryConditionalExpressionSyntax.CloseParenToken">
	<summary>
 The ")" token
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TernaryConditionalExpressionSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new TernaryConditionalExpressionSyntaxSyntax node with the specified
 changes.
 </summary>
	<param name="ifKeyword">
 The new IfKeyword to update this TernaryConditionalExpressionSyntaxSyntax node
 with. If not specified the current IfKeyword will be used in the new
 TernaryConditionalExpressionSyntaxSyntax node.
 </param>
	<param name="openParenToken">
 The new OpenParenToken to update this TernaryConditionalExpressionSyntaxSyntax
 node with. If not specified the current OpenParenToken will be used in the new
 TernaryConditionalExpressionSyntaxSyntax node.
 </param>
	<param name="condition">
 The new Condition to update this TernaryConditionalExpressionSyntaxSyntax node
 with. If not specified the current Condition will be used in the new
 TernaryConditionalExpressionSyntaxSyntax node.
 </param>
	<param name="firstCommaToken">
 The new FirstCommaToken to update this TernaryConditionalExpressionSyntaxSyntax
 node with. If not specified the current FirstCommaToken will be used in the new
 TernaryConditionalExpressionSyntaxSyntax node.
 </param>
	<param name="whenTrue">
 The new WhenTrue to update this TernaryConditionalExpressionSyntaxSyntax node
 with. If not specified the current WhenTrue will be used in the new
 TernaryConditionalExpressionSyntaxSyntax node.
 </param>
	<param name="secondCommaToken">
 The new SecondCommaToken to update this
 TernaryConditionalExpressionSyntaxSyntax node with. If not specified the
 current SecondCommaToken will be used in the new
 TernaryConditionalExpressionSyntaxSyntax node.
 </param>
	<param name="whenFalse">
 The new WhenFalse to update this TernaryConditionalExpressionSyntaxSyntax node
 with. If not specified the current WhenFalse will be used in the new
 TernaryConditionalExpressionSyntaxSyntax node.
 </param>
	<param name="closeParenToken">
 The new CloseParenToken to update this TernaryConditionalExpressionSyntaxSyntax
 node with. If not specified the current CloseParenToken will be used in the new
 TernaryConditionalExpressionSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.TernaryConditionalExpressionSyntax">
	<summary>
 Represents a conditional expression, If(condition, true-expr, false-expr) or
 If(expr, nothing-expr).
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.LambdaExpressionSyntax.Begin">
	<summary>
 The header part of the lambda that includes the "Sub" or "Function" keyword,
 the argument list and return type.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.LambdaExpressionSyntax.BeginTerminatorOpt">
	<summary>
 The statement terminator token that ended the Begin statement. Optional only
 for single line lambdas.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.LambdaExpressionSyntax">
	<summary>
 Represents a lambda expression, either single line or multi-line.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SingleLineLambdaExpressionSyntax.Begin">
	<summary>
 The header part of the lambda that includes the "Sub" or "Function" keyword,
 the argument list and return type.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SingleLineLambdaExpressionSyntax.BeginTerminatorOpt">
	<summary>
 The statement terminator token that ended the Begin statement. Optional only
 for single line lambdas.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.SingleLineLambdaExpressionSyntax.Body">
	<summary>
 The body of the lambda. Depending on the kind of lambda, this is either a
 Statement (single-line Sub lambda) or Expression (single-line Function).
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SingleLineLambdaExpressionSyntax.Update(Roslyn.Compilers.VisualBasic.LambdaHeaderSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxNode)">
	<summary>
 Creates a new SingleLineLambdaExpressionSyntaxSyntax node with the specified
 changes.
 </summary>
	<param name="begin">
 The new Begin to update this SingleLineLambdaExpressionSyntaxSyntax node with.
 If not specified the current Begin will be used in the new
 SingleLineLambdaExpressionSyntaxSyntax node.
 </param>
	<param name="beginTerminatorOpt">
 The new BeginTerminator to update this SingleLineLambdaExpressionSyntaxSyntax
 node with. If not specified the current BeginTerminator will be used in the new
 SingleLineLambdaExpressionSyntaxSyntax node.
 </param>
	<param name="body">
 The new Body to update this SingleLineLambdaExpressionSyntaxSyntax node with.
 If not specified the current Body will be used in the new
 SingleLineLambdaExpressionSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.SingleLineLambdaExpressionSyntax">
	<summary>
 Represents a single line lambda expression.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MultiLineLambdaExpressionSyntax.Begin">
	<summary>
 The header part of the lambda that includes the "Sub" or "Function" keyword,
 the argument list and return type.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MultiLineLambdaExpressionSyntax.BeginTerminatorOpt">
	<summary>
 The statement terminator token that ended the Begin statement. Optional only
 for single line lambdas.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.MultiLineLambdaExpressionSyntax.Statements">
	<summary>
 The body of the lambda. Depending on the kind of lambda, this is either a
 StatementBody (multi-line lambda), Statement (single-line Sub lambda) or
 Expression (single-line Function). This might be an empty list.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.MultiLineLambdaExpressionSyntax.End">
	<summary>
 Returns the "End Sub" or "End Function" statement if this is a multi-line
 lambda.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MultiLineLambdaExpressionSyntax.Update(Roslyn.Compilers.VisualBasic.LambdaHeaderSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Creates a new MultiLineLambdaExpressionSyntaxSyntax node with the specified
 changes.
 </summary>
	<param name="begin">
 The new Begin to update this MultiLineLambdaExpressionSyntaxSyntax node with.
 If not specified the current Begin will be used in the new
 MultiLineLambdaExpressionSyntaxSyntax node.
 </param>
	<param name="beginTerminatorOpt">
 The new BeginTerminator to update this MultiLineLambdaExpressionSyntaxSyntax
 node with. If not specified the current BeginTerminator will be used in the new
 MultiLineLambdaExpressionSyntaxSyntax node.
 </param>
	<param name="statements">
 The new Statements to update this MultiLineLambdaExpressionSyntaxSyntax node
 with. If not specified the current Statements will be used in the new
 MultiLineLambdaExpressionSyntaxSyntax node.
 </param>
	<param name="end">
 The new End to update this MultiLineLambdaExpressionSyntaxSyntax node with. If
 not specified the current End will be used in the new
 MultiLineLambdaExpressionSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.MultiLineLambdaExpressionSyntax">
	<summary>
 Represents a multi-line lambda expression.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.LambdaHeaderSyntax.Attributes">
	<summary>
 A list of all attribute blocks on this declaration. If no attributes were
 specified, Nothing is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.LambdaHeaderSyntax.Modifiers">
	<summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.LambdaHeaderSyntax.Keyword">
	<summary>
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.LambdaHeaderSyntax.ParameterListOpt">
	<summary>
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.LambdaHeaderSyntax.AsClauseOpt">
	<summary>
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.LambdaHeaderSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeBlockSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 Creates a new LambdaHeaderSyntaxSyntax node with the specified changes.
 </summary>
	<param name="attributes">
 The new Attributes to update this LambdaHeaderSyntaxSyntax node with. If not
 specified the current Attributes will be used in the new
 LambdaHeaderSyntaxSyntax node.
 </param>
	<param name="modifiers">
 The new Modifiers to update this LambdaHeaderSyntaxSyntax node with. If not
 specified the current Modifiers will be used in the new
 LambdaHeaderSyntaxSyntax node.
 </param>
	<param name="keyword">
 The new Keyword to update this LambdaHeaderSyntaxSyntax node with. If not
 specified the current Keyword will be used in the new LambdaHeaderSyntaxSyntax
 node.
 </param>
	<param name="parameterListOpt">
 The new ParameterList to update this LambdaHeaderSyntaxSyntax node with. If not
 specified the current ParameterList will be used in the new
 LambdaHeaderSyntaxSyntax node.
 </param>
	<param name="asClauseOpt">
 The new AsClause to update this LambdaHeaderSyntaxSyntax node with. If not
 specified the current AsClause will be used in the new LambdaHeaderSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.LambdaHeaderSyntax">
	<summary>
 Represents the header part of a lambda expression
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ArgumentListSyntax.OpenParenToken">
	<summary>
 The "(" token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ArgumentListSyntax.Arguments">
	<summary>
 The list of arguments. This may be empty. Ommitted argument are represented by
 an OmittedArgumentSyntax node.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ArgumentListSyntax.CloseParenToken">
	<summary>
 The ")" token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ArgumentListSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ArgumentSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new ArgumentListSyntaxSyntax node with the specified changes.
 </summary>
	<param name="openParenToken">
 The new OpenParenToken to update this ArgumentListSyntaxSyntax node with. If
 not specified the current OpenParenToken will be used in the new
 ArgumentListSyntaxSyntax node.
 </param>
	<param name="arguments">
 The new Arguments to update this ArgumentListSyntaxSyntax node with. If not
 specified the current Arguments will be used in the new
 ArgumentListSyntaxSyntax node.
 </param>
	<param name="closeParenToken">
 The new CloseParenToken to update this ArgumentListSyntaxSyntax node with. If
 not specified the current CloseParenToken will be used in the new
 ArgumentListSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ArgumentListSyntax">
	<summary>
 Represents a parenthesized argument list.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.ArgumentSyntax">
	<summary>
 Base class for the possible kinds of arguments that can appear in an argument
 list.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.OmittedArgumentSyntax.Empty">
	<summary>
 An empty token because all non terminals must have a token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OmittedArgumentSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new OmittedArgumentSyntaxSyntax node with the specified changes.
 </summary>
	<param name="empty">
 The new Empty to update this OmittedArgumentSyntaxSyntax node with. If not
 specified the current Empty will be used in the new OmittedArgumentSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.OmittedArgumentSyntax">
	<summary>
 Represents an omitted argument in an argument list. An omitted argument is not
 considered a syntax error but a valid case when no argument is required.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SimpleArgumentSyntax.Expression">
	<summary>
 The expression that is the argument.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SimpleArgumentSyntax.Update(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new SimpleArgumentSyntaxSyntax node with the specified changes.
 </summary>
	<param name="expression">
 The new Expression to update this SimpleArgumentSyntaxSyntax node with. If not
 specified the current Expression will be used in the new
 SimpleArgumentSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.SimpleArgumentSyntax">
	<summary>
 Represents a simple argument that is just an expression.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedArgumentSyntax.Identifier">
	<summary>
 The name used to identify the named argument.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedArgumentSyntax.ColonEqualsToken">
	<summary>
 The ":=" token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedArgumentSyntax.Expression">
	<summary>
 The expression that is the named argument.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedArgumentSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new NamedArgumentSyntaxSyntax node with the specified changes.
 </summary>
	<param name="identifier">
 The new Identifier to update this NamedArgumentSyntaxSyntax node with. If not
 specified the current Identifier will be used in the new
 NamedArgumentSyntaxSyntax node.
 </param>
	<param name="colonEqualsToken">
 The new ColonEqualsToken to update this NamedArgumentSyntaxSyntax node with. If
 not specified the current ColonEqualsToken will be used in the new
 NamedArgumentSyntaxSyntax node.
 </param>
	<param name="expression">
 The new Expression to update this NamedArgumentSyntaxSyntax node with. If not
 specified the current Expression will be used in the new
 NamedArgumentSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.NamedArgumentSyntax">
	<summary>
 Represents a named argument, such as "Value:=7".
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.RangeArgumentSyntax.LowerBound">
	<summary>
 The lower bound of the range. This is typically the integer constant zero.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.RangeArgumentSyntax.ToKeyword">
	<summary>
 The "To" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.RangeArgumentSyntax.UpperBound">
	<summary>
 The upper bound of the range.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.RangeArgumentSyntax.Update(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new RangeArgumentSyntaxSyntax node with the specified changes.
 </summary>
	<param name="lowerBound">
 The new LowerBound to update this RangeArgumentSyntaxSyntax node with. If not
 specified the current LowerBound will be used in the new
 RangeArgumentSyntaxSyntax node.
 </param>
	<param name="toKeyword">
 The new ToKeyword to update this RangeArgumentSyntaxSyntax node with. If not
 specified the current ToKeyword will be used in the new
 RangeArgumentSyntaxSyntax node.
 </param>
	<param name="upperBound">
 The new UpperBound to update this RangeArgumentSyntaxSyntax node with. If not
 specified the current UpperBound will be used in the new
 RangeArgumentSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.RangeArgumentSyntax">
	<summary>
 Represents a range argument, such as "0 to 5", used in array bounds. The
 "Value" property represents the upper bound of the range.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.QueryExpressionSyntax.QueryOperators">
	<summary>
 A list of all the query operators in this query expression. This list always
 contains at least one operator.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.QueryExpressionSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.QueryOperatorSyntax})">
	<summary>
 Creates a new QueryExpressionSyntaxSyntax node with the specified changes.
 </summary>
	<param name="queryOperators">
 The new QueryOperators to update this QueryExpressionSyntaxSyntax node with. If
 not specified the current QueryOperators will be used in the new
 QueryExpressionSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.QueryExpressionSyntax">
	<summary>
 This class represents a query expression. A query expression is composed of one
 or more query operators in a row. The first query operator must be a From or
 Aggregate.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.QueryOperatorSyntax">
	<summary>
 This is a base class for all query operators.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CollectionRangeVariableSyntax.Identifier">
	<summary>
 The name of the range variable being defined.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CollectionRangeVariableSyntax.AsClauseOpt">
	<summary>
 Describes the type of the variable being defined.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.CollectionRangeVariableSyntax.InKeyword">
	<summary>
 The "In" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CollectionRangeVariableSyntax.Expression">
	<summary>
 The expression that serves as the source of items for the range variable.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CollectionRangeVariableSyntax.Update(Roslyn.Compilers.VisualBasic.ModifiedIdentifierSyntax,Roslyn.Compilers.VisualBasic.SimpleAsClauseSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new CollectionRangeVariableSyntaxSyntax node with the specified
 changes.
 </summary>
	<param name="identifier">
 The new Identifier to update this CollectionRangeVariableSyntaxSyntax node
 with. If not specified the current Identifier will be used in the new
 CollectionRangeVariableSyntaxSyntax node.
 </param>
	<param name="asClauseOpt">
 The new AsClause to update this CollectionRangeVariableSyntaxSyntax node with.
 If not specified the current AsClause will be used in the new
 CollectionRangeVariableSyntaxSyntax node.
 </param>
	<param name="inKeyword">
 The new InKeyword to update this CollectionRangeVariableSyntaxSyntax node with.
 If not specified the current InKeyword will be used in the new
 CollectionRangeVariableSyntaxSyntax node.
 </param>
	<param name="expression">
 The new Expression to update this CollectionRangeVariableSyntaxSyntax node
 with. If not specified the current Expression will be used in the new
 CollectionRangeVariableSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.CollectionRangeVariableSyntax">
	<summary>
 Describes a single variable of the form "x [As Type] In expression" for use in
 query expressions.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ExpressionRangeVariableSyntax.NameEqualsOpt">
	<summary>
 The optional name and type of the expression range variable. If ommitted, the
 name of the expression range variable is inferred from the expression.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ExpressionRangeVariableSyntax.Expression">
	<summary>
 The expression used to initialize the expression variable.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ExpressionRangeVariableSyntax.Update(Roslyn.Compilers.VisualBasic.VariableNameEqualsSyntax,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new ExpressionRangeVariableSyntaxSyntax node with the specified
 changes.
 </summary>
	<param name="nameEqualsOpt">
 The new NameEquals to update this ExpressionRangeVariableSyntaxSyntax node
 with. If not specified the current NameEquals will be used in the new
 ExpressionRangeVariableSyntaxSyntax node.
 </param>
	<param name="expression">
 The new Expression to update this ExpressionRangeVariableSyntaxSyntax node
 with. If not specified the current Expression will be used in the new
 ExpressionRangeVariableSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ExpressionRangeVariableSyntax">
	<summary>
 Describes a single variable of the form "[x [As Type] =] expression" for use in
 query expressions.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AggregationRangeVariableSyntax.NameEqualsOpt">
	<summary>
 The optional name and type of the expression range variable. If ommitted, the
 name of the expression range variable is inferred from the aggregation
 expression.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.AggregationRangeVariableSyntax.Aggregation">
	<summary>
 The name of the aggregation function. The "Group" aggregation function is
 represented by the identifier "Group".
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AggregationRangeVariableSyntax.Update(Roslyn.Compilers.VisualBasic.VariableNameEqualsSyntax,Roslyn.Compilers.VisualBasic.AggregationSyntax)">
	<summary>
 Creates a new AggregationRangeVariableSyntaxSyntax node with the specified
 changes.
 </summary>
	<param name="nameEqualsOpt">
 The new NameEquals to update this AggregationRangeVariableSyntaxSyntax node
 with. If not specified the current NameEquals will be used in the new
 AggregationRangeVariableSyntaxSyntax node.
 </param>
	<param name="aggregation">
 The new Aggregation to update this AggregationRangeVariableSyntaxSyntax node
 with. If not specified the current Aggregation will be used in the new
 AggregationRangeVariableSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.AggregationRangeVariableSyntax">
	<summary>
 Describes a single variable of the form "[x [As Type] =] aggregation-function"
 for use in the Into clause of Aggregate or Group By or Group Join query
 operators.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.VariableNameEqualsSyntax.Identifier">
	<summary>
 The name of the variable being defined.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.VariableNameEqualsSyntax.AsClauseOpt">
	<summary>
 Describes the type of the variable being defined.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.VariableNameEqualsSyntax.EqualsToken">
	<summary>
 The "=" token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.VariableNameEqualsSyntax.Update(Roslyn.Compilers.VisualBasic.ModifiedIdentifierSyntax,Roslyn.Compilers.VisualBasic.SimpleAsClauseSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new VariableNameEqualsSyntaxSyntax node with the specified changes.
 </summary>
	<param name="identifier">
 The new Identifier to update this VariableNameEqualsSyntaxSyntax node with. If
 not specified the current Identifier will be used in the new
 VariableNameEqualsSyntaxSyntax node.
 </param>
	<param name="asClauseOpt">
 The new AsClause to update this VariableNameEqualsSyntaxSyntax node with. If
 not specified the current AsClause will be used in the new
 VariableNameEqualsSyntaxSyntax node.
 </param>
	<param name="equalsToken">
 The new EqualsToken to update this VariableNameEqualsSyntaxSyntax node with. If
 not specified the current EqualsToken will be used in the new
 VariableNameEqualsSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.VariableNameEqualsSyntax">
	<summary>
 Represents the name and optional type of an expression range variable.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.AggregationSyntax">
	<summary>
 Represents aggregation in aggregation range variable declaration of a Group By,
 Group Join or Aggregate query operator.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.FunctionAggregationSyntax.FunctionName">
	<summary>
 The name of the aggregation function.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.FunctionAggregationSyntax.OpenParenTokenOpt">
	<summary>
 The "(" token if present.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.FunctionAggregationSyntax.ArgumentOpt">
	<summary>
 The argument to the aggregation function.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.FunctionAggregationSyntax.CloseParenTokenOpt">
	<summary>
 The ")" token, if present.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.FunctionAggregationSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new FunctionAggregationSyntaxSyntax node with the specified changes.
 </summary>
	<param name="functionName">
 The new FunctionName to update this FunctionAggregationSyntaxSyntax node with.
 If not specified the current FunctionName will be used in the new
 FunctionAggregationSyntaxSyntax node.
 </param>
	<param name="openParenTokenOpt">
 The new OpenParenToken to update this FunctionAggregationSyntaxSyntax node
 with. If not specified the current OpenParenToken will be used in the new
 FunctionAggregationSyntaxSyntax node.
 </param>
	<param name="argumentOpt">
 The new Argument to update this FunctionAggregationSyntaxSyntax node with. If
 not specified the current Argument will be used in the new
 FunctionAggregationSyntaxSyntax node.
 </param>
	<param name="closeParenTokenOpt">
 The new CloseParenToken to update this FunctionAggregationSyntaxSyntax node
 with. If not specified the current CloseParenToken will be used in the new
 FunctionAggregationSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.FunctionAggregationSyntax">
	<summary>
 Represents an invocation of an Aggregation function in the aggregation range
 variable declaration of a Group By, Group Join or Aggregate query operator.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.GroupAggregationSyntax.GroupKeyword">
	<summary>
 The "Group" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.GroupAggregationSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new GroupAggregationSyntaxSyntax node with the specified changes.
 </summary>
	<param name="groupKeyword">
 The new GroupKeyword to update this GroupAggregationSyntaxSyntax node with. If
 not specified the current GroupKeyword will be used in the new
 GroupAggregationSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.GroupAggregationSyntax">
	<summary>
 Represents the use of "Group" as the aggregation function in the in the
 aggregation range variable declaration of a Group By or Group Join query
 operator.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.FromQueryOperatorSyntax.FromKeyword">
	<summary>
 The "From" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.FromQueryOperatorSyntax.Variables">
	<summary>
 The list of collection variables declared by this From operator.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.FromQueryOperatorSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.CollectionRangeVariableSyntax})">
	<summary>
 Creates a new FromQueryOperatorSyntaxSyntax node with the specified changes.
 </summary>
	<param name="fromKeyword">
 The new FromKeyword to update this FromQueryOperatorSyntaxSyntax node with. If
 not specified the current FromKeyword will be used in the new
 FromQueryOperatorSyntaxSyntax node.
 </param>
	<param name="variables">
 The new Variables to update this FromQueryOperatorSyntaxSyntax node with. If
 not specified the current Variables will be used in the new
 FromQueryOperatorSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.FromQueryOperatorSyntax">
	<summary>
 Represents a "From" query operator. If this is the beginning of a query, the
 Source will be Nothing. Otherwise, the Source will be the part of the query to
 the left of the From.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.LetQueryOperatorSyntax.LetKeyword">
	<summary>
 The "Let" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.LetQueryOperatorSyntax.Variables">
	<summary>
 The list of expression range variable being defined by the Let operator.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LetQueryOperatorSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ExpressionRangeVariableSyntax})">
	<summary>
 Creates a new LetQueryOperatorSyntaxSyntax node with the specified changes.
 </summary>
	<param name="letKeyword">
 The new LetKeyword to update this LetQueryOperatorSyntaxSyntax node with. If
 not specified the current LetKeyword will be used in the new
 LetQueryOperatorSyntaxSyntax node.
 </param>
	<param name="variables">
 The new Variables to update this LetQueryOperatorSyntaxSyntax node with. If not
 specified the current Variables will be used in the new
 LetQueryOperatorSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.LetQueryOperatorSyntax">
	<summary>
 Represents a "Let" query operator.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AggregateQueryOperatorSyntax.AggregateKeyword">
	<summary>
 The "Aggregate" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AggregateQueryOperatorSyntax.Variables">
	<summary>
 The list of collection range variables declared by this Aggregate operator.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AggregateQueryOperatorSyntax.AdditionalQueryOperators">
	<summary>
 A list of additional query operators. It may be empty.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.AggregateQueryOperatorSyntax.IntoKeyword">
	<summary>
 The "Into" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AggregateQueryOperatorSyntax.AggregationVariables">
	<summary>
 The list of new variables being defined by the aggregation.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AggregateQueryOperatorSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.CollectionRangeVariableSyntax},Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.QueryOperatorSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.AggregationRangeVariableSyntax})">
	<summary>
 Creates a new AggregateQueryOperatorSyntaxSyntax node with the specified
 changes.
 </summary>
	<param name="aggregateKeyword">
 The new AggregateKeyword to update this AggregateQueryOperatorSyntaxSyntax node
 with. If not specified the current AggregateKeyword will be used in the new
 AggregateQueryOperatorSyntaxSyntax node.
 </param>
	<param name="variables">
 The new Variables to update this AggregateQueryOperatorSyntaxSyntax node with.
 If not specified the current Variables will be used in the new
 AggregateQueryOperatorSyntaxSyntax node.
 </param>
	<param name="additionalQueryOperators">
 The new AdditionalQueryOperators to update this
 AggregateQueryOperatorSyntaxSyntax node with. If not specified the current
 AdditionalQueryOperators will be used in the new
 AggregateQueryOperatorSyntaxSyntax node.
 </param>
	<param name="intoKeyword">
 The new IntoKeyword to update this AggregateQueryOperatorSyntaxSyntax node
 with. If not specified the current IntoKeyword will be used in the new
 AggregateQueryOperatorSyntaxSyntax node.
 </param>
	<param name="aggregationVariables">
 The new AggregationVariables to update this AggregateQueryOperatorSyntaxSyntax
 node with. If not specified the current AggregationVariables will be used in
 the new AggregateQueryOperatorSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.AggregateQueryOperatorSyntax">
	<summary>
 Represents an Aggregate query operator.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.DistinctQueryOperatorSyntax.DistinctKeyword">
	<summary>
 The "Distinct" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.DistinctQueryOperatorSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new DistinctQueryOperatorSyntaxSyntax node with the specified
 changes.
 </summary>
	<param name="distinctKeyword">
 The new DistinctKeyword to update this DistinctQueryOperatorSyntaxSyntax node
 with. If not specified the current DistinctKeyword will be used in the new
 DistinctQueryOperatorSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.DistinctQueryOperatorSyntax">
	<summary>
 Represents the "Distinct" query operator.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.WhereQueryOperatorSyntax.WhereKeyword">
	<summary>
 The "Where" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.WhereQueryOperatorSyntax.Condition">
	<summary>
 The boolean expression used for filtering.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.WhereQueryOperatorSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new WhereQueryOperatorSyntaxSyntax node with the specified changes.
 </summary>
	<param name="whereKeyword">
 The new WhereKeyword to update this WhereQueryOperatorSyntaxSyntax node with.
 If not specified the current WhereKeyword will be used in the new
 WhereQueryOperatorSyntaxSyntax node.
 </param>
	<param name="condition">
 The new Condition to update this WhereQueryOperatorSyntaxSyntax node with. If
 not specified the current Condition will be used in the new
 WhereQueryOperatorSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.WhereQueryOperatorSyntax">
	<summary>
 Represents a "Where" query operator.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.PartitionWhileQueryOperatorSyntax.SkipOrTakeKeyword">
	<summary>
 The "Skip" or "Take" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.PartitionWhileQueryOperatorSyntax.WhileKeyword">
	<summary>
 The "While" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.PartitionWhileQueryOperatorSyntax.Condition">
	<summary>
 The boolean expression used for partitioning.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.PartitionWhileQueryOperatorSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new PartitionWhileQueryOperatorSyntaxSyntax node with the specified
 changes.
 </summary>
	<param name="skipOrTakeKeyword">
 The new SkipOrTakeKeyword to update this
 PartitionWhileQueryOperatorSyntaxSyntax node with. If not specified the current
 SkipOrTakeKeyword will be used in the new
 PartitionWhileQueryOperatorSyntaxSyntax node.
 </param>
	<param name="whileKeyword">
 The new WhileKeyword to update this PartitionWhileQueryOperatorSyntaxSyntax
 node with. If not specified the current WhileKeyword will be used in the new
 PartitionWhileQueryOperatorSyntaxSyntax node.
 </param>
	<param name="condition">
 The new Condition to update this PartitionWhileQueryOperatorSyntaxSyntax node
 with. If not specified the current Condition will be used in the new
 PartitionWhileQueryOperatorSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.PartitionWhileQueryOperatorSyntax">
	<summary>
 Represents a "Skip While" or "Take While" query operator. The Kind property
 tells which.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.PartitionQueryOperatorSyntax.SkipOrTakeKeyword">
	<summary>
 The "Skip" or "Take" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.PartitionQueryOperatorSyntax.Count">
	<summary>
 Represents the expression with the number of items to take or skip.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.PartitionQueryOperatorSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new PartitionQueryOperatorSyntaxSyntax node with the specified
 changes.
 </summary>
	<param name="skipOrTakeKeyword">
 The new SkipOrTakeKeyword to update this PartitionQueryOperatorSyntaxSyntax
 node with. If not specified the current SkipOrTakeKeyword will be used in the
 new PartitionQueryOperatorSyntaxSyntax node.
 </param>
	<param name="count">
 The new Count to update this PartitionQueryOperatorSyntaxSyntax node with. If
 not specified the current Count will be used in the new
 PartitionQueryOperatorSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.PartitionQueryOperatorSyntax">
	<summary>
 Represents a "Skip" or "Take" query operator. The Kind property tells which.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.GroupByQueryOperatorSyntax.GroupKeyword">
	<summary>
 The "Group" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.GroupByQueryOperatorSyntax.Items">
	<summary>
 The optional list of variables being grouped; the contents of the Group clause.
 If none were specified, an empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.GroupByQueryOperatorSyntax.ByKeyword">
	<summary>
 The "By" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.GroupByQueryOperatorSyntax.Keys">
	<summary>
 The key values being used for grouping.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.GroupByQueryOperatorSyntax.AggregationVariables">
	<summary>
 The list of new variables that calculate aggregations.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.GroupByQueryOperatorSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ExpressionRangeVariableSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ExpressionRangeVariableSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.AggregationRangeVariableSyntax})">
	<summary>
 Creates a new GroupByQueryOperatorSyntaxSyntax node with the specified changes.
 </summary>
	<param name="groupKeyword">
 The new GroupKeyword to update this GroupByQueryOperatorSyntaxSyntax node with.
 If not specified the current GroupKeyword will be used in the new
 GroupByQueryOperatorSyntaxSyntax node.
 </param>
	<param name="items">
 The new Items to update this GroupByQueryOperatorSyntaxSyntax node with. If not
 specified the current Items will be used in the new
 GroupByQueryOperatorSyntaxSyntax node.
 </param>
	<param name="byKeyword">
 The new ByKeyword to update this GroupByQueryOperatorSyntaxSyntax node with. If
 not specified the current ByKeyword will be used in the new
 GroupByQueryOperatorSyntaxSyntax node.
 </param>
	<param name="keys">
 The new Keys to update this GroupByQueryOperatorSyntaxSyntax node with. If not
 specified the current Keys will be used in the new
 GroupByQueryOperatorSyntaxSyntax node.
 </param>
	<param name="intoKeyword">
 The new IntoKeyword to update this GroupByQueryOperatorSyntaxSyntax node with.
 If not specified the current IntoKeyword will be used in the new
 GroupByQueryOperatorSyntaxSyntax node.
 </param>
	<param name="aggregationVariables">
 The new AggregationVariables to update this GroupByQueryOperatorSyntaxSyntax
 node with. If not specified the current AggregationVariables will be used in
 the new GroupByQueryOperatorSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.GroupByQueryOperatorSyntax">
	<summary>
 Represents the "Group By" query operator.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.JoinQueryOperatorSyntax.JoinKeyword">
	<summary>
 The "Join" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.JoinQueryOperatorSyntax.JoinedVariables">
	<summary>
 Defines the collection range variables being joined to.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.JoinQueryOperatorSyntax.AdditionalJoins">
	<summary>
 An additional Join or Group Join query operator.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.JoinQueryOperatorSyntax.OnKeyword">
	<summary>
 The "On" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.JoinQueryOperatorSyntax.JoinConditions">
	<summary>
 The conditions indicating what expressions to compare during the join. Each
 condition is a JoinCondition, and the separators are "And" keywords.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.JoinQueryOperatorSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.CollectionRangeVariableSyntax},Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.JoinQueryOperatorSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.JoinConditionSyntax})">
	<summary>
 Creates a new JoinQueryOperatorSyntaxSyntax node with the specified changes.
 </summary>
	<param name="joinKeyword">
 The new JoinKeyword to update this JoinQueryOperatorSyntaxSyntax node with. If
 not specified the current JoinKeyword will be used in the new
 JoinQueryOperatorSyntaxSyntax node.
 </param>
	<param name="joinedVariables">
 The new JoinedVariables to update this JoinQueryOperatorSyntaxSyntax node with.
 If not specified the current JoinedVariables will be used in the new
 JoinQueryOperatorSyntaxSyntax node.
 </param>
	<param name="additionalJoins">
 The new AdditionalJoins to update this JoinQueryOperatorSyntaxSyntax node with.
 If not specified the current AdditionalJoins will be used in the new
 JoinQueryOperatorSyntaxSyntax node.
 </param>
	<param name="onKeyword">
 The new OnKeyword to update this JoinQueryOperatorSyntaxSyntax node with. If
 not specified the current OnKeyword will be used in the new
 JoinQueryOperatorSyntaxSyntax node.
 </param>
	<param name="joinConditions">
 The new JoinConditions to update this JoinQueryOperatorSyntaxSyntax node with.
 If not specified the current JoinConditions will be used in the new
 JoinQueryOperatorSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.JoinQueryOperatorSyntax">
	<summary>
 Represents a Join query operator.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.JoinConditionSyntax.Left">
	<summary>
 The left expression in the Join condition.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.JoinConditionSyntax.EqualsKeyword">
	<summary>
 The "Equals" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.JoinConditionSyntax.Right">
	<summary>
 The right expression in the Join condition.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.JoinConditionSyntax.Update(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new JoinConditionSyntaxSyntax node with the specified changes.
 </summary>
	<param name="left">
 The new Left to update this JoinConditionSyntaxSyntax node with. If not
 specified the current Left will be used in the new JoinConditionSyntaxSyntax
 node.
 </param>
	<param name="equalsKeyword">
 The new EqualsKeyword to update this JoinConditionSyntaxSyntax node with. If
 not specified the current EqualsKeyword will be used in the new
 JoinConditionSyntaxSyntax node.
 </param>
	<param name="right">
 The new Right to update this JoinConditionSyntaxSyntax node with. If not
 specified the current Right will be used in the new JoinConditionSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.JoinConditionSyntax">
	<summary>
 Represents the "expression Equals expression" condition in a Join.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.GroupJoinQueryOperatorSyntax.GroupKeyword">
	<summary>
 The "Group" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.GroupJoinQueryOperatorSyntax.JoinKeyword">
	<summary>
 The "Join" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.GroupJoinQueryOperatorSyntax.JoinedVariables">
	<summary>
 Defines the collection range variables being joined to.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.GroupJoinQueryOperatorSyntax.AdditionalJoins">
	<summary>
 An additional Join or Group Join query operator.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.GroupJoinQueryOperatorSyntax.OnKeyword">
	<summary>
 The "On" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.GroupJoinQueryOperatorSyntax.JoinConditions">
	<summary>
 The conditions indicating what expressions to compare during the join. Each
 condition is a JoinCondition, and the separators are "And" keywords.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.GroupJoinQueryOperatorSyntax.IntoKeyword">
	<summary>
 The "Into" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.GroupJoinQueryOperatorSyntax.AggregationVariables">
	<summary>
 The list of new variables that calculate aggregations.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.GroupJoinQueryOperatorSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.CollectionRangeVariableSyntax},Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.JoinQueryOperatorSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.JoinConditionSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.AggregationRangeVariableSyntax})">
	<summary>
 Creates a new GroupJoinQueryOperatorSyntaxSyntax node with the specified
 changes.
 </summary>
	<param name="groupKeyword">
 The new GroupKeyword to update this GroupJoinQueryOperatorSyntaxSyntax node
 with. If not specified the current GroupKeyword will be used in the new
 GroupJoinQueryOperatorSyntaxSyntax node.
 </param>
	<param name="joinKeyword">
 The new JoinKeyword to update this GroupJoinQueryOperatorSyntaxSyntax node
 with. If not specified the current JoinKeyword will be used in the new
 GroupJoinQueryOperatorSyntaxSyntax node.
 </param>
	<param name="joinedVariables">
 The new JoinedVariables to update this GroupJoinQueryOperatorSyntaxSyntax node
 with. If not specified the current JoinedVariables will be used in the new
 GroupJoinQueryOperatorSyntaxSyntax node.
 </param>
	<param name="additionalJoins">
 The new AdditionalJoins to update this GroupJoinQueryOperatorSyntaxSyntax node
 with. If not specified the current AdditionalJoins will be used in the new
 GroupJoinQueryOperatorSyntaxSyntax node.
 </param>
	<param name="onKeyword">
 The new OnKeyword to update this GroupJoinQueryOperatorSyntaxSyntax node with.
 If not specified the current OnKeyword will be used in the new
 GroupJoinQueryOperatorSyntaxSyntax node.
 </param>
	<param name="joinConditions">
 The new JoinConditions to update this GroupJoinQueryOperatorSyntaxSyntax node
 with. If not specified the current JoinConditions will be used in the new
 GroupJoinQueryOperatorSyntaxSyntax node.
 </param>
	<param name="intoKeyword">
 The new IntoKeyword to update this GroupJoinQueryOperatorSyntaxSyntax node
 with. If not specified the current IntoKeyword will be used in the new
 GroupJoinQueryOperatorSyntaxSyntax node.
 </param>
	<param name="aggregationVariables">
 The new AggregationVariables to update this GroupJoinQueryOperatorSyntaxSyntax
 node with. If not specified the current AggregationVariables will be used in
 the new GroupJoinQueryOperatorSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.GroupJoinQueryOperatorSyntax">
	<summary>
 Represents the "Group Join" query operator.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.OrderByQueryOperatorSyntax.OrderKeyword">
	<summary>
 The "Order" keyword
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.OrderByQueryOperatorSyntax.ByKeyword">
	<summary>
 The "By" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.OrderByQueryOperatorSyntax.Orderings">
	<summary>
 The list of OrderExpression's to sort by.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OrderByQueryOperatorSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.OrderingSyntax})">
	<summary>
 Creates a new OrderByQueryOperatorSyntaxSyntax node with the specified changes.
 </summary>
	<param name="orderKeyword">
 The new OrderKeyword to update this OrderByQueryOperatorSyntaxSyntax node with.
 If not specified the current OrderKeyword will be used in the new
 OrderByQueryOperatorSyntaxSyntax node.
 </param>
	<param name="byKeyword">
 The new ByKeyword to update this OrderByQueryOperatorSyntaxSyntax node with. If
 not specified the current ByKeyword will be used in the new
 OrderByQueryOperatorSyntaxSyntax node.
 </param>
	<param name="orderings">
 The new Orderings to update this OrderByQueryOperatorSyntaxSyntax node with. If
 not specified the current Orderings will be used in the new
 OrderByQueryOperatorSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.OrderByQueryOperatorSyntax">
	<summary>
 Represents the "Order By" query operator.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.OrderingSyntax.Expression">
	<summary>
 The expression to sort by.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.OrderingSyntax.AscendingOrDescendingKeywordOpt">
	<summary>
 The "Ascending" or "Descending" keyword, if present. To determine whether to
 sort in ascending or descending order, checking the Kind property is easier.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.OrderingSyntax.Update(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new OrderingSyntaxSyntax node with the specified changes.
 </summary>
	<param name="expression">
 The new Expression to update this OrderingSyntaxSyntax node with. If not
 specified the current Expression will be used in the new OrderingSyntaxSyntax
 node.
 </param>
	<param name="ascendingOrDescendingKeywordOpt">
 The new AscendingOrDescendingKeyword to update this OrderingSyntaxSyntax node
 with. If not specified the current AscendingOrDescendingKeyword will be used in
 the new OrderingSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.OrderingSyntax">
	<summary>
 An expression to order by, plus an optional ordering. The Kind indicates
 whether to order in ascending or descending order.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SelectQueryOperatorSyntax.SelectKeyword">
	<summary>
 The "Select" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SelectQueryOperatorSyntax.Variables">
	<summary>
 The list of expression range variables being defined by the Select query
 operator.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SelectQueryOperatorSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ExpressionRangeVariableSyntax})">
	<summary>
 Creates a new SelectQueryOperatorSyntaxSyntax node with the specified changes.
 </summary>
	<param name="selectKeyword">
 The new SelectKeyword to update this SelectQueryOperatorSyntaxSyntax node with.
 If not specified the current SelectKeyword will be used in the new
 SelectQueryOperatorSyntaxSyntax node.
 </param>
	<param name="variables">
 The new Variables to update this SelectQueryOperatorSyntaxSyntax node with. If
 not specified the current Variables will be used in the new
 SelectQueryOperatorSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.SelectQueryOperatorSyntax">
	<summary>
 Represents the "Select" query operator.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.XmlNodeSyntax">
	<summary>
 This is the base class for all XML expression syntax nodes (XmlDocument and
 XmlElement).
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.XmlDocumentSyntax.PrecedingMisc">
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.XmlDocumentSyntax.FollowingMisc">
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlDocumentSyntax.Update(Roslyn.Compilers.VisualBasic.XmlDeclarationSyntax,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.XmlNodeSyntax},Roslyn.Compilers.VisualBasic.XmlNodeSyntax,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.XmlNodeSyntax})">
	<summary>
 Creates a new XmlDocumentSyntaxSyntax node with the specified changes.
 </summary>
	<param name="declaration">
 The new Declaration to update this XmlDocumentSyntaxSyntax node with. If not
 specified the current Declaration will be used in the new
 XmlDocumentSyntaxSyntax node.
 </param>
	<param name="precedingMisc">
 The new PrecedingMisc to update this XmlDocumentSyntaxSyntax node with. If not
 specified the current PrecedingMisc will be used in the new
 XmlDocumentSyntaxSyntax node.
 </param>
	<param name="root">
 The new Root to update this XmlDocumentSyntaxSyntax node with. If not specified
 the current Root will be used in the new XmlDocumentSyntaxSyntax node.
 </param>
	<param name="followingMisc">
 The new FollowingMisc to update this XmlDocumentSyntaxSyntax node with. If not
 specified the current FollowingMisc will be used in the new
 XmlDocumentSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.XmlDocumentSyntax">
	<summary>
 Represents and XML Document literal expression.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.XmlDeclarationSyntax.EncodingOpt">
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.XmlDeclarationSyntax.StandaloneOpt">
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlDeclarationSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.XmlDeclarationOptionSyntax,Roslyn.Compilers.VisualBasic.XmlDeclarationOptionSyntax,Roslyn.Compilers.VisualBasic.XmlDeclarationOptionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new XmlDeclarationSyntaxSyntax node with the specified changes.
 </summary>
	<param name="lessThanQuestionToken">
 The new LessThanQuestionToken to update this XmlDeclarationSyntaxSyntax node
 with. If not specified the current LessThanQuestionToken will be used in the
 new XmlDeclarationSyntaxSyntax node.
 </param>
	<param name="xmlKeyword">
 The new XmlKeyword to update this XmlDeclarationSyntaxSyntax node with. If not
 specified the current XmlKeyword will be used in the new
 XmlDeclarationSyntaxSyntax node.
 </param>
	<param name="version">
 The new Version to update this XmlDeclarationSyntaxSyntax node with. If not
 specified the current Version will be used in the new
 XmlDeclarationSyntaxSyntax node.
 </param>
	<param name="encodingOpt">
 The new Encoding to update this XmlDeclarationSyntaxSyntax node with. If not
 specified the current Encoding will be used in the new
 XmlDeclarationSyntaxSyntax node.
 </param>
	<param name="standaloneOpt">
 The new Standalone to update this XmlDeclarationSyntaxSyntax node with. If not
 specified the current Standalone will be used in the new
 XmlDeclarationSyntaxSyntax node.
 </param>
	<param name="questionGreaterThanToken">
 The new QuestionGreaterThanToken to update this XmlDeclarationSyntaxSyntax node
 with. If not specified the current QuestionGreaterThanToken will be used in the
 new XmlDeclarationSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.XmlDeclarationSyntax">
	<summary>
 Represents the XML declaration prologue in an XML literal expression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlDeclarationOptionSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.XmlStringSyntax)">
	<summary>
 Creates a new XmlDeclarationOptionSyntaxSyntax node with the specified changes.
 </summary>
	<param name="name">
 The new Name to update this XmlDeclarationOptionSyntaxSyntax node with. If not
 specified the current Name will be used in the new
 XmlDeclarationOptionSyntaxSyntax node.
 </param>
	<param name="equals">
 The new Equals to update this XmlDeclarationOptionSyntaxSyntax node with. If
 not specified the current Equals will be used in the new
 XmlDeclarationOptionSyntaxSyntax node.
 </param>
	<param name="value">
 The new Value to update this XmlDeclarationOptionSyntaxSyntax node with. If not
 specified the current Value will be used in the new
 XmlDeclarationOptionSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.XmlDeclarationOptionSyntax">
	<summary>
 Represents an XML document prologue option - version, encoding, standalone or
 whitespace in an XML literal expression.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.XmlElementSyntax.Content">
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlElementSyntax.Update(Roslyn.Compilers.VisualBasic.XmlElementStartTagSyntax,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.XmlNodeSyntax},Roslyn.Compilers.VisualBasic.XmlElementEndTagSyntax)">
	<summary>
 Creates a new XmlElementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="startTag">
 The new StartTag to update this XmlElementSyntaxSyntax node with. If not
 specified the current StartTag will be used in the new XmlElementSyntaxSyntax
 node.
 </param>
	<param name="content">
 The new Content to update this XmlElementSyntaxSyntax node with. If not
 specified the current Content will be used in the new XmlElementSyntaxSyntax
 node.
 </param>
	<param name="endTag">
 The new EndTag to update this XmlElementSyntaxSyntax node with. If not
 specified the current EndTag will be used in the new XmlElementSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.XmlElementSyntax">
	<summary>
 Represents an XML element with content in an XML literal expression.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.XmlTextSyntax.TextTokens">
	<summary>
 A list of all the text tokens in the Xml text. This list always contains at
 least one token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlTextSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxTokenList)">
	<summary>
 Creates a new XmlTextSyntaxSyntax node with the specified changes.
 </summary>
	<param name="textTokens">
 The new TextTokens to update this XmlTextSyntaxSyntax node with. If not
 specified the current TextTokens will be used in the new XmlTextSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.XmlTextSyntax">
	<summary>
 Represents Xml text.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.XmlElementStartTagSyntax.Attributes">
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlElementStartTagSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.XmlNodeSyntax,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.XmlNodeSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new XmlElementStartTagSyntaxSyntax node with the specified changes.
 </summary>
	<param name="lessThanToken">
 The new LessThanToken to update this XmlElementStartTagSyntaxSyntax node with.
 If not specified the current LessThanToken will be used in the new
 XmlElementStartTagSyntaxSyntax node.
 </param>
	<param name="name">
 The new Name to update this XmlElementStartTagSyntaxSyntax node with. If not
 specified the current Name will be used in the new
 XmlElementStartTagSyntaxSyntax node.
 </param>
	<param name="attributes">
 The new Attributes to update this XmlElementStartTagSyntaxSyntax node with. If
 not specified the current Attributes will be used in the new
 XmlElementStartTagSyntaxSyntax node.
 </param>
	<param name="greaterThanToken">
 The new GreaterThanToken to update this XmlElementStartTagSyntaxSyntax node
 with. If not specified the current GreaterThanToken will be used in the new
 XmlElementStartTagSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.XmlElementStartTagSyntax">
	<summary>
 Represents the start tag of an XML element of the form &amp;lt;element&amp;gt;.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.XmlElementEndTagSyntax.NameOpt">
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlElementEndTagSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.XmlNameSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new XmlElementEndTagSyntaxSyntax node with the specified changes.
 </summary>
	<param name="lessThanSlashToken">
 The new LessThanSlashToken to update this XmlElementEndTagSyntaxSyntax node
 with. If not specified the current LessThanSlashToken will be used in the new
 XmlElementEndTagSyntaxSyntax node.
 </param>
	<param name="nameOpt">
 The new Name to update this XmlElementEndTagSyntaxSyntax node with. If not
 specified the current Name will be used in the new XmlElementEndTagSyntaxSyntax
 node.
 </param>
	<param name="greaterThanToken">
 The new GreaterThanToken to update this XmlElementEndTagSyntaxSyntax node with.
 If not specified the current GreaterThanToken will be used in the new
 XmlElementEndTagSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.XmlElementEndTagSyntax">
	<summary>
 Represents the end tag of an XML element of the form &amp;lt;/element&amp;gt;.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.XmlEmptyElementSyntax.Attributes">
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlEmptyElementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.XmlNodeSyntax,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.XmlNodeSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new XmlEmptyElementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="lessThanToken">
 The new LessThanToken to update this XmlEmptyElementSyntaxSyntax node with. If
 not specified the current LessThanToken will be used in the new
 XmlEmptyElementSyntaxSyntax node.
 </param>
	<param name="name">
 The new Name to update this XmlEmptyElementSyntaxSyntax node with. If not
 specified the current Name will be used in the new XmlEmptyElementSyntaxSyntax
 node.
 </param>
	<param name="attributes">
 The new Attributes to update this XmlEmptyElementSyntaxSyntax node with. If not
 specified the current Attributes will be used in the new
 XmlEmptyElementSyntaxSyntax node.
 </param>
	<param name="slashGreaterThanToken">
 The new SlashGreaterThanToken to update this XmlEmptyElementSyntaxSyntax node
 with. If not specified the current SlashGreaterThanToken will be used in the
 new XmlEmptyElementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.XmlEmptyElementSyntax">
	<summary>
 Represents an empty XML element of the form &amp;lt;element /&amp;gt;
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlAttributeSyntax.Update(Roslyn.Compilers.VisualBasic.XmlNodeSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.XmlNodeSyntax)">
	<summary>
 Creates a new XmlAttributeSyntaxSyntax node with the specified changes.
 </summary>
	<param name="name">
 The new Name to update this XmlAttributeSyntaxSyntax node with. If not
 specified the current Name will be used in the new XmlAttributeSyntaxSyntax
 node.
 </param>
	<param name="equalsToken">
 The new EqualsToken to update this XmlAttributeSyntaxSyntax node with. If not
 specified the current EqualsToken will be used in the new
 XmlAttributeSyntaxSyntax node.
 </param>
	<param name="value">
 The new Value to update this XmlAttributeSyntaxSyntax node with. If not
 specified the current Value will be used in the new XmlAttributeSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.XmlAttributeSyntax">
	<summary>
 Represents an XML attribute in an XML literal expression.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.XmlStringSyntax.TextTokens">
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlStringSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new XmlStringSyntaxSyntax node with the specified changes.
 </summary>
	<param name="startQuoteToken">
 The new StartQuoteToken to update this XmlStringSyntaxSyntax node with. If not
 specified the current StartQuoteToken will be used in the new
 XmlStringSyntaxSyntax node.
 </param>
	<param name="textTokens">
 The new TextTokens to update this XmlStringSyntaxSyntax node with. If not
 specified the current TextTokens will be used in the new XmlStringSyntaxSyntax
 node.
 </param>
	<param name="endQuoteToken">
 The new EndQuoteToken to update this XmlStringSyntaxSyntax node with. If not
 specified the current EndQuoteToken will be used in the new
 XmlStringSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.XmlStringSyntax">
	<summary>
 Represents a string of XML characters embedded as the content of an XML
 element.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.XmlNameSyntax.PrefixOpt">
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlNameSyntax.Update(Roslyn.Compilers.VisualBasic.XmlPrefixSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new XmlNameSyntaxSyntax node with the specified changes.
 </summary>
	<param name="prefixOpt">
 The new Prefix to update this XmlNameSyntaxSyntax node with. If not specified
 the current Prefix will be used in the new XmlNameSyntaxSyntax node.
 </param>
	<param name="localName">
 The new LocalName to update this XmlNameSyntaxSyntax node with. If not
 specified the current LocalName will be used in the new XmlNameSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.XmlNameSyntax">
	<summary>
 Represents an XML name of the form 'name' or 'namespace:name' appearing in
 source as part of an XML literal or member access expression or an XML
 namespace import clause.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlBracketedNameSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.XmlNameSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new XmlBracketedNameSyntaxSyntax node with the specified changes.
 </summary>
	<param name="lessThanToken">
 The new LessThanToken to update this XmlBracketedNameSyntaxSyntax node with. If
 not specified the current LessThanToken will be used in the new
 XmlBracketedNameSyntaxSyntax node.
 </param>
	<param name="name">
 The new Name to update this XmlBracketedNameSyntaxSyntax node with. If not
 specified the current Name will be used in the new XmlBracketedNameSyntaxSyntax
 node.
 </param>
	<param name="greaterThanToken">
 The new GreaterThanToken to update this XmlBracketedNameSyntaxSyntax node with.
 If not specified the current GreaterThanToken will be used in the new
 XmlBracketedNameSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.XmlBracketedNameSyntax">
	<summary>
 Represents an XML name of the form &amp;lt;xml-name&amp;gt; appearing in source
 as part of an XML literal or member access expression or an XML namespace
 import clause.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlPrefixSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new XmlPrefixSyntaxSyntax node with the specified changes.
 </summary>
	<param name="name">
 The new Name to update this XmlPrefixSyntaxSyntax node with. If not specified
 the current Name will be used in the new XmlPrefixSyntaxSyntax node.
 </param>
	<param name="colonToken">
 The new ColonToken to update this XmlPrefixSyntaxSyntax node with. If not
 specified the current ColonToken will be used in the new XmlPrefixSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.XmlPrefixSyntax">
	<summary>
 Represents and XML namespace prefix of the form 'prefix:' as in xml:ns="".
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlCommentSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new XmlCommentSyntaxSyntax node with the specified changes.
 </summary>
	<param name="lessThanMinusMinusToken">
 The new LessThanMinusMinusToken to update this XmlCommentSyntaxSyntax node
 with. If not specified the current LessThanMinusMinusToken will be used in the
 new XmlCommentSyntaxSyntax node.
 </param>
	<param name="textTokens">
 The new TextTokens to update this XmlCommentSyntaxSyntax node with. If not
 specified the current TextTokens will be used in the new XmlCommentSyntaxSyntax
 node.
 </param>
	<param name="minusMinusGreaterThanToken">
 The new MinusMinusGreaterThanToken to update this XmlCommentSyntaxSyntax node
 with. If not specified the current MinusMinusGreaterThanToken will be used in
 the new XmlCommentSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.XmlCommentSyntax">
	<summary>
 Represents an XML comment of the form &amp;lt;-- Comment --&amp;gt; appearing
 in an XML literal expression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlProcessingInstructionSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new XmlProcessingInstructionSyntaxSyntax node with the specified
 changes.
 </summary>
	<param name="lessThanQuestionToken">
 The new LessThanQuestionToken to update this
 XmlProcessingInstructionSyntaxSyntax node with. If not specified the current
 LessThanQuestionToken will be used in the new
 XmlProcessingInstructionSyntaxSyntax node.
 </param>
	<param name="name">
 The new Name to update this XmlProcessingInstructionSyntaxSyntax node with. If
 not specified the current Name will be used in the new
 XmlProcessingInstructionSyntaxSyntax node.
 </param>
	<param name="textTokens">
 The new TextTokens to update this XmlProcessingInstructionSyntaxSyntax node
 with. If not specified the current TextTokens will be used in the new
 XmlProcessingInstructionSyntaxSyntax node.
 </param>
	<param name="questionGreaterThanToken">
 The new QuestionGreaterThanToken to update this
 XmlProcessingInstructionSyntaxSyntax node with. If not specified the current
 QuestionGreaterThanToken will be used in the new
 XmlProcessingInstructionSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.XmlProcessingInstructionSyntax">
	<summary>
 Represents an XML processing instruction of the form '&amp;lt;?
 XMLProcessingTarget XMLProcessingValue ?&amp;gt;'.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlCDataSectionSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new XmlCDataSectionSyntaxSyntax node with the specified changes.
 </summary>
	<param name="beginCDataToken">
 The new BeginCDataToken to update this XmlCDataSectionSyntaxSyntax node with.
 If not specified the current BeginCDataToken will be used in the new
 XmlCDataSectionSyntaxSyntax node.
 </param>
	<param name="textTokens">
 The new TextTokens to update this XmlCDataSectionSyntaxSyntax node with. If not
 specified the current TextTokens will be used in the new
 XmlCDataSectionSyntaxSyntax node.
 </param>
	<param name="endCDataToken">
 The new EndCDataToken to update this XmlCDataSectionSyntaxSyntax node with. If
 not specified the current EndCDataToken will be used in the new
 XmlCDataSectionSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.XmlCDataSectionSyntax">
	<summary>
 Represents an XML CDATA section in an XML literal expression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlEmbeddedExpressionSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new XmlEmbeddedExpressionSyntaxSyntax node with the specified
 changes.
 </summary>
	<param name="lessThanPercentEqualsToken">
 The new LessThanPercentEqualsToken to update this
 XmlEmbeddedExpressionSyntaxSyntax node with. If not specified the current
 LessThanPercentEqualsToken will be used in the new
 XmlEmbeddedExpressionSyntaxSyntax node.
 </param>
	<param name="expression">
 The new Expression to update this XmlEmbeddedExpressionSyntaxSyntax node with.
 If not specified the current Expression will be used in the new
 XmlEmbeddedExpressionSyntaxSyntax node.
 </param>
	<param name="percentGreaterThanToken">
 The new PercentGreaterThanToken to update this
 XmlEmbeddedExpressionSyntaxSyntax node with. If not specified the current
 PercentGreaterThanToken will be used in the new
 XmlEmbeddedExpressionSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.XmlEmbeddedExpressionSyntax">
	<summary>
 Represents an embedded expression in an XML literal e.g.
 '&amp;lt;name&amp;gt;&amp;lt;%= obj.Name =%&amp;gt;&amp;lt;/name&amp;gt;'.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.TypeSyntax">
	<summary>
 Abstract node class that represents the textual description of a type, possibly
 include generic type arguments, qualified names, array specifiers, nullable
 specifier and the like.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ArrayTypeSyntax.ElementType">
	<summary>
 The type of the elements of the array.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ArrayTypeSyntax.RankSpecifiers">
	<summary>
 Represents the list of "()" or "(,,)" modifiers on the array type.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ArrayTypeSyntax.Update(Roslyn.Compilers.VisualBasic.TypeSyntax,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.ArrayRankSpecifierSyntax})">
	<summary>
 Creates a new ArrayTypeSyntaxSyntax node with the specified changes.
 </summary>
	<param name="elementType">
 The new ElementType to update this ArrayTypeSyntaxSyntax node with. If not
 specified the current ElementType will be used in the new ArrayTypeSyntaxSyntax
 node.
 </param>
	<param name="rankSpecifiers">
 The new RankSpecifiers to update this ArrayTypeSyntaxSyntax node with. If not
 specified the current RankSpecifiers will be used in the new
 ArrayTypeSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ArrayTypeSyntax">
	<summary>
 Represents an array type, such as "A() or "A(,)", without bounds specified for
 the array.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NullableTypeSyntax.ElementType">
	<summary>
 The kind of type that is this type is a nullable of. Cannot be an array type or
 a nullable type.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NullableTypeSyntax.QuestionMarkToken">
	<summary>
 The "?" token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NullableTypeSyntax.Update(Roslyn.Compilers.VisualBasic.TypeSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new NullableTypeSyntaxSyntax node with the specified changes.
 </summary>
	<param name="elementType">
 The new ElementType to update this NullableTypeSyntaxSyntax node with. If not
 specified the current ElementType will be used in the new
 NullableTypeSyntaxSyntax node.
 </param>
	<param name="questionMarkToken">
 The new QuestionMarkToken to update this NullableTypeSyntaxSyntax node with. If
 not specified the current QuestionMarkToken will be used in the new
 NullableTypeSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.NullableTypeSyntax">
	<summary>
 A type name that represents a nullable type, such as "Integer?".
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.PredefinedTypeSyntax.Keyword">
	<summary>
 The keyword that was used to describe the built-in type.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.PredefinedTypeSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new PredefinedTypeSyntaxSyntax node with the specified changes.
 </summary>
	<param name="keyword">
 The new Keyword to update this PredefinedTypeSyntaxSyntax node with. If not
 specified the current Keyword will be used in the new
 PredefinedTypeSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.PredefinedTypeSyntax">
	<summary>
 Represents an occurrence of a Visual Basic built-in type such as Integer or
 String in source code.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.NameSyntax">
	<summary>
 Abstract node class that represents a name, possibly include generic arguments
 and qualified names.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SimpleNameSyntax.Identifier">
	<summary>
 The identifier in the name.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SimpleNameSyntax">
	<summary>
 Abstract node class that represents a name, possibly include generic arguments.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.IdentifierNameSyntax.Identifier">
	<summary>
 The identifier in the name.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.IdentifierNameSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new IdentifierNameSyntaxSyntax node with the specified changes.
 </summary>
	<param name="identifier">
 The new Identifier to update this IdentifierNameSyntaxSyntax node with. If not
 specified the current Identifier will be used in the new
 IdentifierNameSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.IdentifierNameSyntax">
	<summary>
 Represents a type name consisting of a single identifier (which might include
 brackets or a type character).
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.GenericNameSyntax.Identifier">
	<summary>
 The identifier in the name.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.GenericNameSyntax.TypeArgumentList">
	<summary>
 The generic argument list.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.GenericNameSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeArgumentListSyntax)">
	<summary>
 Creates a new GenericNameSyntaxSyntax node with the specified changes.
 </summary>
	<param name="identifier">
 The new Identifier to update this GenericNameSyntaxSyntax node with. If not
 specified the current Identifier will be used in the new
 GenericNameSyntaxSyntax node.
 </param>
	<param name="typeArgumentList">
 The new TypeArgumentList to update this GenericNameSyntaxSyntax node with. If
 not specified the current TypeArgumentList will be used in the new
 GenericNameSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.GenericNameSyntax">
	<summary>
 Represents a simple type name with one or more generic arguments, such as "X(Of
 Y, Z).
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.QualifiedNameSyntax.Left">
	<summary>
 The part of the name that appears to the left of the dot. This can itself be
 any name.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.QualifiedNameSyntax.DotToken">
	<summary>
 The "." token that seperates the names.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.QualifiedNameSyntax.Right">
	<summary>
 The part of the name that appears to the right of the dot. This must be a
 simple identifier.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.QualifiedNameSyntax.Update(Roslyn.Compilers.VisualBasic.NameSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SimpleNameSyntax)">
	<summary>
 Creates a new QualifiedNameSyntaxSyntax node with the specified changes.
 </summary>
	<param name="left">
 The new Left to update this QualifiedNameSyntaxSyntax node with. If not
 specified the current Left will be used in the new QualifiedNameSyntaxSyntax
 node.
 </param>
	<param name="dotToken">
 The new DotToken to update this QualifiedNameSyntaxSyntax node with. If not
 specified the current DotToken will be used in the new
 QualifiedNameSyntaxSyntax node.
 </param>
	<param name="right">
 The new Right to update this QualifiedNameSyntaxSyntax node with. If not
 specified the current Right will be used in the new QualifiedNameSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.QualifiedNameSyntax">
	<summary>
 Represents a qualified type name, for example X.Y or X(Of Z).Y.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.GlobalNameSyntax.GlobalKeyword">
	<summary>
 The "Global" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.GlobalNameSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new GlobalNameSyntaxSyntax node with the specified changes.
 </summary>
	<param name="globalKeyword">
 The new GlobalKeyword to update this GlobalNameSyntaxSyntax node with. If not
 specified the current GlobalKeyword will be used in the new
 GlobalNameSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.GlobalNameSyntax">
	<summary>
 Represents a name in the global namespace.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeArgumentListSyntax.OpenParenToken">
	<summary>
 The "(" token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeArgumentListSyntax.OfKeyword">
	<summary>
 The "Of" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeArgumentListSyntax.Arguments">
	<summary>
 A list of all the type arguments.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeArgumentListSyntax.CloseParenToken">
	<summary>
 The ")" token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeArgumentListSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.TypeSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new TypeArgumentListSyntaxSyntax node with the specified changes.
 </summary>
	<param name="openParenToken">
 The new OpenParenToken to update this TypeArgumentListSyntaxSyntax node with.
 If not specified the current OpenParenToken will be used in the new
 TypeArgumentListSyntaxSyntax node.
 </param>
	<param name="ofKeyword">
 The new OfKeyword to update this TypeArgumentListSyntaxSyntax node with. If not
 specified the current OfKeyword will be used in the new
 TypeArgumentListSyntaxSyntax node.
 </param>
	<param name="arguments">
 The new Arguments to update this TypeArgumentListSyntaxSyntax node with. If not
 specified the current Arguments will be used in the new
 TypeArgumentListSyntaxSyntax node.
 </param>
	<param name="closeParenToken">
 The new CloseParenToken to update this TypeArgumentListSyntaxSyntax node with.
 If not specified the current CloseParenToken will be used in the new
 TypeArgumentListSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.TypeArgumentListSyntax">
	<summary>
 Represents a parenthesized list of generic type arguments.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.StructuredTriviaSyntax">
	<summary>
 Abstract class that represent structured trivia.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SkippedTokensSyntax.Tokens">
	<summary>
 The list of tokens that were skipped by the parser.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SkippedTokensSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxTokenList)">
	<summary>
 Creates a new SkippedTokensSyntaxSyntax node with the specified changes.
 </summary>
	<param name="tokens">
 The new Tokens to update this SkippedTokensSyntaxSyntax node with. If not
 specified the current Tokens will be used in the new SkippedTokensSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.SkippedTokensSyntax">
	<summary>
 Represents tokens that were skipped by the parser as part of error recovery,
 and thus are not part of any syntactic structure.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.DocumentationCommentSyntax.Content">
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.DocumentationCommentSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.XmlNodeSyntax})">
	<summary>
 Creates a new DocumentationCommentSyntaxSyntax node with the specified changes.
 </summary>
	<param name="content">
 The new Content to update this DocumentationCommentSyntaxSyntax node with. If
 not specified the current Content will be used in the new
 DocumentationCommentSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.DocumentationCommentSyntax">
	<summary>
 Represents a documentation comment e.g. ''' &amp;lt;Summary&amp;gt; apearing in
 source.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.DirectiveSyntax.Terminator">
	<summary>
 The statement terminator token that ended the Directive.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.DirectiveSyntax.Update(Roslyn.Compilers.VisualBasic.DirectiveStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new DirectiveSyntaxSyntax node with the specified changes.
 </summary>
	<param name="directive">
 The new Directive to update this DirectiveSyntaxSyntax node with. If not
 specified the current Directive will be used in the new DirectiveSyntaxSyntax
 node.
 </param>
	<param name="terminator">
 The new Terminator to update this DirectiveSyntaxSyntax node with. If not
 specified the current Terminator will be used in the new DirectiveSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.DirectiveSyntax">
	<summary>
 Represents a preprocessor directive
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.DirectiveStatementSyntax.HashToken">
	<summary>
 The "#" token in a preprocessor directive.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.DirectiveStatementSyntax">
	<summary>
 Represents a pre-processing directive (such as #If, #Const or #Region)
 appearing in source.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ConstDirectiveSyntax.HashToken">
	<summary>
 The "#" token in a preprocessor directive.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ConstDirectiveSyntax.ConstKeyword">
	<summary>
 The "Const" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ConstDirectiveSyntax.Name">
	<summary>
 The name of the pre-processing constant being defined.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ConstDirectiveSyntax.EqualsToken">
	<summary>
 The "=" token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ConstDirectiveSyntax.Value">
	<summary>
 An expression representing the value of the pre-processing constant being
 defined.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ConstDirectiveSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new ConstDirectiveSyntaxSyntax node with the specified changes.
 </summary>
	<param name="hashToken">
 The new HashToken to update this ConstDirectiveSyntaxSyntax node with. If not
 specified the current HashToken will be used in the new
 ConstDirectiveSyntaxSyntax node.
 </param>
	<param name="constKeyword">
 The new ConstKeyword to update this ConstDirectiveSyntaxSyntax node with. If
 not specified the current ConstKeyword will be used in the new
 ConstDirectiveSyntaxSyntax node.
 </param>
	<param name="name">
 The new Name to update this ConstDirectiveSyntaxSyntax node with. If not
 specified the current Name will be used in the new ConstDirectiveSyntaxSyntax
 node.
 </param>
	<param name="equalsToken">
 The new EqualsToken to update this ConstDirectiveSyntaxSyntax node with. If not
 specified the current EqualsToken will be used in the new
 ConstDirectiveSyntaxSyntax node.
 </param>
	<param name="value">
 The new Value to update this ConstDirectiveSyntaxSyntax node with. If not
 specified the current Value will be used in the new ConstDirectiveSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ConstDirectiveSyntax">
	<summary>
 Represents a #Const pre-processing constant declaration appearing in source.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.IfDirectiveSyntax.HashToken">
	<summary>
 The "#" token in a preprocessor directive.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.IfDirectiveSyntax.ElseKeywordOpt">
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.IfDirectiveSyntax.ThenKeywordOpt">
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.IfDirectiveSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new IfDirectiveSyntaxSyntax node with the specified changes.
 </summary>
	<param name="hashToken">
 The new HashToken to update this IfDirectiveSyntaxSyntax node with. If not
 specified the current HashToken will be used in the new IfDirectiveSyntaxSyntax
 node.
 </param>
	<param name="elseKeywordOpt">
 The new ElseKeyword to update this IfDirectiveSyntaxSyntax node with. If not
 specified the current ElseKeyword will be used in the new
 IfDirectiveSyntaxSyntax node.
 </param>
	<param name="ifOrElseIfKeyword">
 The new IfOrElseIfKeyword to update this IfDirectiveSyntaxSyntax node with. If
 not specified the current IfOrElseIfKeyword will be used in the new
 IfDirectiveSyntaxSyntax node.
 </param>
	<param name="condition">
 The new Condition to update this IfDirectiveSyntaxSyntax node with. If not
 specified the current Condition will be used in the new IfDirectiveSyntaxSyntax
 node.
 </param>
	<param name="thenKeywordOpt">
 The new ThenKeyword to update this IfDirectiveSyntaxSyntax node with. If not
 specified the current ThenKeyword will be used in the new
 IfDirectiveSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.IfDirectiveSyntax">
	<summary>
 Represents the beginning of an #If pre-processing directive appearing in
 source.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ElseDirectiveSyntax.HashToken">
	<summary>
 The "#" token in a preprocessor directive.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ElseDirectiveSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new ElseDirectiveSyntaxSyntax node with the specified changes.
 </summary>
	<param name="hashToken">
 The new HashToken to update this ElseDirectiveSyntaxSyntax node with. If not
 specified the current HashToken will be used in the new
 ElseDirectiveSyntaxSyntax node.
 </param>
	<param name="elseKeyword">
 The new ElseKeyword to update this ElseDirectiveSyntaxSyntax node with. If not
 specified the current ElseKeyword will be used in the new
 ElseDirectiveSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ElseDirectiveSyntax">
	<summary>
 Represents an #Else pre-processing directive appearing in source.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.EndIfDirectiveSyntax.HashToken">
	<summary>
 The "#" token in a preprocessor directive.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.EndIfDirectiveSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new EndIfDirectiveSyntaxSyntax node with the specified changes.
 </summary>
	<param name="hashToken">
 The new HashToken to update this EndIfDirectiveSyntaxSyntax node with. If not
 specified the current HashToken will be used in the new
 EndIfDirectiveSyntaxSyntax node.
 </param>
	<param name="endKeyword">
 The new EndKeyword to update this EndIfDirectiveSyntaxSyntax node with. If not
 specified the current EndKeyword will be used in the new
 EndIfDirectiveSyntaxSyntax node.
 </param>
	<param name="ifKeyword">
 The new IfKeyword to update this EndIfDirectiveSyntaxSyntax node with. If not
 specified the current IfKeyword will be used in the new
 EndIfDirectiveSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.EndIfDirectiveSyntax">
	<summary>
 Represents an #End If pre-processing directive appearing in source.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.RegionDirectiveSyntax.HashToken">
	<summary>
 The "#" token in a preprocessor directive.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.RegionDirectiveSyntax.RegionKeyword">
	<summary>
 The "Region" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.RegionDirectiveSyntax.Name">
	<summary>
 The label of the code region being defined.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.RegionDirectiveSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new RegionDirectiveSyntaxSyntax node with the specified changes.
 </summary>
	<param name="hashToken">
 The new HashToken to update this RegionDirectiveSyntaxSyntax node with. If not
 specified the current HashToken will be used in the new
 RegionDirectiveSyntaxSyntax node.
 </param>
	<param name="regionKeyword">
 The new RegionKeyword to update this RegionDirectiveSyntaxSyntax node with. If
 not specified the current RegionKeyword will be used in the new
 RegionDirectiveSyntaxSyntax node.
 </param>
	<param name="name">
 The new Name to update this RegionDirectiveSyntaxSyntax node with. If not
 specified the current Name will be used in the new RegionDirectiveSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.RegionDirectiveSyntax">
	<summary>
 Represents the beginning of a #Region directive appearing in source.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.EndRegionDirectiveSyntax.HashToken">
	<summary>
 The "#" token in a preprocessor directive.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.EndRegionDirectiveSyntax.EndKeyword">
	<summary>
 The "End" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.EndRegionDirectiveSyntax.RegionKeyword">
	<summary>
 The "Region" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.EndRegionDirectiveSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new EndRegionDirectiveSyntaxSyntax node with the specified changes.
 </summary>
	<param name="hashToken">
 The new HashToken to update this EndRegionDirectiveSyntaxSyntax node with. If
 not specified the current HashToken will be used in the new
 EndRegionDirectiveSyntaxSyntax node.
 </param>
	<param name="endKeyword">
 The new EndKeyword to update this EndRegionDirectiveSyntaxSyntax node with. If
 not specified the current EndKeyword will be used in the new
 EndRegionDirectiveSyntaxSyntax node.
 </param>
	<param name="regionKeyword">
 The new RegionKeyword to update this EndRegionDirectiveSyntaxSyntax node with.
 If not specified the current RegionKeyword will be used in the new
 EndRegionDirectiveSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.EndRegionDirectiveSyntax">
	<summary>
 Represents an #End Region directive appearing in source.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ExternalSourceDirectiveSyntax.HashToken">
	<summary>
 The "#" token in a preprocessor directive.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ExternalSourceDirectiveSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new ExternalSourceDirectiveSyntaxSyntax node with the specified
 changes.
 </summary>
	<param name="hashToken">
 The new HashToken to update this ExternalSourceDirectiveSyntaxSyntax node with.
 If not specified the current HashToken will be used in the new
 ExternalSourceDirectiveSyntaxSyntax node.
 </param>
	<param name="externalSourceKeyword">
 The new ExternalSourceKeyword to update this
 ExternalSourceDirectiveSyntaxSyntax node with. If not specified the current
 ExternalSourceKeyword will be used in the new
 ExternalSourceDirectiveSyntaxSyntax node.
 </param>
	<param name="openParenToken">
 The new OpenParenToken to update this ExternalSourceDirectiveSyntaxSyntax node
 with. If not specified the current OpenParenToken will be used in the new
 ExternalSourceDirectiveSyntaxSyntax node.
 </param>
	<param name="externalSource">
 The new ExternalSource to update this ExternalSourceDirectiveSyntaxSyntax node
 with. If not specified the current ExternalSource will be used in the new
 ExternalSourceDirectiveSyntaxSyntax node.
 </param>
	<param name="commaToken">
 The new CommaToken to update this ExternalSourceDirectiveSyntaxSyntax node
 with. If not specified the current CommaToken will be used in the new
 ExternalSourceDirectiveSyntaxSyntax node.
 </param>
	<param name="lineStart">
 The new LineStart to update this ExternalSourceDirectiveSyntaxSyntax node with.
 If not specified the current LineStart will be used in the new
 ExternalSourceDirectiveSyntaxSyntax node.
 </param>
	<param name="closeParenToken">
 The new CloseParenToken to update this ExternalSourceDirectiveSyntaxSyntax node
 with. If not specified the current CloseParenToken will be used in the new
 ExternalSourceDirectiveSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ExternalSourceDirectiveSyntax">
	<summary>
 Represents the beginning of a #ExternalSource pre-processing directive
 appearing in source.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.EndExternalSourceDirective.HashToken">
	<summary>
 The "#" token in a preprocessor directive.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.EndExternalSourceDirective.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new EndExternalSourceDirectiveSyntax node with the specified changes.
 </summary>
	<param name="hashToken">
 The new HashToken to update this EndExternalSourceDirectiveSyntax node with. If
 not specified the current HashToken will be used in the new
 EndExternalSourceDirectiveSyntax node.
 </param>
	<param name="endKeyword">
 The new EndKeyword to update this EndExternalSourceDirectiveSyntax node with.
 If not specified the current EndKeyword will be used in the new
 EndExternalSourceDirectiveSyntax node.
 </param>
	<param name="externalSourceKeyword">
 The new ExternalSourceKeyword to update this EndExternalSourceDirectiveSyntax
 node with. If not specified the current ExternalSourceKeyword will be used in
 the new EndExternalSourceDirectiveSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.EndExternalSourceDirective">
	<summary>
 Represents an #End ExternalSource pre-processing directive appearing in source.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ExternalChecksumDirectiveSyntax.HashToken">
	<summary>
 The "#" token in a preprocessor directive.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ExternalChecksumDirectiveSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new ExternalChecksumDirectiveSyntaxSyntax node with the specified
 changes.
 </summary>
	<param name="hashToken">
 The new HashToken to update this ExternalChecksumDirectiveSyntaxSyntax node
 with. If not specified the current HashToken will be used in the new
 ExternalChecksumDirectiveSyntaxSyntax node.
 </param>
	<param name="externalChecksumKeyword">
 The new ExternalChecksumKeyword to update this
 ExternalChecksumDirectiveSyntaxSyntax node with. If not specified the current
 ExternalChecksumKeyword will be used in the new
 ExternalChecksumDirectiveSyntaxSyntax node.
 </param>
	<param name="openParenToken">
 The new OpenParenToken to update this ExternalChecksumDirectiveSyntaxSyntax
 node with. If not specified the current OpenParenToken will be used in the new
 ExternalChecksumDirectiveSyntaxSyntax node.
 </param>
	<param name="externalSource">
 The new ExternalSource to update this ExternalChecksumDirectiveSyntaxSyntax
 node with. If not specified the current ExternalSource will be used in the new
 ExternalChecksumDirectiveSyntaxSyntax node.
 </param>
	<param name="firstCommaToken">
 The new FirstCommaToken to update this ExternalChecksumDirectiveSyntaxSyntax
 node with. If not specified the current FirstCommaToken will be used in the new
 ExternalChecksumDirectiveSyntaxSyntax node.
 </param>
	<param name="guid">
 The new Guid to update this ExternalChecksumDirectiveSyntaxSyntax node with. If
 not specified the current Guid will be used in the new
 ExternalChecksumDirectiveSyntaxSyntax node.
 </param>
	<param name="secondCommaToken">
 The new SecondCommaToken to update this ExternalChecksumDirectiveSyntaxSyntax
 node with. If not specified the current SecondCommaToken will be used in the
 new ExternalChecksumDirectiveSyntaxSyntax node.
 </param>
	<param name="checksum">
 The new Checksum to update this ExternalChecksumDirectiveSyntaxSyntax node
 with. If not specified the current Checksum will be used in the new
 ExternalChecksumDirectiveSyntaxSyntax node.
 </param>
	<param name="closeParenToken">
 The new CloseParenToken to update this ExternalChecksumDirectiveSyntaxSyntax
 node with. If not specified the current CloseParenToken will be used in the new
 ExternalChecksumDirectiveSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ExternalChecksumDirectiveSyntax">
	<summary>
 Represents an #ExternalChecksum pre-processing directive appearing in source.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.BadDirectiveSyntax.HashToken">
	<summary>
 The "#" token in a preprocessor directive.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.BadDirectiveSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new BadDirectiveSyntaxSyntax node with the specified changes.
 </summary>
	<param name="hashToken">
 The new HashToken to update this BadDirectiveSyntaxSyntax node with. If not
 specified the current HashToken will be used in the new
 BadDirectiveSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.BadDirectiveSyntax">
	<summary>
 Represents an unrecognized pre-processing directive. This occurs when the
 parser encounters a hash '#' token at the beginning of a physical line but does
 recognize the text that follows as a valid Visual Basic pre-processing
 directive.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EmptyStatement(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 A class to represent an empty statement. This can occur when a colon is on a
 line without anything else.
 </summary>
	<param name="empty">
 An empty token because all non terminals must have a token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndIfStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndUsingStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndWithStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndSelectStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndStructureStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndEnumStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndInterfaceStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndClassStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndModuleStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndNamespaceStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndSubStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndFunctionStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndGetStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndSetStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndPropertyStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndOperatorStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndEventStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndAddHandlerStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndRemoveHandlerStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndRaiseEventStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndWhileStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndTryStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndSyncLockStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndBlockStatement(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="kind">
 A &amp;lt;cref c="SyntaxKind"/&amp;gt; representing the specific kind of
 EndBlockStatementSyntax. One of EndIfStatement, EndUsingStatement,
 EndWithStatement, EndSelectStatement, EndStructureStatement, EndEnumStatement,
 EndInterfaceStatement, EndClassStatement, EndModuleStatement,
 EndNamespaceStatement, EndSubStatement, EndFunctionStatement, EndGetStatement,
 EndSetStatement, EndPropertyStatement, EndOperatorStatement, EndEventStatement,
 EndAddHandlerStatement, EndRemoveHandlerStatement, EndRaiseEventStatement,
 EndWhileStatement, EndTryStatement, EndSyncLockStatement.
 </param>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CompilationUnit(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.OptionStatementSyntax},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ImportsStatementSyntax},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.AttributesStatementSyntax},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an entire source file of VB code.
 </summary>
	<param name="options">
 Represents the list of Option statements at the beginning of a source file.
 </param>
	<param name="imports">
 Represents the list of Imports statements at the beginning of a source file.
 </param>
	<param name="attributes">
 Represents the list of AttributeStatements at the beginning of a source file
 that contain the Assembly and Module attributes.
 </param>
	<param name="members">
 Represents the members of the default namespace for this source file: all the
 top-level type and namespace declarations in the file. May also contain
 Statements that are not valid
 </param>
	<param name="endOfFileToken">
 Represents the end of the source file. This token may have trivia (whitespace,
 comments, ...) attached to it.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.OptionStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an Option statement, such as "Option Strict On".
 </summary>
	<param name="optionKeyword">
 The "Option" keyword.
 </param>
	<param name="nameKeyword">
 The keyword that identifies the option being set: Explicit, Strict, Compare or
 Infer.
 </param>
	<param name="valueKeywordOpt">
 The keyword that identifiers the value being set for the opition: On, Off, Text
 or Binary.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ImportsStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ImportsClauseSyntax})">
	<summary>
 Represents an Imports statement, which has one or more imports clauses.
 </summary>
	<param name="importsKeyword">
 The "Imports" keyword.
 </param>
	<param name="importsClauses">
 A list of one or more import clauses. Each clause is either an alias, namespace
 or XML namespace import.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AliasImportsClause(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.NameSyntax)">
	<summary>
 Represents the clause of an Imports statement that defines an alias for a
 namespace or type.
 </summary>
	<param name="alias">
 The identifier that the alias is being defined for.
 </param>
	<param name="equalsToken">
 The equals sign token.
 </param>
	<param name="name">
 The namespace or type the alias refers to.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.MembersImportsClause(Roslyn.Compilers.VisualBasic.NameSyntax)">
	<summary>
 Represents the clause of an Imports statement that imports all members of a
 namespace.
 </summary>
	<param name="name">
 The namespace or type being imported.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlNamespaceImportsClause(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.XmlAttributeSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Defines a XML namespace for XML expressions.
 </summary>
	<param name="xmlNamespace">
 Identifies the XML namespace alias and URI.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.NamespaceBlock(Roslyn.Compilers.VisualBasic.NamespaceStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a Namespace statement, its contents and the End Namespace statement.
 </summary>
	<param name="begin">
 The statement that begins the NamespaceBlock.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="members">
 The declarations contained in the namespace statement.
 </param>
	<param name="end">
 The End Namespace statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.NamespaceStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.NameSyntax)">
	<summary>
 Represents the beginning statement of a namespace declaration. This node always
 appears as the Begin of a BlockStatement with Kind=NamespaceBlock.
 </summary>
	<param name="namespaceKeyword">
 The "Namespace" keyword.
 </param>
	<param name="name">
 A (possibly dotted) name denoting the namespace being declared.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ModuleBlock(Roslyn.Compilers.VisualBasic.TypeStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InheritsStatementSyntax},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ImplementsStatementSyntax},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a declaration of Module, its contents and the End statement that
 ends it.
 </summary>
	<param name="begin">
 The statement that begins the type or module.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="inherits">
 A list of the Inherits declarations for the type.
 </param>
	<param name="implements">
 A list of the Implements declarations for the type.
 </param>
	<param name="members">
 The declarations contained in the type or module.
 </param>
	<param name="end">
 The End XXX statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.StructureBlock(Roslyn.Compilers.VisualBasic.TypeStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InheritsStatementSyntax},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ImplementsStatementSyntax},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a declaration of a Structure, its contents and the End statement
 that ends it.
 </summary>
	<param name="begin">
 The statement that begins the type or module.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="inherits">
 A list of the Inherits declarations for the type.
 </param>
	<param name="implements">
 A list of the Implements declarations for the type.
 </param>
	<param name="members">
 The declarations contained in the type or module.
 </param>
	<param name="end">
 The End XXX statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.InterfaceBlock(Roslyn.Compilers.VisualBasic.TypeStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InheritsStatementSyntax},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ImplementsStatementSyntax},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a declaration of a Interface, its contents and the End statement
 that ends it.
 </summary>
	<param name="begin">
 The statement that begins the type or module.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="inherits">
 A list of the Inherits declarations for the type.
 </param>
	<param name="implements">
 A list of the Implements declarations for the type.
 </param>
	<param name="members">
 The declarations contained in the type or module.
 </param>
	<param name="end">
 The End XXX statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ClassBlock(Roslyn.Compilers.VisualBasic.TypeStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InheritsStatementSyntax},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ImplementsStatementSyntax},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a declaration of a Class its contents and the End statement that
 ends it.
 </summary>
	<param name="begin">
 The statement that begins the type or module.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="inherits">
 A list of the Inherits declarations for the type.
 </param>
	<param name="implements">
 A list of the Implements declarations for the type.
 </param>
	<param name="members">
 The declarations contained in the type or module.
 </param>
	<param name="end">
 The End XXX statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EnumBlock(Roslyn.Compilers.VisualBasic.EnumStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.EnumMemberDeclarationSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a declaration of an Enum, its contents and the End Enum statement
 that ends it.
 </summary>
	<param name="begin">
 The statement that begins the type or module.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="members">
 The declarations contained in the enumeration.
 </param>
	<param name="end">
 The End XXX statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.InheritsStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.TypeSyntax})">
	<summary>
 Represents an Inherits statement in a Class, Structure or Interface.
 </summary>
	<param name="inheritsKeyword">
 The "Inherits" keyword.
 </param>
	<param name="types">
 A list of the types being inherited.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ImplementsStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.TypeSyntax})">
	<summary>
 Represents an Implements statement in a Class or Structure.
 </summary>
	<param name="implementsKeyword">
 The "Implements" keyword.
 </param>
	<param name="types">
 A list of the types being implemented.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ModuleStatement(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeBlockSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeParameterListSyntax)">
	<summary>
 Represents the beginning statement of a Module declaration. This node always
 appears as the Begin of a TypeBlock with Kind=ModuleDeclarationBlock.
 </summary>
	<param name="attributes">
 A list of all attribute blocks on this declaration. If no attributes were
 specified, an empty list is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </param>
	<param name="keyword">
 The "Module", "Class", "Interface" or "Structure" keyword.
 </param>
	<param name="identifier">
 The name of the type being declared.
 </param>
	<param name="typeParameterListOpt">
 If present, a type parameter list with generic parameters for this type. If no
 generic parameters were present, Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.StructureStatement(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeBlockSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeParameterListSyntax)">
	<summary>
 Represents the beginning statement of a Structure declaration. This node always
 appears as the Begin of a TypeBlock with Kind=StructureDeclarationBlock.
 </summary>
	<param name="attributes">
 A list of all attribute blocks on this declaration. If no attributes were
 specified, an empty list is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </param>
	<param name="keyword">
 The "Module", "Class", "Interface" or "Structure" keyword.
 </param>
	<param name="identifier">
 The name of the type being declared.
 </param>
	<param name="typeParameterListOpt">
 If present, a type parameter list with generic parameters for this type. If no
 generic parameters were present, Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.InterfaceStatement(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeBlockSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeParameterListSyntax)">
	<summary>
 Represents the beginning statement of a Interface declaration. This node always
 appears as the Begin of a TypeBlock with Kind=InterfaceDeclarationBlock.
 </summary>
	<param name="attributes">
 A list of all attribute blocks on this declaration. If no attributes were
 specified, an empty list is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </param>
	<param name="keyword">
 The "Module", "Class", "Interface" or "Structure" keyword.
 </param>
	<param name="identifier">
 The name of the type being declared.
 </param>
	<param name="typeParameterListOpt">
 If present, a type parameter list with generic parameters for this type. If no
 generic parameters were present, Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ClassStatement(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeBlockSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeParameterListSyntax)">
	<summary>
 Represents the beginning statement of a Class declaration. This node always
 appears as the Begin of a TypeBlock with Kind=ClassDeclarationBlock.
 </summary>
	<param name="attributes">
 A list of all attribute blocks on this declaration. If no attributes were
 specified, an empty list is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </param>
	<param name="keyword">
 The "Module", "Class", "Interface" or "Structure" keyword.
 </param>
	<param name="identifier">
 The name of the type being declared.
 </param>
	<param name="typeParameterListOpt">
 If present, a type parameter list with generic parameters for this type. If no
 generic parameters were present, Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EnumStatement(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeBlockSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 Represents the beginning statement of an Enum declaration. This node always
 appears as the Begin of an EnumBlock with Kind=EnumDeclarationBlock.
 </summary>
	<param name="attributes">
 A list of all attribute blocks on this declaration. If no attributes were
 specified, an empty list is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </param>
	<param name="enumKeyword">
 The "Enum" keyword.
 </param>
	<param name="identifier">
 The name of the enum being declared.
 </param>
	<param name="underlyingTypeOpt">
 Optional "As XXX" clause describing the underlying type of the enumeration. If
 no As clause was specified, Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.TypeParameterList(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.TypeParameterSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents the type parameter list in a declaration.
 </summary>
	<param name="openParenToken">
 The "(" token.
 </param>
	<param name="ofKeyword">
 The "Of" keyword.
 </param>
	<param name="parameters">
 A list of the type parameters. There must be at least one type parameter in the
 list.
 </param>
	<param name="closeParenToken">
 The ")" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.TypeParameter(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeParameterConstraintClauseSyntax)">
	<summary>
 Represents a type parameter on a generic type declaration.
 </summary>
	<param name="varianceKeywordOpt">
 Represents the "In" or "Out" variance keyword on a type parameter, if present.
 If no variance modifier was present, Nothing is returned.
 </param>
	<param name="identifier">
 The name of the type parameter
 </param>
	<param name="typeParameterConstraintClauseOpt">
 The "As" keyword, if any type constraints were supplied. If no type constraints
 were supplied, Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.TypeParameterSingleConstraintClause(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ConstraintSyntax)">
	<summary>
 One of the type parameter constraints clauses. This represents a constraint
 clause in the form of "As Constraint".
 </summary>
	<param name="asKeyword">
 The "As" keyword, if any type constraints were supplied. If no type constraints
 were supplied, Nothing is returned.
 </param>
	<param name="constraint">
 A list of the supplied constraints. If no constraints were supplied, Nothing is
 returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.TypeParameterMultipleConstraintClause(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ConstraintSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 One of the type parameter constraints clauses. This represents a constraint
 clause in the form of "As { Constraints }".
 </summary>
	<param name="asKeyword">
 The "As" keyword.
 </param>
	<param name="openBraceToken">
 The "{" token.
 </param>
	<param name="constraints">
 A list of the supplied constraints. If no constraints were supplied, an empty
 list is returned.
 </param>
	<param name="closeBraceToken">
 The "}" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.NewConstraint(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 One of the special type parameter constraints: New, Class or Structure. Which
 kind of special constraint it is can be obtained from the Kind property and is
 one of: NewConstraint, ReferenceConstraint or ValueConstraint.
 </summary>
	<param name="constraintKeyword">
 The "New", "Class" or "Structure" keyword that denotes the kind of special
 constraint.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ClassConstraint(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 One of the special type parameter constraints: New, Class or Structure. Which
 kind of special constraint it is can be obtained from the Kind property and is
 one of: NewConstraint, ReferenceConstraint or ValueConstraint.
 </summary>
	<param name="constraintKeyword">
 The "New", "Class" or "Structure" keyword that denotes the kind of special
 constraint.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.StructureConstraint(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 One of the special type parameter constraints: New, Class or Structure. Which
 kind of special constraint it is can be obtained from the Kind property and is
 one of: NewConstraint, ReferenceConstraint or ValueConstraint.
 </summary>
	<param name="constraintKeyword">
 The "New", "Class" or "Structure" keyword that denotes the kind of special
 constraint.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SpecialConstraint(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 One of the special type parameter constraints: New, Class or Structure. Which
 kind of special constraint it is can be obtained from the Kind property and is
 one of: NewConstraint, ReferenceConstraint or ValueConstraint.
 </summary>
	<param name="kind">
 A &amp;lt;cref c="SyntaxKind"/&amp;gt; representing the specific kind of
 SpecialConstraintSyntax. One of NewConstraint, ClassConstraint,
 StructureConstraint.
 </param>
	<param name="constraintKeyword">
 The "New", "Class" or "Structure" keyword that denotes the kind of special
 constraint.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.TypeConstraint(Roslyn.Compilers.VisualBasic.TypeSyntax)">
	<summary>
 Represents a type parameter constraint that is a type.
 </summary>
	<param name="type">
 The type describing the constraint.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EnumMemberDeclaration(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeBlockSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.EqualsValueSyntax)">
	<summary>
 Represents a name and value in an EnumDeclarationBlock.
 </summary>
	<param name="initializerOpt">
 An optional value for the enum member.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SubBlock(Roslyn.Compilers.VisualBasic.MethodBaseSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
	<param name="begin">
 The declaration that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The End XXX statement that ends the block declaration.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.FunctionBlock(Roslyn.Compilers.VisualBasic.MethodBaseSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
	<param name="begin">
 The declaration that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The End XXX statement that ends the block declaration.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ConstructorBlock(Roslyn.Compilers.VisualBasic.MethodBaseSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
	<param name="begin">
 The declaration that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The End XXX statement that ends the block declaration.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.OperatorBlock(Roslyn.Compilers.VisualBasic.MethodBaseSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
	<param name="begin">
 The declaration that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The End XXX statement that ends the block declaration.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.PropertyGetBlock(Roslyn.Compilers.VisualBasic.MethodBaseSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
	<param name="begin">
 The declaration that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The End XXX statement that ends the block declaration.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.PropertySetBlock(Roslyn.Compilers.VisualBasic.MethodBaseSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
	<param name="begin">
 The declaration that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The End XXX statement that ends the block declaration.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AddHandlerBlock(Roslyn.Compilers.VisualBasic.MethodBaseSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
	<param name="begin">
 The declaration that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The End XXX statement that ends the block declaration.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.RemoveHandlerBlock(Roslyn.Compilers.VisualBasic.MethodBaseSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
	<param name="begin">
 The declaration that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The End XXX statement that ends the block declaration.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.RaiseEventBlock(Roslyn.Compilers.VisualBasic.MethodBaseSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
	<param name="begin">
 The declaration that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The End XXX statement that ends the block declaration.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.MethodBlock(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.MethodBaseSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
	<param name="kind">
 A &amp;lt;cref c="SyntaxKind"/&amp;gt; representing the specific kind of
 MethodBlockSyntax. One of SubBlock, FunctionBlock, ConstructorBlock,
 OperatorBlock, PropertyGetBlock, PropertySetBlock, AddHandlerBlock,
 RemoveHandlerBlock, RaiseEventBlock.
 </param>
	<param name="begin">
 The declaration that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The End XXX statement that ends the block declaration.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.PropertyBlock(Roslyn.Compilers.VisualBasic.PropertyStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.MethodBlockSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a block property declaration: A declaration that has a beginning
 declaration, some get or set accessor blocks and an end statement.
 </summary>
	<param name="begin">
 The property declaration that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="accessors">
 The accessor blocks contained in the property, between the Property and the End
 Property statements.
 </param>
	<param name="end">
 The End Property statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EventBlock(Roslyn.Compilers.VisualBasic.EventStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.MethodBlockSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a custom event declaration: A declaration that has a beginning event
 declaration, some accessor blocks and an end statement.
 </summary>
	<param name="begin">
 The event declaration that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="accessors">
 The accessor blocks contained in the custom event declaration, between the
 Event statement and the End Event statement.
 </param>
	<param name="end">
 The End Event statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ParameterList(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ParameterSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents the parameter list in a method declaration.
 </summary>
	<param name="openParenToken">
 The "(" token that introduces the parameter list. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="parameters">
 The list of parameters. If no parameter list was present, Nothing is returned.
 </param>
	<param name="closeParenToken">
 The ")" token that concludes the parameter list. If no parameter list was
 present, Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SubStatement(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeBlockSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeParameterListSyntax,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax,Roslyn.Compilers.VisualBasic.HandlesClauseSyntax,Roslyn.Compilers.VisualBasic.ImplementsClauseSyntax)">
	<summary>
 The statement that declares a Sub or Function. If this method has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
	<param name="attributes">
 A list of all attribute blocks on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="identifier">
 The name of the method being declared.
 </param>
	<param name="typeParameterListOpt">
 If present, a type parameter list with generic type parameters for this method.
 If no generic type parameters were present, Nothing is returned.
 </param>
	<param name="parameterListOpt">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClauseOpt">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
	<param name="handlesClauseOpt">
 If present, a Handles clause indicated the events that this method handles.
 </param>
	<param name="implementsClauseOpt">
 If present, an Implements clause indicated the interface methods that this
 method implements.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.FunctionStatement(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeBlockSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeParameterListSyntax,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax,Roslyn.Compilers.VisualBasic.HandlesClauseSyntax,Roslyn.Compilers.VisualBasic.ImplementsClauseSyntax)">
	<summary>
 The statement that declares a Sub or Function. If this method has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
	<param name="attributes">
 A list of all attribute blocks on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="identifier">
 The name of the method being declared.
 </param>
	<param name="typeParameterListOpt">
 If present, a type parameter list with generic type parameters for this method.
 If no generic type parameters were present, Nothing is returned.
 </param>
	<param name="parameterListOpt">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClauseOpt">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
	<param name="handlesClauseOpt">
 If present, a Handles clause indicated the events that this method handles.
 </param>
	<param name="implementsClauseOpt">
 If present, an Implements clause indicated the interface methods that this
 method implements.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.MethodStatement(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeBlockSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeParameterListSyntax,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax,Roslyn.Compilers.VisualBasic.HandlesClauseSyntax,Roslyn.Compilers.VisualBasic.ImplementsClauseSyntax)">
	<summary>
 The statement that declares a Sub or Function. If this method has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
	<param name="kind">
 A &amp;lt;cref c="SyntaxKind"/&amp;gt; representing the specific kind of
 MethodStatementSyntax. One of SubStatement, FunctionStatement.
 </param>
	<param name="attributes">
 A list of all attribute blocks on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="identifier">
 The name of the method being declared.
 </param>
	<param name="typeParameterListOpt">
 If present, a type parameter list with generic type parameters for this method.
 If no generic type parameters were present, Nothing is returned.
 </param>
	<param name="parameterListOpt">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClauseOpt">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
	<param name="handlesClauseOpt">
 If present, a Handles clause indicated the events that this method handles.
 </param>
	<param name="implementsClauseOpt">
 If present, an Implements clause indicated the interface methods that this
 method implements.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ConstructorStatement(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeBlockSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 A statement that declares a constructor. This statement will be the Begin of a
 BlockStatement with Kind=MethodDeclarationBlock, and the body of the method
 will be the Body of that BlockStatement.
 </summary>
	<param name="attributes">
 A list of all attribute blocks on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="newKeyword">
 The "New" keyword in the constructor declaration.
 </param>
	<param name="parameterListOpt">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClauseOpt">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DeclareSubStatement(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeBlockSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.LiteralExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.LiteralExpressionSyntax,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 A Declare statement that declares an external DLL method.
 </summary>
	<param name="attributes">
 A list of all attribute blocks on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="declareKeyword">
 The "Declare" keyword.
 </param>
	<param name="charsetKeywordOpt">
 If present, the keyword that defines the string translation semantics of the
 external method.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="identifier">
 The name of the method being declared.
 </param>
	<param name="libKeyword">
 The "Lib" keyword.
 </param>
	<param name="libraryName">
 The string literal with the library name.
 </param>
	<param name="aliasKeywordOpt">
 If present, the "Alias" keyword. If not present, returns Nothing.
 </param>
	<param name="aliasNameOpt">
 The string literal with the alias. If not present, returns Nothing.
 </param>
	<param name="parameterListOpt">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClauseOpt">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DeclareFunctionStatement(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeBlockSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.LiteralExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.LiteralExpressionSyntax,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 A Declare statement that declares an external DLL method.
 </summary>
	<param name="attributes">
 A list of all attribute blocks on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="declareKeyword">
 The "Declare" keyword.
 </param>
	<param name="charsetKeywordOpt">
 If present, the keyword that defines the string translation semantics of the
 external method.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="identifier">
 The name of the method being declared.
 </param>
	<param name="libKeyword">
 The "Lib" keyword.
 </param>
	<param name="libraryName">
 The string literal with the library name.
 </param>
	<param name="aliasKeywordOpt">
 If present, the "Alias" keyword. If not present, returns Nothing.
 </param>
	<param name="aliasNameOpt">
 The string literal with the alias. If not present, returns Nothing.
 </param>
	<param name="parameterListOpt">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClauseOpt">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DeclareStatement(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeBlockSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.LiteralExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.LiteralExpressionSyntax,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 A Declare statement that declares an external DLL method.
 </summary>
	<param name="kind">
 A &amp;lt;cref c="SyntaxKind"/&amp;gt; representing the specific kind of
 DeclareStatementSyntax. One of DeclareSubStatement, DeclareFunctionStatement.
 </param>
	<param name="attributes">
 A list of all attribute blocks on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="declareKeyword">
 The "Declare" keyword.
 </param>
	<param name="charsetKeywordOpt">
 If present, the keyword that defines the string translation semantics of the
 external method.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="identifier">
 The name of the method being declared.
 </param>
	<param name="libKeyword">
 The "Lib" keyword.
 </param>
	<param name="libraryName">
 The string literal with the library name.
 </param>
	<param name="aliasKeywordOpt">
 If present, the "Alias" keyword. If not present, returns Nothing.
 </param>
	<param name="aliasNameOpt">
 The string literal with the alias. If not present, returns Nothing.
 </param>
	<param name="parameterListOpt">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClauseOpt">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DelegateSubStatement(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeBlockSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeParameterListSyntax,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 A statement that declares a delegate type.
 </summary>
	<param name="attributes">
 A list of all attribute blocks on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="delegateKeyword">
 The "Delegate" keyword.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="identifier">
 The name of the delegate being declared.
 </param>
	<param name="typeParameterListOpt">
 If present, a type parameter list with generic type parameters for this
 delegate. If no generic type parameters were present, Nothing is returned.
 </param>
	<param name="parameterListOpt">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClauseOpt">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DelegateFunctionStatement(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeBlockSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeParameterListSyntax,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 A statement that declares a delegate type.
 </summary>
	<param name="attributes">
 A list of all attribute blocks on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="delegateKeyword">
 The "Delegate" keyword.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="identifier">
 The name of the delegate being declared.
 </param>
	<param name="typeParameterListOpt">
 If present, a type parameter list with generic type parameters for this
 delegate. If no generic type parameters were present, Nothing is returned.
 </param>
	<param name="parameterListOpt">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClauseOpt">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DelegateStatement(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeBlockSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeParameterListSyntax,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 A statement that declares a delegate type.
 </summary>
	<param name="kind">
 A &amp;lt;cref c="SyntaxKind"/&amp;gt; representing the specific kind of
 DelegateStatementSyntax. One of DelegateSubStatement,
 DelegateFunctionStatement.
 </param>
	<param name="attributes">
 A list of all attribute blocks on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="delegateKeyword">
 The "Delegate" keyword.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="identifier">
 The name of the delegate being declared.
 </param>
	<param name="typeParameterListOpt">
 If present, a type parameter list with generic type parameters for this
 delegate. If no generic type parameters were present, Nothing is returned.
 </param>
	<param name="parameterListOpt">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClauseOpt">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EventStatement(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeBlockSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax,Roslyn.Compilers.VisualBasic.ImplementsClauseSyntax)">
	<summary>
 A statement that declares an event. If the event being declared is a custom
 event, this statement will be the Begin of a PropertyOrEventBlock, and the
 accessors will be part of the Accessors of that node.
 </summary>
	<param name="attributes">
 A list of all attribute blocks on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="customKeywordOpt">
 The optional Custom keyword for custom event declarations.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="identifier">
 The name of the event being declared.
 </param>
	<param name="parameterListOpt">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClauseOpt">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
	<param name="implementsClauseOpt">
 If present, an Implements clause indicates the interface methods that this
 method implements.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.OperatorStatement(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeBlockSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 A statement that declares an operator. If this operator has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
	<param name="attributes">
 A list of all attribute blocks on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="operator">
 The operator being defined.
 </param>
	<param name="parameterListOpt">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClauseOpt">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.PropertyStatement(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeBlockSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax,Roslyn.Compilers.VisualBasic.EqualsValueSyntax,Roslyn.Compilers.VisualBasic.ImplementsClauseSyntax)">
	<summary>
 Statement that declares a property. If this property has accessors declared,
 this statement will be the Begin of a BlockNode, and the accessors will be the
 Body of that node. Auto properties are property declarations without a
 PropertyBlock.
 </summary>
	<param name="attributes">
 A list of all attribute blocks on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="identifier">
 The name of the property being declared.
 </param>
	<param name="parameterListOpt">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClauseOpt">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
	<param name="initializerOpt">
 If present, an "= initial-value" clause describing the initial value of the
 property.
 </param>
	<param name="implementsClauseOpt">
 If present, an Implements clause indicated the interface methods that this
 method implements.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.GetAccessorStatement(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeBlockSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
	<param name="attributes">
 A list of all attribute blocks on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="parameterListOpt">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClauseOpt">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SetAccessorStatement(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeBlockSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
	<param name="attributes">
 A list of all attribute blocks on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="parameterListOpt">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClauseOpt">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AddHandlerAccessorStatement(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeBlockSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
	<param name="attributes">
 A list of all attribute blocks on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="parameterListOpt">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClauseOpt">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.RemoveHandlerAccessorStatement(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeBlockSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
	<param name="attributes">
 A list of all attribute blocks on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="parameterListOpt">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClauseOpt">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.RaiseEventHandlerAccessorStatement(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeBlockSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
	<param name="attributes">
 A list of all attribute blocks on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="parameterListOpt">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClauseOpt">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AccessorStatement(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeBlockSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
	<param name="kind">
 A &amp;lt;cref c="SyntaxKind"/&amp;gt; representing the specific kind of
 AccessorStatementSyntax. One of GetAccessorStatement, SetAccessorStatement,
 AddHandlerAccessorStatement, RemoveHandlerAccessorStatement,
 RaiseEventHandlerAccessorStatement.
 </param>
	<param name="attributes">
 A list of all attribute blocks on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="parameterListOpt">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClauseOpt">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ImplementsClause(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.QualifiedNameSyntax})">
	<summary>
 Represents the "Implements ..." clause on a type member, which describes which
 interface members this member implements.
 </summary>
	<param name="implementsKeyword">
 The "Implements" keyword.
 </param>
	<param name="interfaceMembers">
 The list of interface members being implemented.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.HandlesClause(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.HandlesClauseItemSyntax})">
	<summary>
 Represents the "Handles ..." clause on a method declaration that describes
 which events this method handles.
 </summary>
	<param name="handlesKeyword">
 The "Handles" keyword.
 </param>
	<param name="events">
 The list of event members being handled.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.HandlesClauseItem(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a single handled event in a "Handles ..." clause.
 </summary>
	<param name="eventContainer">
 The container of the event. This can either be an simple identifier
 (identifying a members of the containing type) or one of the special keywords
 "Me", "MyBase" or "MyClass".
 </param>
	<param name="dotToken">
 The "." token.
 </param>
	<param name="eventMember">
 The event being handled. This must be a simple identifier.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.IncompleteMember(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeBlockSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList)">
	<summary>
 Represents the beginning of a declaration. However, not enough syntax is
 detected to classify this as a field, method, property or event. This is node
 always represents a syntax error.
 </summary>
	<param name="attributes">
 A list of all attribute blocks on this declaration. If no attributes were
 specified, an empty list is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.FieldDeclaration(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeBlockSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.VariableDeclaratorSyntax})">
	<summary>
 Represents the declaration of one or more variables or constants, either as
 local variables or as class/structure members. In the case of a constant, it is
 represented by having "Const" in the Modifiers (although technically "Const" is
 not a modifier, it is represented as one in the parse trees.)
 </summary>
	<param name="attributes">
 A list of all attribute blocks on this declaration. If no attributes were
 specified, an empty list is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </param>
	<param name="declarators">
 The list of variable declarator. Each declarator specifies one or more variable
 names along with a type and/or initializer.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.VariableDeclarator(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ModifiedIdentifierSyntax},Roslyn.Compilers.VisualBasic.AsClauseSyntax,Roslyn.Compilers.VisualBasic.EqualsValueSyntax)">
	<summary>
 Represents the part of a variable or constant declaration statement that
 associated one or more variable names with a type.
 </summary>
	<param name="names">
 The names of the variables being declared. Each name might have a "?" or "()"
 modifier(s) attached.
 </param>
	<param name="asClauseOpt">
 The "As" clause that describes the return type, and possibly includes "New",
 "With" or "From". If no As clause was present, Nothing is returned.
 </param>
	<param name="initializerOpt">
 If present, an "= initial-value" clause describing the initial value of the
 variable or the value of the constant.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SimpleAsClause(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeBlockSyntax},Roslyn.Compilers.VisualBasic.TypeSyntax)">
	<summary>
 Represents an "As {type-name}" clause that does not have an initializer or
 "New". The type has optional attributes associated with it, although attributes
 are not permitted in all possible places where this node occurs.
 </summary>
	<param name="asKeyword">
 The "As" keyword.
 </param>
	<param name="attributes">
 A list of all attribute blocks on the type. If no attributes were specified, an
 empty list is returned.
 </param>
	<param name="type">
 The type-name part of the As clause.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AsNewClause(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.NewExpressionSyntax)">
	<summary>
 Represents an "As New {type-name} [arguments] [initializers]" clause in a
 declaration. The type has optional attributes associated with it, although
 attributes are not permitted in many places where this node occurs (they are
 permitted, for example, on automatically implemented properties.)
 </summary>
	<param name="asKeyword">
 The "As" keyword.
 </param>
	<param name="newExpression">
 The New expression
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ObjectMemberInitializer(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.FieldInitializerSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a "With {...} clause used to initialize a new object's members.
 </summary>
	<param name="withKeyword">
 The "With" keyword.
 </param>
	<param name="openBraceToken">
 The "{" token.
 </param>
	<param name="initializers">
 The comma-separated list of field initializers.
 </param>
	<param name="closeBraceToken">
 The "}" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ObjectCollectionInitializer(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.CollectionInitializerSyntax)">
	<summary>
 Represents a "From {...} clause used to initialize a new collection object's
 elements.
 </summary>
	<param name="fromKeyword">
 The "From" keyword.
 </param>
	<param name="initializer">
 The initializer including the braces.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.InferredFieldInitializer(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represent a field initializer in a With {...} initializer where the field name
 is inferred from the initializer expression.
 </summary>
	<param name="keyKeywordOpt">
 The optional "Key" keyword.
 </param>
	<param name="expression">
 The value being assigned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.NamedFieldInitializer(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represent a named field initializer in a With {...} initializer, such as ".x =
 expr".
 </summary>
	<param name="keyKeywordOpt">
 The optional "Key" keyword.
 </param>
	<param name="dotToken">
 The "." token.
 </param>
	<param name="identifier">
 The name of the field being initialized.
 </param>
	<param name="equalsToken">
 The "=" token.
 </param>
	<param name="expression">
 The value being assigned to the field.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EqualsValue(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents an "= initializer" clause in a declaration for a variable,
 pararameter or automatic property.
 </summary>
	<param name="equalsToken">
 The "=" token.
 </param>
	<param name="value">
 The expression used as the initial value.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.Parameter(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeBlockSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.ModifiedIdentifierSyntax,Roslyn.Compilers.VisualBasic.SimpleAsClauseSyntax,Roslyn.Compilers.VisualBasic.EqualsValueSyntax)">
	<summary>
 Represent a parameter to a method, property, constructor, etc.
 </summary>
	<param name="attributes">
 A list of all attribute blocks on this parameter. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of the modifier tokens "ByVal", "ByRef", "Optional" or "ParamArray" that
 modify this parameter.
 </param>
	<param name="identifier">
 The name of the parameter, including any "?" or "()" modifiers.
 </param>
	<param name="asClauseOpt">
 If present, the "As type-name" clause describing the type of the parameter. If
 no As clause is present, Nothing is returned.
 </param>
	<param name="defaultOpt">
 If present, an initializer with the default value of the parameter. If no
 default value is present, Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ModifiedIdentifier(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ArgumentListSyntax,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.ArrayRankSpecifierSyntax})">
	<summary>
 Represents an identifier with optional "?" or "()" or "(,,,)" modifiers, as
 used in parameter declarations and variable declarations.
 </summary>
	<param name="identifier">
 The identifier that names the item being declared.
 </param>
	<param name="nullableOpt">
 The "?" token that indicates a nullable type.
 </param>
	<param name="arrayBoundsOpt">
 The optional array bounds, such as "(4)" or "(0 to 5, 0 To 6)".
 </param>
	<param name="arrayRankSpecifiers">
 A list of array modifiers for the type. If no array modifiers were present, an
 empty list is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ArrayRankSpecifier(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a modifier that describes an array type, without bounds, such as
 "()" or "(,)".
 </summary>
	<param name="openParenToken">
 The "(" token.
 </param>
	<param name="commaTokens">
 The comma tokens in the array type. There is one less comma than the rank.
 </param>
	<param name="closeParenToken">
 The ")" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AttributeBlock(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.AttributeSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a group of attributes within "&amp;lt;" and "&amp;gt;" brackets.
 </summary>
	<param name="lessThanToken">
 The "&amp;lt;" token.
 </param>
	<param name="attributes">
 A comma separated list of attribute declarations in this attribute block.
 </param>
	<param name="greaterThanToken">
 The "&amp;gt;" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.Attribute(Roslyn.Compilers.VisualBasic.AttributeTargetSyntax,Roslyn.Compilers.VisualBasic.TypeSyntax,Roslyn.Compilers.VisualBasic.ArgumentListSyntax)">
	<summary>
 Represents a single attribute declaration within an attribute block.
 </summary>
	<param name="targetOpt">
 Optional attribute target. Assembly|Module :
 </param>
	<param name="name">
 The name of the attribute.
 </param>
	<param name="argumentListOpt">
 The argument list, if present. If no argument list was supplied, Nothing is
 returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AttributeTarget(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a single attribute declaration within an attribute block.
 </summary>
	<param name="attributeModifier">
 The "Assembly" or "Module" attribute modifier, is present. If no attribute
 modifier is present, Nothing is returned.
 </param>
	<param name="colonToken">
 The ":" token, if an attribute modifier is present. If no attribute modifier is
 present, Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AttributesStatement(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeBlockSyntax})">
	<summary>
 Represents a file-level attribute, in which the attributes have no other
 syntactic element they are attached to.
 </summary>
	<param name="attributes">
 The list of attribute blocks.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.WhileBlock(Roslyn.Compilers.VisualBasic.WhileStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a While...End While statement, including the While, body and End
 While.
 </summary>
	<param name="begin">
 The While statement that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the While...End While. This might be an empty list.
 </param>
	<param name="end">
 The End While statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.UsingBlock(Roslyn.Compilers.VisualBasic.UsingStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents an entire Using...End Using statement, including the Using, body and
 End Using statements.
 </summary>
	<param name="begin">
 The UsingStatement that begins the Using...End Using block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the Using...End Using block. This might be an empty
 list.
 </param>
	<param name="end">
 The End Using statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SyncLockBlock(Roslyn.Compilers.VisualBasic.SyncLockStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a entire SyncLock...End SyncLock block, including the SyncLock
 statement, the enclosed statements, and the End SyncLock statment.
 </summary>
	<param name="begin">
 The SyncLock statement that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the SyncLock...End SyncLock statement. This might
 be an empty list.
 </param>
	<param name="end">
 The End SyncLock statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.WithBlock(Roslyn.Compilers.VisualBasic.WithStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a With...End With block, include the With statement, the body of the
 block and the End With statement.
 </summary>
	<param name="begin">
 The WithStatement that begins the With...End With block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the With...End With block. This might be an empty
 list.
 </param>
	<param name="end">
 The End With statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.LocalDeclaration(Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.VariableDeclaratorSyntax})">
	<summary>
 Represents the declaration of one or more local variables or constants.
 </summary>
	<param name="modifiers">
 The modifier token (Static, Dim or Const) that introduces this local variable
 declaration.
 </param>
	<param name="declarators">
 The list of variable declarator. Each declarator specifies one or more variable
 names along with a type and/or initializer.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.LabelStatement(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a label statement.
 </summary>
	<param name="labelName">
 The name of the label. If the label is a line number, returns an IntegerLiteral
 that is the line number, otherwise, returns an Identifier.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.GoToStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a "GoTo" statement.
 </summary>
	<param name="goToKeyword">
 The "GoTo" keyword.
 </param>
	<param name="labelName">
 The name of the label. If the label is a line number, returns an IntegerLiteral
 that is the line number, otherwise, returns an Identifier.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.StopStatement(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a "Stop" or "End" statement. The Kind can be used to determine which
 kind of statement this is.
 </summary>
	<param name="stopOrEndKeyword">
 The "Stop" or "End" keyword.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndStatement(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a "Stop" or "End" statement. The Kind can be used to determine which
 kind of statement this is.
 </summary>
	<param name="stopOrEndKeyword">
 The "Stop" or "End" keyword.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.StopOrEndStatement(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a "Stop" or "End" statement. The Kind can be used to determine which
 kind of statement this is.
 </summary>
	<param name="kind">
 A &amp;lt;cref c="SyntaxKind"/&amp;gt; representing the specific kind of
 StopOrEndStatementSyntax. One of StopStatement, EndStatement.
 </param>
	<param name="stopOrEndKeyword">
 The "Stop" or "End" keyword.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ExitDoStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
	<param name="exitKeyword">
 The "Exit" keyword.
 </param>
	<param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ExitForStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
	<param name="exitKeyword">
 The "Exit" keyword.
 </param>
	<param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ExitSubStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
	<param name="exitKeyword">
 The "Exit" keyword.
 </param>
	<param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ExitFunctionStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
	<param name="exitKeyword">
 The "Exit" keyword.
 </param>
	<param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ExitOperatorStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
	<param name="exitKeyword">
 The "Exit" keyword.
 </param>
	<param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ExitPropertyStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
	<param name="exitKeyword">
 The "Exit" keyword.
 </param>
	<param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ExitTryStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
	<param name="exitKeyword">
 The "Exit" keyword.
 </param>
	<param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ExitSelectStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
	<param name="exitKeyword">
 The "Exit" keyword.
 </param>
	<param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ExitWhileStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
	<param name="exitKeyword">
 The "Exit" keyword.
 </param>
	<param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ExitStatement(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
	<param name="kind">
 A &amp;lt;cref c="SyntaxKind"/&amp;gt; representing the specific kind of
 ExitStatementSyntax. One of ExitDoStatement, ExitForStatement,
 ExitSubStatement, ExitFunctionStatement, ExitOperatorStatement,
 ExitPropertyStatement, ExitTryStatement, ExitSelectStatement,
 ExitWhileStatement.
 </param>
	<param name="exitKeyword">
 The "Exit" keyword.
 </param>
	<param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ContinueWhileStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a "Continue (block)" statement. THe kind of block referenced can be
 determined by examining the Kind.
 </summary>
	<param name="continueKeyword">
 The "Continue" keyword.
 </param>
	<param name="blockKeyword">
 The "Do", "For" or "While" keyword that identifies the kind of loop being
 continued.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ContinueDoStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a "Continue (block)" statement. THe kind of block referenced can be
 determined by examining the Kind.
 </summary>
	<param name="continueKeyword">
 The "Continue" keyword.
 </param>
	<param name="blockKeyword">
 The "Do", "For" or "While" keyword that identifies the kind of loop being
 continued.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ContinueForStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a "Continue (block)" statement. THe kind of block referenced can be
 determined by examining the Kind.
 </summary>
	<param name="continueKeyword">
 The "Continue" keyword.
 </param>
	<param name="blockKeyword">
 The "Do", "For" or "While" keyword that identifies the kind of loop being
 continued.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ContinueStatement(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a "Continue (block)" statement. THe kind of block referenced can be
 determined by examining the Kind.
 </summary>
	<param name="kind">
 A &amp;lt;cref c="SyntaxKind"/&amp;gt; representing the specific kind of
 ContinueStatementSyntax. One of ContinueWhileStatement, ContinueDoStatement,
 ContinueForStatement.
 </param>
	<param name="continueKeyword">
 The "Continue" keyword.
 </param>
	<param name="blockKeyword">
 The "Do", "For" or "While" keyword that identifies the kind of loop being
 continued.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ReturnStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a "Return" statement.
 </summary>
	<param name="returnKeyword">
 The "Return" keyword.
 </param>
	<param name="expressionOpt">
 The expression being returned, if present.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SingleLineIfStatement(Roslyn.Compilers.VisualBasic.SingleLineIfPartSyntax,Roslyn.Compilers.VisualBasic.SingleLineElsePartSyntax)">
	<summary>
 Represents a line If-Then-Else statement.
 </summary>
	<param name="ifPart">
 The If part of the statement.
 </param>
	<param name="elsePartOpt">
 The Else part of the statement. If there is no Else part, Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SingleLineIfPart(Roslyn.Compilers.VisualBasic.IfStatementSyntax,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Represents part of a single line If statement, consisting of a beginning
 if-statement, followed by a body of statement controlled by that beginning
 statement. The Kind property returns if this is an SingleLineIf.
 </summary>
	<param name="begin">
 The statement that introduces this part of the If...Then...Else...End If. This
 must be an IfStatement.
 </param>
	<param name="statements">
 The statements controlled by this If or Else If. This might be an empty list.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SingleLineElsePart(Roslyn.Compilers.VisualBasic.ElseStatementSyntax,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Represents the Else part of an If statement, consisting of a Else statement,
 followed by a body of statement controlled by that Else.
 </summary>
	<param name="begin">
 The Else statement that introduces this part.
 </param>
	<param name="statements">
 The statements controlled by the Else.This might be an empty list.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.MultiLineIfBlock(Roslyn.Compilers.VisualBasic.IfPartSyntax,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.IfPartSyntax},Roslyn.Compilers.VisualBasic.ElsePartSyntax,Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a block If...Then...Else...EndIf Statement. The Kind property can be
 used to determine if it is a block or line If.
 </summary>
	<param name="ifPart">
 The If part of the statement.
 </param>
	<param name="elseIfParts">
 A list of the "ElseIf" parts of the statement. If there are no ElseIf parts,
 then an empty list is returned.
 </param>
	<param name="elsePartOpt">
 The Else part of the statement. If there is no Else part, Nothing is returned.
 </param>
	<param name="endIf">
 If this is a block if, returns the "End If" statement.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.IfPart(Roslyn.Compilers.VisualBasic.IfStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Represents part of an If statement, consisting of a beginning statement (If or
 ElseIf), followed by a body of statement controlled by that beginning
 statement. The Kind property returns if this is an If or ElseIf.
 </summary>
	<param name="begin">
 The statement that introduces this part of the If...Then...Else...End If. This
 must be an IfStatement.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements controlled by this If or Else If. This might be an empty list.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ElseIfPart(Roslyn.Compilers.VisualBasic.IfStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Represents part of an If statement, consisting of a beginning statement (If or
 ElseIf), followed by a body of statement controlled by that beginning
 statement. The Kind property returns if this is an If or ElseIf.
 </summary>
	<param name="begin">
 The statement that introduces this part of the If...Then...Else...End If. This
 must be an IfStatement.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements controlled by this If or Else If. This might be an empty list.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ElsePart(Roslyn.Compilers.VisualBasic.ElseStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Represents the Else part of an If statement, consisting of a Else statement,
 followed by a body of statement controlled by that Else.
 </summary>
	<param name="begin">
 The Else statement that introduces this part.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements controlled by the Else. This might be an empty list.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.IfStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents the If part or ElseIf part of a If...End If block (or line If). This
 statement is always the Begin of a IfPart. The Kind can be examined to
 determine if this is an If or an ElseIf statement.
 </summary>
	<param name="elseKeywordOpt">
 If this ElseIf was written as "Else If", contains the "Else" keyword. Otherwise
 returns Nothing.
 </param>
	<param name="ifOrElseIfKeyword">
 The "If" or "ElseIf" keyword.
 </param>
	<param name="condition">
 The boolean expression that is being tested.
 </param>
	<param name="thenKeywordOpt">
 The "Then" keyword.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ElseIfStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents the If part or ElseIf part of a If...End If block (or line If). This
 statement is always the Begin of a IfPart. The Kind can be examined to
 determine if this is an If or an ElseIf statement.
 </summary>
	<param name="elseKeywordOpt">
 If this ElseIf was written as "Else If", contains the "Else" keyword. Otherwise
 returns Nothing.
 </param>
	<param name="ifOrElseIfKeyword">
 The "If" or "ElseIf" keyword.
 </param>
	<param name="condition">
 The boolean expression that is being tested.
 </param>
	<param name="thenKeywordOpt">
 The "Then" keyword.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ElseStatement(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents the Else part of a If...End If block (or line If). This statement is
 always the Begin of a ElsePart.
 </summary>
	<param name="elseKeyword">
 The "Else" keyword
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.TryBlock(Roslyn.Compilers.VisualBasic.TryPartSyntax,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.CatchPartSyntax},Roslyn.Compilers.VisualBasic.FinallyPartSyntax,Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents an entire Try...Catch...Finally...End Try statement.
 </summary>
	<param name="tryPart">
 The Try part of the statement.
 </param>
	<param name="catchParts">
 A list of the Catch parts of the statement. If there are no Catch parts, then
 an empty list is returned.
 </param>
	<param name="finallyPartOpt">
 The Finally part of the statement, if present.
 </param>
	<param name="end">
 The "End Try" statement.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.TryPart(Roslyn.Compilers.VisualBasic.TryStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Represents part of an Try...Catch...Finally...End Try statement, consisting of
 a beginning statement (Try, Catch or Finally), followed by a body of statements
 controlled by that beginning statement. The Kind property returns which kind of
 part this is.
 </summary>
	<param name="begin">
 The TryStatement that introduces this part of the Try...Catch...Finally...End
 Try.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements inside the Try part of the Try...Catch...Finally...End Try. This
 might be an empty list.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CatchPart(Roslyn.Compilers.VisualBasic.CatchStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Represents a Catch part of an Try...Catch...Finally...End Try statement,
 consisting of a Catch statement, followed by a body of statements controlled by
 that Catch statement. The Kind property returns which kind of part this is.
 </summary>
	<param name="begin">
 The CatchStatement that introduces this part.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements controlled by the Catch statement. This might be an empty list.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.FinallyPart(Roslyn.Compilers.VisualBasic.FinallyStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Represents the Finally part of an Try...Catch...Finally...End Try statement,
 consisting of a Finally statement, followed by a body of statements controlled
 by the Finally.
 </summary>
	<param name="begin">
 The FinallyStatement that introduces the Finally part of a Try.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements inside the Finally part of the Try...Catch...Finally...End Try.
 This might be an empty list.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.TryStatement(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents the Try part part of a Try...Catch...Finally...End Try. This
 statement is always the Begin of a TryPart.
 </summary>
	<param name="tryKeyword">
 The "Try" keyword
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CatchStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SimpleAsClauseSyntax,Roslyn.Compilers.VisualBasic.CatchFilterClauseSyntax)">
	<summary>
 Represents the Catch part part of a Try...Catch...Finally...End Try. This
 statement is always the Begin of a CatchPart.
 </summary>
	<param name="catchKeyword">
 The "Catch" keyword.
 </param>
	<param name="identifierOpt">
 The identifier representing the exception that was caught, if present.
 </param>
	<param name="asClauseOpt">
 The As clause that defines the type of exception being caught.
 </param>
	<param name="whenClauseOpt">
 The "When" clause, if present.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CatchFilterClause(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents the When/Filter clause of a Catch statement
 </summary>
	<param name="whenKeyword">
 The "When" keyword
 </param>
	<param name="filter">
 The filter expression
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.FinallyStatement(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents the Finally part part of a Try...Catch...Finally...End Try. This
 statement is always the Begin of a FinallyPart.
 </summary>
	<param name="finallyKeyword">
 The "Finally" keyword.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ErrorStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents the "Error" statement.
 </summary>
	<param name="errorKeyword">
 The "Error" keyword.
 </param>
	<param name="errorNumber">
 The expression that represents the error number.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.OnErrorGoToZeroStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an OnError Goto statement.
 </summary>
	<param name="onKeyword">
 The "On" keyword
 </param>
	<param name="errorKeyword">
 The "Error" keyword.
 </param>
	<param name="goToKeyword">
 The "GoTo" keyword
 </param>
	<param name="minusOpt">
 An optional minus for On Error Goto -1
 </param>
	<param name="label">
 The name of the label. If the label is a line number, 0 or -1, returns an
 IntegerLiteralToken that is the line number, otherwise, returns an Identifier.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.OnErrorGoToMinusOneStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an OnError Goto statement.
 </summary>
	<param name="onKeyword">
 The "On" keyword
 </param>
	<param name="errorKeyword">
 The "Error" keyword.
 </param>
	<param name="goToKeyword">
 The "GoTo" keyword
 </param>
	<param name="minusOpt">
 An optional minus for On Error Goto -1
 </param>
	<param name="label">
 The name of the label. If the label is a line number, 0 or -1, returns an
 IntegerLiteralToken that is the line number, otherwise, returns an Identifier.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.OnErrorGoToLabelStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an OnError Goto statement.
 </summary>
	<param name="onKeyword">
 The "On" keyword
 </param>
	<param name="errorKeyword">
 The "Error" keyword.
 </param>
	<param name="goToKeyword">
 The "GoTo" keyword
 </param>
	<param name="minusOpt">
 An optional minus for On Error Goto -1
 </param>
	<param name="label">
 The name of the label. If the label is a line number, 0 or -1, returns an
 IntegerLiteralToken that is the line number, otherwise, returns an Identifier.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.OnErrorGoToStatement(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an OnError Goto statement.
 </summary>
	<param name="kind">
 A &amp;lt;cref c="SyntaxKind"/&amp;gt; representing the specific kind of
 OnErrorGoToStatementSyntax. One of OnErrorGoToZeroStatement,
 OnErrorGoToMinusOneStatement, OnErrorGoToLabelStatement.
 </param>
	<param name="onKeyword">
 The "On" keyword
 </param>
	<param name="errorKeyword">
 The "Error" keyword.
 </param>
	<param name="goToKeyword">
 The "GoTo" keyword
 </param>
	<param name="minusOpt">
 An optional minus for On Error Goto -1
 </param>
	<param name="label">
 The name of the label. If the label is a line number, 0 or -1, returns an
 IntegerLiteralToken that is the line number, otherwise, returns an Identifier.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.OnErrorResumeNextStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an OnError Resume Next statement.
 </summary>
	<param name="onKeyword">
 The "On" keyword
 </param>
	<param name="errorKeyword">
 The "Error" keyword.
 </param>
	<param name="resumeKeyword">
 The "Resume" keyword.
 </param>
	<param name="nextKeyword">
 The "Next"
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ResumeStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a "Resume" statement. The Kind property can be used to determine if
 this is a "Resume", "Resume Next" or "Resume label" statement.
 </summary>
	<param name="resumeKeyword">
 The "Resume" keyword.
 </param>
	<param name="labelOpt">
 The label. The value of this depends on the Kind. If Kind=Resume, returns
 Nothing. If Kind=ResumeNext, returns the keyword "Next", If Kind=ResumeLabel,
 returns an Identifier or IntegerLiteralToken with the label or line number.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ResumeLabelStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a "Resume" statement. The Kind property can be used to determine if
 this is a "Resume", "Resume Next" or "Resume label" statement.
 </summary>
	<param name="resumeKeyword">
 The "Resume" keyword.
 </param>
	<param name="labelOpt">
 The label. The value of this depends on the Kind. If Kind=Resume, returns
 Nothing. If Kind=ResumeNext, returns the keyword "Next", If Kind=ResumeLabel,
 returns an Identifier or IntegerLiteralToken with the label or line number.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ResumeNextStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a "Resume" statement. The Kind property can be used to determine if
 this is a "Resume", "Resume Next" or "Resume label" statement.
 </summary>
	<param name="resumeKeyword">
 The "Resume" keyword.
 </param>
	<param name="labelOpt">
 The label. The value of this depends on the Kind. If Kind=Resume, returns
 Nothing. If Kind=ResumeNext, returns the keyword "Next", If Kind=ResumeLabel,
 returns an Identifier or IntegerLiteralToken with the label or line number.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SelectBlock(Roslyn.Compilers.VisualBasic.SelectStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.CaseBlockSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a Select Case block, including the Select Case that begins it, the
 contains Case blocks and the End Select.
 </summary>
	<param name="begin">
 The Select Case statement that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="caseBlocks">
 A list of the contained Case blocks.
 </param>
	<param name="end">
 The End Select statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SelectStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a Select Case statement. This statement always occurs as the Begin
 of a SelectBlock.
 </summary>
	<param name="selectKeyword">
 The "Select" keyword.
 </param>
	<param name="caseKeywordOpt">
 The "Case" keyword, if present.
 </param>
	<param name="expression">
 The value that branching is based on.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CaseBlock(Roslyn.Compilers.VisualBasic.CaseStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Represents a case statement and its subsequent block.
 </summary>
	<param name="begin">
 The statement that begins the case block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the case block. This might be an empty list.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CaseElseBlock(Roslyn.Compilers.VisualBasic.CaseStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Represents a case statement and its subsequent block.
 </summary>
	<param name="begin">
 The statement that begins the case block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the case block. This might be an empty list.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CaseStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.CaseClauseSyntax})">
	<summary>
 Represents a Case or Case Else statement. This statement is always the Begin of
 a CaseBlock. If this is a Case Else statement, the Kind=CaseElse, otherwise the
 Kind=Case.
 </summary>
	<param name="caseKeyword">
 The "Case" keyword
 </param>
	<param name="cases">
 A list of clauses associated with this Case. If Kind=CaseElse, then this list
 has exactly one child, which is a CaseElseClause.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CaseElseStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.CaseClauseSyntax})">
	<summary>
 Represents a Case or Case Else statement. This statement is always the Begin of
 a CaseBlock. If this is a Case Else statement, the Kind=CaseElse, otherwise the
 Kind=Case.
 </summary>
	<param name="caseKeyword">
 The "Case" keyword
 </param>
	<param name="cases">
 A list of clauses associated with this Case. If Kind=CaseElse, then this list
 has exactly one child, which is a CaseElseClause.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CaseElseClause(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 The "Else" part in a Case Else statement.
 </summary>
	<param name="elseKeyword">
 The "Else" keyword.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CaseValueClause(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a single value in a Case.
 </summary>
	<param name="value">
 The expression that denotes the value being tested against.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CaseRangeClause(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a range "expression To expression" in a Case.
 </summary>
	<param name="lowerBound">
 The lower bound of the range.
 </param>
	<param name="toKeyword">
 The "To" keyword
 </param>
	<param name="upperBound">
 The upper bound of the range.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CaseEqualsClause(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a relation clause in a Case statement, such as "Is &amp;gt;
 expression".
 </summary>
	<param name="isKeywordOpt">
 The "Is" keyword, if present.
 </param>
	<param name="operatorToken">
 The operator in the relational clause. One of "=", "&amp;lt;", "&amp;gt;",
 "&amp;lt;=" or "&amp;gt;=".
 </param>
	<param name="value">
 The expression that denotes the value being tested against.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CaseNotEqualsClause(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a relation clause in a Case statement, such as "Is &amp;gt;
 expression".
 </summary>
	<param name="isKeywordOpt">
 The "Is" keyword, if present.
 </param>
	<param name="operatorToken">
 The operator in the relational clause. One of "=", "&amp;lt;", "&amp;gt;",
 "&amp;lt;=" or "&amp;gt;=".
 </param>
	<param name="value">
 The expression that denotes the value being tested against.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CaseLessThanClause(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a relation clause in a Case statement, such as "Is &amp;gt;
 expression".
 </summary>
	<param name="isKeywordOpt">
 The "Is" keyword, if present.
 </param>
	<param name="operatorToken">
 The operator in the relational clause. One of "=", "&amp;lt;", "&amp;gt;",
 "&amp;lt;=" or "&amp;gt;=".
 </param>
	<param name="value">
 The expression that denotes the value being tested against.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CaseLessThanOrEqualClause(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a relation clause in a Case statement, such as "Is &amp;gt;
 expression".
 </summary>
	<param name="isKeywordOpt">
 The "Is" keyword, if present.
 </param>
	<param name="operatorToken">
 The operator in the relational clause. One of "=", "&amp;lt;", "&amp;gt;",
 "&amp;lt;=" or "&amp;gt;=".
 </param>
	<param name="value">
 The expression that denotes the value being tested against.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CaseGreaterThanOrEqualClause(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a relation clause in a Case statement, such as "Is &amp;gt;
 expression".
 </summary>
	<param name="isKeywordOpt">
 The "Is" keyword, if present.
 </param>
	<param name="operatorToken">
 The operator in the relational clause. One of "=", "&amp;lt;", "&amp;gt;",
 "&amp;lt;=" or "&amp;gt;=".
 </param>
	<param name="value">
 The expression that denotes the value being tested against.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CaseGreaterThanClause(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a relation clause in a Case statement, such as "Is &amp;gt;
 expression".
 </summary>
	<param name="isKeywordOpt">
 The "Is" keyword, if present.
 </param>
	<param name="operatorToken">
 The operator in the relational clause. One of "=", "&amp;lt;", "&amp;gt;",
 "&amp;lt;=" or "&amp;gt;=".
 </param>
	<param name="value">
 The expression that denotes the value being tested against.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CaseRelationalClause(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a relation clause in a Case statement, such as "Is &amp;gt;
 expression".
 </summary>
	<param name="kind">
 A &amp;lt;cref c="SyntaxKind"/&amp;gt; representing the specific kind of
 CaseRelationalClauseSyntax. One of CaseEqualsClause, CaseNotEqualsClause,
 CaseLessThanClause, CaseLessThanOrEqualClause, CaseGreaterThanOrEqualClause,
 CaseGreaterThanClause.
 </param>
	<param name="isKeywordOpt">
 The "Is" keyword, if present.
 </param>
	<param name="operatorToken">
 The operator in the relational clause. One of "=", "&amp;lt;", "&amp;gt;",
 "&amp;lt;=" or "&amp;gt;=".
 </param>
	<param name="value">
 The expression that denotes the value being tested against.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SyncLockStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents the "SyncLock" statement. This statement always occurs as the Begin
 of a SyncLockBlock.
 </summary>
	<param name="syncLockKeyword">
 The "SyncLock" keyword.
 </param>
	<param name="expression">
 The expression being synchronized on.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DoLoopTopTestBlock(Roslyn.Compilers.VisualBasic.DoStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.LoopStatementSyntax)">
	<summary>
 Represents a Do-Loop block. The Kind property can be used to determine if this
 is a top-test, bottom-test or infinite loop.
 </summary>
	<param name="begin">
 The Do statement that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The Loop statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DoLoopBottomTestBlock(Roslyn.Compilers.VisualBasic.DoStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.LoopStatementSyntax)">
	<summary>
 Represents a Do-Loop block. The Kind property can be used to determine if this
 is a top-test, bottom-test or infinite loop.
 </summary>
	<param name="begin">
 The Do statement that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The Loop statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DoLoopForeverBlock(Roslyn.Compilers.VisualBasic.DoStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.LoopStatementSyntax)">
	<summary>
 Represents a Do-Loop block. The Kind property can be used to determine if this
 is a top-test, bottom-test or infinite loop.
 </summary>
	<param name="begin">
 The Do statement that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The Loop statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DoLoopBlock(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.DoStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.LoopStatementSyntax)">
	<summary>
 Represents a Do-Loop block. The Kind property can be used to determine if this
 is a top-test, bottom-test or infinite loop.
 </summary>
	<param name="kind">
 A &amp;lt;cref c="SyntaxKind"/&amp;gt; representing the specific kind of
 DoLoopBlockSyntax. One of DoLoopTopTestBlock, DoLoopBottomTestBlock,
 DoLoopForeverBlock.
 </param>
	<param name="begin">
 The Do statement that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The Loop statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DoStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.WhileUntilClauseSyntax)">
	<summary>
 The Do statement that begins a Do-Loop block. This statement always occurs as
 the Begin of a DoLoopBlock.
 </summary>
	<param name="doKeyword">
 The "Do" keyword.
 </param>
	<param name="whileUntilClauseOpt">
 The "While expression" or "Until expression" part of the Do statement, if
 present.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.LoopStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.WhileUntilClauseSyntax)">
	<summary>
 The Loop statement that ends a Do-Loop block. This statement always occurs as
 the End of a DoLoopBlock.
 </summary>
	<param name="loopKeyword">
 The "Loop" keyword.
 </param>
	<param name="whileUntilClauseOpt">
 The "While expression" or "Until expression" part of the Loop statement, if
 present.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.WhileClause(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a "While expression" or "Until expression" in a Do or Loop
 statement. The Kind of the clause can be "WhileClause" or "UntilClause" to
 indicate which kind of clause.
 </summary>
	<param name="whileOrUntilKeyword">
 The "While" or "Until" keyword.
 </param>
	<param name="condition">
 The boolean expression after the While or Until.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.UntilClause(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a "While expression" or "Until expression" in a Do or Loop
 statement. The Kind of the clause can be "WhileClause" or "UntilClause" to
 indicate which kind of clause.
 </summary>
	<param name="whileOrUntilKeyword">
 The "While" or "Until" keyword.
 </param>
	<param name="condition">
 The boolean expression after the While or Until.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.WhileUntilClause(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a "While expression" or "Until expression" in a Do or Loop
 statement. The Kind of the clause can be "WhileClause" or "UntilClause" to
 indicate which kind of clause.
 </summary>
	<param name="kind">
 A &amp;lt;cref c="SyntaxKind"/&amp;gt; representing the specific kind of
 WhileUntilClauseSyntax. One of WhileClause, UntilClause.
 </param>
	<param name="whileOrUntilKeyword">
 The "While" or "Until" keyword.
 </param>
	<param name="condition">
 The boolean expression after the While or Until.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.WhileStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 The While statement that begins a While...End While block. This statement
 always occurs as the Begin of a WhileBlock.
 </summary>
	<param name="whileKeyword">
 The "While" keyword.
 </param>
	<param name="condition">
 The boolean expression that controls the While loop.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ForBlock(Roslyn.Compilers.VisualBasic.StatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.NextStatementSyntax)">
	<summary>
 Represents a For or For Each block, including the introducting statement, the
 body and the "Next" (which can be omitted if a containing For has a Next with
 multiple variables).
 </summary>
	<param name="begin">
 The For or For Each statement that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the For or For Each loop. This might be an empty
 list.
 </param>
	<param name="endOpt">
 The Next statement that ends the block. If two For statements are ended by a
 single Next statement, the inner For will not have an EndStatment.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ForEachBlock(Roslyn.Compilers.VisualBasic.StatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.NextStatementSyntax)">
	<summary>
 Represents a For or For Each block, including the introducting statement, the
 body and the "Next" (which can be omitted if a containing For has a Next with
 multiple variables).
 </summary>
	<param name="begin">
 The For or For Each statement that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the For or For Each loop. This might be an empty
 list.
 </param>
	<param name="endOpt">
 The Next statement that ends the block. If two For statements are ended by a
 single Next statement, the inner For will not have an EndStatment.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ForStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.ForStepClauseSyntax)">
	<summary>
 The For statement that begins a For-Next block. This statement always occurs as
 the Begin of a ForBlock. Most of the time, the End of that ForBlock is the
 corresponding Next statement. However, multiple nested For statements are ended
 by a single Next statement with multiple variables, then the inner For
 statements will have End set to Nothing, and the Next statement is the End of
 the outermost For statement that is being ended.
 </summary>
	<param name="forKeyword">
 The "For" keyword.
 </param>
	<param name="controlVariable">
 If the For or For Each statement is of a form that does not declare a new loop
 control variable, this is the expression that denotes the loop control
 variable. If this loop is of a form that does declare a new control variable,
 this is a VariableDeclarator that has the variable being declared.
 </param>
	<param name="equalsToken">
 The "=" token.
 </param>
	<param name="fromValue">
 The expression denoting the initial value of the iteration.
 </param>
	<param name="toKeyword">
 The "To" keyword.
 </param>
	<param name="toValue">
 The expression denoting the final value of the iteration.
 </param>
	<param name="stepClauseOpt">
 The optional Step clause.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ForStepClause(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 The Step clause in a For Statement.
 </summary>
	<param name="stepKeyword">
 The "Step" keyword.
 </param>
	<param name="stepValue">
 The expression denoting the step increment.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ForEachStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 The For Each statement that begins a For Each-Next block. This statement always
 occurs as the Begin of a ForBlock, and the body of the For Each-Next is the
 Body of that ForBlock. Most of the time, the End of that ForBlock is the
 corresponding Next statement. However, multiple nested For statements are ended
 by a single Next statement with multiple variables, then the inner For
 statements will have End set to Nothing, and the Next statement is the End of
 the outermost For statement that is being ended.
 </summary>
	<param name="forKeyword">
 The "For" keyword.
 </param>
	<param name="eachKeyword">
 The "Each" keyword.
 </param>
	<param name="controlVariable">
 If the For or For Each statement is of a form that does not declare a new loop
 control variable, this is the expression that denotes the loop control
 variable. If this loop is of a form that does declare a new control variable,
 this is a VariableDeclarator that has the variable being declared.
 </param>
	<param name="inKeyword">
 The "In" keyword.
 </param>
	<param name="expression">
 The expression denoting the collection to iterate over.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.NextStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ExpressionSyntax})">
	<summary>
 The Next statement that ends a For-Next or For Each-Next block. This statement
 always occurs as the End of a ForBlock (with Kind=ForBlock or ForEachBlock),
 and the body of the For-Next is the Body of that ForBlock. The Begin of that
 ForBlock has the corresponding For or For Each statement.
 </summary>
	<param name="nextKeyword">
 The "Next" keyword.
 </param>
	<param name="controlVariables">
 The variables in the Next statement, if present
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.UsingStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.VariableDeclaratorSyntax})">
	<summary>
 The Using statement that begins a Using block. This statement always occurs as
 the Begin of a UsingBlock, and the body of the Using is the Body of that
 UsingBlock.
 </summary>
	<param name="usingKeyword">
 The "Using" keyword.
 </param>
	<param name="expressionOpt">
 If the Using statement is of a form that does not declare a new variable, this
 is the expression used in the using. Otherwise, Nothing is returned.
 </param>
	<param name="variables">
 If the Using statement is of a form that declares one or more new variables,
 this is the list of variable declarations. Otherwise, Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ThrowStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a Throw statement.
 </summary>
	<param name="throwKeyword">
 The "Throw" keyword
 </param>
	<param name="expressionOpt">
 The expression denoting the value being thrown.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AssignmentStatement(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
	<param name="left">
 The target (left hand side) of the assignment.
 </param>
	<param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&amp;lt;&amp;lt;=" or "&amp;gt;&amp;gt;=".
 </param>
	<param name="right">
 The source (right hand side) of the assignment.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.MidAssignment(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
	<param name="left">
 The target (left hand side) of the assignment.
 </param>
	<param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&amp;lt;&amp;lt;=" or "&amp;gt;&amp;gt;=".
 </param>
	<param name="right">
 The source (right hand side) of the assignment.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AddAssignment(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
	<param name="left">
 The target (left hand side) of the assignment.
 </param>
	<param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&amp;lt;&amp;lt;=" or "&amp;gt;&amp;gt;=".
 </param>
	<param name="right">
 The source (right hand side) of the assignment.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SubtractAssignment(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
	<param name="left">
 The target (left hand side) of the assignment.
 </param>
	<param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&amp;lt;&amp;lt;=" or "&amp;gt;&amp;gt;=".
 </param>
	<param name="right">
 The source (right hand side) of the assignment.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.MultiplyAssignment(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
	<param name="left">
 The target (left hand side) of the assignment.
 </param>
	<param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&amp;lt;&amp;lt;=" or "&amp;gt;&amp;gt;=".
 </param>
	<param name="right">
 The source (right hand side) of the assignment.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DivideAssignment(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
	<param name="left">
 The target (left hand side) of the assignment.
 </param>
	<param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&amp;lt;&amp;lt;=" or "&amp;gt;&amp;gt;=".
 </param>
	<param name="right">
 The source (right hand side) of the assignment.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.IntegerDivideAssignment(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
	<param name="left">
 The target (left hand side) of the assignment.
 </param>
	<param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&amp;lt;&amp;lt;=" or "&amp;gt;&amp;gt;=".
 </param>
	<param name="right">
 The source (right hand side) of the assignment.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.PowerAssignment(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
	<param name="left">
 The target (left hand side) of the assignment.
 </param>
	<param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&amp;lt;&amp;lt;=" or "&amp;gt;&amp;gt;=".
 </param>
	<param name="right">
 The source (right hand side) of the assignment.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.LeftShiftAssignment(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
	<param name="left">
 The target (left hand side) of the assignment.
 </param>
	<param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&amp;lt;&amp;lt;=" or "&amp;gt;&amp;gt;=".
 </param>
	<param name="right">
 The source (right hand side) of the assignment.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.RightShiftAssignment(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
	<param name="left">
 The target (left hand side) of the assignment.
 </param>
	<param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&amp;lt;&amp;lt;=" or "&amp;gt;&amp;gt;=".
 </param>
	<param name="right">
 The source (right hand side) of the assignment.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ConcatenateAssignment(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
	<param name="left">
 The target (left hand side) of the assignment.
 </param>
	<param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&amp;lt;&amp;lt;=" or "&amp;gt;&amp;gt;=".
 </param>
	<param name="right">
 The source (right hand side) of the assignment.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CallStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represent an call statement (also known as a invocation statement).
 </summary>
	<param name="callKeywordOpt">
 The "Call" keyword, if present.
 </param>
	<param name="invocation">
 The expression denoting the call. This could be an Invocation or a MemberAccess
 (in the case where no parentheses were supplied.)
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AddHandlerStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents an AddHandler or RemoveHandler statement. The Kind property
 determines which one.
 </summary>
	<param name="addHandlerOrRemoveHandlerKeyword">
 The "AddHandler" or "RemoveHandler" keyword.
 </param>
	<param name="eventExpression">
 The event being accessed.
 </param>
	<param name="commaToken">
 The "," token.
 </param>
	<param name="delegateExpression">
 The delegate being added or removed.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.RemoveHandlerStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents an AddHandler or RemoveHandler statement. The Kind property
 determines which one.
 </summary>
	<param name="addHandlerOrRemoveHandlerKeyword">
 The "AddHandler" or "RemoveHandler" keyword.
 </param>
	<param name="eventExpression">
 The event being accessed.
 </param>
	<param name="commaToken">
 The "," token.
 </param>
	<param name="delegateExpression">
 The delegate being added or removed.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AddRemoveHandlerStatement(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents an AddHandler or RemoveHandler statement. The Kind property
 determines which one.
 </summary>
	<param name="kind">
 A &amp;lt;cref c="SyntaxKind"/&amp;gt; representing the specific kind of
 AddRemoveHandlerStatementSyntax. One of AddHandlerStatement,
 RemoveHandlerStatement.
 </param>
	<param name="addHandlerOrRemoveHandlerKeyword">
 The "AddHandler" or "RemoveHandler" keyword.
 </param>
	<param name="eventExpression">
 The event being accessed.
 </param>
	<param name="commaToken">
 The "," token.
 </param>
	<param name="delegateExpression">
 The delegate being added or removed.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.RaiseEventStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ArgumentListSyntax)">
	<summary>
 Represent a RaiseEvent statement.
 </summary>
	<param name="raiseEventKeyword">
 The "RaiseEvent" keyword
 </param>
	<param name="identifier">
 The name of the event being raised.
 </param>
	<param name="argumentListOpt">
 The argument list, if present.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.WithStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a "With" statement. This statement always occurs as the
 BeginStatement of a WithBlock, and the body of the With is the Body of that
 WithBlock.
 </summary>
	<param name="withKeyword">
 The "With" keyword.
 </param>
	<param name="expression">
 The expression that is the operand of the With statement.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ReDimStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InvocationExpressionSyntax})">
	<summary>
 Represents a ReDim statement.
 </summary>
	<param name="reDimKeyword">
 The "ReDim" keyword.
 </param>
	<param name="preserveKeywordOpt">
 Returns Nothing if Kind=ReDim, returns the "Preserve" keyword if
 Kind=RedimPreserve.
 </param>
	<param name="clauses">
 The list of ReDim clauses. Each clause is a Invocation node with an argument
 list denoting the new bounds for the array.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ReDimPreserveStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InvocationExpressionSyntax})">
	<summary>
 Represents a ReDim statement.
 </summary>
	<param name="reDimKeyword">
 The "ReDim" keyword.
 </param>
	<param name="preserveKeywordOpt">
 Returns Nothing if Kind=ReDim, returns the "Preserve" keyword if
 Kind=RedimPreserve.
 </param>
	<param name="clauses">
 The list of ReDim clauses. Each clause is a Invocation node with an argument
 list denoting the new bounds for the array.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EraseStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ExpressionSyntax})">
	<summary>
 Represents an "Erase" statement.
 </summary>
	<param name="eraseKeyword">
 The "Erase" keyword.
 </param>
	<param name="expressions">
 A list of expressions denoting the arrays to erase.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CharacterLiteralExpression(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
	<param name="token">
 The token that represents the literal. The Kind property determines what type
 this property returns: Kind=IntegerLiteral ==&amp;gt; Returns
 IntegerLiteralToken. Kind=CharacterLiteral ==&amp;gt; Returns
 CharacterLiteralToken. Kind=DecimalLiteral ==&amp;gt; Returns
 DecimalLiteralToken Kind=FloatingLiteral ==&amp;gt; Returns
 FloatingLiteralToken Kind=DateLiteral ==&amp;gt; Returns DateLiteralToken
 Kind=StringLiteral ==&amp;gt; Returns StringLiteralToken Kind=BooleanLiteral
 ==&amp;gt; Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
 Kind=NothingLiteral ==&amp;gt; Returns Keyword (with it's kind being
 NothingKeyword)
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.TrueLiteralExpression(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
	<param name="token">
 The token that represents the literal. The Kind property determines what type
 this property returns: Kind=IntegerLiteral ==&amp;gt; Returns
 IntegerLiteralToken. Kind=CharacterLiteral ==&amp;gt; Returns
 CharacterLiteralToken. Kind=DecimalLiteral ==&amp;gt; Returns
 DecimalLiteralToken Kind=FloatingLiteral ==&amp;gt; Returns
 FloatingLiteralToken Kind=DateLiteral ==&amp;gt; Returns DateLiteralToken
 Kind=StringLiteral ==&amp;gt; Returns StringLiteralToken Kind=BooleanLiteral
 ==&amp;gt; Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
 Kind=NothingLiteral ==&amp;gt; Returns Keyword (with it's kind being
 NothingKeyword)
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.FalseLiteralExpression(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
	<param name="token">
 The token that represents the literal. The Kind property determines what type
 this property returns: Kind=IntegerLiteral ==&amp;gt; Returns
 IntegerLiteralToken. Kind=CharacterLiteral ==&amp;gt; Returns
 CharacterLiteralToken. Kind=DecimalLiteral ==&amp;gt; Returns
 DecimalLiteralToken Kind=FloatingLiteral ==&amp;gt; Returns
 FloatingLiteralToken Kind=DateLiteral ==&amp;gt; Returns DateLiteralToken
 Kind=StringLiteral ==&amp;gt; Returns StringLiteralToken Kind=BooleanLiteral
 ==&amp;gt; Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
 Kind=NothingLiteral ==&amp;gt; Returns Keyword (with it's kind being
 NothingKeyword)
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.NumericLiteralExpression(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
	<param name="token">
 The token that represents the literal. The Kind property determines what type
 this property returns: Kind=IntegerLiteral ==&amp;gt; Returns
 IntegerLiteralToken. Kind=CharacterLiteral ==&amp;gt; Returns
 CharacterLiteralToken. Kind=DecimalLiteral ==&amp;gt; Returns
 DecimalLiteralToken Kind=FloatingLiteral ==&amp;gt; Returns
 FloatingLiteralToken Kind=DateLiteral ==&amp;gt; Returns DateLiteralToken
 Kind=StringLiteral ==&amp;gt; Returns StringLiteralToken Kind=BooleanLiteral
 ==&amp;gt; Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
 Kind=NothingLiteral ==&amp;gt; Returns Keyword (with it's kind being
 NothingKeyword)
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DateLiteralExpression(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
	<param name="token">
 The token that represents the literal. The Kind property determines what type
 this property returns: Kind=IntegerLiteral ==&amp;gt; Returns
 IntegerLiteralToken. Kind=CharacterLiteral ==&amp;gt; Returns
 CharacterLiteralToken. Kind=DecimalLiteral ==&amp;gt; Returns
 DecimalLiteralToken Kind=FloatingLiteral ==&amp;gt; Returns
 FloatingLiteralToken Kind=DateLiteral ==&amp;gt; Returns DateLiteralToken
 Kind=StringLiteral ==&amp;gt; Returns StringLiteralToken Kind=BooleanLiteral
 ==&amp;gt; Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
 Kind=NothingLiteral ==&amp;gt; Returns Keyword (with it's kind being
 NothingKeyword)
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.StringLiteralExpression(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
	<param name="token">
 The token that represents the literal. The Kind property determines what type
 this property returns: Kind=IntegerLiteral ==&amp;gt; Returns
 IntegerLiteralToken. Kind=CharacterLiteral ==&amp;gt; Returns
 CharacterLiteralToken. Kind=DecimalLiteral ==&amp;gt; Returns
 DecimalLiteralToken Kind=FloatingLiteral ==&amp;gt; Returns
 FloatingLiteralToken Kind=DateLiteral ==&amp;gt; Returns DateLiteralToken
 Kind=StringLiteral ==&amp;gt; Returns StringLiteralToken Kind=BooleanLiteral
 ==&amp;gt; Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
 Kind=NothingLiteral ==&amp;gt; Returns Keyword (with it's kind being
 NothingKeyword)
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.NothingLiteralExpression(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
	<param name="token">
 The token that represents the literal. The Kind property determines what type
 this property returns: Kind=IntegerLiteral ==&amp;gt; Returns
 IntegerLiteralToken. Kind=CharacterLiteral ==&amp;gt; Returns
 CharacterLiteralToken. Kind=DecimalLiteral ==&amp;gt; Returns
 DecimalLiteralToken Kind=FloatingLiteral ==&amp;gt; Returns
 FloatingLiteralToken Kind=DateLiteral ==&amp;gt; Returns DateLiteralToken
 Kind=StringLiteral ==&amp;gt; Returns StringLiteralToken Kind=BooleanLiteral
 ==&amp;gt; Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
 Kind=NothingLiteral ==&amp;gt; Returns Keyword (with it's kind being
 NothingKeyword)
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.LiteralExpression(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
	<param name="kind">
 A &amp;lt;cref c="SyntaxKind"/&amp;gt; representing the specific kind of
 LiteralExpressionSyntax. One of CharacterLiteralExpression,
 TrueLiteralExpression, FalseLiteralExpression, NumericLiteralExpression,
 DateLiteralExpression, StringLiteralExpression, NothingLiteralExpression.
 </param>
	<param name="token">
 The token that represents the literal. The Kind property determines what type
 this property returns: Kind=IntegerLiteral ==&amp;gt; Returns
 IntegerLiteralToken. Kind=CharacterLiteral ==&amp;gt; Returns
 CharacterLiteralToken. Kind=DecimalLiteral ==&amp;gt; Returns
 DecimalLiteralToken Kind=FloatingLiteral ==&amp;gt; Returns
 FloatingLiteralToken Kind=DateLiteral ==&amp;gt; Returns DateLiteralToken
 Kind=StringLiteral ==&amp;gt; Returns StringLiteralToken Kind=BooleanLiteral
 ==&amp;gt; Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
 Kind=NothingLiteral ==&amp;gt; Returns Keyword (with it's kind being
 NothingKeyword)
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ParenthesizedExpression(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a parenthesized expression.
 </summary>
	<param name="openParenToken">
 The "(" token
 </param>
	<param name="expression">
 The expression inside the parentheses.
 </param>
	<param name="closeParenToken">
 The ")" token
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.MeExpression(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Identifies the special instance "Me"
 </summary>
	<param name="keyword">
 The "Me", "MyClass" or "MyBase" keyword.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.MyBaseExpression(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Identifies the special instance "MyBase"
 </summary>
	<param name="keyword">
 The "Me", "MyClass" or "MyBase" keyword.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.MyClassExpression(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Identifies the special instance "MyClass"
 </summary>
	<param name="keyword">
 The "Me", "MyClass" or "MyBase" keyword.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.GetTypeExpression(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a GetType expression.
 </summary>
	<param name="getTypeKeyword">
 The "GetType" keyword.
 </param>
	<param name="openParenToken">
 The "(" token.
 </param>
	<param name="type">
 The type to get the Type object for. This can be an open generic type.
 </param>
	<param name="closeParenToken">
 The ")" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.TypeOfIsExpression(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeSyntax)">
	<summary>
 Represents a TypeOf...Is expression.
 </summary>
	<param name="typeOfKeyword">
 The "TypeOf" keyword.
 </param>
	<param name="expression">
 The expression being tested.
 </param>
	<param name="isKeyword">
 The "Is" keyword.
 </param>
	<param name="type">
 The name of the type being tested against.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.GetXmlNamespaceExpression(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a GetXmlNamespace expression.
 </summary>
	<param name="getXmlNamespaceKeyword">
 The "GetXmlNamespace" keyword.
 </param>
	<param name="openParenToken">
 The "(" token.
 </param>
	<param name="nameOpt">
 The Xml namespace name being referenced.
 </param>
	<param name="closeParenToken">
 The ")" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.MemberAccessExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SimpleNameSyntax)">
	<summary>
 Represents member access (.name) or dictionary access (!name). The Kind
 property determines which kind of access.
 </summary>
	<param name="leftOpt">
 The expression on the left-hand-side of the "." or "!" token.
 </param>
	<param name="token">
 The "." or "!" token.
 </param>
	<param name="name">
 The identifier after the "." or "!" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DictionaryAccess(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SimpleNameSyntax)">
	<summary>
 Represents member access (.name) or dictionary access (!name). The Kind
 property determines which kind of access.
 </summary>
	<param name="leftOpt">
 The expression on the left-hand-side of the "." or "!" token.
 </param>
	<param name="token">
 The "." or "!" token.
 </param>
	<param name="name">
 The identifier after the "." or "!" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlElementAccessExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.XmlNodeSyntax)">
	<summary>
 Represents an XML member element access (node.&amp;lt;Element&amp;gt;),
 attribute access (node.@Attribute) or descendents access
 (node...&amp;lt;Descendent&amp;gt;). The Kind property determines which kind of
 access.
 </summary>
	<param name="baseOpt">
 The expression on the left-hand-side of the ".", ".@" or "..." .
 </param>
	<param name="token1">
 The initial dot "." part of the separator.
 </param>
	<param name="token2Opt">
 The "@" part of .@ or the second "." of "...".
 </param>
	<param name="token3Opt">
 The third "." in a "..." separator.
 </param>
	<param name="name">
 The identifier after the ".", ".@" or "..."
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlDescendantAccessExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.XmlNodeSyntax)">
	<summary>
 Represents an XML member element access (node.&amp;lt;Element&amp;gt;),
 attribute access (node.@Attribute) or descendents access
 (node...&amp;lt;Descendent&amp;gt;). The Kind property determines which kind of
 access.
 </summary>
	<param name="baseOpt">
 The expression on the left-hand-side of the ".", ".@" or "..." .
 </param>
	<param name="token1">
 The initial dot "." part of the separator.
 </param>
	<param name="token2Opt">
 The "@" part of .@ or the second "." of "...".
 </param>
	<param name="token3Opt">
 The third "." in a "..." separator.
 </param>
	<param name="name">
 The identifier after the ".", ".@" or "..."
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlAttributeAccessExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.XmlNodeSyntax)">
	<summary>
 Represents an XML member element access (node.&amp;lt;Element&amp;gt;),
 attribute access (node.@Attribute) or descendents access
 (node...&amp;lt;Descendent&amp;gt;). The Kind property determines which kind of
 access.
 </summary>
	<param name="baseOpt">
 The expression on the left-hand-side of the ".", ".@" or "..." .
 </param>
	<param name="token1">
 The initial dot "." part of the separator.
 </param>
	<param name="token2Opt">
 The "@" part of .@ or the second "." of "...".
 </param>
	<param name="token3Opt">
 The third "." in a "..." separator.
 </param>
	<param name="name">
 The identifier after the ".", ".@" or "..."
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlMemberAccessExpression(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.XmlNodeSyntax)">
	<summary>
 Represents an XML member element access (node.&amp;lt;Element&amp;gt;),
 attribute access (node.@Attribute) or descendents access
 (node...&amp;lt;Descendent&amp;gt;). The Kind property determines which kind of
 access.
 </summary>
	<param name="kind">
 A &amp;lt;cref c="SyntaxKind"/&amp;gt; representing the specific kind of
 XmlMemberAccessExpressionSyntax. One of XmlElementAccessExpression,
 XmlDescendantAccessExpression, XmlAttributeAccessExpression.
 </param>
	<param name="baseOpt">
 The expression on the left-hand-side of the ".", ".@" or "..." .
 </param>
	<param name="token1">
 The initial dot "." part of the separator.
 </param>
	<param name="token2Opt">
 The "@" part of .@ or the second "." of "...".
 </param>
	<param name="token3Opt">
 The third "." in a "..." separator.
 </param>
	<param name="name">
 The identifier after the ".", ".@" or "..."
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.InvocationExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.ArgumentListSyntax)">
	<summary>
 Represents an invocation expression consisting of an invocation target and an
 optional argument list or an array, parameterized property or object default
 property index.
 </summary>
	<param name="expression">
 The target of the call or index expression.
 </param>
	<param name="argumentListOpt">
 The argument list.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ObjectCreationExpression(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeBlockSyntax},Roslyn.Compilers.VisualBasic.TypeSyntax,Roslyn.Compilers.VisualBasic.ArgumentListSyntax,Roslyn.Compilers.VisualBasic.ObjectCreationInitializerSyntax)">
	<summary>
 Represents a New expression that creates a new non-array object, possibly with
 a "With" or "From" clause.
 </summary>
	<param name="newKeyword">
 The "New" keyword.
 </param>
	<param name="attributes">
 A list of all attribute blocks on the type. If no attributes were specified, an
 empty list is returned.
 </param>
	<param name="type">
 The type of the object being initialized.
 </param>
	<param name="argumentListOpt">
 The argument list, if present. If no argument list was supplied, Nothing is
 returned.
 </param>
	<param name="initializerOpt">
 An optional From or With clause to initialize the new object.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AnonymousObjectCreationExpression(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeBlockSyntax},Roslyn.Compilers.VisualBasic.ObjectMemberInitializerSyntax)">
	<summary>
 Represents a New expression that create an object of anonymous type.
 </summary>
	<param name="newKeyword">
 The "New" keyword.
 </param>
	<param name="attributes">
 A list of all attribute blocks on the type. If no attributes were specified, an
 empty list is returned.
 </param>
	<param name="initializer">
 The With clause to initialize the new object.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ArrayCreationExpression(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeBlockSyntax},Roslyn.Compilers.VisualBasic.TypeSyntax,Roslyn.Compilers.VisualBasic.ArgumentListSyntax,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.ArrayRankSpecifierSyntax},Roslyn.Compilers.VisualBasic.CollectionInitializerSyntax)">
	<summary>
 Represents an expression that creates a new array.
 </summary>
	<param name="newKeyword">
 The "New" keyword.
 </param>
	<param name="attributes">
 A list of all attribute blocks on the type. If no attributes were specified, an
 empty list is returned.
 </param>
	<param name="type">
 The element type of the array being created.
 </param>
	<param name="arrayBoundsOpt">
 The optional array bounds, such as "(4)" or "(0 to 5, 0 To 6)".
 </param>
	<param name="rankSpecifiers">
 A list of array modifiers such as "()" or "(,)". If no array modifiers were
 present, an empty list is returned.
 </param>
	<param name="initializer">
 The initializer including the braces.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CollectionInitializer(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ExpressionSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an expression that creates a new array wihout naming the element
 type.
 </summary>
	<param name="openBraceToken">
 The "{" token.
 </param>
	<param name="initializers">
 The list of initializers between the braces.
 </param>
	<param name="closeBraceToken">
 The "}" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CTypeExpression(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a CType, DirectCast or TryCast conversion expression. The Kind
 property determines which kind of cast it is.
 </summary>
	<param name="keyword">
 The "CType", "DirectCast" or "TryCast" keyword.
 </param>
	<param name="openParenToken">
 The "(" token.
 </param>
	<param name="expression">
 The expression being cast.
 </param>
	<param name="commaToken">
 The "," token.
 </param>
	<param name="type">
 The type the expression is being cast to.
 </param>
	<param name="closeParenToken">
 The ")" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DirectCastExpression(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a CType, DirectCast or TryCast conversion expression. The Kind
 property determines which kind of cast it is.
 </summary>
	<param name="keyword">
 The "CType", "DirectCast" or "TryCast" keyword.
 </param>
	<param name="openParenToken">
 The "(" token.
 </param>
	<param name="expression">
 The expression being cast.
 </param>
	<param name="commaToken">
 The "," token.
 </param>
	<param name="type">
 The type the expression is being cast to.
 </param>
	<param name="closeParenToken">
 The ")" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.TryCastExpression(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a CType, DirectCast or TryCast conversion expression. The Kind
 property determines which kind of cast it is.
 </summary>
	<param name="keyword">
 The "CType", "DirectCast" or "TryCast" keyword.
 </param>
	<param name="openParenToken">
 The "(" token.
 </param>
	<param name="expression">
 The expression being cast.
 </param>
	<param name="commaToken">
 The "," token.
 </param>
	<param name="type">
 The type the expression is being cast to.
 </param>
	<param name="closeParenToken">
 The ")" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CastExpression(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a CType, DirectCast or TryCast conversion expression. The Kind
 property determines which kind of cast it is.
 </summary>
	<param name="kind">
 A &amp;lt;cref c="SyntaxKind"/&amp;gt; representing the specific kind of
 CastExpressionSyntax. One of CTypeExpression, DirectCastExpression,
 TryCastExpression.
 </param>
	<param name="keyword">
 The "CType", "DirectCast" or "TryCast" keyword.
 </param>
	<param name="openParenToken">
 The "(" token.
 </param>
	<param name="expression">
 The expression being cast.
 </param>
	<param name="commaToken">
 The "," token.
 </param>
	<param name="type">
 The type the expression is being cast to.
 </param>
	<param name="closeParenToken">
 The ")" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.PredefinedCastExpression(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a cast to a pre-defined type using a pre-defined cast expression,
 such as CInt or CLng.
 </summary>
	<param name="keyword">
 The keyword that was used in the cast operation.
 </param>
	<param name="openParenToken">
 The "(" token.
 </param>
	<param name="expression">
 The expression being cast.
 </param>
	<param name="closeParenToken">
 The ")" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AddExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SubtractExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.MultiplyExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DivideExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.IntegerDivideExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.PowerExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.LeftShiftExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.RightShiftExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ConcatenateExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ModuloExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EqualsExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.NotEqualsExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.LessThanExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.LessThanOrEqualExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.GreaterThanOrEqualExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.GreaterThanExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.IsExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.IsNotExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.LikeExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.OrExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XorExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AndExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.OrElseExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AndAlsoExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.BinaryExpression(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="kind">
 A &amp;lt;cref c="SyntaxKind"/&amp;gt; representing the specific kind of
 BinaryExpressionSyntax. One of AddExpression, SubtractExpression,
 MultiplyExpression, DivideExpression, IntegerDivideExpression, PowerExpression,
 LeftShiftExpression, RightShiftExpression, ConcatenateExpression,
 ModuloExpression, EqualsExpression, NotEqualsExpression, LessThanExpression,
 LessThanOrEqualExpression, GreaterThanOrEqualExpression, GreaterThanExpression,
 IsExpression, IsNotExpression, LikeExpression, OrExpression, XorExpression,
 AndExpression, OrElseExpression, AndAlsoExpression.
 </param>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.PlusExpression(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Describes a unary operator: Plus, Negate, Not or AddressOf.
 </summary>
	<param name="operatorToken">
 The token that is the operator.
 </param>
	<param name="operand">
 The expression being operated on.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.NegateExpression(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Describes a unary operator: Plus, Negate, Not or AddressOf.
 </summary>
	<param name="operatorToken">
 The token that is the operator.
 </param>
	<param name="operand">
 The expression being operated on.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.NotExpression(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Describes a unary operator: Plus, Negate, Not or AddressOf.
 </summary>
	<param name="operatorToken">
 The token that is the operator.
 </param>
	<param name="operand">
 The expression being operated on.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AddressOfExpression(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Describes a unary operator: Plus, Negate, Not or AddressOf.
 </summary>
	<param name="operatorToken">
 The token that is the operator.
 </param>
	<param name="operand">
 The expression being operated on.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.UnaryExpression(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Describes a unary operator: Plus, Negate, Not or AddressOf.
 </summary>
	<param name="kind">
 A &amp;lt;cref c="SyntaxKind"/&amp;gt; representing the specific kind of
 UnaryExpressionSyntax. One of PlusExpression, NegateExpression, NotExpression,
 AddressOfExpression.
 </param>
	<param name="operatorToken">
 The token that is the operator.
 </param>
	<param name="operand">
 The expression being operated on.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.BinaryConditionalExpression(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a conditional expression, If(condition, true-expr, false-expr) or
 If(expr, nothing-expr).
 </summary>
	<param name="ifKeyword">
 The "If" keyword
 </param>
	<param name="openParenToken">
 The "(" token
 </param>
	<param name="firstExpression">
 The first expression inside the parentheses.
 </param>
	<param name="commaToken">
 The "," token.
 </param>
	<param name="secondExpression">
 The second expression inside the parentheses.
 </param>
	<param name="closeParenToken">
 The ")" token
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.TernaryConditionalExpression(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a conditional expression, If(condition, true-expr, false-expr) or
 If(expr, nothing-expr).
 </summary>
	<param name="ifKeyword">
 The "If" keyword
 </param>
	<param name="openParenToken">
 The "(" token
 </param>
	<param name="condition">
 The first expression inside the parentheses.
 </param>
	<param name="firstCommaToken">
 The "," token.
 </param>
	<param name="whenTrue">
 The second expression inside the parentheses.
 </param>
	<param name="secondCommaToken">
 The "," token.
 </param>
	<param name="whenFalse">
 The second expression inside the parentheses.
 </param>
	<param name="closeParenToken">
 The ")" token
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SingleLineFunctionLambdaExpression(Roslyn.Compilers.VisualBasic.LambdaHeaderSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxNode)">
	<summary>
 Represents a single line lambda expression.
 </summary>
	<param name="begin">
 The header part of the lambda that includes the "Sub" or "Function" keyword,
 the argument list and return type.
 </param>
	<param name="beginTerminatorOpt">
 The statement terminator token that ended the Begin statement. Optional only
 for single line lambdas.
 </param>
	<param name="body">
 The body of the lambda. Depending on the kind of lambda, this is either a
 Statement (single-line Sub lambda) or Expression (single-line Function).
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SingleLineSubLambdaExpression(Roslyn.Compilers.VisualBasic.LambdaHeaderSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxNode)">
	<summary>
 Represents a single line lambda expression.
 </summary>
	<param name="begin">
 The header part of the lambda that includes the "Sub" or "Function" keyword,
 the argument list and return type.
 </param>
	<param name="beginTerminatorOpt">
 The statement terminator token that ended the Begin statement. Optional only
 for single line lambdas.
 </param>
	<param name="body">
 The body of the lambda. Depending on the kind of lambda, this is either a
 Statement (single-line Sub lambda) or Expression (single-line Function).
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SingleLineLambdaExpression(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.LambdaHeaderSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxNode)">
	<summary>
 Represents a single line lambda expression.
 </summary>
	<param name="kind">
 A &amp;lt;cref c="SyntaxKind"/&amp;gt; representing the specific kind of
 SingleLineLambdaExpressionSyntax. One of SingleLineFunctionLambdaExpression,
 SingleLineSubLambdaExpression.
 </param>
	<param name="begin">
 The header part of the lambda that includes the "Sub" or "Function" keyword,
 the argument list and return type.
 </param>
	<param name="beginTerminatorOpt">
 The statement terminator token that ended the Begin statement. Optional only
 for single line lambdas.
 </param>
	<param name="body">
 The body of the lambda. Depending on the kind of lambda, this is either a
 Statement (single-line Sub lambda) or Expression (single-line Function).
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.MultiLineFunctionLambdaExpression(Roslyn.Compilers.VisualBasic.LambdaHeaderSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a multi-line lambda expression.
 </summary>
	<param name="begin">
 The header part of the lambda that includes the "Sub" or "Function" keyword,
 the argument list and return type.
 </param>
	<param name="beginTerminatorOpt">
 The statement terminator token that ended the Begin statement. Optional only
 for single line lambdas.
 </param>
	<param name="statements">
 The body of the lambda. Depending on the kind of lambda, this is either a
 StatementBody (multi-line lambda), Statement (single-line Sub lambda) or
 Expression (single-line Function). This might be an empty list.
 </param>
	<param name="end">
 Returns the "End Sub" or "End Function" statement if this is a multi-line
 lambda.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.MultiLineSubLambdaExpression(Roslyn.Compilers.VisualBasic.LambdaHeaderSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a multi-line lambda expression.
 </summary>
	<param name="begin">
 The header part of the lambda that includes the "Sub" or "Function" keyword,
 the argument list and return type.
 </param>
	<param name="beginTerminatorOpt">
 The statement terminator token that ended the Begin statement. Optional only
 for single line lambdas.
 </param>
	<param name="statements">
 The body of the lambda. Depending on the kind of lambda, this is either a
 StatementBody (multi-line lambda), Statement (single-line Sub lambda) or
 Expression (single-line Function). This might be an empty list.
 </param>
	<param name="end">
 Returns the "End Sub" or "End Function" statement if this is a multi-line
 lambda.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.MultiLineLambdaExpression(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.LambdaHeaderSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a multi-line lambda expression.
 </summary>
	<param name="kind">
 A &amp;lt;cref c="SyntaxKind"/&amp;gt; representing the specific kind of
 MultiLineLambdaExpressionSyntax. One of MultiLineFunctionLambdaExpression,
 MultiLineSubLambdaExpression.
 </param>
	<param name="begin">
 The header part of the lambda that includes the "Sub" or "Function" keyword,
 the argument list and return type.
 </param>
	<param name="beginTerminatorOpt">
 The statement terminator token that ended the Begin statement. Optional only
 for single line lambdas.
 </param>
	<param name="statements">
 The body of the lambda. Depending on the kind of lambda, this is either a
 StatementBody (multi-line lambda), Statement (single-line Sub lambda) or
 Expression (single-line Function). This might be an empty list.
 </param>
	<param name="end">
 Returns the "End Sub" or "End Function" statement if this is a multi-line
 lambda.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SubLambdaHeader(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeBlockSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 Represents the header part of a lambda expression
 </summary>
	<param name="attributes">
 A list of all attribute blocks on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="parameterListOpt">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClauseOpt">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.FunctionLambdaHeader(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeBlockSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 Represents the header part of a lambda expression
 </summary>
	<param name="attributes">
 A list of all attribute blocks on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="parameterListOpt">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClauseOpt">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.LambdaHeader(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeBlockSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 Represents the header part of a lambda expression
 </summary>
	<param name="kind">
 A &amp;lt;cref c="SyntaxKind"/&amp;gt; representing the specific kind of
 LambdaHeaderSyntax. One of SubLambdaHeader, FunctionLambdaHeader.
 </param>
	<param name="attributes">
 A list of all attribute blocks on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="parameterListOpt">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClauseOpt">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ArgumentList(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ArgumentSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a parenthesized argument list.
 </summary>
	<param name="openParenToken">
 The "(" token.
 </param>
	<param name="arguments">
 The list of arguments. This may be empty. Ommitted argument are represented by
 an OmittedArgumentSyntax node.
 </param>
	<param name="closeParenToken">
 The ")" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.OmittedArgument(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an omitted argument in an argument list. An omitted argument is not
 considered a syntax error but a valid case when no argument is required.
 </summary>
	<param name="empty">
 An empty token because all non terminals must have a token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SimpleArgument(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a simple argument that is just an expression.
 </summary>
	<param name="expression">
 The expression that is the argument.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.NamedArgument(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a named argument, such as "Value:=7".
 </summary>
	<param name="identifier">
 The name used to identify the named argument.
 </param>
	<param name="colonEqualsToken">
 The ":=" token.
 </param>
	<param name="expression">
 The expression that is the named argument.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.RangeArgument(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a range argument, such as "0 to 5", used in array bounds. The
 "Value" property represents the upper bound of the range.
 </summary>
	<param name="lowerBound">
 The lower bound of the range. This is typically the integer constant zero.
 </param>
	<param name="toKeyword">
 The "To" keyword.
 </param>
	<param name="upperBound">
 The upper bound of the range.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.QueryExpression(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.QueryOperatorSyntax})">
	<summary>
 This class represents a query expression. A query expression is composed of one
 or more query operators in a row. The first query operator must be a From or
 Aggregate.
 </summary>
	<param name="queryOperators">
 A list of all the query operators in this query expression. This list always
 contains at least one operator.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CollectionRangeVariable(Roslyn.Compilers.VisualBasic.ModifiedIdentifierSyntax,Roslyn.Compilers.VisualBasic.SimpleAsClauseSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Describes a single variable of the form "x [As Type] In expression" for use in
 query expressions.
 </summary>
	<param name="identifier">
 The name of the range variable being defined.
 </param>
	<param name="asClauseOpt">
 Describes the type of the variable being defined.
 </param>
	<param name="inKeyword">
 The "In" keyword.
 </param>
	<param name="expression">
 The expression that serves as the source of items for the range variable.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ExpressionRangeVariable(Roslyn.Compilers.VisualBasic.VariableNameEqualsSyntax,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Describes a single variable of the form "[x [As Type] =] expression" for use in
 query expressions.
 </summary>
	<param name="nameEqualsOpt">
 The optional name and type of the expression range variable. If ommitted, the
 name of the expression range variable is inferred from the expression.
 </param>
	<param name="expression">
 The expression used to initialize the expression variable.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AggregationRangeVariable(Roslyn.Compilers.VisualBasic.VariableNameEqualsSyntax,Roslyn.Compilers.VisualBasic.AggregationSyntax)">
	<summary>
 Describes a single variable of the form "[x [As Type] =] aggregation-function"
 for use in the Into clause of Aggregate or Group By or Group Join query
 operators.
 </summary>
	<param name="nameEqualsOpt">
 The optional name and type of the expression range variable. If ommitted, the
 name of the expression range variable is inferred from the aggregation
 expression.
 </param>
	<param name="aggregation">
 The name of the aggregation function. The "Group" aggregation function is
 represented by the identifier "Group".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.VariableNameEquals(Roslyn.Compilers.VisualBasic.ModifiedIdentifierSyntax,Roslyn.Compilers.VisualBasic.SimpleAsClauseSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents the name and optional type of an expression range variable.
 </summary>
	<param name="identifier">
 The name of the variable being defined.
 </param>
	<param name="asClauseOpt">
 Describes the type of the variable being defined.
 </param>
	<param name="equalsToken">
 The "=" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.FunctionAggregation(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an invocation of an Aggregation function in the aggregation range
 variable declaration of a Group By, Group Join or Aggregate query operator.
 </summary>
	<param name="functionName">
 The name of the aggregation function.
 </param>
	<param name="openParenTokenOpt">
 The "(" token if present.
 </param>
	<param name="argumentOpt">
 The argument to the aggregation function.
 </param>
	<param name="closeParenTokenOpt">
 The ")" token, if present.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.GroupAggregation(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents the use of "Group" as the aggregation function in the in the
 aggregation range variable declaration of a Group By or Group Join query
 operator.
 </summary>
	<param name="groupKeyword">
 The "Group" keyword.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.FromQueryOperator(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.CollectionRangeVariableSyntax})">
	<summary>
 Represents a "From" query operator. If this is the beginning of a query, the
 Source will be Nothing. Otherwise, the Source will be the part of the query to
 the left of the From.
 </summary>
	<param name="fromKeyword">
 The "From" keyword.
 </param>
	<param name="variables">
 The list of collection variables declared by this From operator.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.LetQueryOperator(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ExpressionRangeVariableSyntax})">
	<summary>
 Represents a "Let" query operator.
 </summary>
	<param name="letKeyword">
 The "Let" keyword.
 </param>
	<param name="variables">
 The list of expression range variable being defined by the Let operator.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AggregateQueryOperator(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.CollectionRangeVariableSyntax},Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.QueryOperatorSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.AggregationRangeVariableSyntax})">
	<summary>
 Represents an Aggregate query operator.
 </summary>
	<param name="aggregateKeyword">
 The "Aggregate" keyword.
 </param>
	<param name="variables">
 The list of collection range variables declared by this Aggregate operator.
 </param>
	<param name="additionalQueryOperators">
 A list of additional query operators. It may be empty.
 </param>
	<param name="intoKeyword">
 The "Into" keyword.
 </param>
	<param name="aggregationVariables">
 The list of new variables being defined by the aggregation.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DistinctQueryOperator(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents the "Distinct" query operator.
 </summary>
	<param name="distinctKeyword">
 The "Distinct" keyword.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.WhereQueryOperator(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a "Where" query operator.
 </summary>
	<param name="whereKeyword">
 The "Where" keyword.
 </param>
	<param name="condition">
 The boolean expression used for filtering.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SkipWhileQueryOperator(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a "Skip While" or "Take While" query operator. The Kind property
 tells which.
 </summary>
	<param name="skipOrTakeKeyword">
 The "Skip" or "Take" keyword.
 </param>
	<param name="whileKeyword">
 The "While" keyword.
 </param>
	<param name="condition">
 The boolean expression used for partitioning.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.TakeWhileQueryOperator(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a "Skip While" or "Take While" query operator. The Kind property
 tells which.
 </summary>
	<param name="skipOrTakeKeyword">
 The "Skip" or "Take" keyword.
 </param>
	<param name="whileKeyword">
 The "While" keyword.
 </param>
	<param name="condition">
 The boolean expression used for partitioning.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.PartitionWhileQueryOperator(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a "Skip While" or "Take While" query operator. The Kind property
 tells which.
 </summary>
	<param name="kind">
 A &amp;lt;cref c="SyntaxKind"/&amp;gt; representing the specific kind of
 PartitionWhileQueryOperatorSyntax. One of SkipWhileQueryOperator,
 TakeWhileQueryOperator.
 </param>
	<param name="skipOrTakeKeyword">
 The "Skip" or "Take" keyword.
 </param>
	<param name="whileKeyword">
 The "While" keyword.
 </param>
	<param name="condition">
 The boolean expression used for partitioning.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SkipQueryOperator(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a "Skip" or "Take" query operator. The Kind property tells which.
 </summary>
	<param name="skipOrTakeKeyword">
 The "Skip" or "Take" keyword.
 </param>
	<param name="count">
 Represents the expression with the number of items to take or skip.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.TakeQueryOperator(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a "Skip" or "Take" query operator. The Kind property tells which.
 </summary>
	<param name="skipOrTakeKeyword">
 The "Skip" or "Take" keyword.
 </param>
	<param name="count">
 Represents the expression with the number of items to take or skip.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.PartitionQueryOperator(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a "Skip" or "Take" query operator. The Kind property tells which.
 </summary>
	<param name="kind">
 A &amp;lt;cref c="SyntaxKind"/&amp;gt; representing the specific kind of
 PartitionQueryOperatorSyntax. One of SkipQueryOperator, TakeQueryOperator.
 </param>
	<param name="skipOrTakeKeyword">
 The "Skip" or "Take" keyword.
 </param>
	<param name="count">
 Represents the expression with the number of items to take or skip.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.GroupByQueryOperator(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ExpressionRangeVariableSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ExpressionRangeVariableSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.AggregationRangeVariableSyntax})">
	<summary>
 Represents the "Group By" query operator.
 </summary>
	<param name="groupKeyword">
 The "Group" keyword.
 </param>
	<param name="items">
 The optional list of variables being grouped; the contents of the Group clause.
 If none were specified, an empty list is returned.
 </param>
	<param name="byKeyword">
 The "By" keyword.
 </param>
	<param name="keys">
 The key values being used for grouping.
 </param>
	<param name="aggregationVariables">
 The list of new variables that calculate aggregations.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.JoinQueryOperator(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.CollectionRangeVariableSyntax},Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.JoinQueryOperatorSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.JoinConditionSyntax})">
	<summary>
 Represents a Join query operator.
 </summary>
	<param name="joinKeyword">
 The "Join" keyword.
 </param>
	<param name="joinedVariables">
 Defines the collection range variables being joined to.
 </param>
	<param name="additionalJoins">
 An additional Join or Group Join query operator.
 </param>
	<param name="onKeyword">
 The "On" keyword.
 </param>
	<param name="joinConditions">
 The conditions indicating what expressions to compare during the join. Each
 condition is a JoinCondition, and the separators are "And" keywords.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.JoinCondition(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents the "expression Equals expression" condition in a Join.
 </summary>
	<param name="left">
 The left expression in the Join condition.
 </param>
	<param name="equalsKeyword">
 The "Equals" keyword.
 </param>
	<param name="right">
 The right expression in the Join condition.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.GroupJoinQueryOperator(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.CollectionRangeVariableSyntax},Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.JoinQueryOperatorSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.JoinConditionSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.AggregationRangeVariableSyntax})">
	<summary>
 Represents the "Group Join" query operator.
 </summary>
	<param name="groupKeyword">
 The "Group" keyword.
 </param>
	<param name="joinKeyword">
 The "Join" keyword.
 </param>
	<param name="joinedVariables">
 Defines the collection range variables being joined to.
 </param>
	<param name="additionalJoins">
 An additional Join or Group Join query operator.
 </param>
	<param name="onKeyword">
 The "On" keyword.
 </param>
	<param name="joinConditions">
 The conditions indicating what expressions to compare during the join. Each
 condition is a JoinCondition, and the separators are "And" keywords.
 </param>
	<param name="intoKeyword">
 The "Into" keyword.
 </param>
	<param name="aggregationVariables">
 The list of new variables that calculate aggregations.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.OrderByQueryOperator(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.OrderingSyntax})">
	<summary>
 Represents the "Order By" query operator.
 </summary>
	<param name="orderKeyword">
 The "Order" keyword
 </param>
	<param name="byKeyword">
 The "By" keyword.
 </param>
	<param name="orderings">
 The list of OrderExpression's to sort by.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AscendingOrdering(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 An expression to order by, plus an optional ordering. The Kind indicates
 whether to order in ascending or descending order.
 </summary>
	<param name="expression">
 The expression to sort by.
 </param>
	<param name="ascendingOrDescendingKeywordOpt">
 The "Ascending" or "Descending" keyword, if present. To determine whether to
 sort in ascending or descending order, checking the Kind property is easier.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DescendingOrdering(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 An expression to order by, plus an optional ordering. The Kind indicates
 whether to order in ascending or descending order.
 </summary>
	<param name="expression">
 The expression to sort by.
 </param>
	<param name="ascendingOrDescendingKeywordOpt">
 The "Ascending" or "Descending" keyword, if present. To determine whether to
 sort in ascending or descending order, checking the Kind property is easier.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.Ordering(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 An expression to order by, plus an optional ordering. The Kind indicates
 whether to order in ascending or descending order.
 </summary>
	<param name="kind">
 A &amp;lt;cref c="SyntaxKind"/&amp;gt; representing the specific kind of
 OrderingSyntax. One of AscendingOrdering, DescendingOrdering.
 </param>
	<param name="expression">
 The expression to sort by.
 </param>
	<param name="ascendingOrDescendingKeywordOpt">
 The "Ascending" or "Descending" keyword, if present. To determine whether to
 sort in ascending or descending order, checking the Kind property is easier.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SelectQueryOperator(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ExpressionRangeVariableSyntax})">
	<summary>
 Represents the "Select" query operator.
 </summary>
	<param name="selectKeyword">
 The "Select" keyword.
 </param>
	<param name="variables">
 The list of expression range variables being defined by the Select query
 operator.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlDocument(Roslyn.Compilers.VisualBasic.XmlDeclarationSyntax,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.XmlNodeSyntax},Roslyn.Compilers.VisualBasic.XmlNodeSyntax,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.XmlNodeSyntax})">
	<summary>
 Represents and XML Document literal expression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlDeclaration(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.XmlDeclarationOptionSyntax,Roslyn.Compilers.VisualBasic.XmlDeclarationOptionSyntax,Roslyn.Compilers.VisualBasic.XmlDeclarationOptionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents the XML declaration prologue in an XML literal expression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlDeclarationOption(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.XmlStringSyntax)">
	<summary>
 Represents an XML document prologue option - version, encoding, standalone or
 whitespace in an XML literal expression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlElement(Roslyn.Compilers.VisualBasic.XmlElementStartTagSyntax,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.XmlNodeSyntax},Roslyn.Compilers.VisualBasic.XmlElementEndTagSyntax)">
	<summary>
 Represents an XML element with content in an XML literal expression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlText(Roslyn.Compilers.VisualBasic.SyntaxTokenList)">
	<summary>
 Represents Xml text.
 </summary>
	<param name="textTokens">
 A list of all the text tokens in the Xml text. This list always contains at
 least one token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlElementStartTag(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.XmlNodeSyntax,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.XmlNodeSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents the start tag of an XML element of the form &amp;lt;element&amp;gt;.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlElementEndTag(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.XmlNameSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents the end tag of an XML element of the form &amp;lt;/element&amp;gt;.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlEmptyElement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.XmlNodeSyntax,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.XmlNodeSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an empty XML element of the form &amp;lt;element /&amp;gt;
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlAttribute(Roslyn.Compilers.VisualBasic.XmlNodeSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.XmlNodeSyntax)">
	<summary>
 Represents an XML attribute in an XML literal expression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlString(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a string of XML characters embedded as the content of an XML
 element.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlName(Roslyn.Compilers.VisualBasic.XmlPrefixSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an XML name of the form 'name' or 'namespace:name' appearing in
 source as part of an XML literal or member access expression or an XML
 namespace import clause.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlBracketedName(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.XmlNameSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an XML name of the form &amp;lt;xml-name&amp;gt; appearing in source
 as part of an XML literal or member access expression or an XML namespace
 import clause.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlPrefix(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents and XML namespace prefix of the form 'prefix:' as in xml:ns="".
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlComment(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an XML comment of the form &amp;lt;-- Comment --&amp;gt; appearing
 in an XML literal expression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlProcessingInstruction(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an XML processing instruction of the form '&amp;lt;?
 XMLProcessingTarget XMLProcessingValue ?&amp;gt;'.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlCDataSection(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an XML CDATA section in an XML literal expression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlEmbeddedExpression(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an embedded expression in an XML literal e.g.
 '&amp;lt;name&amp;gt;&amp;lt;%= obj.Name =%&amp;gt;&amp;lt;/name&amp;gt;'.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ArrayType(Roslyn.Compilers.VisualBasic.TypeSyntax,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.ArrayRankSpecifierSyntax})">
	<summary>
 Represents an array type, such as "A() or "A(,)", without bounds specified for
 the array.
 </summary>
	<param name="elementType">
 The type of the elements of the array.
 </param>
	<param name="rankSpecifiers">
 Represents the list of "()" or "(,,)" modifiers on the array type.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.NullableType(Roslyn.Compilers.VisualBasic.TypeSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 A type name that represents a nullable type, such as "Integer?".
 </summary>
	<param name="elementType">
 The kind of type that is this type is a nullable of. Cannot be an array type or
 a nullable type.
 </param>
	<param name="questionMarkToken">
 The "?" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.PredefinedType(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an occurrence of a Visual Basic built-in type such as Integer or
 String in source code.
 </summary>
	<param name="keyword">
 The keyword that was used to describe the built-in type.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.IdentifierName(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a type name consisting of a single identifier (which might include
 brackets or a type character).
 </summary>
	<param name="identifier">
 The identifier in the name.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.GenericName(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeArgumentListSyntax)">
	<summary>
 Represents a simple type name with one or more generic arguments, such as "X(Of
 Y, Z).
 </summary>
	<param name="identifier">
 The identifier in the name.
 </param>
	<param name="typeArgumentList">
 The generic argument list.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.QualifiedName(Roslyn.Compilers.VisualBasic.NameSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SimpleNameSyntax)">
	<summary>
 Represents a qualified type name, for example X.Y or X(Of Z).Y.
 </summary>
	<param name="left">
 The part of the name that appears to the left of the dot. This can itself be
 any name.
 </param>
	<param name="dotToken">
 The "." token that seperates the names.
 </param>
	<param name="right">
 The part of the name that appears to the right of the dot. This must be a
 simple identifier.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.GlobalName(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a name in the global namespace.
 </summary>
	<param name="globalKeyword">
 The "Global" keyword.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.TypeArgumentList(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.TypeSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a parenthesized list of generic type arguments.
 </summary>
	<param name="openParenToken">
 The "(" token.
 </param>
	<param name="ofKeyword">
 The "Of" keyword.
 </param>
	<param name="arguments">
 A list of all the type arguments.
 </param>
	<param name="closeParenToken">
 The ")" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlNameToken(System.String,Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.SyntaxTriviaList,Roslyn.Compilers.VisualBasic.SyntaxTriviaList)">
	<summary>
 Represents an Xml NCName per Namespaces in XML 1.0
 </summary>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlTextLiteralToken(System.String,System.String,Roslyn.Compilers.VisualBasic.SyntaxTriviaList,Roslyn.Compilers.VisualBasic.SyntaxTriviaList)">
	<summary>
 Represents character data in Xml content also known as PCData or in an Xml
 attribute value. All text is here for now even text that does not need
 normalizationsuch as comment, pi and cdata text.
 </summary>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlEntityLiteralToken(System.String,System.String,Roslyn.Compilers.VisualBasic.SyntaxTriviaList,Roslyn.Compilers.VisualBasic.SyntaxTriviaList)">
	<summary>
 Represents character data in Xml content also known as PCData or in an Xml
 attribute value. All text is here for now even text that does not need
 normalizationsuch as comment, pi and cdata text.
 </summary>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlTextToken(Roslyn.Compilers.VisualBasic.SyntaxKind,System.String,System.String,Roslyn.Compilers.VisualBasic.SyntaxTriviaList,Roslyn.Compilers.VisualBasic.SyntaxTriviaList)">
	<summary>
 Represents character data in Xml content also known as PCData or in an Xml
 attribute value. All text is here for now even text that does not need
 normalizationsuch as comment, pi and cdata text.
 </summary>
	<param name="kind">
 A &amp;lt;cref c="SyntaxKind"/&amp;gt; representing the specific kind of
 XmlTextTokenSyntax. One of XmlTextLiteralToken, XmlEntityLiteralToken.
 </param>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DecimalLiteralToken(System.String,Roslyn.Compilers.VisualBasic.TypeCharacter,System.Decimal,Roslyn.Compilers.VisualBasic.SyntaxTriviaList,Roslyn.Compilers.VisualBasic.SyntaxTriviaList)">
	<summary>
 Represents a Decimal literal token.
 </summary>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DateLiteralToken(System.String,System.DateTime,Roslyn.Compilers.VisualBasic.SyntaxTriviaList,Roslyn.Compilers.VisualBasic.SyntaxTriviaList)">
	<summary>
 Represents an Date literal token.
 </summary>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.StringLiteralToken(System.String,System.String,Roslyn.Compilers.VisualBasic.SyntaxTriviaList,Roslyn.Compilers.VisualBasic.SyntaxTriviaList)">
	<summary>
 Represents an string literal token.
 </summary>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CharacterLiteralToken(System.String,System.Char,Roslyn.Compilers.VisualBasic.SyntaxTriviaList,Roslyn.Compilers.VisualBasic.SyntaxTriviaList)">
	<summary>
 Represents an string literal token.
 </summary>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SkippedTokens(Roslyn.Compilers.VisualBasic.SyntaxTokenList)">
	<summary>
 Represents tokens that were skipped by the parser as part of error recovery,
 and thus are not part of any syntactic structure.
 </summary>
	<param name="tokens">
 The list of tokens that were skipped by the parser.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DocumentationComment(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.XmlNodeSyntax})">
	<summary>
 Represents a documentation comment e.g. ''' &amp;lt;Summary&amp;gt; apearing in
 source.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.Directive(Roslyn.Compilers.VisualBasic.DirectiveStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a preprocessor directive
 </summary>
	<param name="terminator">
 The statement terminator token that ended the Directive.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.WhitespaceTrivia(System.String)">
	<summary>
 Trivia nodes represents parts of the program text that are not parts of the
 syntactic grammar, such as spaces, newlines, comments, preprocessors
 directives, and disabled code.
 </summary>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndOfLineTrivia(System.String)">
	<summary>
 Trivia nodes represents parts of the program text that are not parts of the
 syntactic grammar, such as spaces, newlines, comments, preprocessors
 directives, and disabled code.
 </summary>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ColonTrivia(System.String)">
	<summary>
 Trivia nodes represents parts of the program text that are not parts of the
 syntactic grammar, such as spaces, newlines, comments, preprocessors
 directives, and disabled code.
 </summary>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CommentTrivia(System.String)">
	<summary>
 Trivia nodes represents parts of the program text that are not parts of the
 syntactic grammar, such as spaces, newlines, comments, preprocessors
 directives, and disabled code.
 </summary>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.LineContinuationTrivia(System.String)">
	<summary>
 Trivia nodes represents parts of the program text that are not parts of the
 syntactic grammar, such as spaces, newlines, comments, preprocessors
 directives, and disabled code.
 </summary>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ImplicitLineContinuationTrivia(System.String)">
	<summary>
 Trivia nodes represents parts of the program text that are not parts of the
 syntactic grammar, such as spaces, newlines, comments, preprocessors
 directives, and disabled code.
 </summary>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DocumentationCommentExteriorTrivia(System.String)">
	<summary>
 Trivia nodes represents parts of the program text that are not parts of the
 syntactic grammar, such as spaces, newlines, comments, preprocessors
 directives, and disabled code.
 </summary>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DisabledTextTrivia(System.String)">
	<summary>
 Trivia nodes represents parts of the program text that are not parts of the
 syntactic grammar, such as spaces, newlines, comments, preprocessors
 directives, and disabled code.
 </summary>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SkippedTextTrivia(System.String)">
	<summary>
 Trivia nodes represents parts of the program text that are not parts of the
 syntactic grammar, such as spaces, newlines, comments, preprocessors
 directives, and disabled code.
 </summary>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SyntaxTrivia(Roslyn.Compilers.VisualBasic.SyntaxKind,System.String)">
	<summary>
 Trivia nodes represents parts of the program text that are not parts of the
 syntactic grammar, such as spaces, newlines, comments, preprocessors
 directives, and disabled code.
 </summary>
	<param name="kind">
 A &amp;lt;cref c="SyntaxKind"/&amp;gt; representing the specific kind of
 SyntaxTrivia. One of WhitespaceTrivia, EndOfLineTrivia, ColonTrivia,
 CommentTrivia, LineContinuationTrivia, ImplicitLineContinuationTrivia,
 DocumentationCommentExteriorTrivia, DisabledTextTrivia, SkippedTextTrivia.
 </param>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ConstDirective(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a #Const pre-processing constant declaration appearing in source.
 </summary>
	<param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
	<param name="constKeyword">
 The "Const" keyword.
 </param>
	<param name="name">
 The name of the pre-processing constant being defined.
 </param>
	<param name="equalsToken">
 The "=" token.
 </param>
	<param name="value">
 An expression representing the value of the pre-processing constant being
 defined.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.IfDirective(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents the beginning of an #If pre-processing directive appearing in
 source.
 </summary>
	<param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ElseIfDirective(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents the beginning of an #If pre-processing directive appearing in
 source.
 </summary>
	<param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ElseDirective(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an #Else pre-processing directive appearing in source.
 </summary>
	<param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndIfDirective(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an #End If pre-processing directive appearing in source.
 </summary>
	<param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.RegionDirective(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents the beginning of a #Region directive appearing in source.
 </summary>
	<param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
	<param name="regionKeyword">
 The "Region" keyword.
 </param>
	<param name="name">
 The label of the code region being defined.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndRegionDirective(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an #End Region directive appearing in source.
 </summary>
	<param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
	<param name="endKeyword">
 The "End" keyword.
 </param>
	<param name="regionKeyword">
 The "Region" keyword.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ExternalSourceDirective(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents the beginning of a #ExternalSource pre-processing directive
 appearing in source.
 </summary>
	<param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndExternalSourceDirective(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an #End ExternalSource pre-processing directive appearing in source.
 </summary>
	<param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ExternalChecksumDirective(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an #ExternalChecksum pre-processing directive appearing in source.
 </summary>
	<param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.BadDirective(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an unrecognized pre-processing directive. This occurs when the
 parser encounters a hash '#' token at the beginning of a physical line but does
 recognize the text that follows as a valid Visual Basic pre-processing
 directive.
 </summary>
	<param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.ChildSyntaxList.Occupancy(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode)">
	<summary>
 How many actual nodes is represented by a node (note that some nodes are lists).
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Compilation.m_LazyWellKnownTypes">
	<summary>
 An array of cached well known types available for use in this Compilation.
 Lazily filled by GetWellKnownType method.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.Compilation.m_LazyWellKnownTypeMembers">
	<summary>
 Lazy cache of well known members.
 Not yet known value is represented by ErrorTypeSymbol.UnknownResultType
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Compilation.GetWellKnownTypeMember(Roslyn.Compilers.WellKnownMember)">
	<summary>
 Lookup member declaration in well known type used by this Compilation.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OptionsValidator.ParseImports(System.Collections.Generic.IEnumerable{System.String},Roslyn.Compilers.DiagnosticBag@)">
	<summary>
 Parse the project level imports, adding errors to the errorBag as necessary
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OptionsValidator.IsValidNamespaceName(System.String)">
	<summary>
 Validate and parse the root namespace. If the root namespace string is a valid namespace name, the parsed
 version is returned. Otherwise Nothing is returned.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OptionsValidator.IsValidRootNamespaceComponent(System.String)">
	<summary>
 Check if a string is a valid component of the root namespace. We use the usual
 VB identifier rules, but don't check for keywords (this is the same as previous versions).
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.OptionsValidator">
	<summary>
 This class is used to validate the compiler options.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeSymbol.BaseType">
	<summary>
 Gets the BaseType of this type. If the base type could not be determined, then 
 an instance of ErrorType is returned. If this kind of type does not have a base type
 (for example, interfaces), Nothing is returned. Also the special class System.Object
 always has a BaseType of Nothing.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeSymbol.Interfaces">
	<summary>
 Gets the set of interfaces that this type directly implements. This set does not
 include interfaces that are base interfaces of directed implemented interfaces.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeSymbol.AllInterfaces">
	<summary>
 The list of all interfaces of which this type is a declared subtype, excluding this type
 itself. This includes all declared base interfaces, all declared base interfaces of base
 types, and all declared base interfaces of those results (recursively).  Each result
 appears exactly once in the list. This list is topologically sorted by the inheritance
 relationship: if interface type A extends interface type B, then A precedes B in the
 list. This is not quite the same as "all interfaces of which this type is a proper
 subtype" because it does not take into account variance: AllInterfaces for
 IEnumerable&lt;string&gt; will not include IEnumerble&lt;object&gt;
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeSymbol.MakeAllInterfaces">
 Produce all implemented interfaces in topologically sorted order. We use
 TypeSymbol.Interfaces as the source of edge data, which has had cycles and infinitely
 long dependency cycles removed. Consequently, it is possible (and we do) use the
 simplest version of Tarjan's topological sorting algorithm.

</member><member name="P:Roslyn.Compilers.VisualBasic.TypeSymbol.InterfacesAndTheirBaseInterfaces">
	<summary>
 Gets the set of interfaces that this type directly implements, plus the base interfaces
 of all such types.
 </summary>
	<remarks>
 CONSIDER: it probably isn't truly necessary to cache this.  If space gets tight, consider
 alternative approaches (recompute every time, cache on the side, only store on some types,
 etc).
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeSymbol.IsReferenceType">
	<summary>
 Returns true if this type is known to be a reference type. It is never the case
 that IsReferenceType and IsValueType both return true. However, for an unconstrained
 type parameter, IsReferenceType and IsValueType will both return false.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeSymbol.IsValueType">
	<summary>
 Returns true if this type is known to be a value type. It is never the case
 that IsReferenceType and IsValueType both return true. However, for an unconstrained
 type parameter, IsReferenceType and IsValueType will both return false.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeSymbol.IsAnonymousType">
	<summary>
 Is this a symbol for an anonymous type (including delegate).
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeSymbol.TypeKind">
	<summary>
 Gets the kind of this type.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeSymbol.SpecialType">
	<summary>
 Gets corresponding special TypeId of this type.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeSymbol.PrimitiveTypeCode">
	<summary>
 Gets corresponding primitive type code for this type declaration.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeSymbol.InternalSubstituteTypeParameters(Roslyn.Compilers.VisualBasic.TypeSubstitution)">
	<summary>
 Substitute the given type substitution within this type, returning a new type. If the
 substitution had no effect, return Me. 
 !!! Only code implementing construction of generic types is allowed to call this method !!!
 !!! All other code should use Construct methods.                                        !!! 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeSymbol.LookupMetadataType(System.String,System.Int32)">
	<summary>
 Lookup an immediately nested type referenced from metadata, names should be
 compared case-sensitively.
 </summary>
	<param name="typeName">
 Simple type name with generic name mangling removed.
 </param>
	<param name="arity">
 Target arity of the type.
 </param>
	<returns>
 Symbol for the type, or MissingMetadataSymbol if the type isn't found.
 </returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeSymbol.GetUseSiteErrorInfo">
	<summary>
 Returns error info for an error, if any, that should be reported at the use site of the symbol.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeSymbol.GetUseSiteErrorInfo(System.Collections.Generic.HashSet{Roslyn.Compilers.VisualBasic.TypeSymbol}@)">
	<summary>
 Has the same purpose as the one above, but carries a hash set of types that are being checked or have been checked
 already in order to avoid duplicate work and, more importantly, avoid infinit loops due to cyclic type references.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeSymbol.HighestPriorityUseSiteError">
	<summary>
 Return error code that has highest priority while calculating use site error for this symbol. 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeSymbol.FindImplementationForInterfaceMember(Roslyn.Compilers.VisualBasic.Symbol)">
	<summary>
 Returns the corresponding symbol in this type or a base type that implements 
 interfaceMember (either implicitly or explicitly), or null if no such symbol 
 exists (which might be either because this type doesn't implement the container 
 of interfaceMember, or this type doesn't supply a member that successfully 
 implements interfaceMember).
 </summary>
	<param name="interfaceMember">
 Must be an interface property, method, or event.
 </param>
	<returns>The implementing member.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeSymbol.ComputeImplementationForInterfaceMember(Roslyn.Compilers.VisualBasic.Symbol)">
	<summary>
 Compute the implementation for an interface member in this type, or Nothing if none.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.TypeSymbol">
	<summary>
 A TypeSymbol is a base class for all the symbols that represent a type
 in Visual Basic.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.TypeSubstitution._pairs">
	<summary>
 A map between type parameters of _targetGenericDefinition and corresponding type arguments.
 Represented by an array of Key-Value pairs. Keys are type parameters of _targetGenericDefinition 
 in no particular order. Identity substitutions are omitted. 
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.TypeSubstitution._targetGenericDefinition">
	<summary>
 Definition of a symbol which this instance of TypeSubstitution primarily targets.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.TypeSubstitution._parent">
	<summary>
 An instance of TypeSubstitution describing substitution for containing type.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeSubstitution.PairsIncludingParent">
	<summary>
 Get all the pairs of substitutions, including from the parent substitutations. The substutitions
 are in order from outside-in (parent substutitions before child substitutions).
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeSubstitution.ThrowIfSubstitutingToAlphaRenamedTypeParameter">
	<summary>
 Verify TypeSubstitution to make sure it dosn't map any 
 type parameter to an alpha-renamed type parameter.
 </summary>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeSubstitution.GetSubstitutionForGenericDefinition(Roslyn.Compilers.VisualBasic.Symbol)">
	<summary>
 Return TypeSubstitution instance that targets particular generic definition.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeSubstitution.IsValidToApplyTo(Roslyn.Compilers.VisualBasic.Symbol)">
	<summary>
 Does substitution target either genericDefinition or 
 one of it's containers?
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeSubstitution.Concat(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.TypeSubstitution,Roslyn.Compilers.VisualBasic.TypeSubstitution)">
	<summary>
 Combine two substitutions into one by concatinating. 
 
 They may not directly or indirectly (through Parent) target the same generic definition.
 sub2 is expected to target types lower in the containership hierarchy.
 Either or both can be Nothing. 
 
 targetGenericDefinition specifies target generic definition for the result. 
 If sub2 is not Nothing, it must target targetGenericDefinition.
 If sub2 is Nothing, sub1 will be "extended" with identity substitutions to target 
 targetGenericDefinition.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeSubstitution.Create(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.TypeParameterSymbol[],Roslyn.Compilers.VisualBasic.TypeSymbol[])">
	<summary>
 Create a substitution. If the substitution is the identity substitution, Nothing is returned.
 </summary>
	<param name="targetGenericDefinition">Generic definition the result should target.</param>
	<param name="params">
 Type parameter definitions. Duplicates aren't allowed. Type parameters of containing type
 must precede type parameters of a nested type.  
 </param>
	<param name="args">Corresponding type arguments.</param>
	<returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeSubstitution.Create(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.TypeParameterSymbol},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.TypeSymbol})">
	<summary>
 Create a substitution. If the substitution is the identity substitution, Nothing is returned.
 </summary>
	<param name="targetGenericDefinition">Generic definition the result should target.</param>
	<param name="params">
 Type parameter definitions. Duplicates aren't allowed. Type parameters of containing type
 must precede type parameters of a nested type.  
 </param>
	<param name="args">Corresponding type arguments.</param>
	<returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeSubstitution.Concat(Roslyn.Compilers.VisualBasic.TypeSubstitution,Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.ReadOnlyArray{System.Collections.Generic.KeyValuePair{Roslyn.Compilers.VisualBasic.TypeParameterSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol}})">
	<summary>
 Private helper to make sure identity substitutions are injected for types between 
 targetGenericDefinition and parent.TargetGenericDefinition.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeSubstitution.CreateForAlphaRename(Roslyn.Compilers.VisualBasic.TypeSubstitution,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.TypeParameterSymbol})">
	<summary>
 Create substitution to handle alpha-renaming of type parameters. 
 It maps type parameter definition to corresponding alpha-renamed type parameter.
 </summary>
	<param name="alphaRenamedTypeParameters">Alpha-renamed type parameters.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeSubstitution.CreateAdditionalMethodTypeParameterSubstitution(Roslyn.Compilers.VisualBasic.MethodSymbol,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.TypeSymbol})">
	<summary>
 Create TypeSubstitution that can be used to substitute method's type parameters
 in types involved in method's signature. 
 
 Unlike for other contruction methods in this class, targetMethod doesn't have to be 
 original definition, it is allowed to be specialized unconstructed generic method.
 
 An item in typeArguments can be an alpha-renamed type parameter, but it must belong
 to the targetMethod and can only appear at its ordinal position to represent the lack
 of substitution for it.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeSubstitution.AddjustForConstruct(Roslyn.Compilers.VisualBasic.TypeSubstitution,Roslyn.Compilers.VisualBasic.TypeSubstitution,Roslyn.Compilers.VisualBasic.TypeSubstitution)">
	<summary>
 Adjust substitution for construction.
 This has the following effects:
     1) The passed in additionalSubstitution is used on each type argument.
     2) If any parameters in the given additionalSubstitution are not present in oldConstructSubstitution, they are added.
     3) Parent substitution in oldConstructSubstitution is replaced with adjustedParent. 
 
 oldConstructSubstitution can be cancelled out by additionalSubstitution. In this case, 
 if the adjustedParent is Nothing, Nothing is returned.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeSubstitution.PrivateAddjustForConstruct(Roslyn.Compilers.ArrayBuilder{System.Collections.Generic.KeyValuePair{Roslyn.Compilers.VisualBasic.TypeParameterSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol}},Roslyn.Compilers.VisualBasic.TypeSubstitution,Roslyn.Compilers.VisualBasic.TypeSubstitution)">
	<summary>
 This has the following effects:
     1) The passed in additionalSubstitution is used on each type argument.
     2) If any parameters in the given additionalSubstitution are not present in oldConstructSubstitution, they are added.
 
 Result is placed into pairs. Identity substitutions are omitted.
 
 Returns True if the set of pairs have changed, False otherwise.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeSubstitution.Create(Roslyn.Compilers.VisualBasic.TypeSubstitution,Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.TypeSymbol})">
	<summary>
 Create substitution for targetGenericDefinition based on its type 
 arguments (matched to type parameters by position) and TypeSubstitution
 for direct or indirect container.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.TypeSubstitution">
	<summary>
 Immutable. Thread-safe.
 
 Represents a type substitution, with substitutions of types for a set of type parameters.
 Each TypeSubstitution object has three pieces of information:
    - OriginalDefinition of generic symbol the substitution is targeting.
    - An array of pairs that provide a mapping from symbol's type parameters to type arguments.
      identity substitutions are omitted.
    - TypeSubstitution object for containing type to provide mapping for its type
      parameters, if any. 
 
 The identity substitution (for the whole type hierarchy) is represented by Nothing. That said,
 top level parent of non-Nothing instance of TypeSubstitution is guaranteed to be non-identity 
 substitution. The instance may still be an identity substitution just for target generic definition,
 which will be represented by an empty mapping array. 
 
 The chain of TypeSubstitution objects is guaranteed to not skip any type in the containership hierarchy,
 even types with zero arity contained in generic type will have corresponding TypeSubstitution object with
 empty mapping array.
 
 Example:
     Class A(Of T,S)
          Class B
              Class C(Of U)
              End Class
          End Class
     End Class 
 
 TypeSubstitution for A(Of Integer, S).B.C(Of Byte) is C{U-&gt;Byte}=&gt;B{}=&gt;A{T-&gt;Integer}
 TypeSubstitution for A(Of T, S).B.C(Of Byte) is C{U-&gt;Byte}
 TypeSubstitution for A(Of Integer, S).B is B{}=&gt;A{T-&gt;Integer}
 TypeSubstitution for A(Of Integer, S).B.C(Of U) is C{}=&gt;B{}=&gt;A{T-&gt;Integer}
 
 CONSIDER:
     An array of KeyValuePair(Of TypeParameterSymbol, TypeSymbol)objects is used to represent type 
     parameter substitution mostly due to historical reasons. It might be more convenient and more 
     efficient to use ordinal based array of TypeSymbol objects instead.

 There is a Construct method that can be called on original definition with TypeSubstitution object as
 an argument. The advantage of that method is the ability to substitute type parameters of several types  
 in the containership hierarchy in one call. What type the TypeSubstitution parameter targets makes a 
 difference.
 
 For example:
      C.Construct(C{}=&gt;B{}=&gt;A{T-&gt;Integer}) == A(Of Integer, S).B.C(Of U)
      C.Construct(B{}=&gt;A{T-&gt;Integer}) == A(Of Integer, S).B.C(Of )
      B.Construct(B{}=&gt;A{T-&gt;Integer}) == A(Of Integer, S).B
 
 See comment for IsValidToApplyTo method as well.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeParameterSymbol.Ordinal">
	<summary>
 Gets the ordinal order of this type parameter. The first type parameter has ordinal zero.
 TODO: Is this property really needed?
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeParameterSymbol.ConstraintTypes">
	<summary>
 Get the types that were directly specified as constraints on this type parameter.
 TODO: Is this member necessary, or should we instead use BaseType and Interfaces?
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeParameterSymbol.HasConstructorConstraint">
	<summary>
 Returns whether the parameterless constructor constraint was specified.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeParameterSymbol.IsMethodTypeParameter">
	<summary>
 True if this a type parameter for a generic method
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeParameterSymbol.DeclaringMethod">
	<summary>
 The method that declares this type parameter 
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeParameterSymbol.DeclaringType">
	<summary>
 The type that declares this type parameter
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeParameterSymbol.InternalSubstituteTypeParameters(Roslyn.Compilers.VisualBasic.TypeSubstitution)">
	<summary>
 Substitute the given type substitution within this type, returning a new type. If the
 substitution had no effect, return Me. 
 !!! Only code implementing construction of generic types is allowed to call this method !!!
 !!! All other code should use Construct methods.                                        !!! 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeParameterSymbol.GetNonInterfaceConstraint">
	<summary>
 Return a non-interface type constraint or Nothing.
 If there are more than one type constraints (which can happen when at least one of them
 is from another type parameter used as a constraint), pick the most derived type as the
 result.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.TypeParameterSymbol">
	<summary>
 Represents a type parameter in a generic type or generic method.
 TODO: Should document how the BaseType and Interfaces members behave.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SymbolVisitor`2.Visit(Roslyn.Compilers.VisualBasic.Symbol,`0)">
	<summary>
 Call the correct VisitXXX method in this class based on the particular type of symbol that is passed in.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SymbolVisitor`2">
	<summary>
 Virtual dispatch based on a symbol's particular class. 
 </summary>
	<typeparam name="TResult">Result type</typeparam>
	<typeparam name="TArgument">Additional argument type</typeparam>
</member><member name="M:Roslyn.Compilers.VisualBasic.SymbolExtensions.GetKindText(Roslyn.Compilers.VisualBasic.Symbol)">
	<summary>
 String such as 'class', 'interface' etc that can be used in error messages.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SymbolExtensions.GetPropertyKindText(Roslyn.Compilers.VisualBasic.PropertySymbol)">
	<summary>
 String "ReadOnly", "WriteOnly", or "" describing the kind of property.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SymbolExtensions.MatchesAnyName(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.TypeParameterSymbol},System.String)">
	<summary>
 Checks if there is a name match with any type parameter.
 </summary>
	<param name="this"></param>
	<param name="name"></param>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SymbolExtensions.IsOverloads(Roslyn.Compilers.VisualBasic.Symbol)">
	<summary>
 Helper that tells if symbol has Overloads (hidebysig) on it
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SymbolExtensions.IsShadows(Roslyn.Compilers.VisualBasic.Symbol)">
	<summary>
 Member that does not have Overloads, is considered Shadows (hidebyname)
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SymbolExtensions.ShadowsExplicitly(Roslyn.Compilers.VisualBasic.Symbol)">
	<summary>
 Was member declared with Shadows in source?
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SymbolExtensions.RequiresImplementation(Roslyn.Compilers.VisualBasic.Symbol)">
	<summary>
 Is this a member of a interface that requires implementation?
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AttributeData.Location">
	<summary>
 The location of the attribute.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AttributeData.AttributeClass">
	<summary>
 The attribute class.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AttributeData.AttributeConstructor">
	<summary>
 The constructor on the attribute class.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AttributeData.PositionalArguments">
	<summary>
 Positional (constructor) arguments on the attribute.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AttributeData.NamedArguments">
	<summary>
 Named (property value) arguments on the attribute. 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AttributeData.IsTargetAttribute(System.String,System.String)">
	<summary>
 Compares the namespace and type name with the attribute's namespace and type name.  Returns true if they are the same.
 </summary>
	<param name="namespaceName"></param>
	<param name="typeName"></param>
</member><member name="M:Roslyn.Compilers.VisualBasic.AttributeData.GetPositionalArgument``1(System.Int32,Roslyn.Compilers.SpecialType)">
	<summary>
 Returns the value of a positional argument as type T. Throws if no positional argument exists or the argument cannot be converted to the
 type.
 </summary>
	<typeparam name="T"></typeparam>
	<param name="i"></param>
	<param name="specType"></param>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.AttributeData.GetNamedArgument``1(System.String,Roslyn.Compilers.SpecialType,``0)">
	<summary>
 Returns the value of a named argument as type T. If there is more than one named argument with this name it returns the first one.
 If no named argument is found then the default value is returned.
 </summary>
	<typeparam name="T"></typeparam>
	<param name="key">The metadata property or field name. This name is case sensitive</param>
	<param name="specType"></param>
	<param name="defaultValue"></param>
</member><member name="T:Roslyn.Compilers.VisualBasic.AttributeData">
	<summary>
 A Symbol attribute represents a .NET attribute applied to a symbol.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypedConstant.Kind">
	<summary>
 The TypedConstant's kind. Can be one of Primitive, Enum, Type, Array or Error
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypedConstant.Value">
	<summary>
  Returns the value for non array values. For "Primitive" constants this is a boxed value or a string or nothing. For
 "Enum" constants this is a boxed value of the underlying type. For "Type" constants, this is a TypeSymbol
 for the type. For "Array" constants this throws.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypedConstant.Values">
	<summary>
 Returns the value for array constants. Throws for non-arrays.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypedConstant.Type">
	<summary>
 The TypedConstant's type. This is either a TypeSymbol of one of the primitive types, a TypeSymbol of an enum
 type, a TypeSymbol for System.Type or an ArrayTypeSymbol.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypedConstant.GetTypedConstantKind(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.Compilation)">
	<remarks>
 TypedConstant isn't computing its own kind from the type symbol because it doesn't
 have a way to recognize the well-known type System.Type.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.TypedConstant">
	<summary>
 TypedConstant represents a constant value used as an argument to an Attribute. The Typed constant can represent
 a primitive type, an enum type, a system.type or an array of TypedConstants. 
 
 Kind            _value                              _type
 Primitive       Boxed value, string or nothing      TypeSymbol for the boxed value possibly nothing for nothing literal
 Enum            Boxed value of the underlying type  TypeSymbol for enum
 Type            TypeSymbol or nothing               TypeSymbol for System.Type
 Array           TypeConstant() or nothing           ArrayTypeSymbol
 Error           nothing                             TypeSymbol or ErrorTypeSymbol
 
 </summary>
	<remarks></remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.Symbol.Name">
	<summary>
 Gets the name of this symbol.
 </summary>
	<returns>Returns the name of this symbol. Symbols without a name return the empty string;
 Nothing is never returned.</returns>
</member><member name="P:Roslyn.Compilers.VisualBasic.Symbol.Kind">
	<summary>
 Gets the kind of this symbol.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Symbol.ContainingSymbol">
	<summary>
 Get the symbol that logically contains this symbol. 
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Symbol.ContainingNamespace">
	<summary>
 Gets the nearest enclosing namespace for this namespace or type. For a nested type,
 returns the namespace that contains its container.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Symbol.ContainingType">
	<summary>
 Returns the containing type, if this symbol is immediately contained by a type.
 Otherwise returns Nothing.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Symbol.ContainingNamespaceOrType">
	<summary>
 Returns the containing type or namespace, if this symbol is immediately contained by it.
 Otherwise returns Nothing.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Symbol.ContainingAssembly">
	<summary>
 Returns the assembly containing this symbol. If this symbol is shared
 across multiple assemblies, or doesn't belong to an assembly, returns Nothing.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Symbol.ContainingModule">
	<summary>
 Returns the module containing this symbol. If this symbol is shared
 across multiple modules, or doesn't belong to a module, returns Nothing.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Symbol.OriginalDefinition">
	<summary>
 Get the original definition of this symbol. If this symbol is derived from another
 symbol by (say) type substitution, this gets the original symbol, as it was defined
 in source or metadata.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Symbol.IsDefinition">
	<summary>
 Returns whether this the original definition of this symbol.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Symbol.Locations">
	<summary>
 Gets the locations where this symbol was originally defined, either in source
 or metadata. Some symbols (for example, partial classes) may be defined in more
 than one location.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Symbol.DeclaredAccessibility">
	<summary>
 Get this accessibility that was declared on this symbol. For symbols that do
 not have accessibility declared on them, returns NotApplicable.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Symbol.IsShared">
	<summary>
 Returns true if this symbol is "shared"; i.e., declared with the "Shared"
 modifier or implicitly always shared.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Symbol.IsOverridable">
	<summary>
 Returns true if this member is overridable, has an implementation,
 and does not override a base class member; i.e., declared with the "Overridable"
 modifier. Does not return true for members declared as MustOverride or Overrides.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Symbol.IsOverrides">
	<summary>
 Returns true if this symbol was declared to override a base class members; i.e., declared
 with the "Overrides" modifier. Still returns true if the members was declared
 to override something, but (erroneously) no member to override exists.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Symbol.IsMustOverride">
	<summary>
 Returns true if this symbol was declared as requiring an override; i.e., declared
 with the "MustOverride" modifier. Never returns true for types. 
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Symbol.IsNotOverridable">
	<summary>
 Returns true if this symbol was declared to override a base class members and was
 also restricted from further overriding; i.e., declared with the "NotOverridable"
 modifier. Never returns true for types.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Symbol.IsSynthesized">
	<summary>
 Returns true if this symbol was automatically synthesized by the compiler.  This is
 intended for symbols that are not internal compilation details, but are instead
 ordinary symbols that can be consumed without requiring the user to manually supply them
 themselves.  For example, the default constructor for a class or struct that is created
 if the user does not provide one themselves.  Or the Invoke method for a delegate.
 Or the generated backing field for an auto property.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Symbol.ImplicitlyDefinedBy">
	<summary>
 Returns the symbol that implicitly defined this symbol, or Nothing if this
 symbol was declared explicitly. Examples of implicit symbols are property
 accessors and the backing field for an automatically implemented property.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Symbol.CanBeReferencedByName">
	<summary>
 Returns true if this symbol can be referenced by its name in code. Examples of symbols
 that cannot be referenced by name are:
    constructors, operators, 
    accessor methods for properties and events.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Symbol.CanBeReferencedByNameIgnoringIllegalCharacters">
	<summary>
 As an optimization, viability checking in the lookup code should use this property instead
 of CanBeReferencedByName.
 </summary>
	<remarks>
 This property exists purely for performance reasons.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Symbol.GetAttributes">
	<summary>
 Gets the attributes on this symbol. Returns an empty IEnumerable if there are
 no attributes.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Symbol.GetAttributes(Roslyn.Compilers.VisualBasic.NamedTypeSymbol)">
	<summary>
 Gets the attributes of a given attribute class on this symbol. Returns an empty
 IEnumerable if there are no attributes.
 </summary>
	<param name="attributeType">The type of attribute to check for.</param>
	<returns>All attributes of the given type, or an empty IEnumerable if none.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Symbol.GetAttributes(Roslyn.Compilers.VisualBasic.MethodSymbol)">
	<summary>
 Gets the attributes by attribute constructor method symbol. Returns an empty IEnumerable if there are no
 attributes.
 </summary>
	<param name="attributeConstructor">The attribute constructor to check for.</param>
	<returns>All attributes of the given type, or an empty IEnumerable if none.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Symbol.GetAttributes(System.String,System.String)">
	<summary>
 Gets attributes that match the namespace and type name.
 </summary>
	<param name="namespaceName"></param>
	<param name="typeName"></param>
	<returns></returns>
	<remarks></remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.Symbol.SynthesizedAttributeData">
	<summary>
 Structure to wrap data needed to create an synthesized attribute
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Symbol.GetSynthesizedAttributes(Roslyn.Compilers.VisualBasic.Emit.Module)">
	<summary>
 Gets the synthesized attributes for this symbol.
 </summary>
	<param name="moduleBeingBuilt">The module.</param>
	<returns>Array of synthesized attributes of this symbol</returns>
</member><member name="P:Roslyn.Compilers.VisualBasic.Symbol.IsFromSource">
	<summary>
 True if and only if the symbol is the one original symbol resulting from some
 declaration in the source. The declaration might be implicit, for example a synthesized
 constructor is considered to come from source. This is not true for constructed members,
 substituted members (e.g. members of a constructed type), alpha-renamed type parameters,
 or anything not from source.  This applies to named type symbols, field symbols, method
 symbols, parameter symbols, type parameter symbols, property symbols, event symbols,
 etc. Array types never return true for this property, as they are not "declared" in the
 source.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Symbol.GetDocumentationCommentID">
	<summary>
 Returns the Documentation Comment ID for the symbol.
 </summary>
	<exception cref="T:System.InvalidOperationException">Thrown if the symbol does not support
 documentation comments.</exception>
</member><member name="M:Roslyn.Compilers.VisualBasic.Symbol.GetDocumentationComment(System.Globalization.CultureInfo,System.Threading.CancellationToken)">
	<summary>
 Fetches the documentation comment for this element with a cancellation token.
 </summary>
	<returns>A DocumentationComment object.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Symbol.op_Equality(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.Symbol)">
	<summary>
 Compare two symbol objects to see if they refer to the same symbol. You should always use
 = and &lt;&gt; or the Equals method, to compare two symbols for equality.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Symbol.op_Inequality(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.Symbol)">
	<summary>
 Compare two symbol objects to see if they refer to the same symbol. You should always use
 = and &lt;&gt;, or the Equals method, to compare two symbols for equality.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Symbol.IFormattable_ToString(System.String,System.IFormatProvider)">
	<summary>
 This is intended primarily for inserting localized descriptions of symbols into
 user-facing error messages.  If you need more fine-grained control of the output, try
 calling Symbol.ToDisplayString directly.
 </summary>
	<remarks>
 Generally speaking, this method should not be called directly.  Instead, they should be
 passed directly to errors/diagnostics.  To use a different format string, update the
 error message (e.g. Change "Problem with {0}" to "Problem with {0:S}" to display the
 short name of a symbol).
 
 We could have subclasses do their own parsing of the format string (to accept other
 formats), but we can probably do everything from here using Symbol.Kind.
 </remarks>
	<param name="format">
     G - general: default (determined by SymbolDisplay.ToDisplayString)
     E - error: format to be used in compiler error messages
     T - test: includes lots of qualification, parameters, modifiers, etc
     S - short: just the (user-facing) name of the symbol
     I - IL: to be used when visualizing IL
 </param>
	<param name="formatProvider">Usually a CultureInfo object.</param>
	<returns>A description of this symbol.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Symbol.AttributeTarget">
	<summary>
 Returns the appropriate AttributeTarget for a symbol.  This is used to validate attribute usage when
 applying an attribute to a symbol. For any symbol that does not support the application of custom
 attributes 0 is returned.
 </summary>
	<returns>The attribute target flag for this symbol or 0 if none apply.</returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Symbol.GetUseSiteErrorInfo">
	<summary>
 Returns error info for an error, if any, that should be reported at the use site of the symbol.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Symbol.DeriveUseSiteErrorInfoFromType(Roslyn.Compilers.VisualBasic.TypeSymbol,System.Collections.Generic.HashSet{Roslyn.Compilers.VisualBasic.TypeSymbol}@)">
	<summary>
 Derive error info from a type symbol.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Symbol.HighestPriorityUseSiteError">
	<summary>
 Return error code that has highest priority while calculating use site error for this symbol. 
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Symbol">
	<summary>
 The base class for all symbols (namespaces, classes, method, parameters, etc.) that are 
 exposed by the compiler.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SubstitutedNamedType._substitution">
	<summary>
 Type substitution for this symbol, it targets OriginalDefinition of the symbol.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SubstitutedNamedType.EqualsWithNoRegardToTypeArguments``1(``0)">
	<summary>
 Compare SubstitutedNamedTypes with no regard to type arguments.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SubstitutedNamedType.SpecializedType._container">
	<summary>
  Symbol for the containing type, either specialized or constructed.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SubstitutedNamedType.SpecializedType">
	<summary>
 Base class for symbols representing non-generic or open generic types contained within constructed generic type.
 For example: A(Of Integer).B, A(Of Integer).B.C or A(Of Integer).B.C(Of ).
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SubstitutedNamedType.SpecializedGenericType._typeParameters">
	<summary>
 Alpha-renamed type parameters, i.e. type parameters with constraints substituted according
 to containing type's TypeSubstitution.
 For example:
     Class A (Of T)
         Class B(Of S As T)
             Dim x As A(Of Integer).B(Of S) 'error BC32044: Type argument 'S' does not inherit from or implement the constraint type 'Integer'.
         End Class
     End Class
  
 Given a type A(Of IComparable).B(Of ), alpha-renamed type parameter S will have type constraint IComparable.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SubstitutedNamedType.SpecializedGenericType.InternalSubstituteTypeParameters(Roslyn.Compilers.VisualBasic.TypeSubstitution)">
	<summary>
 Substitute the given type substitution within this type, returning a new type. If the
 substitution had no effect, return Me. 
 !!! Only code implementing construction of generic types is allowed to call this method !!!
 !!! All other code should use Construct methods.                                        !!! 
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SubstitutedNamedType.SpecializedGenericType">
	<summary>
 Symbol representing open generic type directly or indirectly contained within constructed
 generic type.
 For example: A(Of Integer).B(Of ) or A(Of Integer).B.C(Of , )
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SubstitutedNamedType.SpecializedNonGenericType.InternalSubstituteTypeParameters(Roslyn.Compilers.VisualBasic.TypeSubstitution)">
	<summary>
 Substitute the given type substitution within this type, returning a new type. If the
 substitution had no effect, return Me. 
 !!! Only code implementing construction of generic types is allowed to call this method !!!
 !!! All other code should use Construct methods.                                        !!! 
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SubstitutedNamedType.SpecializedNonGenericType">
	<summary>
 Symbol representing non-generic type directly or indirectly contained within constructed
 generic type.
 For example: A(Of Integer).B or A(Of Integer).B.C
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SubstitutedNamedType.ConstructedType">
	<summary>
 Base class for symbols representing constructed generic types.
 For example: A(Of Integer), A.B(Of Integer), A(Of Integer).B.C(Of Integer).
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SubstitutedNamedType.ConstructedInstanceType.InternalSubstituteTypeParameters(Roslyn.Compilers.VisualBasic.TypeSubstitution)">
	<summary>
 Substitute the given type substitution within this type, returning a new type. If the
 substitution had no effect, return Me. 
 !!! Only code implementing construction of generic types is allowed to call this method !!!
 !!! All other code should use Construct methods.                                        !!! 
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SubstitutedNamedType.ConstructedInstanceType">
	<summary>
 Symbols representing constructed generic type that isn't contained within another constructed generic type.
 For example: A(Of Integer), A.B(Of Integer), but not A(Of Integer).B.C(Of Integer).
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SubstitutedNamedType.ConstructedSpecializedGenericType._constructedFrom">
	<summary>
 Symbol for the ConstructedFrom type.
      A(Of Integer).B(Of ) for A(Of Integer).B(Of Integer),
      A(Of Integer).B.C(Of ) for A(Of Integer).B.C(Of Integer)
 
 All types in its containership hierarchy must be either constructed or non-generic, or original definitions.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SubstitutedNamedType.ConstructedSpecializedGenericType.InternalSubstituteTypeParameters(Roslyn.Compilers.VisualBasic.TypeSubstitution)">
	<summary>
 Substitute the given type substitution within this type, returning a new type. If the
 substitution had no effect, return Me. 
 !!! Only code implementing construction of generic types is allowed to call this method !!!
 !!! All other code should use Construct methods.                                        !!! 
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SubstitutedNamedType.ConstructedSpecializedGenericType">
	<summary>
 Symbols representing constructed generic type that is contained within another constructed generic type.
 For example: A(Of Integer).B(Of Integer), A(Of Integer).B.C(Of Integer).
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SubstitutedNamedType">
	<summary>
 A SubstitutedNamedType represents a named type that has had some sort
 of substitution applied to it. I.e., its not a pure instance type, but at least
 one type parameter in this type or a containing type has a substitution made for
 it. 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeSymbolExtensions.IsComImportType(Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 Is this a class or an interface with ComImport attribute?
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeSymbolExtensions.DigThroughArrayType(Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 Dig through possibly jugged array type to the ultimate element type
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeSymbolExtensions.IsValidTypeForConstField(Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 Determines whether the given type is valid for a const field.
 VB Spec 9.5: The type of a constant may only be a primitive type or Object
 </summary>
	<param name="fieldType">The type of the field.</param><returns>
		<c>true</c> if type is valid for a const field; otherwise, <c>false</c>.
 </returns>
</member><member name="T:Roslyn.Compilers.VisualBasic.TypeKind">
	<summary>
 Represents the different kinds of types.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.TempLocalSymbol">
	<summary>
 TempLocalSymbol is special kind of LocalSymbol that can be byref.
 
 The semantics of LHS ByRef local is roughly the same as of a ByRef argument
    EmitAssignment will do EmitAddress for RHS and then assign.
                                     
 The semantics of RHS ByRef local is roughly the same as of a ByRef parameter
    EmitExpression   will load the value which local is referring to.
    EmitAddress      will load the actual local.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SymbolKind">
	<summary>
 Represents the different kinds of symbol.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SubstitutedTypeParameterSymbol.m_ContainingSymbol">
	<summary>
 Containing type or method.
 The field is not read-only because it is intialized after construction through
 SetContainingSymbol() method.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SubstitutedTypeParameterSymbol.InternalSubstituteTypeParameters(Roslyn.Compilers.VisualBasic.TypeSubstitution)">
	<summary>
 Substitute the given type substitution within this type, returning a new type. If the
 substitution had no effect, return Me. 
 !!! Only code implementing construction of generic types is allowed to call this method !!!
 !!! All other code should use Construct methods.                                        !!! 
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SubstitutedTypeParameterSymbol">
	<summary>
 A SubstitutedTypeParameterSymbol represents an alpha-renamed type parameter.
 They are created only for open generic types and methods that are contained within a 
 constructed generic type.
 
 Alpha-renamed type parameters have their constraints substituted according
 to type/method's containing type's TypeSubstitution.
 For example:
     Class A (Of T)
         Class B(Of S As T)
         End Class
     End Class
  
 Given a type A(Of IComparable).B(Of ), alpha-renamed type parameter T will have type constraint IComparable.
 The rest will be exactly as for the original type parameter T. In fact, OriginalDefinition will return symbol for T.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SubstitutedPropertySymbol">
	<summary>
 Represents a property that has undergone type substitution.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SubstitutedParameterSymbol.SubstitutedMethodParameterSymbol">
	<summary>
 Represents a method parameter that has undergone type substitution.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SubstitutedParameterSymbol.SubstitutedPropertyParameterSymbol">
	<summary>
 Represents a property parameter that has undergone type substitution.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SubstitutedParameterSymbol">
	<summary>
 Represents a parameter that has undergone type substitution.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SubstitutedMethodSymbol.TypeSubstitution">
	<summary>
 If this is a generic method return TypeSubstitution for it. 
 TypeSubstitution for containing type otherwise.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SubstitutedMethodSymbol.EqualsWithNoRegardToTypeArguments``1(``0)">
	<summary>
 Compare with no regard to type arguments.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SubstitutedMethodSymbol.SpecializedMethod">
	<summary>
 Base class for symbols representing non-generic or open generic methods contained within constructed generic type.
 For example: A(Of Integer).B, A(Of Integer).B.C or A(Of Integer).B.C(Of ).
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SubstitutedMethodSymbol.SetAssociatedProperty(Roslyn.Compilers.VisualBasic.SubstitutedPropertySymbol)">
	<summary>
 Associate the method with a particular property. Returns
 false if the method is already associated with a property.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SubstitutedMethodSymbol.SpecializedNonGenericMethod">
	<summary>
 Symbol representing non-generic method directly or indirectly contained within constructed
 generic type.
 For example: A(Of Integer).B or A(Of Integer).B.C
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SubstitutedMethodSymbol.SpecializedGenericMethod._typeParameters">
	<summary>
 Alpha-renamed type parameters, i.e. type parameters with constraints substituted according
 to containing type's TypeSubstitution.
 For example:
     Class A (Of T)
         Sub B(Of S As T)()
         End Sub
     End Class
  
 Given a method A(Of IComparable).B(Of ), alpha-renamed type parameter S will have type constraint IComparable.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SubstitutedMethodSymbol.SpecializedGenericMethod">
	<summary>
 Symbol representing open generic method directly or indirectly contained within constructed
 generic type.
 For example: A(Of Integer).B(Of ) or A(Of Integer).B.C(Of , )
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SubstitutedMethodSymbol.ConstructedMethod">
	<summary>
 Base class for symbols representing constructed generic methods.
 For example: A(Of Integer), A.B(Of Integer), A(Of Integer).B.C(Of Integer).
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SubstitutedMethodSymbol.ConstructedSpecializedGenericMethod._constructedFrom">
	<summary>
 Symbol for the ConstructedFrom method.
      A(Of Integer).B(Of ) for A(Of Integer).B(Of Integer),
      A(Of Integer).B.C(Of ) for A(Of Integer).B.C(Of Integer)
 
 All types in its containership hierarchy must be either constructed or non-generic, or original definitions.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SubstitutedMethodSymbol.ConstructedSpecializedGenericMethod">
	<summary>
 Symbols representing constructed generic method that is contained within constructed generic type.
 For example: A(Of Integer).B(Of Integer), A(Of Integer).B.C(Of Integer).
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SubstitutedMethodSymbol.ConstructedNotSpecializedGenericMethod">
	<summary>
 Symbols representing constructed generic method that isn't contained within constructed generic type.
 For example: A(Of Integer), A.B(Of Integer), but not A(Of Integer).B.C(Of Integer).
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SubstitutedMethodSymbol">
	<summary>
 Represents a method that has undergone type substitution. This is use for a method
 inside a generic type that has undergone type substitution. It also serves as a base class
 for ConstructedMethodSymbol, which is used for a method after type substitution in the method type parameters.  
 
 TODO: Need a way to partially construct an extension method.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SubstitutedFieldSymbol">
	<summary>
 Represents a member variable (field) that has undergone type substitution.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AssemblySymbol.GetSpecialTypeMember(Roslyn.Compilers.SpecialMember)">
	<summary>
 Lookup member declaration in predefined CorLib type used by this Assembly.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AssemblySymbol.GetDeclaredSpecialTypeMember(Roslyn.Compilers.SpecialMember)">
	<summary>
 Lookup member declaration in predefined CorLib type in this Assembly. Only valid if this 
 assembly is the Cor Library
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.MetadataOrSourceAssemblySymbol.m_LazySpecialTypeMembers">
	<summary>
 Lazy cache of special members.
 Not yet known value is represented by ErrorTypeSymbol.UnknownResultType
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MetadataOrSourceAssemblySymbol.GetDeclaredSpecialTypeMember(Roslyn.Compilers.SpecialMember)">
	<summary>
 Lookup member declaration in predefined CorLib type in this Assembly. Only valid if this 
 assembly is the Cor Library
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SubstitutedErrorType.InternalSubstituteTypeParameters(Roslyn.Compilers.VisualBasic.TypeSubstitution)">
	<summary>
 Substitute the given type substitution within this type, returning a new type. If the
 substitution had no effect, return Me. 
 !!! Only code implementing construction of generic types is allowed to call this method !!!
 !!! All other code should use Construct methods.                                        !!! 
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.UnboundLambdaParameterSymbol">
	<summary>
 Represents a Lambda parameter for an UnboundLambda.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SynthesizedParameterSymbol.#ctor(Roslyn.Compilers.VisualBasic.MethodSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol,System.Int32,System.Boolean,System.String)">
	<summary>
 Initializes a new instance of the <see cref="T:Roslyn.Compilers.VisualBasic.SynthesizedParameterSymbol"/> class.
 </summary>
	<param name="container">The containing symbol</param>
	<param name="type">The type of this parameter</param>
	<param name="ordinal">The ordinal number of this parameter</param>
	<param name="isByRef">Whether the parameter is ByRef or not</param>
	<param name="name">The name of this parameter</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.SynthesizedParameterSymbol.#ctor(Roslyn.Compilers.VisualBasic.MethodSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol,System.Int32,System.Boolean,System.String,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.CustomModifier})">
	<summary>
 Initializes a new instance of the <see cref="T:Roslyn.Compilers.VisualBasic.SynthesizedParameterSymbol"/> class.
 </summary>
	<param name="container">The containing symbol</param>
	<param name="type">The type of this parameter</param>
	<param name="ordinal">The ordinal number of this parameter</param>
	<param name="isByRef">Whether the parameter is ByRef or not</param>
	<param name="name">The name of this parameter</param>
	<param name="customModifiers">The custom modifiers of this parameter</param>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedParameterSymbol.ContainingSymbol">
	<summary>
 Gets the containing symbol.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedParameterSymbol.CustomModifiers">
	<summary>
 The list of custom modifiers, if any, associated with the parameter. Evaluate this property only if IsModified is true.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedParameterSymbol.DefaultValue">
	<summary>
 A compile time constant value that should be supplied as the corresponding argument value by callers that do not explicitly specify an argument value for this parameter.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedParameterSymbol.HasDefaultValue">
	<summary>
 True if the parameter has a default value that should be supplied as the argument value by a caller for which the argument value has not been explicitly specified.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedParameterSymbol.IsByRef">
	<summary>
 Gets a value indicating whether this instance is by ref.
 </summary>
	<value>
		<c>true</c> if this instance is by ref; otherwise, <c>false</c>.
 </value>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedParameterSymbol.IsOptional">
	<summary>
 True if the argument value must be included in the marshalled arguments passed to a remote callee only if it is different from the default value (if there is one).
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedParameterSymbol.IsParamArray">
	<summary>
 Gets a value indicating whether this instance is param array.
 </summary>
	<value>
		<c>true</c> if this instance is param array; otherwise, <c>false</c>.
 </value>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedParameterSymbol.Locations">
	<summary>
 A potentially empty collection of locations that correspond to this instance.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedParameterSymbol.Ordinal">
	<summary>
 Gets the ordinal.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedParameterSymbol.Type">
	<summary>
 Gets the type.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedParameterSymbol.Name">
	<summary>
 Gets the name.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SynthesizedParameterSymbol">
	<summary>
 Instances of this class represent parameters of methods that have been synthesized. E.g. the parameters of delegate methods
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SynthesizedLambdaSymbol.#ctor(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.SyntaxTree,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.BoundLambdaParameterSymbol},Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 Initializes a new instance of the <see cref="T:Roslyn.Compilers.VisualBasic.SynthesizedLambdaSymbol"/> class.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedLambdaSymbol.IsSynthesized">
	<summary>
 Gets a value indicating whether the symbol was generated by the compiler
 rather than declared explicitly.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SynthesizedLambdaSymbol">
	<summary>
 Represents a synthesized lambda. 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SynthesizedDelegateMethodSymbol.#ctor(System.String,Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.SourceMemberFlags,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.DelegateStatementSyntax,Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.DiagnosticBag,System.Threading.CancellationToken)">
	<summary>
 Initializes a new instance of the <see cref="T:Roslyn.Compilers.VisualBasic.SynthesizedDelegateMethodSymbol"/> class and creates the parameters out of the syntax node.
 </summary>
	<param name="name">The name of this method.</param>
	<param name="containingSymbol">The containing symbol.</param>
	<param name="flags">The flags for this method.</param>
	<param name="returnType">The return type.</param>
	<param name="syntax">The related syntax node.</param>
	<param name="binder">The binder.</param>
	<param name="diagnostics">The diagnostics.</param>
	<param name="cancellationToken">The cancellation token.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.SynthesizedDelegateMethodSymbol.#ctor(System.String,Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.SourceMemberFlags,Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 Initializes a new instance of the <see cref="T:Roslyn.Compilers.VisualBasic.SynthesizedDelegateMethodSymbol"/> class. The parameters are not initialized and need to be set 
 by using the <see cref="M:Roslyn.Compilers.VisualBasic.SynthesizedDelegateMethodSymbol.SetParameters(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.ParameterSymbol})"/> method.
 </summary>
	<param name="name">The name of this method.</param>
	<param name="containingSymbol">The containing symbol.</param>
	<param name="flags">The flags for this method.</param>
	<param name="returnType">The return type.</param>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedDelegateMethodSymbol.Arity">
	<summary>
 Returns the arity of this method, or the number of type parameters it takes.
 A non-generic method has zero arity.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedDelegateMethodSymbol.AssociatedPropertyOrEvent">
	<summary>
 If this method has MethodKind of MethodKind.PropertyGet or MethodKind.PropertySet,
 returns the property that this method is the getter or setter for.
 If this method has MethodKind of MethodKind.EventAdd or MethodKind.EventRemove,
 returns the event that this method is the adder or remover for.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedDelegateMethodSymbol.CallingConvention">
	<summary>
 Calling convention of the signature.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedDelegateMethodSymbol.ContainingSymbol">
	<summary>
 Gets the <see cref="T:ISymbol"/> for the immediately containing symbol.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedDelegateMethodSymbol.DeclaredAccessibility">
	<summary>
 Gets a <see cref="T:CommonAccessibility"/> indicating the declared accessibility for the symbol.
 Returns NotApplicable if no accessibility is declared.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedDelegateMethodSymbol.ExplicitInterfaceImplementations">
	<summary>
 Returns interface methods explicitly implemented by this method.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedDelegateMethodSymbol.IsExtensionMethod">
	<summary>
 Returns true if this method is an extension method.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedDelegateMethodSymbol.IsExternalMethod">
	<summary>
 Gets a value indicating whether this instance is external method.
 </summary>
	<value>
		<c>true</c> if this instance is external method; otherwise, <c>false</c>.
 </value>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedDelegateMethodSymbol.IsMustOverride">
	<summary>
 Gets a value indicating whether this instance is abstract or not.
 </summary>
	<value>
		<c>true</c> if this instance is abstract; otherwise, <c>false</c>.
 </value>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedDelegateMethodSymbol.IsNotOverridable">
	<summary>
 Gets a value indicating whether this instance is not overridable.
 </summary>
	<value>
		<c>true</c> if this instance is not overridable; otherwise, <c>false</c>.
 </value>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedDelegateMethodSymbol.IsOverloads">
	<summary>
 Gets a value indicating whether this instance is overloads.
 </summary>
	<value>
		<c>true</c> if this instance is overloads; otherwise, <c>false</c>.
 </value>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedDelegateMethodSymbol.IsOverridable">
	<summary>
 Gets a value indicating whether this instance is overridable.
 </summary>
	<value>
		<c>true</c> if this instance is overridable; otherwise, <c>false</c>.
 </value>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedDelegateMethodSymbol.IsOverrides">
	<summary>
 Gets a value indicating whether this instance is overrides.
 </summary>
	<value>
		<c>true</c> if this instance is overrides; otherwise, <c>false</c>.
 </value>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedDelegateMethodSymbol.IsShared">
	<summary>
 Gets a value indicating whether this instance is shared.
 </summary>
	<value>
		<c>true</c> if this instance is shared; otherwise, <c>false</c>.
 </value>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedDelegateMethodSymbol.IsSub">
	<summary>
 Gets a value indicating whether this instance is a sub.
 </summary>
	<value>
		<c>true</c> if this instance is sub; otherwise, <c>false</c>.
 </value>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedDelegateMethodSymbol.IsVararg">
	<summary>
 Gets a value indicating whether this instance is vararg.
 </summary>
	<value>
		<c>true</c> if this instance is vararg; otherwise, <c>false</c>.
 </value>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedDelegateMethodSymbol.Locations">
	<summary>
 A potentially empty collection of locations that correspond to this instance.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedDelegateMethodSymbol.MethodKind">
	<summary>
 Gets what kind of method this is. There are several different kinds of things in the
 VB language that are represented as methods. This property allow distinguishing those things
 without having to decode the name of the method.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedDelegateMethodSymbol.Parameters">
	<summary>
 The parameters forming part of this signature.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedDelegateMethodSymbol.ReturnType">
	<summary>
 Gets the return type of the method.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedDelegateMethodSymbol.ReturnTypeCustomModifiers">
	<summary>
 Returns the list of custom modifiers, if any, associated with the returned value.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedDelegateMethodSymbol.TypeArguments">
	<summary>
 Returns the type arguments that have been substituted for the type parameters.
 If nothing has been substituted for a given type parameter,
 then the type parameter itself is consider the type argument.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedDelegateMethodSymbol.TypeParameters">
	<summary>
 Get the type parameters on this method. If the method has not generic,
 returns an empty list.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedDelegateMethodSymbol.IsRuntimeImplemented">
	<summary>
 True if the implementation of this method is supplied by the runtime.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedDelegateMethodSymbol.IsSynthesized">
	<summary>
 Gets a value indicating whether the symbol was generated by the compiler
 rather than declared explicitly.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedDelegateMethodSymbol.Name">
	<summary>
 Gets the symbol name. Returns the empty string if unnamed.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SynthesizedDelegateMethodSymbol.SetParameters(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.ParameterSymbol})">
	<summary>
 Sets the parameters.
 </summary>
	<param name="parameters">The parameters.</param>
</member><member name="T:Roslyn.Compilers.VisualBasic.SynthesizedDelegateMethodSymbol">
	<summary>
 This class represent a compiler generated method
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SynthesizedFieldSymbol">
	<summary>
 Represents a compiler generated field of given type and name.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SynthesizedEnumConstantSymbol">
	<summary>
 A compiler generated field for an enum constant.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SynthesizedConstructorSymbol.m_container">
	<summary>
 The containing Type.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SynthesizedConstructorSymbol.m_isShared">
	<summary>
 Flag to indicate if this is a shared constructor or an instance constructor.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SynthesizedConstructorSymbol.Create(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.SyntaxTree,Roslyn.Compilers.VisualBasic.NamedTypeSymbol,System.Boolean,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Create a new instance of the <see cref="T:Roslyn.Compilers.VisualBasic.SynthesizedConstructorSymbol"/> class.
 </summary>
	<param name="container">The containing type for the synthesized constructor.</param>
	<param name="isShared">if set to <c>true</c> if this is a shared constructor.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.SynthesizedConstructorSymbol.#ctor(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.SyntaxTree,Roslyn.Compilers.VisualBasic.NamedTypeSymbol,System.Boolean)">
	<summary>
 Initializes a new instance of the <see cref="T:Roslyn.Compilers.VisualBasic.SynthesizedConstructorSymbol"/> class.
 </summary>
	<param name="container">The containing type for the synthesized constructor.</param>
	<param name="isShared">if set to <c>true</c> if this is a shared constructor.</param>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedConstructorSymbol.IsSynthesized">
	<summary>
 Gets a value indicating whether the symbol was generated by the compiler
 rather than declared explicitly.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedConstructorSymbol.Name">
	<summary>
 Gets the symbol name. Returns the empty string if unnamed.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedConstructorSymbol.Arity">
	<summary>
 Returns the arity of this method, or the number of type parameters it takes.
 A non-generic method has zero arity.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedConstructorSymbol.AssociatedPropertyOrEvent">
	<summary>
 If this method has MethodKind of MethodKind.PropertyGet or MethodKind.PropertySet,
 returns the property that this method is the getter or setter for.
 If this method has MethodKind of MethodKind.EventAdd or MethodKind.EventRemove,
 returns the event that this method is the adder or remover for.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedConstructorSymbol.CallingConvention">
	<summary>
 Calling convention of the signature.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedConstructorSymbol.ContainingSymbol">
	<summary>
 Gets the <see cref="T:ISymbol"/> for the immediately containing symbol.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedConstructorSymbol.DeclaredAccessibility">
	<summary>
 Gets a <see cref="T:CommonAccessibility"/> indicating the declared accessibility for the symbol.
 Returns NotApplicable if no accessibility is declared.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedConstructorSymbol.ExplicitInterfaceImplementations">
	<summary>
 Returns interface methods explicitly implemented by this method.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedConstructorSymbol.IsExtensionMethod">
	<summary>
 Returns true if this method is an extension method.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedConstructorSymbol.IsExternalMethod">
	<summary>
 Gets a value indicating whether this instance is external method.
 </summary>
	<value>
		<c>true</c> if this instance is external method; otherwise, <c>false</c>.
 </value>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedConstructorSymbol.IsMustOverride">
	<summary>
 Gets a value indicating whether this instance is abstract or not.
 </summary>
	<value>
		<c>true</c> if this instance is abstract; otherwise, <c>false</c>.
 </value>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedConstructorSymbol.IsNotOverridable">
	<summary>
 Gets a value indicating whether this instance is not overridable.
 </summary>
	<value>
		<c>true</c> if this instance is not overridable; otherwise, <c>false</c>.
 </value>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedConstructorSymbol.IsOverloads">
	<summary>
 Gets a value indicating whether this instance is overloads.
 </summary>
	<value>
		<c>true</c> if this instance is overloads; otherwise, <c>false</c>.
 </value>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedConstructorSymbol.IsOverridable">
	<summary>
 Gets a value indicating whether this instance is overridable.
 </summary>
	<value>
		<c>true</c> if this instance is overridable; otherwise, <c>false</c>.
 </value>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedConstructorSymbol.IsOverrides">
	<summary>
 Gets a value indicating whether this instance is overrides.
 </summary>
	<value>
		<c>true</c> if this instance is overrides; otherwise, <c>false</c>.
 </value>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedConstructorSymbol.IsShared">
	<summary>
 Gets a value indicating whether this instance is shared.
 </summary>
	<value>
		<c>true</c> if this instance is shared; otherwise, <c>false</c>.
 </value>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedConstructorSymbol.IsSub">
	<summary>
 Gets a value indicating whether this instance is sub.
 </summary>
	<value>
		<c>true</c> if this instance is sub; otherwise, <c>false</c>.
 </value>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedConstructorSymbol.IsVararg">
	<summary>
 Gets a value indicating whether this instance is vararg.
 </summary>
	<value>
		<c>true</c> if this instance is vararg; otherwise, <c>false</c>.
 </value>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedConstructorSymbol.Locations">
	<summary>
 A potentially empty collection of locations that correspond to this instance.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedConstructorSymbol.MethodKind">
	<summary>
 Gets what kind of method this is. There are several different kinds of things in the
 VB language that are represented as methods. This property allow distinguishing those things
 without having to decode the name of the method.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedConstructorSymbol.Parameters">
	<summary>
 The parameters forming part of this signature.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedConstructorSymbol.ReturnType">
	<summary>
 Gets the return type of the method.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedConstructorSymbol.ReturnTypeCustomModifiers">
	<summary>
 Returns the list of custom modifiers, if any, associated with the returned value.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedConstructorSymbol.TypeArguments">
	<summary>
 Returns the type arguments that have been substituted for the type parameters.
 If nothing has been substituted for a given type parameter,
 then the type parameter itself is consider the type argument.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedConstructorSymbol.TypeParameters">
	<summary>
 Get the type parameters on this method. If the method has not generic,
 returns an empty list.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SynthesizedConstructorSymbol">
	<summary>
 This class represents a compiler generated constructor
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SynthesizedBackingFieldSymbol">
	<summary>
 Represents a compiler generated backing field for an automatically implemented property.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.SourceTypeParameterSymbol.m_HasReferenceTypeConstraint">
	<summary>
 Temporary hook for tests.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SourceTypeParameterSymbol.m_HasValueTypeConstraint">
	<summary>
 Temporary hook for tests.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SourceTypeParameterSymbol">
	<summary>
 Represents a type parameter symbol defined in source.
 </summary>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceAttributeData.IsTargetAttribute(Roslyn.Compilers.VisualBasic.Symbol,System.String,System.String,System.Byte[][])">
	<summary>
 This method finds an attribute by metadata name and signature. The algorithm for signature matching is similar to the one
 in Module.GetTargetAttributeSignatureIndex. Note, the signature matching is limited to primitive types
 and System.Type.  It will not match an arbitrary signature but it is sufficient to match the signatures of the current set of
 well known attributes.
 </summary>
	<param name="targetSymbol">The symbol which is the target of the attribute</param>
	<param name="namespaceName">The attribute's namespace</param>
	<param name="typeName">The attribute's type name</param>
	<param name="signatures">The attribute's signature in metadata encoding</param>
	<returns></returns>
</member><member name="P:Roslyn.Compilers.VisualBasic.SourcePropertySymbol.DeclarationSyntax">
	<summary> Property declaration syntax node </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SourcePropertySymbol.ShadowsExplicitly">
	<summary> True if 'Shadows' is explicitly specified in method's declaration </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SourcePropertySymbol.OverloadsExplicitly">
	<summary> True if 'Overloads' is explicitly specified in method's declaration </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SourcePropertySymbol.OverridesExplicitly">
	<summary> True if 'Overrides' is explicitly specified in method's declaration </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourcePropertySymbol.GetAccessorOverride(System.Boolean)">
	<summary>
 Helper method for accessors to get the overridden accessor methods. Should only be called by the
 accessor method symbols.
 </summary>
	<param name="getter">True to get overridden getters, False to get overridden setters</param>
	<returns>All the accessors of the given kind implemented by this property.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourcePropertySymbol.GetAccessorImplementations(System.Boolean)">
	<summary>
 Helper method for accessors to get the overridden accessor methods. Should only be called by the
 accessor method symbols.
 </summary>
	<param name="getter">True to get implemented getters, False to get implemented setters</param>
	<returns>All the accessors of the given kind implemented by this property.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourcePropertySymbol.IsAccessibilityMoreRestrictive(Roslyn.Compilers.VisualBasic.Accessibility,Roslyn.Compilers.VisualBasic.Accessibility)">
	<summary>
 Return true if the accessor accessibility is more restrictive
 than the property accessibility, otherwise false.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourcePropertySymbol.GetAccessorBlockBeginLocation(Roslyn.Compilers.VisualBasic.SourcePropertyAccessorSymbol)">
	<summary>
 Returns the location (span) of the accessor begin block.
 (Used for consistency with the native compiler that
 highlights the entire begin block for certain diagnostics.)
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourcePropertySymbol.ReportAccessorAccessibilityError(Roslyn.Compilers.VisualBasic.SourcePropertyAccessorSymbol,Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.VisualBasic.MethodBlockSyntax,Roslyn.Compilers.VisualBasic.ERRID,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Report an error associated with the accessor accessibility modifier.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourcePropertySymbol.CloneParameters(Roslyn.Compilers.VisualBasic.MethodSymbol,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.ParameterSymbol})">
	<summary>
 Clone the property parameters for the accessor method. The
 parameters are cloned (rather than referenced from the property)
 since the ContainingSymbol needs to be set to the accessor.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SourcePropertySymbol.SyntaxTree">
	<summary>
 Gets the syntax tree.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourcePropertyAccessorSymbol.BindParameters(Roslyn.Compilers.VisualBasic.SourcePropertySymbol,Roslyn.Compilers.VisualBasic.SourcePropertyAccessorSymbol,Roslyn.Compilers.VisualBasic.Location,Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.DiagnosticBag,System.Threading.CancellationToken)">
	<summary>
 Bind parameters declared on the accessor and combine with any
 parameters declared on the property. If there are no explicit parameters
 and this is a setter, create a synthesized value parameter.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SourceSimpleParameterSymbol">
	<summary>
 Represents a parameters declared in source, that is not optional, does not have a default value, 
 attributes, or is a ParamArray. This is a separate class to save memory, since there are LOTS
 of parameters.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceComplexParameterSymbol.GetSynthesizedAttributes(Roslyn.Compilers.VisualBasic.Emit.Module)">
	<summary>
 Gets the synthesized attributes for this symbol.
 </summary>
	<param name="moduleBeingBuilt">The module.</param>
	<returns>Array of synthesized attributes of this symbol</returns>
</member><member name="T:Roslyn.Compilers.VisualBasic.SourceComplexParameterSymbol">
	<summary>
 Represents a parameter symbol defined in source.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceNamespaceSymbol.RegisterDeclaredCorTypes">
	<summary>
 Register COR types declared in this namespace, if any, in the COR types cache.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.MemberCollections.#ctor(System.Collections.Generic.Dictionary{System.String,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.Symbol}})">
	<summary>
 Initializes a new instance of the <see cref="T:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.MemberCollections"/> struct.
 </summary>
	<param name="members">The members.</param>
</member><member name="T:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.MemberCollections">
	<summary>
  Structure to wrap the different members kinds used while building the lists.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.MembersAndInitializers.#ctor(System.Collections.Generic.Dictionary{System.String,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.Symbol}},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.FieldOrPropertyInitializer}},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.FieldOrPropertyInitializer}})">
	<summary>
 Initializes a new instance of the <see cref="T:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.MembersAndInitializers"/> class.
 </summary>
	<param name="members">The members.</param>
	<param name="staticInitializers">The static initializers.</param>
	<param name="instanceInitializers">The instance initializers.</param>
</member><member name="T:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.MembersAndInitializers">
	<summary>
  Structure to wrap the different arrays of members.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.m_lazyMembersAndInitializers">
	<summary>
 The different kinds of members of this type
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.ComputeTypeFlags(Roslyn.Compilers.VisualBasic.MergedTypeDeclaration,System.Boolean)">
	<summary>
 Compute the type flags from the declaration.
 This function DOES NOT diagnose errors in the modifiers. Given the set of modifiers,
 it produces the flags, even in the case of potentially conflicting modifiers. We have to
 return some answer even in the case of errors.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.ConstantFieldRequiresSharedConstructor(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.FieldOrPropertyInitializer}})">
	<summary>
 Returns true if at least one of the elements of this list require a shared constructor
 because its type is either decimal or date and the field is const. 
 Non const fields that are shared always require a shared constructor, so this function
 should be called to determine if a synthesized shared constructor is needed that is not 
 listed in members list.
 </summary>
	<param name="staticInitializers">The static initializers.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.SharedFieldRequiresSharedConstructor(Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.FieldOrPropertyInitializer}})">
	<summary>
 Returns true if at least one of the elements of this list require a shared constructor
 because its shared (and not const, which would imply shared)
 </summary>
	<param name="staticInitializers">The static initializers.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.CheckForOverloadOverridesShadowsClashesInSameType(Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.MembersAndInitializers,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Performs a check for overloads/overrides/shadows conflicts, generates diagnostics.
 </summary>
	<param name="membersAndInitializers"></param>
	<param name="diagBag"></param>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.AddDelegateMembers(System.Collections.Generic.Dictionary{System.String,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.Symbol}},Roslyn.Compilers.VisualBasic.SyntaxTree,Roslyn.Compilers.VisualBasic.DelegateStatementSyntax,Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.DiagnosticBag,System.Threading.CancellationToken)">
	<summary>
 Adds the delegate members to the given named type symbol
 </summary>
	<param name="members">The member collections where to add the member to</param>
	<param name="tree">The syntax tree</param>
	<param name="syntax">The syntax of the delegate declaration (sub or function delegate statement)</param>
	<param name="diagnostics">The diagnostics.</param>
	<param name="cancellationToken">The cancellation token.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.CreateSharedConstructorsForConstFieldsIfRequired(Roslyn.Compilers.DiagnosticBag)">
	<summary>
 In case the passed initializers require a shared constructor, this method returns a new MethodSymbol instance for the 
 shared constructor if there is not already an explicit shared constructor
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.StaticInitializers">
	<summary>
 Gets the static initializers.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.InstanceInitializers">
	<summary>
 Gets the instance initializers.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.GenerateAllDeclarationErrors(System.Threading.CancellationToken)">
	<summary>
 Force all declaration errors to be generated.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.BindAllMemberAttributes(System.Threading.CancellationToken)">
	<summary>
  Ensure all attributes on on members in the named type are bound.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.EnumUnderlyingType">
	<summary>
 For enum types, gets the underlying type. Returns null on all other
 kinds of types.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.GetSynthesizedAttributes(Roslyn.Compilers.VisualBasic.Emit.Module)">
	<summary>
 Gets the synthesized attributes for this symbol.
 </summary>
	<param name="moduleBeingBuilt">The module.</param>
	<returns>Array of synthesized attributes of this symbol</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.CheckInterfaceUnification(Roslyn.Compilers.DiagnosticBag)">
	<summary>
 It is invalid for a type to directly (vs through a base class) implement two interfaces that
 unify (i.e. are the same for some substitution of type parameters).
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.AddInitializer(Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.FieldOrPropertyInitializer}@,Roslyn.Compilers.VisualBasic.FieldOrPropertyInitializer)">
	<summary>
 Adds a field initializer for the field to list of field initializers
 </summary>
	<param name="initializers">All initializers.</param>
	<param name="fieldInitializer">The field initializer to add to the list of initializers.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.AddInitializers(Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.FieldOrPropertyInitializer}}@,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.FieldOrPropertyInitializer})">
	<summary>
 Adds an array of initializers to the member collections structure
 </summary>
	<param name="allInitializers">All initializers.</param>
	<param name="siblings">The siblings.</param>
</member><member name="T:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol">
	<summary>
 Represents a type or module declared in source. 
 Could be a class, structure, interface, delegate, enum, module.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SourceTypeFlags">
	<summary>
 Holds information about a SourceType in a compact form.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.SourceModuleSymbol.m_AssemblySymbol">
	<summary>
 Owning assembly.
 </summary>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceModuleSymbol.GetAllDeclarationErrorsInTree(Roslyn.Compilers.VisualBasic.SyntaxTree,System.Threading.CancellationToken)">
	<summary>
 Get all the declaration errors in a single tree.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceModuleSymbol.GetAllDeclarationErrors(System.Threading.CancellationToken)">
	<summary>
 Get all the declaration errors.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SourceModuleSymbol">
	<summary>
 Represents the primary module of an assembly being built by compiler.
 </summary>
	<remarks></remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.SourceMethodSymbol.ShadowsExplicitly">
	<summary> True if 'Shadows' is explicitly specified in method's declaration </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SourceMethodSymbol.OverloadsExplicitly">
	<summary> True if 'Overloads' is explicitly specified in method's declaration </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SourceMethodSymbol.OverridesExplicitly">
	<summary> True if 'Overrides' is explicitly specified in method's declaration </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SourceMethodSymbol">
	<summary>
 Represents a method declared in source. 
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SourceFieldSymbol.DeclarationSyntax">
	<summary> Field declaration syntax node </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SourceFieldSymbol.EqualsValueOrAsNewInitOpt">
	<summary> Field initializer's declaration syntax node. 
 It can be a EqualsValueSyntax or AsNewClauseSyntax</summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SourceFieldSymbol.HasDeclaredType">
	<summary>
 Gets a value indicating whether this instance has declared type. This means a field was declared with an AsClause
 or in case of const fields with an AsClause whose type is not System.Object
 </summary>
	<value>
		<c>true</c> if this instance has declared type; otherwise, <c>false</c>.
 </value>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceFieldSymbol.GetInferredType(Roslyn.Compilers.VisualBasic.ConstantFieldsInProgress)">
	<summary>
 Gets the inferred type of this const field from the initialization value.
 </summary>
	<param name="inProgress">The previously visited const fields; used to detect cycles.</param><returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceFieldSymbol.GetConstantValue(Roslyn.Compilers.VisualBasic.ConstantFieldsInProgress)">
	<summary>
 Gets the constant value.
 </summary>
	<param name="inProgress">The previously visited const fields; used to detect cycles.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceFieldSymbol.GetConstantValueDiagnostics(Roslyn.Compilers.VisualBasic.ConstantFieldsInProgress)">
	<summary>
 Gets the diagnostics generated during determining the constant value of this field.
 </summary>
	<param name="inProgress">The previously visited const fields; used to detect cycles.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceFieldSymbol.MakeConstantTuple(Roslyn.Compilers.VisualBasic.ConstantFieldsInProgress)">
	<summary>
 Makes the constant tuple if needed.
 </summary>
	<param name="inProgress">The previously visited const fields; used to detect cycles.</param>
</member><member name="P:Roslyn.Compilers.VisualBasic.SourceFieldSymbol.SyntaxTree">
	<summary>
 Gets the syntax tree.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceFieldSymbol.GetSynthesizedAttributes(Roslyn.Compilers.VisualBasic.Emit.Module)">
	<summary>
 Gets the synthesized attributes for this symbol.
 </summary>
	<param name="moduleBeingBuilt">The module.</param>
	<returns>Array of synthesized attributes of this symbol</returns>
</member><member name="T:Roslyn.Compilers.VisualBasic.SourceFile.BoundFileInformation">
	<summary>
 The bound information from a file.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SourceFile.MemberImports">
	<summary>
 Return the member imports for this file. May return Nothing if there are no member imports.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SourceFile.AliasImports">
	<summary>
 Return the alias imports for this file. May return Nothing if there are no alias imports.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SourceFile.OptionStrict">
	<summary>
 Returns the value of the Option Strict declaration if there was one, otherwise Null.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SourceFile.OptionInfer">
	<summary>
 Returns the value of the Option Infer declaration if there was one, otherwise Null.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SourceFile.OptionExplicit">
	<summary>
 Returns the value of the Option Explicit declaration if there was one, otherwise Null.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SourceFile.OptionCompareText">
	<summary>
 Returns the value of the Option Compare Text/Binary declaration if there was one, otherwise Null. True means
 Text, False means Binary.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SourceFile.AssemblyAttributes">
	<summary>
 Returns the assembly attributes for this file.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SourceFile.ModuleAttributes">
	<summary>
 Returns the module attributes for this file.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceFile.GenerateAllDeclarationErrors">
	<summary>
 Force all declaration errors to be generated.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceDelegateSymbol.#ctor(Roslyn.Compilers.VisualBasic.MergedTypeDeclaration,Roslyn.Compilers.VisualBasic.NamespaceOrTypeSymbol,Roslyn.Compilers.VisualBasic.SourceModuleSymbol)">
	<summary>
 Initializes a new instance of the <see cref="T:Roslyn.Compilers.VisualBasic.SourceDelegateSymbol"/> class.
 </summary>
	<param name="decl">The decl.</param>
	<param name="containingSymbol">The containing symbol.</param>
	<param name="containingModule">The containing module.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceDelegateSymbol.AddDelegateMembers(System.Collections.Generic.Dictionary{System.String,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.Symbol}},Roslyn.Compilers.VisualBasic.SyntaxTree,Roslyn.Compilers.VisualBasic.DelegateStatementSyntax,Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.DiagnosticBag,System.Threading.CancellationToken)">
	<summary>
 Adds the delegate members to this source delegate symbol
 </summary>
	<param name="members">The member collections where to add the member to</param>
	<param name="tree">The syntax tree</param>
	<param name="syntax">The syntax of the delegate declaration (sub or function delegate statement)</param>
	<param name="diagnostics">The diagnostics.</param>
	<param name="cancellationToken">The cancellation token.</param>
</member><member name="T:Roslyn.Compilers.VisualBasic.SourceDelegateSymbol">
	<summary>
 This class represents a synthesized delegate type derived from a delegate statement
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SourceAssemblySymbol.m_Compilation">
	<summary>
 A Compilation the assembly is created for.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.SourceAssemblySymbol.m_AssemblyName">
	<summary>
 Assembly's identity, maybe incomplete. 
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.SourceAssemblySymbol.m_Modules">
	<summary>
 A list of modules the assembly consists of. 
 The first (index=0) module is a SourceModuleSymbol, which is a primary module, the rest are net-modules.
 </summary>
	<remarks></remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.SourceAssemblySymbol.Compilation">
	<summary>
 A Compilation the assembly is created for.
 </summary>
	<value></value>
	<returns></returns>
	<remarks></remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.SourceAssemblySymbol">
	<summary>
 Represents an assembly built by compiler.
 </summary>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverrideHidingHelper.CheckHidingAndOverridingForType(Roslyn.Compilers.VisualBasic.NamedTypeSymbol,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Check for overriding and hiding errors in container and report them via diagnostics.
 </summary>
	<param name="container">Containing type to check. Should be an original definition.</param>
	<param name="diagnostics">Place diagnostics here.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverrideHidingHelper.CheckMembersAgainstBaseType(Roslyn.Compilers.VisualBasic.NamedTypeSymbol,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Check each member of container for constraints against the base type. For methods and properties and events,
 checking overriding and hiding constraints. For other members, just check for hiding issues.
 </summary>
	<param name="container">Containing type to check. Should be an original definition.</param>
	<param name="diagnostics">Place diagnostics here.</param>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverrideHidingHelper.CheckAllAbstractsAreOverriddenAndNotHidden(Roslyn.Compilers.VisualBasic.NamedTypeSymbol,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 If the "container" is a non-MustInherit, make sure it has no MustOverride Members
 If "container" is a non-MustInherit inheriting from a MustInherit, make sure that all MustOverride members
 have been overridden.
 If "container" is a MustInherit inheriting from a MustInherit, make sure that no MustOverride members
 have been shadowed.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverrideHidingHelper.CheckShadowing(Roslyn.Compilers.VisualBasic.NamedTypeSymbol,Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Report any diagnostics related to shadowing for a member.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverrideHidingHelper.CanOverrideOrHide(Roslyn.Compilers.VisualBasic.Symbol)">
	<summary>
 Some symbols do not participate in overriding/hiding (e.g. constructors). Accessors are consider
 to override or hide.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.OverrideHidingHelper">
	<summary>
 Methods, Properties, and Events all can override or hide members. 
 This class has helper methods and extensions for sharing by multiple symbol types.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverrideHidingHelper`1.MakeOverriddenMembers(`0)">
	<summary>
 Walk up the type hierarchy from ContainingType and list members that this
 method overrides (accessible methods/properties with the same signature, if this
 method is declared "override").
 
 Methods in the overridden list may not be virtual or may have different
 accessibities, types, accessors, etc.  They are really candidates to be
 overridden.
 
 </summary>
	<remarks>
 In the presence of non-VB types, the meaning of "same signature" is rather
 complicated.  If this method isn't from source, then it refers to the runtime's
 notion of signature (i.e. including return type, custom modifiers, etc).
 If this method is from source, use the VB version of signature. Note that 
 Dev10 C# has a rule that prefers members with less custom modifiers. Dev 10 VB has no
 such rule, so I'm not adding such a rule here.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverrideHidingHelper`1.FindOverriddenMembersInType(`0,System.Boolean,Roslyn.Compilers.VisualBasic.NamedTypeSymbol,Roslyn.Compilers.VisualBasic.NamedTypeSymbol,Roslyn.Compilers.ArrayBuilder{`0})">
	<summary>
 Look for overridden members in a specific type.  
 </summary>
	<param name="overridingSym">Syntax that overriding or hiding.</param>
	<param name="overridingIsFromSource">True if "overridingSym" is from source (this.IsFromSource).</param>
	<param name="overridingContainingType">The type that contains this method (this.ContainingType).</param>
	<param name="currType">The type to search.</param>
	<param name="overriddenBuilder">Builder to place overridden members in.</param>
</member><member name="T:Roslyn.Compilers.VisualBasic.OverrideHidingHelper`1">
	<summary>
 Many of the methods want to generically work on properties, methods (and maybe events) as TSymbol. We put all these
 methods into a generic class for convenience.
 </summary>
</member><member name="T:BaseTypeAnalysis.DependencyDesc">
	<summary>
 a link in a dependency chain
 it means that "dependent" is dependent on the rest of the chain.
 "kind" tells what kind of dependency this is.
 </summary>
</member><member name="T:BaseTypeAnalysis.DependencyKind">
	<summary>
 Source types may have dependencies via inheritance or containment
 The diagnostics is different in those cases.
 </summary>
</member><member name="M:BaseTypeAnalysis.GetDependenceDiagnosticForBase(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 Detects situations when a type participates in a dependency loop
 And generates appropriate diagnostics.
 No diagnostics means there was no loop
 </summary>
</member><member name="M:BaseTypeAnalysis.GetDependenceChain(System.Collections.Generic.HashSet{Roslyn.Compilers.VisualBasic.Symbol},Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 if there is a dependency chain from "current" to the "root"
 Returning Nothing, means that there is no dependency
 Returning Empty, means that root and current are the same and we have a 0-length dependency
 Otherwise a dependence chain is formed.
 </summary>
</member><member name="M:BaseTypeAnalysis.GetDependencyDiagnosticsForImportedClass(Roslyn.Compilers.VisualBasic.NamedTypeSymbol)">
	<summary>
 Verifies that given symbol does not have loops in its inheritance chain
 and reports appropriate diagnostics.
 </summary>
</member><member name="M:BaseTypeAnalysis.GetDependencyDiagnosticsForImportedBaseInterface(Roslyn.Compilers.VisualBasic.NamedTypeSymbol,Roslyn.Compilers.VisualBasic.NamedTypeSymbol)">
	<summary>
 Verifies that given symbol does not have loops in its inheritance hierarchy
 and reports appropriate diagnostics.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingModuleSymbol.m_RetargetingAssembly">
	<summary>
 Owning RetargetingAssemblySymbol.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingModuleSymbol.m_UnderlyingModule">
	<summary>
 The underlying ModuleSymbol, cannot be another RetargetingModuleSymbol.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingModuleSymbol.m_RetargetingAssemblyMap">
	<summary>
 The map that captures information about what assembly should be retargeted 
 to what assembly. Key is the AssemblySymbol the underlying module references,
 value is the corresponding AssemblySymbol this module references and corresponding
 retargeting map for symbols.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingModuleSymbol.m_SymbolMap">
	<summary>
 Retargeting map from underlying module to this one.
 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingModuleSymbol.#ctor(Roslyn.Compilers.VisualBasic.Retargeting.RetargetingAssemblySymbol,Roslyn.Compilers.VisualBasic.SourceModuleSymbol)">
	<summary>
 Constructor.
 </summary>
	<param name="retargetingAssembly">
 Owning assembly.
 </param>
	<param name="underlyingModule">
 Underlying ModuleSymbol, cannot be another RetargetingModuleSymbol.
 </param>
	<remarks></remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingModuleSymbol.UnderlyingModule">
	<summary>
 The underlying ModuleSymbol, cannot be another RetargetingModuleSymbol.
 </summary>
	<value></value>
</member><member name="M:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingModuleSymbol.SetReferences(Roslyn.Compilers.ReadOnlyArray{System.Reflection.AssemblyName},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.AssemblySymbol})">
	<summary>
 A helper method for AssemblyManager to set AssemblySymbols for assemblies 
 referenced by this module.
 </summary>
	<param name="symbols"></param>
	<remarks></remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingModuleSymbol">
	<summary>
 Represents a primary module of a RetargetingAssemblySymbol. Essentially this is a wrapper around 
 another SourceModuleSymbol that is responsible for retargeting symbols from one assembly to another. 
 It can retarget symbols for multiple assemblies at the same time.
 
 Here is how retargeting is implemented in general:
 - Symbols from underlying module are substituted with retargeting symbols.
 - Symbols from referenced assemblies that can be reused as is (i.e. don't have to be retargeted) are
   used as is.
 - Symbols from referenced assemblies that must be retargeted are substituted with result of retargeting.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingAssemblySymbol.m_UnderlyingAssembly">
	<summary>
 The underlying AssemblySymbol, it leaks symbols that should be retargeted.
 This cannot be an instance of RetargetingAssemblySymbol.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingAssemblySymbol.m_Modules">
	<summary>
 The list of contained ModuleSymbol objects. First item in the list
 is RetargetingModuleSymbol that wraps corresponding SourceModuleSymbol 
 from m_UnderlyingAssembly.Modules list, the rest are PEModuleSymbols for 
 added modules.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingAssemblySymbol.m_NoPiaResolutionAssemblies">
	<summary>
 An array of assemblies involved in canonical type resolution of
 NoPia local types defined within this assembly. In other words, all 
 references used by a compilation referencing this assembly.
 The array and its content is provided by AssemblyManager and must not be modified.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingAssemblySymbol.m_LinkedReferencedAssemblies">
	<summary>
 An array of assemblies referenced by this assembly, which are linked (/l-ed) by 
 each compilation that is using this AssemblySymbol as a reference. 
 If this AssemblySymbol is linked too, it will be in this array too.
 The array and its content is provided by AssemblyManager and must not be modified.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingAssemblySymbol.m_NoPiaUnificationMap">
	<summary>
 A map from a local NoPia type to corresponding canonical type.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingAssemblySymbol.m_IsLinked">
	<summary>
 Assembly is /l-ed by compilation that is using it as a reference.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingAssemblySymbol.#ctor(Roslyn.Compilers.VisualBasic.SourceAssemblySymbol,System.Boolean)">
	<summary>
 Constructor.
 </summary>
	<param name="underlyingAssembly">
 The underlying AssemblySymbol, cannot be an instance of RetargetingAssemblySymbol.
 </param>
	<param name="isLinked">
 Assembly is /l-ed by compilation that is using it as a reference.
 </param>
</member><member name="P:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingAssemblySymbol.UnderlyingAssembly">
	<summary>
 The underlying AssemblySymbol.
 This cannot be an instance of RetargetingAssemblySymbol.
 </summary>
	<value></value>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingAssemblySymbol.GetDeclaredSpecialType(Roslyn.Compilers.SpecialType)">
	<summary>
 Lookup declaration for FX type in this Assembly.
 </summary>
	<param name="type"></param>
	<returns></returns>
	<remarks></remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingAssemblySymbol">
	<summary>
 Essentially this is a wrapper around another AssemblySymbol that is responsible for retargeting
 symbols from one assembly to another. It can retarget symbols for multiple assemblies at the same time. 
 
 For example, compilation C1 references v1 of Lib.dll and compilation C2 references C1 and v2 of Lib.dll. 
 In this case, in context of C2, all types from v1 of Lib.dll leaking through C1 (through method 
 signatures, etc.) must be retargeted to the types from v2 of Lib.dll. This is what 
 RetargetingAssemblySymbol is responsible for. In the example above, modules in C2 do not 
 reference C1.m_AssemblySymbol, but reference a special RetargetingAssemblySymbol created for 
 C1 by AssemblyManager.
 
 Here is how retargeting is implemented in general:
 - Symbols from underlying assembly are substituted with retargeting symbols.
 - Symbols from referenced assemblies that can be reused as is (i.e. doesn't have to be retargeted) are
   used as is.
 - Symbols from referenced assemblies that must be retargeted are substituted with result of retargeting.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.PropertySymbol.Type">
	<summary>
 Gets the type of the property. 
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.PropertySymbol.TypeCustomModifiers">
	<summary>
 Returns the list of custom modifiers, if any, associated with the type of the property. 
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.PropertySymbol.Parameters">
	<summary>
 Gets the parameters of this property. If this property has no parameters, returns
 an empty list.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.PropertySymbol.IsDefault">
	<summary>
 Returns true if this property is a default property. 
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.PropertySymbol.IsReadOnly">
	<summary>
 Returns true if this is a read-only property; i.e., has no set accessor.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.PropertySymbol.IsWriteOnly">
	<summary>
 Returns true if this is a write-only property; i.e., has no get accessor.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.PropertySymbol.GetMethod">
	<summary>
 Gets the associated "get" method for this property. If this property
 has no get accessor, returns Nothing.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.PropertySymbol.SetMethod">
	<summary>
 Gets the associated "set" method for this property. If this property
 has no set accessor, returns Nothing.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.PropertySymbol.IsOverloads">
	<summary>
 Returns true if this property hides a base property by name and signature.
 The equivalent of the "hidebysig" flag in metadata. 
 </summary>
	<remarks>
 This property should not be confused with general property overloading in Visual Basic, and is not directly related. 
 This property will only return true if this method hides a base property by name and signature (Overloads keyword).
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.PropertySymbol.OverriddenProperty">
	<summary>
 If this property overrides another property (because it both had the override modifier
 on it, and there correctly was a property to override, returns the overridden property.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.PropertySymbol.ExplicitInterfaceImplementations">
	<summary>
 Returns interface properties explicitly implemented by this property.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.PropertySymbol.MeParameter">
	<summary>
 Get the "this" parameter for this property.  This is only valid for source fields.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.PropertySymbol.HighestPriorityUseSiteError">
	<summary>
 Return error code that has highest priority while calculating use site error for this symbol. 
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.PropertySymbol">
	<summary>
 Represents a property.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ParameterSymbol.IsByRef">
	<summary>
 Is this ByRef parameter.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ParameterSymbol.IsOut">
	<summary>
 Is this Out parameter. Currently may only be True for the parameters of methods from PE.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ParameterSymbol.Type">
	<summary>
 Gets the type of this parameter.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ParameterSymbol.CustomModifiers">
	<summary>
 The list of custom modifiers, if any, associated with the parameter.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ParameterSymbol.Ordinal">
	<summary>
 Gets the ordinal order of this parameter. The first type parameter has ordinal zero.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ParameterSymbol.IsParamArray">
	<summary>
 Returns true if this parameter was declared as a ParamArray. 
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ParameterSymbol.IsOptional">
	<summary>
 Returns true if this parameter was declared as Optional. 
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ParameterSymbol.HasDefaultValue">
	<summary>
 Returns true if this parameter specifies a default value that is passed
 if no value is provided. If this property returns true, the value
 of the default value can be obtained with the DefaultValue property.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ParameterSymbol.DefaultValue">
	<summary>
 Returns the default value of this parameter. If HasDefaultValue
 returns false, then this property throws an InvalidOperationException.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.ParameterSymbol">
	<summary>
 Represents a parameter of a method or property.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamespaceSymbol.GetNamespaceMembers(System.Threading.CancellationToken)">
	<summary>
 Get all the members of this symbol that are namespaces.
 </summary>
	<returns>An IEnumerable containing all the namespaces that are members of this symbol. If this symbol has no namespace members,
 returns an empty IEnumerable. Never returns Nothing.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamespaceSymbol.GetModuleMembers">
	<summary>
 Get all the members of this symbol that are modules.
 </summary>
	<returns>An IEnumerable containing all the types that are members of this namespace. If this namespace has no module members,
 returns an empty IEnumerable. Never returns Nothing.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamespaceSymbol.GetModuleMembers(System.String)">
	<summary>
 Get all the members of this symbol that are modules that have a particular name
 </summary>
	<returns>An IEnumerable containing all the modules that are members of this namespace with the given name. 
 If this symbol has no modules with this name,
 returns an empty IEnumerable. Never returns Nothing.</returns>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamespaceSymbol.IsGlobalNamespace">
	<summary>
 Returns whether this namespace is the unnamed, global namespace that is 
 at the root of all namespaces.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamespaceSymbol.Extent">
	<summary>
 Namespaces are by their nature open-ended, but a NamespaceSymbol contains
 a specific set of members. The set of members contained by a NamespaceSymbol is denoted
 by the Extent of the namespace. If a Namespace has an Extent of NamespaceExtent.Module,
 it contains members of the namespace that are present in a particular module. If a Namespace has
 an extent of NamespaceExtent.Compilation, it contains all members of the namespace in a compilation,
 including those defined in source and all directly referenced metadata assemblies (or added metadata modules). 
 </summary>
	<returns>NamespaceExtent.Module if this namespace is restricted to members from a single module. 
 NamespaceExtend.Compilation if this namespace is merged across source and directly referenced metadata
 in a compilation.</returns>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamespaceSymbol.ContainingAssembly">
	<summary>
 Containing assembly.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamespaceSymbol.ContainingModule">
	<summary>
 Containing module.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamespaceSymbol.Kind">
	<summary>
 Gets the kind of this symbol.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamespaceSymbol.Accept``2(Roslyn.Compilers.VisualBasic.SymbolVisitor{``0,``1},``0)">
	<summary>
 Implements visitor pattern.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamespaceSymbol.DeclaredAccessibility">
	<summary>
 Get this accessibility that was declared on this symbol. For symbols that do
 not have accessibility declared on them, returns NotApplicable.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamespaceSymbol.DeclaredAccessibilityOfMostAccessibleDescendantType">
	<summary>
 Returns declared accessibility of most accessible type within this namespace or within a containing namespace recursively.
 Valid return values:
     Friend,
     Public,
     NotApplicable - if there are no types.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamespaceSymbol.GetDeclaredAccessibilityOfMostAccessibleDescendantType">
	<summary>
 Calculate declared accessibility of most accessible type within this namespace or within a containing namespace recursively.
 Expected to be called at most once per namespace symbol, unless there is a race condition.
 
 Valid return values:
     Friend,
     Public,
     NotApplicable - if there are no types.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamespaceSymbol.ContainsTypesAccessibleFrom(Roslyn.Compilers.VisualBasic.AssemblySymbol)">
	<summary>
 Returns true if namespace contains types accessible from the target assembly.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamespaceSymbol.IsShared">
	<summary>
 Returns true if this symbol is "shared"; i.e., declared with the "Shared"
 modifier or implicitly always shared.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamespaceSymbol.LookupNestedNamespace(System.Collections.Generic.IEnumerable{System.String})">
	<summary>
 Lookup a nested namespace.
 </summary>
	<param name="names">
 Sequence of names for nested child namespaces.
 </param>
	<returns>
 Symbol for the most nested namespace, if found. Nothing 
 if namespace or any part of it can not be found.
 </returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamespaceSymbol.LookupMetadataType(System.String,System.String,System.Int32)">
	<summary>
 Lookup an immediately nested type referenced from metadata, names should be
 compared case-sensitively.
 </summary>
	<param name="fullTypeName">
 Full type name with generic name mangling removed.
 </param>
	<param name="simpleTypeName">
 Simple type name with generic name mangling removed.
 </param>
	<param name="arity">
 Target arity of the type.
 </param>
	<returns>
 Symbol for the type, or MissingMetadataSymbol if the type isn't found.
 </returns>
	<remarks></remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.NamespaceSymbol">
	<summary>
 Represents a namespace.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamespaceOrTypeSymbol.IsNamespace">
	<summary>
 Returns true if this symbol is a namespace. If its not a namespace, it must be a type.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamespaceOrTypeSymbol.IsType">
	<summary>
 Returns true if this symbols is a type. Equivalent to Not IsNamespace.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamespaceOrTypeSymbol.GetMembers(System.Threading.CancellationToken)">
	<summary>
 Get all the members of this symbol.
 </summary>
	<returns>A ReadOnlyArray containing all the members of this symbol. If this symbol has no members,
 returns an empty ReadOnlyArray. Never returns Null.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamespaceOrTypeSymbol.GetMembers(System.String,System.Threading.CancellationToken)">
	<summary>
 Get all the members of this symbol that have a particular name.
 </summary>
	<returns>A ReadOnlyArray containing all the members of this symbol with the given name. If there are
 no members with this name, returns an empty ReadOnlyArray. Never returns Null.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamespaceOrTypeSymbol.GetTypeMembers(System.Threading.CancellationToken)">
	<summary>
 Get all the members of this symbol that are types.
 </summary>
	<returns>An IEnumerable containing all the types that are members of this symbol. If this symbol has no type members,
 returns an empty IEnumerable. Never returns Nothing.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamespaceOrTypeSymbol.GetTypeMembers(System.String,System.Threading.CancellationToken)">
	<summary>
 Get all the members of this symbol that are types that have a particular name, and any arity.
 </summary>
	<returns>A ReadOnlyArray containing all the types that are members of this symbol with the given name. 
 If this symbol has no type members with this name,
 returns an empty ReadOnlyArray. Never returns Null.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamespaceOrTypeSymbol.GetTypeMembers(System.String,System.Int32,System.Threading.CancellationToken)">
	<summary>
 Get all the members of this symbol that are types that have a particular name and arity.
 </summary>
	<returns>An IEnumerable containing all the types that are members of this symbol with the given name and arity.
 If this symbol has no type members with this name and arity,
 returns an empty IEnumerable. Never returns Nothing.</returns>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamespaceOrTypeSymbol.IsMustOverride">
	<summary>
 Returns true if this symbol was declared as requiring an override; i.e., declared
 with the "MustOverride" modifier. Never returns true for types. 
 </summary>
	<returns>
 Always returns False.
 </returns>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamespaceOrTypeSymbol.IsNotOverridable">
	<summary>
 Returns true if this symbol was declared to override a base class members and was
 also restricted from further overriding; i.e., declared with the "NotOverridable"
 modifier. Never returns true for types.
 </summary>
	<returns>
 Always returns False.
 </returns>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamespaceOrTypeSymbol.IsOverridable">
	<summary>
 Returns true if this member is overridable, has an implementation,
 and does not override a base class member; i.e., declared with the "Overridable"
 modifier. Does not return true for members declared as MustOverride or Overrides.
 </summary>
	<returns>
 Always returns False.
 </returns>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamespaceOrTypeSymbol.IsOverrides">
	<summary>
 Returns true if this symbol was declared to override a base class members; i.e., declared
 with the "Overrides" modifier. Still returns true if the members was declared
 to override something, but (erroneously) no member to override exists.
 </summary>
	<returns>
 Always returns False.
 </returns>
</member><member name="T:Roslyn.Compilers.VisualBasic.NamespaceOrTypeSymbol">
	<summary>
 Represents either a namespace or a type.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.Arity">
	<summary>
 Returns the arity of this type, or the number of type parameters it takes.
 A non-generic type has zero arity.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.TypeParameters">
	<summary>
 Returns the type parameters that this type has. If this is a non-generic type,
 returns an empty ReadOnlyArray.  
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.TypeArguments">
	<summary>
 Returns the type arguments that have been substituted for the type parameters. 
 If nothing has been substituted for a give type parameters,
 then the type parameter itself is consider the type argument.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.ConstructedFrom">
	<summary>
 Returns the type symbol that this type was constructed from. This type symbol
 has the same containing type, but has type arguments that are the same
 as the type parameters (although its containing type might not).
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.EnumUnderlyingType">
	<summary>
 For enum types, gets the underlying type. Returns null on all other
 kinds of types.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.DelegateInvokeMethod">
	<summary>
 For delegate types, gets the delegate's invoke method.  Returns null on
 all other kinds of types.  Note that is is possible to have an ill-formed 
 delegate type imported from metadata which does not have an Invoke method.
 Such a type will be classified as a delegate but its DelegateInvokeMethod
 would be null.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.IsMustInherit">
	<summary>
 Returns true if this type was declared as requiring a derived class;
 i.e., declared with the "MustInherit" modifier. Always true for interfaces.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.IsNotInheritable">
	<summary>
 Returns true if this type does not allow derived types; i.e., declared
 with the NotInheritable modifier, or else declared as a Module, Structure,
 Enum, or Delegate.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.MightContainExtensionMethods">
	<summary>
 If this property returns false, it is certain that there are no extension
 methods inside this type. If this property returns true, it is highly likely
 (but not certain) that this type contains extension methods. This property allows
 the search for extension methods to be narrowed much more quickly.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.InstanceConstructors">
	<summary>
 Get the instance constructors for this type.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.IsReferenceType">
	<summary>
 Returns true if this type is known to be a reference type. It is never the case
 that IsReferenceType and IsValueType both return true. However, for an unconstrained
 type parameter, IsReferenceType and IsValueType will both return false.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.IsValueType">
	<summary>
 Returns true if this type is known to be a value type. It is never the case
 that IsReferenceType and IsValueType both return true. However, for an unconstrained
 type parameter, IsReferenceType and IsValueType will both return false.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.CanConstruct">
	<summary>
 Returns True if this types has Arity &gt;= 1 and Construct can be called. This is primarily useful
 when deal with error cases.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.Construct(Roslyn.Compilers.VisualBasic.TypeSymbol[])">
	<summary>
 Returns a constructed type given its type arguments.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.Construct(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.TypeSymbol})">
	<summary>
 Construct a new type from this type, substituting the given type arguments for the 
 type parameters. This method should only be called if this named type does not have
 any substitutions applied for its own type arguments with exception of alpha-rename
 substitution (although it's container might have substitutions applied).
 </summary>
	<param name="typeArguments">A set of type arguments to be applied. Must have the same length
 as the number of type parameters that this type has.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.Construct(Roslyn.Compilers.VisualBasic.TypeSubstitution)">
	<summary>
 Construct a new type from this type definition, substituting the given type arguments for the 
 type parameters. This method should only be called on the OriginalDefinition. Unlike previous 
 Construct method, this overload supports type parameter substitution on this type and any number
 of its containing types. See comments for TypeSubstitution type for more information.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.TypeSubstitution">
	<summary>
 If this is a generic type instantiation or a nested type of a generic type instantiation,
 return TypeSubstitution for this construction. Nothing otherwise.
 Returned TypeSubstitution should target OriginalDefinition of the symbol.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.Name">
	<summary>
 Gets the name of this symbol.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.MemberNames">
	<summary>
 Collection of names of members declared within this type.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.GetMembers(System.Threading.CancellationToken)">
	<summary>
 Get all the members of this symbol.
 </summary>
	<returns>A ReadOnlyArray containing all the members of this symbol. If this symbol has no members,
 returns an empty ReadOnlyArray. Never returns Null.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.GetMembers(System.String,System.Threading.CancellationToken)">
	<summary>
 Get all the members of this symbol that have a particular name.
 </summary>
	<returns>A ReadOnlyArray containing all the members of this symbol with the given name. If there are
 no members with this name, returns an empty ReadOnlyArray. Never returns Null.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.GetTypeMembers(System.Threading.CancellationToken)">
	<summary>
 Get all the members of this symbol that are types.
 </summary>
	<returns>An IEnumerable containing all the types that are members of this symbol. If this symbol has no type members,
 returns an empty IEnumerable. Never returns Nothing.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.GetTypeMembers(System.String,System.Threading.CancellationToken)">
	<summary>
 Get all the members of this symbol that are types that have a particular name, and any arity.
 </summary>
	<returns>A ReadOnlyArray containing all the types that are members of this symbol with the given name. 
 If this symbol has no type members with this name,
 returns an empty ReadOnlyArray. Never returns Null.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.GetTypeMembers(System.String,System.Int32,System.Threading.CancellationToken)">
	<summary>
 Get all the members of this symbol that are types that have a particular name and arity.
 </summary>
	<returns>An IEnumerable containing all the types that are members of this symbol with the given name and arity.
 If this symbol has no type members with this name and arity,
 returns an empty IEnumerable. Never returns Nothing.</returns>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.DeclaredAccessibility">
	<summary>
 Get this accessibility that was declared on this symbol. For symbols that do
 not have accessibility declared on them, returns NotApplicable.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.Accept``2(Roslyn.Compilers.VisualBasic.SymbolVisitor{``0,``1},``0)">
	<summary>
 Supports visitor pattern. 
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.Kind">
	<summary>
 Gets the kind of this symbol.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.MakeDeclaredBase(Roslyn.Compilers.ConsList{Roslyn.Compilers.VisualBasic.Symbol},Roslyn.Compilers.DiagnosticBag)">
	<summary>
 NamedTypeSymbol calls derived implementations of this method when declared base type
 is needed for the first time.
 
 basesBeingResolved are passed if there are any types already have their bases resolved
 so that the derived implementation could avoid infinite recursion
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.MakeDeclaredInterfaces(Roslyn.Compilers.ConsList{Roslyn.Compilers.VisualBasic.Symbol},Roslyn.Compilers.DiagnosticBag)">
	<summary>
 NamedTypeSymbol calls derived implementations of this method when declared interfaces
 are needed for the first time.
 
 basesBeingResolved are passed if there are any types already have their bases resolved
 so that the derived implementation could avoid infinite recursion
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.GetDeclaredBase(Roslyn.Compilers.ConsList{Roslyn.Compilers.VisualBasic.Symbol})">
	<summary>
 Base type as "declared".
 Declared base type may contain circularities.
 
 If DeclaredBase must be accessed while other DeclaredBases are being resolved, 
 the bases that are being resolved must be specified here to prevent potential infinite recursion.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.GetDeclaredInterfaces(Roslyn.Compilers.ConsList{Roslyn.Compilers.VisualBasic.Symbol})">
	<summary>
 Interfaces as "declared".
 Declared interfaces may contain circularities.
 
 If DeclaredInterfaces must be accessed while other DeclaredInterfaces are being resolved, 
 the bases that are being resolved must be specified here to prevent potential infinite recursion.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.MakeAcyclicBaseType(Roslyn.Compilers.DiagnosticBag)">
	<summary>
 NamedTypeSymbol calls derived implementations of this method when acyclic base type
 is needed for the first time.
 This method typically calls GetDeclaredBase, filters for 
 illegal cycles and other conditions before returning result as acyclic.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.MakeAcyclicInterfaces(Roslyn.Compilers.DiagnosticBag)">
	<summary>
 NamedTypeSymbol calls derived implementations of this method when acyclic base interfaces
 are needed for the first time.
 This method typically calls GetDeclaredInterfaces, filters for 
 illegal cycles and other conditions before returning result as acyclic.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.CheckBase(Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Do additional verification of base types after acyclic base is found.
 This is the chance to do diagnostics that may need to walk bases and as such can be performed
 only after cycles are detected and broken
 </summary>
	<param name="diagnostics"></param>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.BaseType">
	<summary>
 Base type. 
 Could be Nothing for Interfaces or Object.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.Interfaces">
	<summary>
 Interfaces that are implemented or inherited (if current type is interface itself).
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.GetBestKnownBaseType">
	<summary>
 Returns declared base type or actual base type if already known
 This is only used by cycle detection code so that it can observe when cycles are broken 
 while not forcing actual Base to be realized.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.GetBestKnownInterfaces">
	<summary>
 Returns declared interfaces or actual Interfaces if already known
 This is only used by cycle detection code so that it can observe when cycles are broken 
 while not forcing actual Interfaces to be realized.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.IsGenericType">
	<summary>
 True iff this type or some containing type has type parameters.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.GetEmittedNamespaceName">
	<summary>
 Should return full emitted namespace name for a top level type if the name 
 might be different in case from containing namespace symbol full name, Nothing overwise.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.GenerateTempNumber">
	<summary>
 Produces a sequential number for the next synthetic member.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.ImplementsAllMembersOfInterface(Roslyn.Compilers.VisualBasic.NamedTypeSymbol)">
	<summary>
 Does this type implement all the members of the given interface. Does not include members
 of interfaces that iface inherits, only direct members.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.NamedTypeSymbol">
	<summary>
 Represents a type other than an array, a type parameter.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ModuleSymbol.GlobalNamespace">
	<summary>
 Returns a NamespaceSymbol representing the global (root) namespace, with
 module extent, that can be used to browse all of the symbols defined in this module.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ModuleSymbol.ContainingAssembly">
	<summary>
 Returns the containing assembly. Modules are always directly contained by an assembly,
 so this property always returns the same as ContainingSymbol.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ModuleSymbol.GetReferencedAssemblies">
	<summary>
 Returns an array of assembly identities for assemblies referenced by this module.
 Items at the same position from GetReferencedAssemblies and from GetReferencedAssemblySymbols 
 should correspond to each other.
 
 The array and its content is provided by AssemblyManager and must not be modified.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ModuleSymbol.GetReferencedAssemblySymbols">
	<summary>
 Returns an array of AssemblySymbol objects corresponding to assemblies referenced 
 by this module. Items at the same position from GetReferencedAssemblies and 
 from GetReferencedAssemblySymbols should correspond to each other. If reference is 
 not resolved by compiler, GetReferencedAssemblySymbols returns MissingAssemblySymbol in the
 correspnding item.
 
 The array and its content is provided by AssemblyManager and must not be modified.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ModuleSymbol.SetReferences(Roslyn.Compilers.ReadOnlyArray{System.Reflection.AssemblyName},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.AssemblySymbol})">
	<summary>
 A helper method for AssemblyManager to set assembly identities for assemblies 
 referenced by this module and corresponding AssemblySymbols.
 </summary>
	<param name="names"></param>
	<param name="symbols"></param>
</member><member name="M:Roslyn.Compilers.VisualBasic.ModuleSymbol.LookupTopLevelMetadataType(System.String,System.Int32)">
	<summary>
 Lookup a top level type referenced from metadata, names should be
 compared case-sensitively.
 </summary>
	<param name="actualName">
 Full type name with generic name mangling removed.
 </param>
	<param name="arity">
 Type's arity.
 </param>
	<returns>
 Symbol for the type, or MissingMetadataSymbol if the type isn't found.
 </returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ModuleSymbol.GetModuleNamespace(Roslyn.Compilers.Common.INamespaceSymbol)">
	<summary>
 Given a namespace symbol, returns the corresponding module specific namespace symbol
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ModuleSymbol.IsMissing">
	<summary>
 Does this symbol represent a missing Module.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.ModuleSymbol">
	<summary>
 Represents a module within an assembly. Every assembly contains one or more modules.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.MissingMetadataTypeSymbol.TopLevel.m_LazyTypeId">
	<summary>
 SpecialType.TypeId
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MissingMetadataTypeSymbol.TopLevel.NamespaceName">
	<summary>
 This is the FULL namespace name (e.g., "System.Collections.Generic")
 of the type that couldn't be found.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.MissingMetadataTypeSymbol.TopLevel">
	<summary>
 Represents not nested missing type.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.MissingMetadataTypeSymbol.Nested">
	<summary>
 Represents nested missing type.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.MissingMetadataTypeSymbol">
	<summary>
 A MissingMetadataSymbol is a special kind of ErrorSymbol that represents
 a type symbol that was attempted to be read from metadata, but couldn't be
 found, because:
   a) The metadata file it lives in wasn't referenced
   b) The metadata file was referenced, but didn't contain the type
   c) The metadata file was referenced, contained the correct outer type, but
      didn't contains a nested type in that outer type.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodSymbol.MethodKind">
	<summary>
 Gets what kind of method this is. There are several different kinds of things in the
 VB language that are represented as methods. This property allow distinguishing those things
 without having to decode the name of the method.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodSymbol.IsVararg">
	<summary>
 Returns whether this method is using VARARG calling convention.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodSymbol.IsGenericMethod">
	<summary>
 Returns whether this method is generic; i.e., does it have any type parameters?
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodSymbol.Arity">
	<summary>
 Returns the arity of this method, or the number of type parameters it takes.
 A non-generic method has zero arity.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodSymbol.TypeParameters">
	<summary>
 Get the type parameters on this method. If the method has not generic,
 returns an empty list.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodSymbol.TypeArguments">
	<summary>
 Returns the type arguments that have been substituted for the type parameters. 
 If nothing has been substituted for a give type parameters,
 then the type parameter itself is consider the type argument.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodSymbol.ConstructedFrom">
	<summary>
 Returns the method symbol that this method was constructed from. This method symbol
 has the same containing type (if any), but has type arguments that are the same
 as the type parameters (although its containing type might not).
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodSymbol.IsSub">
	<summary>
 Returns true if this method has no return type; i.e., is a Sub instead of a Function.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodSymbol.ReturnType">
	<summary>
 Gets the return type of the method. If the method is a Sub, returns
 the same type symbol as is returned by Compilation.VoidType.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodSymbol.ReturnTypeCustomModifiers">
	<summary>
 Returns the list of custom modifiers, if any, associated with the returned value. 
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodSymbol.ReturnTypeAttributes">
	<summary>
 Returns the list of attributes, if any, associated with the return type.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodSymbol.ParameterCount">
	<summary>
 Optimization: in many cases, the parameter count (fast) is sufficient and we
 don't need the actual parameter symbols (slow).
 </summary>
	<remarks>
 The default implementation is always correct, but may be unnecessarily slow.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodSymbol.Parameters">
	<summary>
 Gets the parameters of this method. If this method has no parameters, returns
 an empty list.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodSymbol.Syntax">
	<summary>
 Should return syntax node that originated the method. 
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodSymbol.SyntaxTree">
	<summary>
 Should return syntax tree for the node returned by Syntax property
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MethodSymbol.CallsAreOmitted(Roslyn.Compilers.VisualBasic.Compilation)">
	<summary>
 Returns true if calls to this method are omitted in this compilation.  Calls are omitted
 when the called method is a partial method with no implementation part, or when the called
 method is a conditional method whose condition is not true in the given compilation.
 </summary>
	<param name="compilation"></param>
	<returns></returns>
	<remarks></remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodSymbol.AssociatedPropertyOrEvent">
	<summary>
 If this method has MethodKind of MethodKind.PropertyGet or MethodKind.PropertySet,
 returns the property that this method is the getter or setter for.
 If this method has MethodKind of MethodKind.EventAdd or MethodKind.EventRemove,
 returns the event that this method is the adder or remover for.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodSymbol.OverriddenMethod">
	<summary>
 If this method overrides another method (because it both had the override modifier
 on it, and there correctly was a method to override, returns the overridden method.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodSymbol.ExplicitInterfaceImplementations">
	<summary>
 Returns interface methods explicitly implemented by this method.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodSymbol.IsExternalMethod">
	<summary>
 Returns true if this method is an external method; i.e., declared
 with a "Declare".
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodSymbol.IsExtensionMethod">
	<summary>
 Returns true if this method is an extension method; i.e., declared
 with a Extension attribute.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodSymbol.IsOverloads">
	<summary>
 Returns true if this method hides a base method by name and signature.
 The equivalent of the "hidebysig" flag in metadata. 
 </summary>
	<remarks>
 This property should not be confused with general method overloading in Visual Basic, and is not directly related. 
 This property will only return true if this method hides a base method by name and signature (Overloads keyword).
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodSymbol.ShadowsExplicitly">
	<summary> 
 True if 'Shadows' is explicitly specified in method's declaration, or that of its associated
 property (for an accessor method). 
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodSymbol.IsRuntimeImplemented">
	<summary>
 True if the implementation of this method is supplied by the runtime.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodSymbol.MeParameter">
	<summary>
 Get the "this" parameter for this method.  This is only valid for source methods.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodSymbol.HighestPriorityUseSiteError">
	<summary>
 Return error code that has highest priority while calculating use site error for this symbol. 
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CompilationReference.Compilation">
	<summary>
 Returns the referenced Compilation.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CompilationReference.#ctor(Roslyn.Compilers.VisualBasic.Compilation,System.Boolean,System.String)">
	<summary>
 Create an CompilationReference.
 </summary>
	<param name="compilation">The compilation to reference.</param>
	<param name="embedInteropTypes">Should interop types be embedded in the created assembly?</param>
	<param name="alias">A namespace alias for this reference.</param>
</member><member name="T:Roslyn.Compilers.VisualBasic.CompilationReference">
	<summary>
 Represents a reference to another Compilation. 
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.MetadataOrSourceAssemblySymbol.m_LazySpecialTypes">
	<summary>
 An array of cached Cor types defined in this assembly.
 Lazily filled by GetSpecialType method.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.MetadataOrSourceAssemblySymbol.m_CachedSpecialTypes">
	<summary>
 How many Cor types have we cached so far.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MetadataOrSourceAssemblySymbol.GetDeclaredSpecialType(Roslyn.Compilers.SpecialType)">
	<summary>
 Lookup declaration for predefined CorLib type in this Assembly. Only should be
 called if it is know that this is the Cor Library (mscorlib).
 </summary>
	<param name="type"></param>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.MetadataOrSourceAssemblySymbol.RegisterDeclaredSpecialType(Roslyn.Compilers.VisualBasic.NamedTypeSymbol)">
	<summary>
 Register declaration of predefined CorLib type in this Assembly.
 </summary>
	<param name="corType"></param>
</member><member name="P:Roslyn.Compilers.VisualBasic.MetadataOrSourceAssemblySymbol.KeepLookingForDeclaredSpecialTypes">
	<summary>
 Continue looking for declaration of predefined CorLib type in this Assembly
 while symbols for new type declarations are constructed.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.MetadataOrSourceAssemblySymbol">
	<summary>
 Represents source or metadata assembly.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.Metadata.PE.PETypeParameterSymbol.m_lazyConstraintTypes">
	<summary>
 Lazily initialized by EnsureConstraintTypesAreLoaded.
 </summary>
	<remarks></remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.Metadata.PE.PETypeParameterSymbol">
	<summary>
 The class to represent all generic type parameters imported from a PE/module.
 </summary>
	<remarks></remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.Metadata.PE.PEParameterSymbol">
	<summary>
 The class to represent all types imported from a PE/module.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.Metadata.PE.PENestedNamespaceSymbol.m_ContainingNamespaceSymbol">
	<summary>
 The parent namespace. There is always one, Global namespace contains all
 top level namespaces. 
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.Metadata.PE.PENestedNamespaceSymbol.m_Name">
	<summary>
 The name of the namespace.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.Metadata.PE.PENestedNamespaceSymbol.m_TypesByNS">
	<summary>
 The sequence of groups of TypeDef row ids for types contained within the namespace, 
 recursively including those from nested namespaces. The row ids are grouped by the 
 fully-qualified namespace name in case-sensitive manner. There could be multiple groups 
 for each fully-qualified namespace name. The groups are sorted by their key  
 in case-insensitive manner. Empty string is used as namespace name for types 
 immediately contained within Global namespace. Therefore, all types in this namespace, if any, 
 will be in several first IGroupings.
 
 This member is initialized by constructor and is cleared in EnsureAllMembersLoaded 
 as soon as symbols for children are created.
 </summary>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Metadata.PE.PENestedNamespaceSymbol.#ctor(System.String,Roslyn.Compilers.VisualBasic.Metadata.PE.PENamespaceSymbol,System.Collections.Generic.IEnumerable{System.Linq.IGrouping{System.String,System.UInt32}})">
	<summary>
 Constructor.
 </summary>
	<param name="name">
 Name of the namespace, must be not empty.
 </param>
	<param name="containingNamespace">
 Containing namespace.
 </param>
	<param name="typesByNS">
 The sequence of groups of TypeDef row ids for types contained within the namespace, 
 recursively including those from nested namespaces. The row ids are grouped by the 
 fully-qualified namespace name in case-sensitive manner. There could be multiple groups 
 for each fully-qualified namespace name. The groups are sorted by their key  
 in case-insensitive manner. Empty string is used as namespace name for types 
 immediately contained within Global namespace. Therefore, all types in this namespace, if any, 
 will be in several first IGroupings.
 </param>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Metadata.PE.PENestedNamespaceSymbol.GetDeclaredAccessibilityOfMostAccessibleDescendantType">
	<summary>
 Calculate declared accessibility of most accessible type within this namespace or within a containing namespace recursively.
 Expected to be called at most once per namespace symbol, unless there is a race condition.
 
 Valid return values:
     Friend,
     Public,
     NotApplicable - if there are no types.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Metadata.PE.PENestedNamespaceSymbol">
	<summary>
 The class to represent all, but Global, namespaces imported from a PE/module.
 Namespaces that differ only by casing in name are merged.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.Metadata.PE.PENamespaceSymbol.m_lazyMembers">
	<summary>
 A map of namespaces immediately contained within this namespace 
 grouped by their name (case-insensitively).
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.Metadata.PE.PENamespaceSymbol.m_lazyTypes">
	<summary>
 A map of types immediately contained within this namespace 
 grouped by their name (case-insensitively).
 </summary>
	<remarks></remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.Metadata.PE.PENamespaceSymbol.ContainingPEModule">
	<summary>
 Returns PEModuleSymbol containing the namespace.
 </summary>
	<returns>PEModuleSymbol containing the namespace.</returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Metadata.PE.PENamespaceSymbol.LoadAllMembers(System.Collections.Generic.IEnumerable{System.Linq.IGrouping{System.String,System.UInt32}})">
	<summary>
 Initializes m_Namespaces and m_Types maps with information about 
 namespaces and types immediately contained within this namespace.
 </summary>
	<param name="typesByNS">
 The sequence of groups of TypeDef row ids for types contained within the namespace, 
 recursively including those from nested namespaces. The row ids must be grouped by the 
 fully-qualified namespace name in case-sensitive manner. There could be multiple groups 
 for each fully-qualified namespace name. The groups must be sorted by their key in 
 case-insensensitive manner. Empty string must be used as namespace name for types 
 immediately contained within Global namespace. Therefore, all types in THIS namespace, 
 if any, must be in several first IGroupings.
 </param>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Metadata.PE.PENamespaceSymbol.LazyInitializeNamespaces(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Collections.Generic.IEnumerable{System.Linq.IGrouping{System.String,System.UInt32}}}})">
	<summary>
 Create symbols for nested namespaces and initialize m_Namespaces map.
 </summary>
	<param name="childNamespaces"></param>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Metadata.PE.PENamespaceSymbol.LazyInitializeTypes(System.Collections.Generic.IEnumerable{System.Linq.IGrouping{System.String,System.UInt32}})">
	<summary>
 Create symbols for nested types and initialize m_Types map.
 </summary>
	<param name="types"></param>
	<remarks></remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.Metadata.PE.PENamespaceSymbol.AreTypesLoaded">
	<summary>
 For test purposes only.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Metadata.PE.PENamespaceSymbol">
	<summary>
 The base class to represent a namespace imported from a PE/module.
 Namespaces that differ only by casing in name are merged.
 </summary>
	<remarks></remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.Metadata.PE.PENamedTypeSymbolWithEmittedNamespaceName">
	<summary>
 The class to represent top level types imported from a PE/module.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.Metadata.PE.PENamedTypeSymbol.m_lazyNestedTypes">
	<summary>
 A map of types immediately contained within this type 
 grouped by their name (case-insensitively).
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.Metadata.PE.PENamedTypeSymbol.m_lazyMemberNames">
	<summary>
 A set of all the names of the members in this type.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Metadata.PE.PENamedTypeSymbol.m_lazyMembers">
	<summary>
 A map of members immediately contained within this type 
 grouped by their name (case-insensitively).
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.Metadata.PE.PENamedTypeSymbol.m_lazyTypeKind">
	<summary>
 Lazily initialized by TypeKind property.
 Using Integer type to make sure read/write operations are atomic.
 </summary>
	<remarks></remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.Metadata.PE.PENamedTypeSymbol">
	<summary>
 The class to represent all types imported from a PE/module.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.Metadata.PE.PEModuleSymbol.m_AssemblySymbol">
	<summary>
 Owning AssemblySymbol. This can be a PEAssemblySymbol or a SourceAssemblySymbol.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.Metadata.PE.PEModuleSymbol.m_Module">
	<summary>
 A Module object providing metadata.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.Metadata.PE.PEModuleSymbol.m_GlobalNamespace">
	<summary>
 Global namespace. 
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.Metadata.PE.PEModuleSymbol.m_LazySystemTypeSymbol">
	<summary>
 Cache the symbol for well-known type System.Type because we use it frequently
 (for attributes).
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Metadata.PE.PEModuleSymbol.TypeDefRowIdToTypeMap">
	<summary>
 This is a map from TypeDef row id to the target TypeSymbol. 
 It is used by MetadataDecoder to speed-up type reference resolution
 for metadata coming from this module. The map is lazily populated
 as we load types from the module.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.Metadata.PE.PEModuleSymbol.TypeRefRowIdToTypeMap">
	<summary>
 This is a map from TypeRef row id to the target TypeSymbol. 
 It is used by MetadataDecoder to speed-up type reference resolution
 for metadata coming from this module. The map is lazily populated
 by MetadataDecoder as we resolve TypeRefs from the module.
 </summary>
	<remarks></remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.Metadata.PE.PEModuleSymbol">
	<summary>
 Represents a net-module imported from a PE. Can be a primary module of an assembly. 
 </summary>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Metadata.PE.PEMethodSymbol.SetAssociatedProperty(Roslyn.Compilers.VisualBasic.Metadata.PE.PEPropertySymbol,Roslyn.Compilers.VisualBasic.MethodKind)">
	<summary>
 Associate the method with a particular property. Returns
 false if the method is already associated with a property.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Metadata.PE.PEMethodSymbol.IsRuntimeImplemented">
	<summary>
 True if the implementation of this method is supplied by the runtime.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Metadata.PE.PEMethodSymbol">
	<summary>
 The class to represent all methods imported from a PE/module.
 </summary>
	<remarks></remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.Metadata.PE.PEFieldSymbol">
	<summary>
 The class to represent all fields imported from a PE/module.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.Metadata.PE.PEGlobalNamespaceSymbol.m_ModuleSymbol">
	<summary>
 The module containing the namespace.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.Metadata.PE.PEAssemblySymbol.m_Assembly">
	<summary>
 An Assembly object providing metadata for the assembly.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.Metadata.PE.PEAssemblySymbol.m_DocumentationProvider">
	<summary>
 An IMetadataDocumentationProvider providing XML documentation for this assembly.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Metadata.PE.PEAssemblySymbol.m_Modules">
	<summary>
 The list of contained PEModuleSymbol objects.
 The list doesn't use type ReadOnlyCollection(Of PEModuleSymbol) so that we
 can return it from Modules property as is.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.Metadata.PE.PEAssemblySymbol.m_NoPiaResolutionAssemblies">
	<summary>
 An array of assemblies involved in canonical type resolution of
 NoPia local types defined within this assembly. In other words, all 
 references used by a compilation referencing this assembly.
 The array and its content is provided by AssemblyManager and must not be modified.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Metadata.PE.PEAssemblySymbol.m_LinkedReferencedAssemblies">
	<summary>
 An array of assemblies referenced by this assembly, which are linked (/l-ed) by 
 each compilation that is using this AssemblySymbol as a reference. 
 If this AssemblySymbol is linked too, it will be in this array too.
 The array and its content is provided by AssemblyManager and must not be modified.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Metadata.PE.PEAssemblySymbol.m_IsLinked">
	<summary>
 Assembly is /l-ed by compilation that is using it as a reference.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Metadata.PE.PEAssemblySymbol">
	<summary>
 Represents an assembly imported from a PE.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.Metadata.PE.MetadataDecoder.m_ModuleSymbol">
	<summary>
 ModuleSymbol for the module - source of metadata.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Metadata.PE.MetadataDecoder.m_typeContextOpt">
	<summary>
 Type context for resolving generic type arguments.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Metadata.PE.MetadataDecoder.m_methodContextOpt">
	<summary>
 Method context for resolving generic method type arguments.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Metadata.PE.MetadataDecoder.LookupTopLevelTypeDefSymbol(System.Int32,System.String,System.UInt16)">
	<summary>
 Lookup a type defined in referenced assembly.
 </summary>
	<param name="referencedAssemblyIndex"></param>
	<param name="emittedName"></param>
	<param name="arity"></param>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Metadata.PE.MetadataDecoder.LookupTopLevelTypeDefSymbol(System.String,System.UInt16)">
	<summary>
 Lookup a type defined in this module.
 This method will be called only if the type we are
 looking for hasn't been loaded yet. Otherwise, MetadataDecoder
 would have found the type in TypeDefRowIdToTypeMap based on its 
 TypeDef row id. 
 </summary>
	<param name="emittedName"></param>
	<param name="arity"></param>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Metadata.PE.MetadataDecoder.SubstituteTypeParameters(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol[],System.Boolean[])">
	<summary>
 Produce constructed type symbol.
 </summary>
	<param name="genericTypeDef">
 Symbol for generic type.
 </param>
	<param name="arguments">
 Generic type arguments, including those for nesting types.
 </param>
	<param name="refersToNoPiaLocalType">
 Flags for arguments. Each item indicates whether corresponding argument refers to NoPia local types.
 </param>
	<returns></returns>
	<remarks></remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.Metadata.PE.MetadataDecoder.IsOrClosedOverATypeFromAssembliesVisitor">
	<summary>
 Perform a check whether the type or at least one of its generic arguments 
 is defined in the specified assemblies. The check is performed recursively. 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Metadata.PE.MetadataDecoder.SubstituteNoPiaLocalType(System.String,System.Boolean,Roslyn.Compilers.VisualBasic.TypeSymbol,System.String,System.String,System.String,Roslyn.Compilers.VisualBasic.AssemblySymbol,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.AssemblySymbol})">
	<summary>
 Find canonical type for NoPia embedded type.
 </summary>
	<param name="name"></param>
	<param name="isInterface"></param>
	<param name="baseType"></param>
	<param name="interfaceGuid"></param>
	<param name="scope"></param>
	<param name="identifier"></param>
	<param name="referringAssembly"></param>
	<param name="lookupIn"></param>
	<returns>
 Symbol for the canonical type or an ErrorTypeSymbol. Never returns null.
 </returns>
</member><member name="T:Roslyn.Compilers.VisualBasic.Metadata.PE.MetadataDecoder">
	<summary>
 Helper class to resolve metadata tokens and signatures.
 </summary>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.MergedNamespaceSymbol.Create(Roslyn.Compilers.VisualBasic.AssemblySymbol,Roslyn.Compilers.VisualBasic.NamespaceSymbol,System.Collections.Generic.IEnumerable{Roslyn.Compilers.VisualBasic.NamespaceSymbol})">
	<summary>
 Create a possibly merged namespace symbol. If only a single namespace is passed it, it is just returned directly.
 If two or more namespaces are passed in, then a new merged namespace is created with the given extent and container.
 </summary>
	<param name="extent">The namespace extent to use, IF a merged namespace is created.</param>
	<param name="containingNamespace">The containing namespace to used, IF a merged namespace is created.</param>
	<param name="namespacesToMerge">One or more namespaces to merged. If just one, then it is returned.
 The merged namespace symbol may hold onto the array.</param>
	<returns></returns>A namespace symbol representing the merged namespace.(of /returns)

</member><member name="M:Roslyn.Compilers.VisualBasic.MergedNamespaceSymbol.SlowGetChildrenOfName(System.String)">
	<summary>
 Method that is called from the CachingLookup to lookup the children of a given name. Looks
 in all the constituent namespaces.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MergedNamespaceSymbol.SlowGetChildNames">
	<summary>
 Method that is called from the CachingLookup to get all child names. Looks
 in all constituent namespaces.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MergedNamespaceSymbol.GetDeclaredAccessibilityOfMostAccessibleDescendantType">
	<summary>
 Calculate declared accessibility of most accessible type within this namespace or within a containing namespace recursively.
 Expected to be called at most once per namespace symbol, unless there is a race condition.
 
 Valid return values:
     Friend,
     Public,
     NotApplicable - if there are no types.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MergedNamespaceSymbol.RawContainsAccessibleTypes">
	<summary>
 For test purposes only.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MergedNamespaceSymbol.CompilationMergedNamespaceSymbol.ContainsTypesAccessibleFrom(Roslyn.Compilers.VisualBasic.AssemblySymbol)">
	<summary>
 Returns true if namespace contains types accessible from the target assembly.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.MergedNamespaceSymbol">
	<summary>
 A MergedNamespaceSymbol represents a namespace that merges the contents of two or more other
 namespaces. Any sub-namespaces with the same names are also merged if they have two or more
 instances.
 
 Merged namespaces are used to merged the symbols from multiple metadata modules and the source "module"
 into a single symbol tree that represents all the available symbols. The compiler resolves names
 against Me merged set of symbols.
 
 Typically there will not be very many merged namespaces in a Compilation: only the root namespaces and
 namespaces that are used in multiple referenced modules. (Microsoft, System, System.Xml,
 System.Diagnostics, System.Threading, ...)
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.FieldSymbol.Type">
	<summary>
 Gets the type of this variable.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.FieldSymbol.HasDeclaredType">
	<summary>
 Gets a value indicating whether this instance has declared type. This means a field was declared with an AsClause
 or in case of const fields with an AsClause whose type is not System.Object
 </summary>
	<value>
		<c>true</c> if this instance has declared type; otherwise, <c>false</c>.
 </value>
</member><member name="P:Roslyn.Compilers.VisualBasic.FieldSymbol.CustomModifiers">
	<summary>
 The list of custom modifiers, if any, associated with the member variable.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.FieldSymbol.AssociatedProperty">
	<summary>
 If this variable serves as a backing variable for an automatically generated
 property, returns that property. Otherwise returns Nothing.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.FieldSymbol.IsReadOnly">
	<summary>
 Returns true if this variable was declared as ReadOnly 
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.FieldSymbol.IsConst">
	<summary>
 Returns true if this field was declared as "const" (i.e. is a constant declaration), or
 is an Enum member.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.FieldSymbol.IsMetadataConstant">
	<summary>
 Gets a value indicating whether this instance is metadata constant. A field is considered to be 
 metadata constant if the field value is a valid default value for a field.
 </summary>
	<value>
		<c>true</c> if this instance is metadata constant; otherwise, <c>false</c>.
 </value>
</member><member name="P:Roslyn.Compilers.VisualBasic.FieldSymbol.IsConstButNotMetadataConstant">
	<summary>
 Gets a value indicating whether this instance is const, but not metadata constant. A field is considered to be 
 const but not metadata constant if the const field's type is either Date or Decimal.
 </summary>
	<value>
		<c>true</c> if this instance is metadata constant; otherwise, <c>false</c>.
 </value>
</member><member name="P:Roslyn.Compilers.VisualBasic.FieldSymbol.HasConstantValue">
	<summary>
 Returns false if the field wasn't declared as "const", or constant value was omitted or erroneous.
 True otherwise.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.FieldSymbol.ConstantValue">
	<summary>
 If IsConst returns true, then returns the value of the constant or Enum member.
 If IsConst return false, then returns Nothing.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.FieldSymbol.GetConstantValue(Roslyn.Compilers.VisualBasic.ConstantFieldsInProgress)">
	<summary>
 Gets the constant value.
 </summary>
	<param name="inProgress">The previously visited const fields; used to detect cycles.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.FieldSymbol.GetConstantValueDiagnostics(Roslyn.Compilers.VisualBasic.ConstantFieldsInProgress)">
	<summary>
 Gets the diagnostics generated by determining the constant value of a field.
 </summary>
	<param name="inProgress">The previously visited const fields; used to detect cycles.</param><returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.FieldSymbol.GetInferredType(Roslyn.Compilers.VisualBasic.ConstantFieldsInProgress)">
	<summary>
 Const fields do not (always) have to be declared with a given type. To get the inferred type determined from
 the initialization this method should be called instead of "Type". For non const field this method returns the
 declared type.
 </summary>
	<param name="inProgress">The previously visited const fields; used to detect cycles.</param><returns></returns>
</member><member name="P:Roslyn.Compilers.VisualBasic.FieldSymbol.IsSpecialName">
	<summary>
 Called from IFieldDefinition.IsSpecialName to allow
 derived types to override default implementation.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.FieldSymbol.IsRuntimeSpecial">
	<summary>
 Called from IFieldDefinition.IsRuntimeSpecial to allow
 derived types to override default implementation.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.FieldSymbol.MeParameter">
	<summary>
 Get the "this" parameter for this field.  This is only valid for source fields.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.FieldSymbol.HighestPriorityUseSiteError">
	<summary>
 Return error code that has highest priority while calculating use site error for this symbol. 
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.FieldSymbol">
	<summary>
 Represents a member variable -- a variable declared as a member of a Class or Structure. 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InstanceTypeSymbol.InternalSubstituteTypeParameters(Roslyn.Compilers.VisualBasic.TypeSubstitution)">
	<summary>
 Substitute the given type substitution within this type, returning a new type. If the
 substitution had no effect, return Me. 
 !!! Only code implementing construction of generic types is allowed to call this method !!!
 !!! All other code should use Construct methods.                                        !!! 
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InstanceTypeSymbol">
	<summary>
 An InstanceTypeSymbol is a NamedTypeSymbol that is a pure instance type, where the class
(and any containing classes) have no type substitutions applied.
 This class provide shared implementation for types whose definition is (possibly lazily)
 constructed from source or metadata. It provides the shared implementation between these two, primarily
 the implementation of Construct and InternalSubstituteTypeParameters.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.IdentifierComparison.Comparer">
	<summary>
 Returns a StringComparer that compares strings according the VB identifier comparison rules.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.IdentifierComparison.Equals(System.String,System.String)">
	<summary>
 Determines if two VB identifiers are equal according to the VB identifier comparison rules.
 </summary>
	<param name="ident1">First identifier to compare</param>
	<param name="ident2">Second identifier to compare</param>
	<returns>True if the identifiers should be considered the same.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.IdentifierComparison.Compare(System.String,System.String)">
	<summary>
 Compares two VB identifiers according to the VB identifier comparison rules.
 </summary>
	<param name="ident1">First identifier to compare</param>
	<param name="ident2">Second identifier to compare</param>
	<returns>-1 if ident1 &lt; ident2, 1 if ident1 &gt; ident2, 0 if they are equal.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.IdentifierComparison.GetHashCode(System.String)">
	<summary>
 Gets a case-insensitive hash code for VB identifiers.
 </summary>
	<param name="ident">identifier to get the hash code for</param>
	<returns>The hash code for the given identifier</returns>
</member><member name="T:Roslyn.Compilers.VisualBasic.IdentifierComparison">
	<summary>
 A class that encapsulates the VB case-insensitive identifier comparison rules.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ErrorTypeSymbol.ErrorInfo">
	<summary>
 Returns information about the reason that this type is in error.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ErrorTypeSymbol.InternalSubstituteTypeParameters(Roslyn.Compilers.VisualBasic.TypeSubstitution)">
	<summary>
 Substitute the given type substitution within this type, returning a new type. If the
 substitution had no effect, return Me. 
 !!! Only code implementing construction of generic types is allowed to call this method !!!
 !!! All other code should use Construct methods.                                        !!! 
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ErrorTypeSymbol.NonErrorGuessType">
	<summary> 
 If we believe we know which symbol the user intended, then we should retain that information
 in the corresponding error symbol - it can be useful for deciding how to handle the error.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ErrorTypeSymbol.CandidateSymbols">
	<summary>
 If we have candidate symbols that the user intended, then return those.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ErrorTypeSymbol.ResultKind">
	<summary>
 Return why the candidate symbols were bad.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CustomModifier.IsOptional">
	<summary>
 If true, a language may use the modified storage location without 
 being aware of the meaning of the modification, modopt vs. modreq. 
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CustomModifier.Modifier">
	<summary>
 A type used as a tag that indicates which type of modification applies.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.CustomModifier">
	<summary>
 Represents a custom modifier (modopt/modreq).
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Compilation.m_lazyAssemblySymbol">
	<summary>
 The SourceAssemblySymbol for this compilation. Do not access directly, use Assembly
 property instead. This field is lazily initialized by AssemblyManager,
 AssemblyManager.CacheLockObject must be locked while AssemblyManager "calculates" the
 value and assigns it, several threads must not perform duplicate "calculation"
 simultaneously.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.Compilation.m_References">
	<summary>
 The list of metadata references provided to Create method.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.Compilation.m_OutputName">
	<summary>
 The name passed to the constructor of the Compilation.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Compilation.m_Options">
	<summary>
 The options passed to the constructor of the Compilation
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Compilation.m_lazyReferencedAssembliesMap">
	<summary>
 A map from a metadata reference to an AssemblySymbol used for it.
 Do not access directly, use ReferencedAssembliesMap property instead. 
 This field is lazily initialized by AssemblyManager when it creates 
 SourceAssemblySymbol, AssemblyManager.CacheLockObject must be locked while 
 AssemblyManager "calculates" the value and assigns it, several threads
 must not perform duplicate "calculation" simultaneously.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.Compilation.m_lazyReferencedModulesMap">
	<summary>
 A map from a net-module metadata reference to a ModuleSymbol used for it.
 The ModuleSymbol is one of the modules contained in m_AssemblySymbol.Modules list.
 Do not access directly, use ReferencedModulesMap property instead. 
 This field is lazily initialized by AssemblyManager when it creates 
 SourceAssemblySymbol, AssemblyManager.CacheLockObject must be locked while 
 AssemblyManager "calculates" the value and assigns it, several threads
 must not perform duplicate "calculation" simultaneously.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.Compilation.m_lazyGlobalNamespace">
	<summary>
 The global namespace symbol. Lazily populated on first access.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Compilation.m_rootNamespaces">
	<summary>
 A map between syntax trees and the root declarations in the declaration table.
 Incrementally updated between compilation versions when source changes are made.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Compilation.m_lazyAssemblyManagerDiagnostics">
	<summary>
 reference through AssemblyManagerDiagnostics
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Compilation.m_declarationTable">
	<summary>
 The declaration table that holds onto declarations from source. Incrementally updated
 between compilation versions when source changes are made.
 </summary>
	<remarks></remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.Compilation.SyntaxTrees">
	<summary>
 Get a read-only list of the syntax trees that this compilation was created with.
 The ordering of the trees is arbitrary and may be different than the order the
 trees were supplied to the compilation.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Compilation.ContainsSyntaxTree(Roslyn.Compilers.VisualBasic.SyntaxTree)">
	<summary>
 Is the passed in syntax tree in this compilation?
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Compilation.References">
	<summary>
 Get a read-only list of the references that this compilation was created with.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Compilation.Name">
	<summary>
	</summary>
	<value></value>
	<returns>The assembly name of the compilation. This is commonly the name without the extension.</returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Compilation.GetReferencedAssemblySymbol(Roslyn.Compilers.MetadataReference)">
	<summary>
 Gets the AssemblySymbol that represents the assembly that was references with the given reference. If the reference
 was a Module reference, then this assembly is returned.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Compilation.GetReferencedModuleSymbol(Roslyn.Compilers.ModuleFileReference)">
	<summary>
 Gets the ModuleSymbol that represents an added metadata module.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Compilation.GetReferenceFromMetadataLocation(Roslyn.Compilers.VisualBasic.Location)">
	<summary>
 Given a location in metadata, gets the reference in this compilation that that metadata location
 refers to. 
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Compilation.Assembly">
	<summary>
 Gets the AssemblySymbol that represents the assembly being created.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Compilation.SourceModule">
	<summary>
 Get a ModuleSymbol that refers to the module being created by compiling all of the code. By
 getting the GlobalNamespace property of that module, all of the namespace and types defined in source code 
 can be obtained.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Compilation.GlobalNamespace">
	<summary>
 Gets the merged root namespace that contains all namespaces and types defined in source code or in 
 referenced metadata, merged into a single namespace hierarchy. This namespace hierarchy is how the compiler
 binds types that are referenced in code.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Compilation.GetCompilationNamespace(Roslyn.Compilers.Common.INamespaceSymbol)">
	<summary>
 Given a namespace symbol, returns the corresponding namespace symbol with Compilation extent
 that refers to that namespace in this compilation. Returns Nothing if there is no corresponding 
 namespace. This should not occur if the namespace symbol came from an assembly referenced by this
 compilation. 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Compilation.GetSemanticModel(Roslyn.Compilers.VisualBasic.SyntaxTree)">
	<summary> 
 Get a fresh bindings object.  Note that each invocation gets a fresh
 bindings object, each of which has a cache.  Therefore, one
 effectively clears the cache by discarding the bindings object.
</summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Compilation.GetDiagnostics(System.Threading.CancellationToken)">
	<summary>
 Get all diagnostics for the entire compilation. This includes diagnostics from parsing, declarations, and
 the bodies of methods. Getting all the diagnostics is potentially a length operations, as it requires parsing and
 compiling all the code. The set of diagnostics is not caches, so each call to this method will recompile all
 methods.
 </summary>
	<param name="cancellationToken">Cancellation token to allow cancelling the operation.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Compilation.GetDeclarationDiagnostics(System.Threading.CancellationToken)">
	<summary>
 Get parse and declarations diagnostics for the entire compilation. This includes diagnostics from parsing, declarations, BUT NOT
 the bodies of methods or initializers. The set of declaration diagnostics is cached, so calling this method a second time
 should be fast.
 </summary>
	<param name="cancellationToken">Cancellation token to allow cancelling the operation.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Compilation.GetDiagnostics(Roslyn.Compilers.VisualBasic.CompilationStage,System.Threading.CancellationToken)">
	<summary>
 Get all errors in the compilation, up through the given compilation stage. Note that this may
 require significant work by the compiler, as all source code must be compiled to the given
 level in order to get the errors. Errors on Options should be inspected by the user prior to constructing the compilation.
 </summary>
	<returns>
 Returns all errors. The errors are not sorted in any particular order, and the client
 should sort the errors as desired.
 </returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Compilation.Create(System.String,Roslyn.Compilers.VisualBasic.CompilationOptions,System.Collections.Generic.IEnumerable{Roslyn.Compilers.VisualBasic.SyntaxTree},System.Collections.Generic.IEnumerable{Roslyn.Compilers.MetadataReference})">
	<summary>
 Create a new compilation from scratch.
 </summary>
	<param name="outputName">The name of the compilation (filename and extension).</param>
	<param name="syntaxTrees">The syntax trees with the source code for the new compilation.</param>
	<param name="references">The references for the new compilation.</param>
	<param name="options">The compiler options to use.</param>
	<returns>A new compilation.</returns>
</member><member name="P:Roslyn.Compilers.VisualBasic.Compilation.ThisSymbolCache">
	<summary>
 Until binding deals with "Me" as a parameter symbol, we fake it using a map.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Compilation.GetSpecialType(Roslyn.Compilers.SpecialType)">
	<summary>
 Get symbol for predefined type from Cor Library referenced by this compilation.
 </summary>
	<param name="typeId"></param>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Compilation.GetTypeByMetadataName(System.String)">
	<summary>
 Lookup a type within the compilation's assembly and all referenced assemblies
 using its canonical CLR metadata name (names are compared case-sensitively).
 </summary>
	<param name="metadataName">
	</param>
	<returns>
 Symbol for the type or null if type cannot be found or is ambiguous. 
 </returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Compilation.CreateDefaultWin32Resources(System.Boolean,System.Boolean,System.IO.Stream,System.IO.Stream)">
	<summary>
 Create a stream filled with default win32 resources.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Compilation.Emit(System.IO.Stream,System.String,System.IO.Stream,System.IO.Stream,System.Threading.CancellationToken,System.Func{System.String,System.IO.Stream},System.IO.Stream,System.Collections.Generic.IEnumerable{Roslyn.Compilers.ResourceDescription})">
	<summary>
 Attempts to emit the assembly to the given stream. If there are 
 compilation errors, false is returned. In this case, some bytes 
 might have been written to the stream. The compilation errors can be
 obtained by called GetDiagnostics(CompilationStage.Emit). If true is 
 returned, the compilation proceeded without error and a valid 
 assembly was written to the stream.
 </summary>
	<returns>True if the compilation proceeded without error and a new assembly was created. False if compilation errors occurred.
 </returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Compilation.Emit(System.IO.Stream,System.String,System.IO.Stream,System.IO.Stream,System.Threading.CancellationToken,System.Func{System.String,System.IO.Stream},System.IO.Stream,System.Collections.Generic.IEnumerable{Roslyn.Compilers.ResourceDescription},Roslyn.Compilers.CodeGen.CompilationTestData)">
	<summary>
 This overload is only intended to be directly called by tests that want to pass an ilBuilderMap.
 The map is used for storing a list of methods and their associated IL.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Compilation.EmitMetadataOnly(System.IO.Stream,System.IO.Stream,System.Threading.CancellationToken,System.Func{System.String,System.IO.Stream})">
	<summary>
 Attempts to emit just the metadata parts of the compilation, without compiling any executable code 
 (method bodies). No debug info can be produced.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Compilation.Clone">
	<summary>
 Create a duplicate of this compilation with different symbol instances
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Compilation.ClassifyConversion(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 Determine what kind of conversion, if any, there is between the types 
 "source" and "destination".
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Compilation">
	<summary>
 The Compilation object is an immutable representation of a single invocation of the
 compiler. Although immutable, a Compilation is also on-demand, in that a compilation can be
 created quickly, but will that compiler parts or all of the code in order to respond to
 method or properties. Also, a compilation can produce a new compilation with a small change
 from the current compilation. This is, in many cases, more efficient than creating a new
 compilation from scratch, as the new compilation can share information from the old
 compilation.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.CompilationStage">
	<summary>
 Represents the possible compilation stages for which it is possible to get diagnostics (errors).
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.AssemblySymbol.m_CorLibrary">
	<summary>
 The system assembly, which provides primitive types like Object, String, etc., think mscorlib.dll. 
 The value is provided by AssemblyManager and must not be modified. For SourceAssemblySymbol, non-missing 
 coreLibrary must match one of the referenced assemblies returned by GetReferencedAssemblySymbols() method of 
 the main module. If there is no existing assembly that can be used as a source for the primitive types, 
 the value is a Compilation.MissingCorLibrary. 
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AssemblySymbol.CorLibrary">
	<summary>
 The system assembly, which provides primitive types like Object, String, etc., think mscorlib.dll. 
 The value is a MissingAssemblySymbol if none of the referenced assemblies can be used as a source for the 
 primitive types and the owning assembly cannot be used as the source too. Otherwise, it is one of 
 the referenced assemblies returned by GetReferencedAssemblySymbols() method or the owning assembly.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AssemblySymbol.SetCorLibrary(Roslyn.Compilers.VisualBasic.AssemblySymbol)">
	<summary>
 A helper method for AssemblyManager to set the system assembly, which provides primitive 
 types like Object, String, etc., think mscorlib.dll. 
 </summary>
	<param name="corLibrary"></param>
</member><member name="P:Roslyn.Compilers.VisualBasic.AssemblySymbol.BaseName">
	<summary>
 Get the base name of the assembly. This is equivalent to AssemblyName.Name, but may be 
 much faster to retrieve for source code assemblies, since it does not require binding the assembly-level
 attributes that contain the version number and other assembly information.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AssemblySymbol.IsInteractive">
	<summary>
 True if the assembly contains interactive code.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AssemblySymbol.AssemblyName">
	<summary>
 Get the name of this assembly.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AssemblySymbol.Modules">
	<summary>
 Gets a read-only list of all the modules in this assembly. (There must be at least one.) The first one is the main module
 that holds the assembly manifest.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AssemblySymbol.GlobalNamespace">
	<summary>
 Gets the merged root namespace that contains all namespaces and types defined in the modules
 of this assembly. If there is just one module in this assembly, this property just returns the 
 GlobalNamespace of that module.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AssemblySymbol.IsMissing">
	<summary>
 Does this symbol represent a missing assembly.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AssemblySymbol.LookupTopLevelMetadataType(System.String,System.Int32)">
	<summary>
 Lookup a top level type referenced from metadata, names should be
 compared case-sensitively.
 </summary>
	<param name="emittedName">
 Full type name with generic name mangling.
 </param>
	<param name="arity"></param>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.AssemblySymbol.LookupForwardedMetadataType(System.String,System.Int32)">
	<summary>
 Lookup type among forwarded types.
 </summary>
	<param name="emittedName"></param>
	<param name="arity"></param>
	<returns>
 Symbol for forwarded type or Nothing if type is not one of forwarded types.
 </returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.AssemblySymbol.GetDeclaredSpecialType(Roslyn.Compilers.SpecialType)">
	<summary>
 Lookup declaration for predefined CorLib type in this Assembly. Only valid if this 
 assembly is the Cor Library
 </summary>
	<param name="type"></param>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.AssemblySymbol.RegisterDeclaredSpecialType(Roslyn.Compilers.VisualBasic.NamedTypeSymbol)">
	<summary>
 Register declaration of predefined CorLib type in this Assembly.
 </summary>
	<param name="corType"></param>
</member><member name="P:Roslyn.Compilers.VisualBasic.AssemblySymbol.KeepLookingForDeclaredSpecialTypes">
	<summary>
 Continue looking for declaration of predefined CorLib type in this Assembly
 while symbols for new type declarations are constructed.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AssemblySymbol.GetNoPiaResolutionAssemblies">
	<summary>
 Return an array of assemblies involved in canonical type resolution of
 NoPia local types defined within this assembly. In other words, all 
 references used by previous compilation referencing this assembly.
 </summary>
	<returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.AssemblySymbol.GetLinkedReferencedAssemblies">
	<summary>
 Return an array of assemblies referenced by this assembly, which are linked (/l-ed) by 
 each compilation that is using this AssemblySymbol as a reference. 
 If this AssemblySymbol is linked too, it will be in this array too.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AssemblySymbol.IsLinked">
	<summary>
 Assembly is /l-ed by compilation that is using it as a reference.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AssemblySymbol.GetSpecialType(Roslyn.Compilers.SpecialType)">
	<summary>
 Get symbol for predefined type from Cor Library used by this assembly.
 </summary>
	<param name="type"></param>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.AssemblySymbol.GetPrimitiveType(Microsoft.Cci.PrimitiveTypeCode)">
	<summary>
 Get symbol for predefined type from Cor Library used by this assembly.
 </summary>
	<param name="type"></param>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.AssemblySymbol.GetTypeByMetadataName(System.String)">
	<summary>
 Lookup a type within the assembly using its canonical CLR metadata name (names are compared case-sensitively).
 </summary>
	<param name="metadataName">
	</param>
	<returns>
 Symbol for the type or null if type cannot be found or is ambiguous. 
 </returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.AssemblySymbol.GetTypeByMetadataName(System.String,System.Boolean)">
	<summary>
 Lookup a type within the assembly using its canonical CLR metadata name (names are compared case-sensitively).
 </summary>
	<param name="metadataName"></param>
	<param name="includeReferences">
 If search within assembly fails, lookup in assemblies referenced by the primary module.
 For source assembly, this is equivalent to all assembly references given to compilation.
 </param>
	<returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.AssemblySymbol.GetTopLevelTypeByMetadataName(System.String,System.Boolean)">
	<summary>
 Lookup a top level type within the assembly or one of the assemblies reeferenced by the primary module, 
 names are compared case-sensitively. In case of ambiguity, type from this assembly wins,
 otherwise Nothing is returned.
 </summary>
	<returns>
 Symbol for the type or Nothing if type cannot be found or ambiguous. 
 </returns>
</member><member name="T:Roslyn.Compilers.VisualBasic.AssemblySymbol">
	<summary>
 Represents a .NET assembly. An assembly consists of one or more modules.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Compilation.m_OtherAssemblySymbols">
	<summary>
 The list of RetargetingAssemblySymbol objects created for this Compilation. 
 RetargetingAssemblySymbols are created when some other compilation references this one, 
 but the other references provided are incompatible with it. For example, compilation C1 
 references v1 of Lib.dll and compilation C2 references C1 and v2 of Lib.dll. In this case, 
 in context of C2, all types from v1 of Lib.dll leaking through C1 (through method 
 signatures, etc.) must be retargeted to the types from v2 of Lib.dll. This is what 
 RetargetingAssemblySymbol is responsible for. In the example above, modules in C2 do not 
 reference C1.m_AssemblySymbol, but reference a special RetargetingAssemblySymbol created for 
 C1 by AssemblyManager.
 
 WeakReference is used to allow RetargetingAssemblySymbols to be collected when they become unused.
 
 The cache must be locked for the duration of read/write operations, 
 see AssemblyManager.CacheLockObject property.
  
 Friend accessibility is for test purpose only.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.Compilation.MissingCorLibrary">
	<summary>
 AssemblySymbol to represent missing, for whatever reason, CorLibrary.
 The symbol is created by AssemblyManager on as needed basis and is shared by all compilations
 with missing CorLibraries.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Compilation.AssemblyManager.#ctor">
	<summary>
 This is a shared class, no instances should be created.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.Compilation.AssemblyManager.CompilationsToCompact">
	<summary>
 List of compilations that should be compacted.
 
 The cache must be locked for the duration of read/write operations, 
 see AssemblyManager.CacheLockObject property.
 
 Internal accessibility is for test purpose only.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Compilation.AssemblyManager.CompactTimerIsOn">
	<summary>
 For test purposes.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Compilation.AssemblyManager.CompactCacheOfRetargetingAssemblies">
	<summary>
 Called by compactTimer.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Compilation.AssemblyManager.LockAndCleanCaches">
	<summary>
 Lock and clean global Metadata caches, meant to be used for test purpose only.
 </summary>
	<remarks></remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.Compilation.AssemblyManager.CacheLockObject">
	<summary>
 The object that must be locked for the duration of read/write operations on AssemblyManager's caches.
 </summary>
	<value></value>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Compilation.AssemblyManager.IsSourceAssemblySymbolCreated(Roslyn.Compilers.VisualBasic.Compilation)">
	<summary>
 For testing purposes only.
 </summary>
	<param name="compilation"></param>
	<returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Compilation.AssemblyManager.IsReferencedAssembliesMapCreated(Roslyn.Compilers.VisualBasic.Compilation)">
	<summary>
 For testing purposes only.
 </summary>
	<param name="compilation"></param>
	<returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Compilation.AssemblyManager.IsReferencedModulesMapCreated(Roslyn.Compilers.VisualBasic.Compilation)">
	<summary>
 For testing purposes only.
 </summary>
	<param name="compilation"></param>
	<returns></returns>
</member><member name="T:Roslyn.Compilers.VisualBasic.Compilation.AssemblyManager">
	<summary>
 AssemblyManager encapsulates functionality to create an underlying SourceAssemblySymbol 
 (with underlying ModuleSymbols) for Compilation and AssemblySymbols for referenced assemblies 
 (with underlying ModuleSymbols) all properly linked together based on reference resolution 
 between them.
 
 AssemblyManager is also responsible for reuse of metadata readers for imported modules and 
 assemblies as well as existing AssemblySymbols for referenced assemblies. In order to do that, 
 it maintains global cache for metadata readers and AssemblySymbols associated with them. 
 The cache uses WeakReferences to refer to the metadata readers and AssemblySymbols to allow 
 memory and resources being reclaimed once they are no longer used. The tricky part about reusing 
 existing AssemblySymbols is to find a set of AssemblySymbols that are created for the referenced 
 assemblies, which (the AssemblySymbols from the set) are linked in a way, consistent with the 
 reference resolution between the referenced assemblies.
 
 When existing Compilation is used as a metadata reference, there are scenarios when its underlying 
 SourceAssemblySymbol cannot be used to provide symbols in context of the new Compilation. Consider 
 classic multi-targeting scenario: compilation C1 references v1 of Lib.dll and compilation C2 
 references C1 and v2 of Lib.dll. In this case, SourceAssemblySymbol for C1 is linked to AssemblySymbol 
 for v1 of Lib.dll. However, given the set of references for C2, the same reference for C1 should be 
 resolved against v2 of Lib.dll. In other words, in context of C2, all types from v1 of Lib.dll 
 leaking through C1 (through method signatures, etc.) must be retargeted to the types from v2 of Lib.dll.
 In this case, AssemblyManager creates a special RetargetingAssemblySymbol for C1, which is responsible 
 for the type retargeting. The RetargetingAssemblySymbols could also be reused for different 
 Compilations, AssemblyManager maintains a cache of RetargetingAssemblySymbols (WeakReferences) for each 
 Compilation.
 
 The only public entry point of this class is CreateSourceAssembly() method.
 
 TODO: Comment on CorLibrary.
 </summary>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ArrayTypeSymbol.#ctor(Roslyn.Compilers.VisualBasic.TypeSymbol,System.Collections.Generic.List{Roslyn.Compilers.MetadataReader.MetadataDecoder{Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.MethodSymbol,Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.TypedConstant}.ModifierInfo},Roslyn.Compilers.VisualBasic.AssemblySymbol)">
	<summary>
 Create a new ArrayTypeSymbol.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ArrayTypeSymbol.#ctor(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.CustomModifier},System.Int32,Roslyn.Compilers.VisualBasic.Compilation)">
	<summary>
 Create a new ArrayTypeSymbol.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ArrayTypeSymbol.#ctor(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.CustomModifier},System.Int32,Roslyn.Compilers.VisualBasic.AssemblySymbol)">
	<summary>
 Create a new ArrayTypeSymbol.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ArrayTypeSymbol.#ctor(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.CustomModifier},System.Int32,Roslyn.Compilers.VisualBasic.NamedTypeSymbol,Roslyn.Compilers.VisualBasic.NamedTypeSymbol)">
	<summary>
 Create a new ArrayTypeSymbol.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ArrayTypeSymbol.#ctor(Roslyn.Compilers.VisualBasic.TypeSymbol,System.Int32,Roslyn.Compilers.VisualBasic.NamedTypeSymbol,Roslyn.Compilers.VisualBasic.NamedTypeSymbol)">
	<summary>
 Create a new ArrayTypeSymbol.
 </summary>
	<param name="elementType">The element type of this array type.</param>
	<param name="rank">The rank of this array type.</param>
	<param name="systemArray">Symbol for Syste.Array</param>
	<param name="iListOfT">Symbol for IList(Of T), can be Nothing for rank &gt; 1.</param>
</member><member name="P:Roslyn.Compilers.VisualBasic.ArrayTypeSymbol.CustomModifiers">
	<summary>
 The list of custom modifiers, if any, associated with the array.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ArrayTypeSymbol.Rank">
	<summary>
 Gets the number of dimensions of this array. A regular single-dimensional array
 has rank 1, a two-dimensional array has rank 2, etc.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ArrayTypeSymbol.ElementType">
	<summary>
 Gets the type of the elements that are stored in this array.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ArrayTypeSymbol.InternalSubstituteTypeParameters(Roslyn.Compilers.VisualBasic.TypeSubstitution)">
	<summary>
 Substitute the given type substitution within this type, returning a new type. If the
 substitution had no effect, return Me. 
 !!! Only code implementing construction of generic types is allowed to call this method !!!
 !!! All other code should use Construct methods.                                        !!! 
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.ArrayTypeSymbol">
	<summary>
 An ArrayTypeSymbol represents an array type, such as Integer() or Object(,).
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.StatementSyntaxWalker">
	<summary>
 This class walks all the statements in some syntax, in order, except those statements that are contained
 inside expressions (a statement can occur inside an expression if it is inside
 a lambda.)
 
 This is used when collecting the declarations and declaration spaces of a method body.
 
 Typically the client overrides this class and overrides various Visit methods, being sure to always
 delegate back to the base.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LocalSymbol.#ctor(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ModifiedIdentifierSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax,Roslyn.Compilers.VisualBasic.EqualsValueSyntax,Roslyn.Compilers.VisualBasic.LocalSymbol.LocalDeclarationKind,Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 Create a local variable symbol. Note: this does not insert it automatically into a
 local binder so that it can be found by lookup.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.LocalSymbol.IsReadOnly">
	<summary>
 Returns true if this local is a ReadOnly local. Compiler has a concept of ReadOnly locals.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.LocalSymbol">
	<summary>
 Represents a local variable (typically inside a method body). This could also be a local variable implicitly
 declared by a For, Using, etc. When used as a temporary variable, its container can also be a Field or Property Symbol.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.LambdaSymbol.ReturnTypeIsBeingInferred">
	<summary>
 This symbol is used as the return type of a LambdaSymbol when we are interpreting 
 lambda's body in order to infer its return type.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.LambdaSymbol.ReturnTypeIsUnknown">
	<summary>
 This symbol is used as the return type of a LambdaSymbol when we failed to 
 infer lambda's return type, but still want to interpret its body.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.LambdaSymbol.MeParameter">
	<summary>
 "Me" parameter for this lambda will be that of the containing symbol
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.LambdaSymbol">
	<summary>
 Represents a method symbol for a lambda method.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.LambdaParameterSymbol">
	<summary>
 Represents a Lambda parameter.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ImplementsHelper.ComputeImplementationForInterfaceMember``1(``0,Roslyn.Compilers.VisualBasic.TypeSymbol,System.Collections.Generic.IEqualityComparer{``0})">
	<summary>
 Performs interface mapping to determine which symbol in this type or a base type
 actually implements a particular interface member.
 </summary>
	<typeparam name="TSymbol">MethodSymbol or PropertySymbol or EventSymbol (an interface member).</typeparam>
	<param name="interfaceMember">A non-null member on an interface type.</param>
	<param name="implementingType">The type implementing the interface member.</param>
	<param name="comparer">A comparer for comparing signatures of TSymbol according to metadata implementation rules.</param>
	<returns>The implementing member or Nothing, if there isn't one.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.ImplementsHelper.FindImplicitImplementationDeclaredInType``1(``0,Roslyn.Compilers.VisualBasic.TypeSymbol,System.Collections.Generic.IEqualityComparer{``0})">
	<summary>
 Search the declared methods of a type for one that could be an implicit implementation
 of a given interface method (depending on interface declarations). It is assumed that the implementing
 type is not a source type.
 </summary>
	<typeparam name="TSymbol">MethodSymbol or PropertySymbol or EventSymbol (an interface member).</typeparam>
	<param name="interfaceMember">The interface member being implemented.</param>
	<param name="currType">The type on which we are looking for a declared implementation of the interface method.</param>
	<param name="comparer">A comparer for comparing signatures of TSymbol according to metadata implementation rules.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.ImplementsHelper.SubstituteExplicitInterfaceImplementations``1(Roslyn.Compilers.ReadOnlyArray{``0},Roslyn.Compilers.VisualBasic.TypeSubstitution)">
	<summary>
 Given a set of explicit interface implementations that are undergoing substitution, return the substituted versions.
 </summary>
	<typeparam name="TSymbol">Type of the interface members (Method, Property, Event)</typeparam>
	<param name="unsubstitutedImplementations">The ROA of members that are being implemented</param>
	<param name="substitution">The type substitution</param>
	<returns>The substituted members.</returns>
</member><member name="T:Roslyn.Compilers.VisualBasic.ImplementsHelper">
	<summary>
 Methods, Properties, and Events all have implements clauses and need to handle interface
 implementation. This module has helper methods and extensions for sharing by multiple
 symbol types.
 </summary>
	<remarks></remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.BoundLambdaParameterSymbol">
	<summary>
 Represents a Lambda parameter for a LambdaSymbol.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingTypeParameterSymbol.m_RetargetingModule">
	<summary>
 Owning RetargetingModuleSymbol.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingTypeParameterSymbol.m_UnderlyingTypeParameter">
	<summary>
 The underlying TypeParameterSymbol, cannot be another RetargetingTypeParameterSymbol.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingTypeParameterSymbol">
	<summary>
 Represents a type parameter in a RetargetingModuleSymbol. Essentially this is a wrapper around 
 another TypeParameterSymbol that is responsible for retargeting symbols from one assembly to another. 
 It can retarget symbols for multiple assemblies at the same time.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingPropertySymbol.m_RetargetingModule">
	<summary>
 Owning RetargetingModuleSymbol.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingPropertySymbol.m_UnderlyingProperty">
	<summary>
 The underlying PropertySymbol, cannot be another RetargetingPropertySymbol.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingParameterSymbol.m_UnderlyingParameter">
	<summary>
 The underlying ParameterSymbol, cannot be another RetargetingParameterSymbol.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingParameterSymbol.RetargetingMethodParameterSymbol.m_RetargetingMethod">
	<summary>
 Owning RetargetingMethodSymbol.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingParameterSymbol.RetargetingPropertyParameterSymbol.m_RetargetingProperty">
	<summary>
 Owning RetargetingPropertySymbol.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingParameterSymbol">
	<summary>
 Represents a parameter of a RetargetingMethodSymbol. Essentially this is a wrapper around 
 another ParameterSymbol that is responsible for retargeting symbols from one assembly to another. 
 It can retarget symbols for multiple assemblies at the same time.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingNamespaceSymbol.m_RetargetingModule">
	<summary>
 Owning RetargetingModuleSymbol.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingNamespaceSymbol.m_UnderlyingNamespace">
	<summary>
 The underlying NamespaceSymbol, cannot be another RetargetingNamespaceSymbol.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingNamespaceSymbol.GetDeclaredAccessibilityOfMostAccessibleDescendantType">
	<summary>
 Calculate declared accessibility of most accessible type within this namespace or within a containing namespace recursively.
 Expected to be called at most once per namespace symbol, unless there is a race condition.
 
 Valid return values:
     Friend,
     Public,
     NotApplicable - if there are no types.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingNamespaceSymbol">
	<summary>
 Represents a namespace of a RetargetingModuleSymbol. Essentially this is a wrapper around 
 another NamespaceSymbol that is responsible for retargeting symbols from one assembly to another. 
 It can retarget symbols for multiple assemblies at the same time.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingNamedTypeSymbol.m_RetargetingModule">
	<summary>
 Owning RetargetingModuleSymbol.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingNamedTypeSymbol.m_UnderlyingType">
	<summary>
 The underlying NamedTypeSymbol, cannot be another RetargetingNamedTypeSymbol.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingNamedTypeSymbol">
	<summary>
 Represents a type of a RetargetingModuleSymbol. Essentially this is a wrapper around 
 another NamedTypeSymbol that is responsible for retargeting referenced symbols from one assembly to another. 
 It can retarget symbols for multiple assemblies at the same time.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingMethodSymbol.m_RetargetingModule">
	<summary>
 Owning RetargetingModuleSymbol.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingMethodSymbol.m_UnderlyingMethod">
	<summary>
 The underlying MethodSymbol, cannot be another RetargetingMethodSymbol.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingMethodSymbol">
	<summary>
 Represents a method in a RetargetingModuleSymbol. Essentially this is a wrapper around 
 another MethodSymbol that is responsible for retargeting symbols from one assembly to another. 
 It can retarget symbols for multiple assemblies at the same time.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingFieldSymbol.m_RetargetingModule">
	<summary>
 Owning RetargetingModuleSymbol.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingFieldSymbol.m_UnderlyingField">
	<summary>
 The underlying FieldSymbol, cannot be another RetargetingFieldSymbol.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingFieldSymbol">
	<summary>
 Represents a field in a RetargetingModuleSymbol. Essentially this is a wrapper around 
 another FieldSymbol that is responsible for retargeting symbols from one assembly to another. 
 It can retarget symbols for multiple assemblies at the same time.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.PropertySignatureComparer.ExplicitPropertyImplementationComparer">
	<summary>
 This instance is used when trying to determine which implemented interface property is implemented
 by a property with an Implements clause, according to VB rules.
 The property signatures are compared without regard to name (including the interface part, if any)
 and the return types must match.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.PropertySignatureComparer.OverrideSignatureComparer">
	<summary>
 This instance is used to check whether one property overrides another, according to the VB definition.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.PropertySignatureComparer.AllAspectsSignatureComparer">
	<summary>
 This instance is used to compare all aspects.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.PropertySignatureComparer.RuntimePropertySignatureComparer">
	<summary>
 This instance is intended to reflect the definition of signature equality used by the runtime (ECMA 335 Section 8.6.1.6).
 It considers type, name, parameters, and custom modifiers.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.PropertySignatureComparer">
	<summary>
 Implementation of IEqualityComparer for PropertySymbols, with options for various aspects
 to compare.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.PEOrSourceOrMergedNamespaceSymbol.DeclaredAccessibilityOfMostAccessibleDescendantType">
	<summary>
 Returns declared accessibility of most accessible type within this namespace or within a containing namespace recursively.
 Valid return values:
     Friend,
     Public,
     NotApplicable - if there are no types.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.PEOrSourceOrMergedNamespaceSymbol">
	<summary>
 Represents a namespace.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.OverriddenMembersResult`1">
	<summary>
 Groups the information computed by MakeOverriddenMembers.
 </summary>
	<remarks>
 In C# this class also stores hidden members (and is named OverriddenOrHiddenMembersResult). 
 The way VB warns on hidden members, this did not turn out to be useful.
 </remarks>
	<typeparam name="TSymbol">Expected to be a member symbol type (e.g. method, property).</typeparam>
</member><member name="T:Roslyn.Compilers.VisualBasic.NoPiaMissingCanonicalTypeSymbol">
	<summary>
 A NoPiaMissingCanonicalTypeSymbol is a special kind of ErrorSymbol that represents
 a NoPia embedded type symbol that was attempted to be substituted with canonical type, 
 but the canonocal type couldn't be found.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.NoPiaIllegalGenericInstantiationSymbol">
	<summary>
 A NoPiaIllegalGenericInstantiationSymbol is a special kind of ErrorSymbol that represents
 a generic type instantiation that cannot cross assembly boundaries according to NoPia rules.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.NoPiaAmbiguousCanonicalTypeSymbol">
	<summary>
 A NoPiaAmbiguousCanonicalTypeSymbol is a special kind of ErrorSymbol that represents
 a NoPia embedded type symbol that was attempted to be substituted with canonical type, 
 but the canonocal type was ambiguous.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.NonMissingModuleSymbol.m_ReferencedAssemblySymbols">
	<summary>
 An array of AssemblySymbol objects corresponding to assemblies referenced by this module.
 The array and its content is provided by AssemblyManager and must not be modified.
 Items at the same position from this array and from GetReferencedAssemblySymbols should 
 correspond to each other. If reference is not resolved by compiler, corresponding item in 
 this array contains MissingAssemblySymbol.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.NonMissingModuleSymbol.m_ReferencedAssemblies">
	<summary>
 An array of assembly identities for assemblies referenced by this module.
 The array and its content is provided by AssemblyManager and must not be modified.
 Items at the same position from this array and from ModuleSymbol.m_ReferencedAssemblySymbols
 should correspond to each other. This array is returned by GetReferencedAssemblies() method.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NonMissingModuleSymbol.IsMissing">
	<summary>
 Does this symbol represent a missing Module.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NonMissingModuleSymbol.GetReferencedAssemblies">
	<summary>
 Returns an array of assembly identities for assemblies referenced by this module.
 Items at the same position from GetReferencedAssemblies and from GetReferencedAssemblySymbols 
 should correspond to each other.
 
 The array and its content is provided by AssemblyManager and must not be modified.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NonMissingModuleSymbol.GetReferencedAssemblySymbols">
	<summary>
 Returns an array of AssemblySymbol objects corresponding to assemblies referenced 
 by this module. Items at the same position from GetReferencedAssemblies and 
 from GetReferencedAssemblySymbols should correspond to each other. If reference is 
 not resolved by compiler, GetReferencedAssemblySymbols returns MissingAssemblySymbol in the
 correspnding item.
 
 The array and its content is provided by AssemblyManager and must not be modified.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NonMissingModuleSymbol.SetReferences(Roslyn.Compilers.ReadOnlyArray{System.Reflection.AssemblyName},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.AssemblySymbol})">
	<summary>
 A helper method for AssemblyManager to set assembly identities for assemblies 
 referenced by this module and corresponding AssemblySymbols.
 </summary>
	<param name="names"></param>
	<param name="symbols"></param>
</member><member name="M:Roslyn.Compilers.VisualBasic.NonMissingModuleSymbol.LookupTopLevelMetadataType(System.String,System.Int32)">
	<summary>
 Lookup a top level type referenced from metadata, names should be
 compared case-sensitively.
 </summary>
	<param name="actualName">
 Full type name with generic name mangling removed.
 </param>
	<param name="arity">
 Type's arity.
 </param>
	<returns>
 Symbol for the type, or MissingMetadataSymbol if the type isn't found.
 </returns>
	<remarks></remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.NonMissingModuleSymbol">
	<summary>
 A <see cref="T:Roslyn.Compilers.VisualBasic.NonMissingModuleSymbol"/> is a special kind of <see cref="T:Roslyn.Compilers.VisualBasic.ModuleSymbol"/> that represents
 a module that is not missing, i.e. the "real" thing.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.NonMissingAssemblySymbol.m_EmittedNameToTypeMap">
	<summary>
 This is a cache similar to the one used by MetaImport::GetTypeByName
 in native compiler. The difference is that native compiler pre-populates 
 the cache when it loads types. Here we are populating the cache only
 with things we looked for, so that next time we are looking for the same 
 thing, the lookup is fast. This cache also takes care of TypeForwarders. 
 Gives about 8% win on subsequent lookups in some scenarios.     
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.NonMissingAssemblySymbol.m_lazyGlobalNamespace">
	<summary>
 The global namespace symbol. Lazily populated on first access.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NonMissingAssemblySymbol.IsMissing">
	<summary>
 Does this symbol represent a missing assembly.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NonMissingAssemblySymbol.GlobalNamespace">
	<summary>
 Gets the merged root namespace that contains all namespaces and types defined in the modules
 of this assembly. If there is just one module in this assembly, this property just returns the 
 GlobalNamespace of that module.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NonMissingAssemblySymbol.LookupTopLevelMetadataType(System.String,System.Int32)">
	<summary>
 Lookup a top level type referenced from metadata, names should be
 compared case-sensitively.
 </summary>
	<param name="emittedName">
 Full type name with generic name mangling.
 </param>
	<param name="arity"></param>
	<returns></returns>
	<remarks></remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.NonMissingAssemblySymbol">
	<summary>
 A <see cref="T:Roslyn.Compilers.VisualBasic.NonMissingAssemblySymbol"/> is a special kind of <see cref="T:Roslyn.Compilers.VisualBasic.AssemblySymbol"/> that represents
 an assembly that is not missing, i.e. the "real" thing.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamespaceExtent.Kind">
	<summary>
 Returns what kind of extent: Module, Assembly, or Compilation.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamespaceExtent.Module">
	<summary>
 If the Kind is ExtendKind.Module, returns the module symbol that this namespace
 encompasses. Otherwise throws InvalidOperationException.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamespaceExtent.Assembly">
	<summary>
 If the Kind is ExtendKind.Assembly, returns the aseembly symbol that this namespace
 encompasses. Otherwise throws InvalidOperationException.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamespaceExtent.Compilation">
	<summary>
 If the Kind is ExtendKind.Compilation, returns the compilation symbol that this namespace
 encompasses. Otherwise throws InvalidOperationException.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamespaceExtent.#ctor(Roslyn.Compilers.VisualBasic.ModuleSymbol)">
	<summary>
 Create a NamespaceExtent that represents a given ModuleSymbol.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamespaceExtent.#ctor(Roslyn.Compilers.VisualBasic.AssemblySymbol)">
	<summary>
 Create a NamespaceExtent that represents a given AssemblySymbol.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamespaceExtent.#ctor(Roslyn.Compilers.VisualBasic.Compilation)">
	<summary>
 Create a NamespaceExtent that represents a given Compilation.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.NamespaceExtent">
	<summary>
 A NamespaceExtent represents whether a namespace contains types and sub-namespaces from a particular module,
 assembly, or merged across all modules (source and metadata) in a particular compilation.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.NamespaceExtent.ExtentKind">
	<summary>
 Describes the kind of the namespace extent.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedTypeSymbolExtensions.IsOrInGenericType(Roslyn.Compilers.VisualBasic.NamedTypeSymbol)">
	<summary>
 Safe to call on a null reference.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.MissingNamespaceSymbol">
	<summary>
 A <see cref="T:Roslyn.Compilers.VisualBasic.MissingNamespaceSymbol"/> is a special kind of <see cref="T:Roslyn.Compilers.VisualBasic.NamespaceSymbol"/> that represents
 a namespace that couldn't be found.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.MissingModuleSymbol">
	<summary>
 A <see cref="T:Roslyn.Compilers.VisualBasic.MissingModuleSymbol"/> is a special kind of <see cref="T:Roslyn.Compilers.VisualBasic.ModuleSymbol"/> that represents
 a module that couldn't be found.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.MissingAssemblySymbol">
	<summary>
 A <see cref="T:Roslyn.Compilers.VisualBasic.MissingAssemblySymbol"/> is a special kind of <see cref="T:Roslyn.Compilers.VisualBasic.AssemblySymbol"/> that represents
 an assembly that couldn't be found.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.MissingCorLibrarySymbol.m_LazySpecialTypes">
	<summary>
 An array of cached Cor types defined in this assembly.
 Lazily filled by GetDeclaredSpecialType method.
 </summary>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.MissingCorLibrarySymbol.GetDeclaredSpecialType(Roslyn.Compilers.SpecialType)">
	<summary>
 Lookup declaration for predefined CorLib type in this Assembly. Only should be
 called if it is know that this is the Cor Library (mscorlib).
 </summary>
	<param name="type"></param>
</member><member name="T:Roslyn.Compilers.VisualBasic.MissingCorLibrarySymbol">
	<summary>
 AssemblySymbol to represent missing, for whatever reason, CorLibrary.
 The symbol is created by AssemblyManager on as needed basis and is shared by all compilations
 with missing CorLibraries.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.MethodSignatureComparer.ExplicitMethodImplementationComparer">
	<summary>
 This instance is used when trying to determine which implemented interface method is implemented
 by a method with an Implements clause, according to VB rules.
 The method signatures are compared without regard to name (including the interface part, if any)
 and the return types must match.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.MethodSignatureComparer.OverrideSignatureComparer">
	<summary>
 This instance is used to check whether one method matches another for overriding, according to the VB definition.
 Its possible for methods to match, but still not be considered eligible for overriding.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.MethodSignatureComparer.RuntimeMethodSignatureComparer">
	<summary>
 This instance is intended to reflect the definition of signature equality used by the runtime (ECMA 335 Section 8.6.1.6).
 It considers return type, name, parameters, calling convention, and custom modifiers.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.MethodSignatureComparer.AllAspectsSignatureComparer">
	<summary>
 This instance is used to compare all aspects.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.MethodSignatureComparer.DuplicateSourceMethodComparer">
	<summary>
 This instance is used to determine if two VisualBasic methods declared in source have
 the same signature. Names, arities, parameter types are
 considered. ByRef, optional parameters, return types, type parameter contraints, custom modifiers, etc are ignored.
 </summary>
	<remarks>
 This does the same comparison that MethodSignature used to do.
 </remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.MethodSignatureComparer.VisualBasicSignatureAndConstraintsAndReturnTypeComparer">
	<summary>
 This instance is used to search for methods that have the same signature, return type,
 and constraints according to the VisualBasic definition.  Custom modifiers are ignored.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.MethodSignatureComparer">
	<summary>
 Implementation of IEqualityComparer for MethodSymbols, with options for various aspects
 to compare.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.MethodKind.Ordinary">
	<summary>
 A normal method.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.MethodKind.Constructor">
	<summary>
 An instance constructor. The return type is always void.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.MethodKind.SharedConstructor">
	<summary>
 A shared constructor. The return type is always void.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.MethodKind.DelegateInvoke">
	<summary>
 The invoke method of a delegate.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.MethodKind.Operator">
	<summary>
 A user-defined operator.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.MethodKind.Conversion">
	<summary>
 A user-defined conversion.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.MethodKind.PropertyGet">
	<summary>
 The implicitly-defined get method associated with a property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.MethodKind.PropertySet">
	<summary>
 The implicitly-defined set method associated with a property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.MethodKind.EventAdd">
	<summary>
 The implicitly-defined add method associated with an event.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.MethodKind.EventRemove">
	<summary>
 The implicitly-defined remove method associated with an event.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.MethodKind.EventRaise">
	<summary>
 The implicitly-defined raise method associated with an event.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.MethodKind.LambdaMethod">
	<summary>
 A method symbol for a lambda expression.
 </summary>
	<remarks></remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.Metadata.PE.PEPropertySymbol">
	<summary>
 The class to represent all properties imported from a PE/module.
 </summary>
	<remarks></remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.Metadata.PE.PEAttributeData.AttributeClass">
	<summary>
 The attribute class.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Metadata.PE.PEAttributeData.AttributeConstructor">
	<summary>
 The constructor on the attribute class.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Metadata.PE.PEAttributeData.PositionalArguments">
	<summary>
 Positional (constructor) arguments on the attribute.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Metadata.PE.PEAttributeData.NamedArguments">
	<summary>
 Named (property value) arguments on the attribute. 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Metadata.PE.PEAttributeData.IsTargetAttribute(System.String,System.String)">
	<summary>
 Matches an attribute by metadata namespace, metadata type name. Does not load the type symbol for
 the attribute.
 </summary>
	<param name="namespaceName"></param>
	<param name="typeName"></param>
	<returns>True if the attribute data matches.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Metadata.PE.PEAttributeData.IsTargetAttribute(Roslyn.Compilers.VisualBasic.Symbol,System.String,System.String,System.Byte[][])">
	<summary>
 Matches an attribute by metadata namespace, metadata type name and metadata signature. Does not load the
 type symbol for the attribute.
 </summary>
	<param name="namespaceName"></param>
	<param name="typeName"></param>
	<param name="signature"></param>
	<returns>True if the attribute matches</returns>
</member><member name="T:Roslyn.Compilers.VisualBasic.Metadata.PE.PEAttributeData">
	<summary>
 Class to represent custom attributes attached to symbols.
 </summary>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Metadata.PE.MethodRefMetadataDecoder.GetGenericMethodTypeParamSymbol(System.Int32)">
	<summary>
 We know that we'll never have a method context because that's what we're
 trying to find.  Instead, just return an indexed type parameter that will
 make comparison easier.
 </summary>
	<param name="position"></param>
	<returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Metadata.PE.MethodRefMetadataDecoder.GetGenericTypeParamSymbol(System.Int32)">
	<summary>
 This override changes two things:
     1) Return type arguments instead of type parameters.
     2) Handle non-PE types.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Metadata.PE.MethodRefMetadataDecoder.FindMethodBySignature(Roslyn.Compilers.VisualBasic.TypeSymbol,System.UInt32)">
	<summary>
 Search through the members of a given type symbol to find the method that matches a particular
 signature.
 </summary>
	<param name="targetTypeSymbol">Type containing the desired method symbol.</param>
	<param name="targetMemberRefToken">A MemberRef token that can be used to obtain the name and signature of the method</param>
	<returns>The matching method symbol, or null if the inputs do not correspond to a valid method.</returns>
</member><member name="T:Roslyn.Compilers.VisualBasic.Metadata.PE.MethodRefMetadataDecoder">
	<summary>
 This subclass of MetadataDecoder is specifically for finding
 method symbols corresponding to method MemberRefs.  The parent 
 implementation is unsuitable because it requires a PEMethodSymbol
 for context when decoding method type parameters and no such
 context is available because it is precisely what we are trying
 to find.  Since we know in advance that there will be no context
 and that signatures decoded with this class will only be used
 for comparison (when searching through the methods of a known
 TypeSymbol), we can return indexed type parameters instead.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InstanceErrorTypeSymbol.InternalSubstituteTypeParameters(Roslyn.Compilers.VisualBasic.TypeSubstitution)">
	<summary>
 Substitute the given type substitution within this type, returning a new type. If the
 substitution had no effect, return Me. 
 !!! Only code implementing construction of generic types is allowed to call this method !!!
 !!! All other code should use Construct methods.                                        !!! 
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InstanceErrorTypeSymbol">
	<summary>
 The base class for potentially constructable (i.e. with known arity) error type symbols
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.IndexedTypeParameterSymbol.Take(System.Int32)">
	<summary>
 Create a vector of n dummy type parameters.  Always reuses the same type parameter symbol
 for the same position.
 </summary>
	<param name="count"></param>
	<returns></returns>
</member><member name="T:Roslyn.Compilers.VisualBasic.IndexedTypeParameterSymbol">
	<summary>
 Indexed type parameters are used in place of type parameters for method signatures.  There is
 a unique mapping from index to a single IndexedTypeParameterSymbol.  
 
 They don't have a containing symbol or locations.
 
 They do not have constraints, variance, or attributes. 
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.FieldOrPropertyInitializer.FieldsOrProperty">
	<summary>
 The field or property being initialized
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.FieldOrPropertyInitializer.Syntax">
	<summary>
 A reference to <see cref="T:Roslyn.Compilers.VisualBasic.EqualsValueSyntax"/>.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.FieldOrPropertyInitializer.#ctor(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.FieldSymbol},Roslyn.Compilers.VisualBasic.SyntaxReference)">
	<summary>
 Initializes a new instance of the <see cref="T:Roslyn.Compilers.VisualBasic.FieldOrPropertyInitializer"/> structure.
 </summary>
	<param name="fields">The fields.</param>
	<param name="syntax">The syntax for this field.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.FieldOrPropertyInitializer.#ctor(Roslyn.Compilers.VisualBasic.PropertySymbol,Roslyn.Compilers.VisualBasic.SyntaxReference)">
	<summary>
 Initializes a new instance of the <see cref="T:Roslyn.Compilers.VisualBasic.FieldOrPropertyInitializer"/> structure.
 </summary>
	<param name="property">The property.</param>
	<param name="syntax">The syntax for this property.</param>
</member><member name="T:Roslyn.Compilers.VisualBasic.FieldOrPropertyInitializer">
	<summary>
 Represents a field or property initializer. Holds the symbol and the syntax for the initialization.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ExtendedErrorTypeSymbol.ErrorInfo">
	<summary>
 Returns information about the reason that this type is in error.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.ExtendedErrorTypeSymbol">
	<summary>
 An error type symbol with name and diagnostic. More info can be added in the future.
 </summary>
	<remarks></remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.AliasSymbol.Target">
	<summary>
 Gets the <see cref="T:Roslyn.Compilers.VisualBasic.NamespaceOrTypeSymbol"/>  for the
 namespace or type referenced by the alias.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AliasSymbol.ContainingSymbol">
	<summary>
 Using aliases in VB are always at the top
 level within a compilation unit, within the [Global] namespace declaration.  We
 return that as the "containing" symbol, even though the alias isn't a member of the
 namespace as such.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.AliasSymbol">
	<summary>
 Symbol representing a using alias appearing in a compilation unit. 
 Generally speaking, these symbols do not appear in the set of symbols reachable
 from the unnamed namespace declaration.  In other words, when a using alias is used in a
 program, it acts as a transparent alias, and the symbol to which it is an alias is used in
 the symbol table.  For example, in the source code
 <pre>
 Imports o = System.Object
 Namespace NS
     partial class C : Inherits o : End Class
     partial class C : Inherits Object : End Class
     partial class C : Inherits System.Object : End Class
 End Namespace
 
 </pre>
 all three declarations for class C are equivalent and result in the same symbol table object for C. 
 However, these alias symbols do appear in the results of certain SemanticModel APIs. 
 Specifically, for the base clause of the first of C's class declarations, the
 following APIs may produce a result that contains an AliasSymbol:
 <pre>
     SemanticInfo SemanticModel.GetSemanticInfo(ExpressionSyntax expression);
     SemanticInfo SemanticModel.BindExpression(SyntaxNode location, ExpressionSyntax expression);
     SemanticInfo SemanticModel.BindType(SyntaxNode location, ExpressionSyntax type);
     SemanticInfo SemanticModel.BindNamespaceOrType(SyntaxNode location, ExpressionSyntax type);
 </pre>
 Also, the following are affected if container=Nothing (and, for the latter, when container=Nothing or arity=0):
 <pre>
     Public Function LookupNames(position As Integer, Optional container As NamespaceOrTypeSymbol = Nothing, Optional options As LookupOptions = LookupOptions.[Default], Optional results As List(Of String) = Nothing) As IList(Of String)
     Public Function LookupSymbols(position As Integer,
                                  Optional container As NamespaceOrTypeSymbol = Nothing,
                                  Optional name As String = Nothing,
                                  Optional arity As Integer? = Nothing,
                                  Optional options As LookupOptions = LookupOptions.[Default],
                                  Optional results As List(Of Symbol) = Nothing) As IList(Of Symbol)
 </pre>
	</summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Accessibility.NotApplicable">
	<summary>
 Indicates that accessibility is not applicable to this kind of symbol.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Accessibility">
	<summary>
 Represents the accessibility of a symbol.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.CustomSymbolDisplayFormatter">
	<summary>
 This class associates a symbol with particular custom format for display.
 It can be passed as an argument for an error message in place where symbol display should go, 
 which allows to defer building strings and doing many other things (like loading metadata) 
 associated with that until the error message is actually requested.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeArgumentInference.InferenceNode.InferTypeAndPropagateHints">
	<summary>
 Returns True if the inference algorithm should be restarted.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeArgumentInference.InferenceGraph.FindMatchingBaseInterface(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol@)">
	<summary>
 Returns False if the search should be cancelled.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeArgumentInference.InferenceGraph.FindMatchingBaseClass(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol@)">
	<summary>
 Returns False if the search should be cancelled.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.TypeArgumentInference">
	<summary>
 The only public entry point is the Infer method.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.OverloadResolution.Candidate.IsExtensionMethod">
	<summary>
 Whether the method is used as extension method vs. called as a static method.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.OverloadResolution.Candidate.PrecedenceLevel">
	<summary>
 Precedence level for an extension method.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.OverloadResolution.Candidate.CurriedTypeParameters">
	<summary>
 Extension method type parameters that were fixed during currying, if any.
 If none were curried, BitArray.Null should be returned. 
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.OverloadResolution.Candidate.ReceiverType">
	<summary>
 Receiver type for extension method. Otherwise, containing type.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.OverloadResolution.Candidate.ReceiverTypeDefinition">
	<summary>
 For extension methods, the type of the fist parameter in method's definition (i.e. before type parameters are substituted).
 Otherwise, same as the ReceiverType.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.OverloadResolution.Candidate">
	<summary>
 Information about a candidate from a group.
 Will have different implementation for methods, extension methods and properties.
 </summary>
	<remarks></remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.OverloadResolution.MethodCandidate">
	<summary>
 Implementation for an ordinary method (based on usage).
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.OverloadResolution.ExtensionMethodCandidate">
	<summary>
 Implementation for an extension method, i.e. it is used as an extension method.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.OverloadResolution.PropertyCandidate">
	<summary>
 Implementation for a property.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult.MaxDelegateRelaxationLevel">
	<summary>
 Only bits specific to delegate relaxation level are returned.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.OverloadResolution.OverloadResolutionResult.RemainingCandidatesRequireNarrowingConversion">
	<summary>
 This might simplify error reporting. If not, consider getting rid of this property. 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.MethodOrPropertyInvocationOverloadResolution(Roslyn.Compilers.VisualBasic.BoundMethodOrPropertyGroup,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.BoundExpression},Roslyn.Compilers.ReadOnlyArray{System.String},Roslyn.Compilers.VisualBasic.Binder,System.Boolean)">
	<summary>
 Perform overload resolution on the given method or property group, with the given arguments and names.
 The names can be null if no names were supplied to any arguments.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.MethodInvocationOverloadResolution(Roslyn.Compilers.VisualBasic.BoundMethodGroup,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.BoundExpression},Roslyn.Compilers.ReadOnlyArray{System.String},Roslyn.Compilers.VisualBasic.Binder,System.Boolean,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.SyntaxNode)">
	<summary>
 Perform overload resolution on the given method group, with the given arguments and names.
 The names can be null if no names were supplied to any arguments.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.MethodInvocationOverloadResolution(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.MethodSymbol},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.TypeSymbol},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.BoundExpression},Roslyn.Compilers.ReadOnlyArray{System.String},Roslyn.Compilers.VisualBasic.Binder,System.Boolean,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.SyntaxNode)">
	<summary>
 Perform overload resolution on the given array of method symbols. 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.PropertyInvocationOverloadResolution(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.PropertySymbol},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.BoundExpression},Roslyn.Compilers.ReadOnlyArray{System.String},Roslyn.Compilers.VisualBasic.Binder,System.Boolean)">
	<summary>
 Perform overload resolution on the given array of property symbols. 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.ResolveMethodOverloading(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.OverloadResolution.MethodCandidate},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.OverloadResolution.ExtensionMethodCandidate},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.TypeSymbol},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.BoundExpression},Roslyn.Compilers.ReadOnlyArray{System.String},Roslyn.Compilers.VisualBasic.Binder,System.Boolean,System.Boolean,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.SyntaxNode)">
	<summary>
 The entry point to resolve overloading of methods.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.EliminateLessApplicableToTheArguments(Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.BoundExpression},System.Boolean,System.Boolean)">
	<summary>
 §11.8.1 Overloaded Method Resolution
      6.	Next, if, given any two members of the set, M and N, M is more applicable than N 
         to the argument list, eliminate N from the set. If more than one member remains 
         in the set and the remaining members are not equally applicable to the argument 
         list, a compile-time error results.
      7.	Otherwise, given any two members of the set, M and N, apply the following tie-breaking rules, in order.
 
 Returns amount of applicable candidates left.
 
 Note that less applicable candidates are going to be eliminated if and only if there are most applicable
 candidates.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.ApplyTieBreakingRulesToEquallyApplicableCandidates(Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.BoundExpression})">
	<summary>
 Returns amount of applicable candidates left.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.FastFindMostApplicableCandidates(Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.BoundExpression},Roslyn.Compilers.ArrayBuilder{System.Int32})">
	<summary>
 Returns True if there are most applicable candidates.
 
 indexesOfMostApplicableCandidates will contain indexes of equally applicable candidates, which are most applicable
 by comparison to the other (non-equal) candidates. The indexes will be in ascending order.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.ApplyTieBreakingRules(Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult},Roslyn.Compilers.ArrayBuilder{System.Int32},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.BoundExpression})">
	<summary>
 §11.8.1 Overloaded Method Resolution
      7.	Otherwise, given any two members of the set, M and N, apply the following tie-breaking rules, in order.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.ShadowBasedOnTieBreakingRules(Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult,Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.BoundExpression},System.Boolean@,System.Boolean@)">
	<summary>
 §11.8.1 Overloaded Method Resolution
      7.	Otherwise, given any two members of the set, M and N, apply the following tie-breaking rules, in order.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.ShadowBasedOnDelegateRelaxation(Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult},System.Int32@)">
	<summary>
 Implements shadowing based on
 §11.8.1 Overloaded Method Resolution.
 7.8.	If one or more arguments are AddressOf or lambda expressions, and all of the corresponding 
         delegate types in M match exactly, but not all do in N, eliminate N from the set.
 7.9.	If one or more arguments are AddressOf or lambda expressions, and all of the corresponding 
         delegate types in M are widening conversions, but not all are in N, eliminate N from the set.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.ShadowBasedOnInferenceLevel(Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.BoundExpression},System.Int32@,System.Int32@,System.Boolean@)">
	<summary>
 Implements shadowing based on
 §11.8.1 Overloaded Method Resolution.
 7.7.  If M and N both required type inference to produce type arguments, and M did not 
       require determining the dominant type for any of its type arguments (i.e. each the 
       type arguments inferred to a single type), but N did, eliminate N from the set.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.CompareApplicabilityToTheArguments(Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult@,Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult@,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.BoundExpression})">
	<summary>
 §11.8.1.1 Applicability
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.CompareParameterTypeApplicability(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.BoundExpression)">
	<summary>
 §11.8.1.1 Applicability
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.GroupEquallyApplicableCandidates(Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult},System.Int32)">
	<summary>
 This method groups equally applicable (§11.8.1.1 Applicability) candidates into buckets. 
 
 Returns an ArrayBuilder of buckets. Each bucket is represented by an ArrayBuilder(Of Integer), 
 which contains indexes of equally applicable candidates from input parameter 'candidates'.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.EliminateExtensionMethodsInPresenceOfInstanceMethods(Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult})">
	<summary>
 §11.8.1 Overloaded Method Resolution
      5.	Next, if any instance methods remain in the set, 
         eliminate all extension methods from the set.
 
 Returns amount of applicable candidates left.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.AnalyzeNarrowingCandidates(Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.BoundExpression},System.Boolean,System.Boolean,System.Boolean@)">
	<summary>
 §11.8.1 Overloaded Method Resolution
      3.	Next, eliminate all members from the set that require narrowing conversions 
         to be applicable to the argument list, except for the case where the argument 
         expression type is Object.
      4.	Next, eliminate all remaining members from the set that require narrowing coercions 
         to be applicable to the argument list. If the set is empty, the type containing the 
         method group is not an interface, and strict semantics are not being used, the 
         invocation target expression is reclassified as a late-bound method access.
         Otherwise, the normal rules apply.
 
 Returns amount of applicable candidates left.
 </summary>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.EliminateNotApplicableToArguments(Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.BoundExpression},Roslyn.Compilers.ReadOnlyArray{System.String},Roslyn.Compilers.VisualBasic.Binder,System.Int32@)">
	<summary>
 §11.8.1 Overloaded Method Resolution
     2.	Next, eliminate all members from the set that are inaccessible or not applicable to the argument list.
 
 Note, similar to Dev10 compiler this process will eliminate candidates requiring narrowing conversions
 if strict semantics is used, exception are candidates that require narrowing only from numeric constants.
 
 Returns amount of applicable candidates left.
 </summary>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.BuildParameterToArgumentMap(Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult@,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.BoundExpression},Roslyn.Compilers.ReadOnlyArray{System.String},Roslyn.Compilers.ArrayBuilder{System.Int32}@,Roslyn.Compilers.ArrayBuilder{System.Int32}@)">
	<summary>
 Figure out corresponding arguments for parameters §11.8.2 Applicable Methods.
 
 Note, this function mutates the candidate structure.
 
 If non-Nothing ArrayBuilders are returned through parameterToArgumentMap and paramArrayItems
 parameters, the caller is responsible fo returning them into the pool.
 
 Assumptions: 
    1) This function is never called for a candidate that should be rejected due to parameter count.
    2) Omitted arguments [ Call Foo(a, , b) ] are represented by OmittedArgumentExpression node in the arguments array.
    3) Omitted argument never has name.
    4) argumentNames contains Nothing for all positional arguments.
 
 !!! Should keep this function in sync with Binder.PassArguments, which uses data this function populates.              !!!
 !!! Should keep this function in sync with Binder.ReportOverloadResolutionFailureForASingleCandidate.                  !!!
 !!! Everything we flag as an error here, Binder.ReportOverloadResolutionFailureForASingleCandidate should detect as well. !!!
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.MatchArguments(Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult@,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.BoundExpression},Roslyn.Compilers.ReadOnlyArray{System.String},Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 Match candidate's parameters to arguments §11.8.2 Applicable Methods.
 
 Note, similar to Dev10 compiler this process will eliminate candidate requiring narrowing conversions
 if strict semantics is used, exception are candidates that require narrowing only from numeric constants.
 
 Assumptions: 
    1) This function is never called for a candidate that should be rejected due to parameter count.
    2) Omitted arguments [ Call Foo(a, , b) ] are represented by OmittedArgumentExpression node in the arguments array.
    3) Omitted argument never has name.
    4) argumentNames contains Nothing for all positional arguments.
 
 !!! Should keep this function in sync with Binder.PassArguments, which uses data this function populates.              !!!
 !!! Should keep this function in sync with Binder.ReportOverloadResolutionFailureForASingleCandidate.                  !!!
 !!! Should keep this function in sync with InferenceGraph.PopulateGraph.                                               !!!
 !!! Everything we flag as an error here, Binder.ReportOverloadResolutionFailureForASingleCandidate should detect as well. !!!
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.MatchArgumentToByRefParameter(Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult@,Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.VisualBasic.ConversionKind@,Roslyn.Compilers.VisualBasic.ConversionKind@)">
	<summary>
 Should be in sync with Binder.ReportByRefConversionErrors.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.MatchArgumentToByValParameter(Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult@,Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.VisualBasic.ConversionKind@)">
	<summary>
 Should be in sync with Binder.ReportByValConversionErrors.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.CollectOverloadedCandidates(Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.OverloadResolution.Candidate},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.TypeSymbol},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.BoundExpression},Roslyn.Compilers.ReadOnlyArray{System.String},Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.SyntaxNode,System.Boolean)">
	<summary>
 Performs an initial pass through the group of candidates and does
 the following in the process.
 1) Eliminates candidates based on the number of supplied arguments and number of supplied generic type arguments.
 2) Adds additional entries for expanded ParamArray forms when applicable.
 3) Infers method's generic type arguments if needed.
 4) Substitutes method's generic type arguments.
 5) Eliminates candidates based on shadowing by signature.
    This partially takes care of §11.8.1 Overloaded Method Resolution, section 7.1.	
      If M is defined in a more derived type than N, eliminate N from the set. 
 6) Eliminates candidates with identical virtual signatures by applying various shadowing and
    tie-breaking rules from §11.8.1 Overloaded Method Resolution, section 7.0 
     • If M has fewer parameters from an expanded paramarray than N, eliminate N from the set. 
 7) Takes care of unsupported overloading within the same type for instance methods/properties.
 
 Assumptions:
 1) Shadowing by name has been already applied.
 2) group can include extension methods.
 3) group contains original definitions, i.e. method type arguments have not been substituted yet. 
    Exception are extension methods with type parameters substituted based on receiver type rather 
    than based on type arguments supplied at the call site.    
 4) group contains only accessible candidates.
 5) group doesn't contain members involved into unsupported overloading, i.e. differ by casing or custom modifiers only.
 6) group does not contain duplicates.
 7) All elements of arguments array are Not Nothing, omitted arguments are represented by OmittedArgumentExpression node.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.CombineCandidates(Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult},Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult,System.Int32,Roslyn.Compilers.ReadOnlyArray{System.String})">
	<summary>
 Combine new candidate with the list of existing candidates, applying various shadowing and
 tie-breaking rules. New candidate may or may not be added to the result, some
 existing candidates may be removed from the result.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.ShadowBasedOnExtensionVsInstanceAndPrecedence(Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult,Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult,System.Boolean@,System.Boolean@)">
	<summary>
 Implements shadowing based on
 §11.8.1 Overloaded Method Resolution.
    7.5.	If M is not an extension method and N is, eliminate N from the set.
    7.6.	If M and N are extension methods and M was found before N, eliminate N from the set.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.ShadowBasedOnGenericity(Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult,Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult,System.Boolean@,System.Boolean@,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.BoundExpression})">
	<summary>
 Implements shadowing based on
 §11.8.1 Overloaded Method Resolution.
    7.4.	If M is less generic than N, eliminate N from the set.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.ShadowBasedOnExtensionMethodTargetTypeGenericity(Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult,Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult,System.Boolean@,System.Boolean@)">
	<summary>
 Implements shadowing based on
 §11.8.1 Overloaded Method Resolution.
    7.3.	If M and N are extension methods and the target type of M has fewer type 
         parameters than the target type of N, eliminate N from the set. 
         !!! Note that spec talks about "fewer type parameters", but it is not really about count. 
         !!! It is about one refers to a type parameter and the other one doesn't.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.ShadowBasedOnReceiverType(Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult,Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult,System.Boolean@,System.Boolean@)">
	<summary>
 Implements shadowing based on
 §11.8.1 Overloaded Method Resolution.
    7.1.	If M is defined in a more derived type than N, eliminate N from the set.
         This rule also applies to the types that extension methods are defined on. 
    7.2.	If M and N are extension methods and the target type of M is a class or 
         structure and the target type of N is an interface, eliminate N from the set.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.DoesReceiverMatchInstance(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 For a receiver to match an instance, more or less, the type of that instance has to be convertible
 to the type of the receiver with the same bit-representation (i.e. identity on value-types
 and reference-convertibility on reference types).
 Actually, we don't include the reference-convertibilities that seem nonsensical, e.g. enum() to underlyingtype()
 We do include inheritance, implements and variance conversions amongst others.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.ShadowBasedOnParamArrayUsage(Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult,Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult,System.Boolean@,System.Boolean@)">
	<summary>
 Implements shadowing based on
 §11.8.1 Overloaded Method Resolution.
 •	If M has fewer parameters from an expanded paramarray than N, eliminate N from the set.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Conversion.Exists">
	<summary>
 True if the conversion exists, either as an widening or narrowing conversion.
 </summary>
	<remarks>
 If this returns True, exactly one of IsNarrowing or IsWidening will return True. If this returns False,
 neither IsNarrowing or IsWidening will return True.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.Conversion.IsNarrowing">
	<summary>
 True if this conversion a narrowing conversion, and not a widening conversion. 
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Conversion.IsWidening">
	<summary>
 True if this conversion is a widening conversion, and not a narrowing conversion.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Conversion.IsIdentity">
	<summary>
 True if this conversion is an identity conversion. 
 </summary>
	<remarks>
 Note that identity conversion are also considered widening conversions.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.Conversion.IsDefault">
	<summary>
 True if this conversion is a default conversion (a conversion from the "Nothing" literal). 
 </summary>
	<remarks>Note that default conversions are considered widening conversions.</remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.Conversion.IsNumeric">
	<summary>
 True if this conversion is a widening numeric conversion or a narrowing numeric conversion, as defined in
 section 8.3.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Conversion.IsBoolean">
	<summary>
 True if this conversion is a narrowing boolean conversion, as defined in section 8.2.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Conversion.IsReference">
	<summary>
 True if this conversion is a widening reference conversion or narrowing reference conversion, as defined in
 section 8.4.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Conversion.IsAnonymousDelegate">
	<summary>
 True if this conversion is a widening anonymous delegate conversion as defined in section 8.8, or a
 narrowing anonymous delegate conversion as defined in section 8.9.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Conversion.IsArray">
	<summary>
 True if this conversion is a widening array conversion or a narrowing array conversion, as defined in
 section 8.5.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Conversion.IsValueType">
	<summary>
 True if this conversion a widening value type conversion or a narrowing value type conversion as defined in
 section 8.6.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Conversion.IsNullableValueType">
	<summary>
 True if this conversion a widening nullable value type conversion or a narrowing nullable value type
 conversion as defined in section 8.6.1.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Conversion.IsString">
	<summary>
 True if this conversion a widening string conversion or a narrowing string conversion as defined in section
 8.7.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Conversion.IsTypeParameter">
	<summary>
 True if this conversion a widening type parameter or a narrowing type parameter conversion, as defined in
 section 8.10.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Conversion.IsUserDefined">
	<summary>
 True if this conversion a widening user defined or a narrowing user defined conversion, as defined in
 section 8.11.
 </summary>
	<remarks>
 If this returns True, the involved conversion method can be obtained with the UserDefinedConversionMethod
 property.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.Conversion.Method">
	<summary>
 The method that defines the user defined conversion, if any. Otherwise returns Nothing.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Conversion">
	<summary>
 Summarizes whether a conversion is allowed, and if so, which kind of conversion (and in some cases, the
 associated symbol).
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.ConversionKind.Identity">
	<summary>
 Because flags can be combined, use the method IsIdentityConversion when testing for ConversionKind.Identity
 </summary>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Conversions.TryFoldConstantConversion(Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.TypeSymbol,System.Boolean@)">
	<summary>
 Attempts to fold conversion of a constant expression. 
 
 Returns Nothing if conversion cannot be folded.
 
 If conversion failed due to non-integer overflow, ConstantValue.Bad is returned. Consumer 
 is responsible for reporting appropriate diagnostics.
 
 If integer overflow occurs, integerOverflow is set to True and ConstantValue for overflowed result is returned. 
 Consumer is responsible for reporting appropriate diagnostics and potentially discarding the result.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Conversions.TryFoldConstantNumericOrBooleanConversion(Roslyn.Compilers.ConstantValue@,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol,System.Boolean@)">
	<summary>
 Attempts to fold conversion of a constant expression.
 
 Returns Nothing if conversion cannot be folded, i.e. unexpected source and destination types. 
 Returns Bad value (Discriminator = ConstantValueTypeDiscriminator.Bad) if conversion failed due to non-integer overflow. 
 
 If integer overflow occurs, integerOverflow is set to True and the overflowed result is returned. 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Conversions.ClassifyConversion(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 This function classifies all intrinsic language conversions and user-defined conversions.
 </summary>
	<param name="source"></param>
	<param name="destination"></param>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Conversions.ClassifyConversion(Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 This function classifies all intrinsic language conversions and user-defined conversions.
 </summary>
	<param name="source"></param>
	<param name="destination"></param>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Conversions.ClassifyExpressionReclassification(Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 Reclassify lambdas, array literals, etc. 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Conversions.ClassifyUserDefinedConversion(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 This function classifies user-defined conversions between two types.
 </summary>
	<param name="source"></param>
	<param name="destination"></param>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Conversions.ClassifyUserDefinedConversion(Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 This function classifies user-defined conversions.
 </summary>
	<param name="source"></param>
	<param name="destination"></param>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Conversions.ClassifyPredefinedConversion(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 This function classifies all intrinsic language conversions, such as inheritance,
 implementation, array covariance, and conversions between intrinsic types.
 </summary>
	<param name="source"></param>
	<param name="destination"></param>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Conversions.IsDerivedFrom(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 Returns true if and only if baseType is a base class of derivedType.
 </summary>
	<param name="derivedType">
 Derived class type.
 </param>
	<param name="baseType">
 Target base class type.
 </param>
	<returns></returns>
	<remarks>
	</remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Conversions.ClassifyMethodConversionBasedOnReturnType(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 Calculate MethodConversionKind based on required return type conversion.
 
 TODO: It looks like Dev10 MethodConversionKinds for return are badly named because
       they appear to give classification in the direction opposite to the data
       flow. This is very confusing. However, I am not going to rename them just yet.
       Will do this when all parts are ported and working together, otherwise it will 
       be very hard to port the rest of the feature.
 
 We are trying to classify conversion between methods
 ConvertFrom(...) As returnTypeOfConvertFromMethod -&gt; ConvertTo(...) As returnTypeOfConvertToMethod
 
 The relaxation stub would look like:
 Stub(...) As returnTypeOfConvertToMethod
     Return ConvertFrom(...)
 End ... 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Conversions.ClassifyMethodConversionBasedOnArgumentConversion(Roslyn.Compilers.VisualBasic.ConversionKind,Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 Returns the methods conversions for the given conversion kind

 We are trying to classify conversion between methods arguments
 delegateInvoke(parameterConvertFrom) -&gt; targetMethod(parameterConvertTo)
 
 The relaxation stub would look like (stub has same signature as delegate invoke):
 Stub(parameterConvertFrom)
     return targetMethod(parameterConvertTo)
 End Method
 </summary>
	<param name="conversion">The conversion.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Conversions.DetermineDelegateRelaxationLevelForLambdaReturn(Roslyn.Compilers.VisualBasic.BoundReturnStatement)">
	<summary>
 Will set only bits used for delegate relaxation level.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Conversions.DetermineDelegateRelaxationLevel(Roslyn.Compilers.VisualBasic.MethodConversionKind,System.Boolean)">
	<summary>
 Determine the relaxation level of a given conversion. This will be used by
 overload resolution in case of conflict. This is to prevent applications that compiled in VB8
 to fail in VB9 because there are more matches. And the same for flipping strict On to Off.
 
 Will set only bits used for delegate relaxation level.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Conversions.IsStubRequiredForMethodConversion(Roslyn.Compilers.VisualBasic.MethodConversionKind)">
	<summary>
 Determines whether a stub needed for the delegate creations conversion based on the given method conversions.
 </summary>
	<param name="methodConversions">The method conversions.</param><returns>
		<c>true</c> if a stub needed for conversion; otherwise, <c>false</c>.
 </returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Conversions.IsNarrowingMethodConversion(Roslyn.Compilers.VisualBasic.MethodConversionKind,System.Boolean)">
	<summary>
 Tells whether the method conversion is considered to be narrowing or not.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Conversions.IsCLRPredefinedConversion(Roslyn.Compilers.VisualBasic.ConversionKind)">
	<summary>
 Determines whether the given conversion is CLR supported conversion or not.
 </summary>
	<param name="conversion">The conversion.</param><returns>
		<c>true</c> if the given conversion is a CLR supported conversion; otherwise, <c>false</c>.
 </returns>
</member><member name="T:Roslyn.Compilers.VisualBasic.Conversions">
	<summary>
 The purpose of this class is to answer questions about convertibility of one type to another.
 It also answers questions about conversions from an expression to a type.

 The code is organized such that each method attempts to implement exactly one section of the
 specification.
 </summary>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.CompileTimeCalculations.NarrowIntegralResult(System.Int64,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol,System.Boolean@)">
	<summary>
 Narrow a quadword result to a specific integral type, setting Overflow true
 if the result value cannot be represented in the result type.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticFacts.HaveSameSignature(Roslyn.Compilers.VisualBasic.MethodSymbol,Roslyn.Compilers.VisualBasic.MethodSymbol)">
	<summary>
 Determine if two methods have the same signature according to section 4.1.1 of the VB language spec.
 The name, number of type parameters, and number and types of the method's non-optional parameters are
 considered. ByRef/Byval, parameter names, returns type, constraints, or optional parameters are not considered.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticFacts.IsSymbolAccessible(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.NamedTypeSymbol,Roslyn.Compilers.VisualBasic.NamedTypeSymbol)">
	<summary> 
 Checks if 'symbol' is accessible from within 'within'.  If 'symbol' is accessed off
 of an expression then 'throughTypeOpt' is the type of that expression. This is needed to
 properly do protected access checks.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticFacts.IsSymbolAccessible(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.AssemblySymbol)">
	<summary> 
 Checks if 'symbol' is accessible from within the assembly 'within', but outside any 
 type. Protected members are deemed inaccessible.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.ResolveUnaryOperator(Roslyn.Compilers.VisualBasic.UnaryOperatorKind,Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.SpecialType@)">
	<summary>
 Returns UnaryOperatorKind.Error in case of error, otherwise adjusted operator kind.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.ResolveNotLiftedIntrinsicUnaryOperator(Roslyn.Compilers.VisualBasic.UnaryOperatorKind,Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 Returns result type of the operator or SpecialType.None if operator is not supported.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.TryFoldConstantUnaryOperator(Roslyn.Compilers.VisualBasic.UnaryOperatorKind,Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.TypeSymbol,System.Boolean@)">
	<summary>
 Attempts to fold unary operator applied to a constant expression. 
 
 Returns Nothing if operator cannot be folded.
 
 If folding failed due to non-integer overflow, ConstantValue.Bad is returned. Consumer 
 is responsible for reporting appropriate diagnostics.
 
 If integer overflow occurs, integerOverflow is set to True and ConstantValue for overflowed result is returned. 
 Consumer is responsible for reporting appropriate diagnostics and potentially discarding the result.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.ResolveBinaryOperator(Roslyn.Compilers.VisualBasic.BinaryOperatorKind,Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.SpecialType@)">
	<summary>
 Returns UnaryOperatorKind.Error in case of error, otherwise adjusted operator kind.
 
 For comparison operators, the operator type computed here is not
 the result type of the comparison (which is typically boolean),
 but is the type to which the operands are to be converted. For
 other operators, the type computed here is both the result type
 and the common operand type.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.TryFoldConstantBinaryOperator(Roslyn.Compilers.VisualBasic.BinaryOperatorKind,Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.TypeSymbol,System.Boolean@,System.Boolean@)">
	<summary>
 Attempts to fold binary operator applied to constant expressions. 
 
 Returns Nothing if operator cannot be folded.
 
 If folding failed due to non-integer overflow or divide by zero, 
 ConstantValue.Bad is returned. Consumer is responsible for reporting appropriate diagnostics.
 
 If divide by zero occurs, divideByZero is set to True.
 
 If integer overflow occurs, integerOverflow is set to True and ConstantValue for overflowed result is returned. 
 Consumer is responsible for reporting appropriate diagnostics and potentially discarding the result.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.ResolveNotLiftedIntrinsicBinaryOperator(Roslyn.Compilers.VisualBasic.BinaryOperatorKind,Roslyn.Compilers.SpecialType,Roslyn.Compilers.SpecialType)">
	<summary>
 Returns result type of the operator or SpecialType.None if operator is not supported.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AccessCheck.IsSymbolAccessible(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.AssemblySymbol,Roslyn.Compilers.ConsList{Roslyn.Compilers.VisualBasic.Symbol})">
	<summary>
 Checks if 'symbol' is accessible from within assembly 'within'.  
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AccessCheck.IsSymbolAccessible(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.NamedTypeSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.ConsList{Roslyn.Compilers.VisualBasic.Symbol})">
	<summary>
 Checks if 'symbol' is accessible from within type 'within', with
 an optional qualifier of type "throughTypeOpt".
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AccessCheck.IsSymbolAccessible(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.NamedTypeSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol,System.Boolean@,Roslyn.Compilers.ConsList{Roslyn.Compilers.VisualBasic.Symbol})">
	<summary>
 Checks if 'symbol' is accessible from within type 'within', with
 an qualifier of type "throughTypeOpt". Sets "failedThroughTypeCheck" to true
 if it failed the "through type" check.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AccessCheck.IsSymbolAccessibleCore(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.ConsList{Roslyn.Compilers.VisualBasic.Symbol},System.Boolean@)">
	<summary>
 Checks if 'symbol' is accessible from within 'within', which must be a NamedTypeSymbol or 
 an AssemblySymbol.  If 'symbol' is accessed off
 of an expression then 'throughTypeOpt' is the type of that expression. This is needed to
 properly do protected access checks. Sets "failedThroughTypeCheck" to true if this protected
 check failed.
 
 NOTE(cyrusn): I expect this function to be called a lot.  As such, i do not do any memory
 allocations in the function itself (including not making any iterators).  This does mean
 that certain helper functions that we'd like to call are inlined in this method to
 prevent the overhead of returning collections or enumerators.  
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.AccessCheck.AccessExposure.ExposedType">
	<summary>
 The exposed type.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.AccessCheck.AccessExposure.ExposedTo">
	<summary>
 Namespace or type that "gains" access to the type.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.AccessCheck.AccessExposure">
	<summary>
 Captures information about illegal access exposure.
 </summary>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.AccessCheck.VerifyAccessExposure(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.AccessCheck.AccessExposure}@)">
	<summary>
 Returns true if there is no illegal access exposure, false otherwise.
 </summary>
	<param name="exposedThrough">
 Type or member exposing the type.
 </param>
	<param name="exposedType">
 The exposed type.
 </param>
	<param name="illegalExposure">
 If function returns false, it requests an instance of ArrayBuilder from the pool and populates
 it with information about illegal exposure. The caller is responsible for returning the ArrayBuilder
 to the pool.
 </param>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.AccessCheck.VerifyAccessExposure(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.NamedTypeSymbol,Roslyn.Compilers.VisualBasic.NamespaceOrTypeSymbol@)">
	<summary>
 Returns true if there is no illegal access exposure, false otherwise.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AccessCheck.MemberIsOrNestedInType(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.NamedTypeSymbol)">
	<summary>
 Determine if member is the definition of the type, or 
 is contained (directly or indirectly) in the definition of the type.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AccessCheck.VerifyAccessExposureHelper(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.NamedTypeSymbol,Roslyn.Compilers.VisualBasic.NamespaceOrTypeSymbol@,System.Boolean@,System.Boolean)">
	<summary>
 Returns true if there is no illegal access exposure, false otherwise.
 
 Four cases:
 1: Member is not protected, non of its enclosing scopes are protected
 2: Member is not protected, but some of its enclosing scopes are protected
 3: Member is protected, non of its enclosing scopes are protected
 4: Member is protected, some of its enclosing scopes are also protected
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AccessCheck.CanBeAccessedThroughInheritance(Roslyn.Compilers.VisualBasic.NamedTypeSymbol,Roslyn.Compilers.VisualBasic.NamedTypeSymbol,System.Boolean)">
	<summary>
 Can type be accessed through container's inheritance?
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AccessCheck.FindEnclosingTypeWithGivenAccess(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.Accessibility,System.Boolean)">
	<summary>
 This function finds the inner most enclosing scope whose Access
 is lesser than or equal to the given access "StopAtAccess".
 </summary>
	<param name="member">Member - for which the enclosing scope has to be found</param>
	<param name="stopAtAccess">the enclosing scope's access has to be lesser than</param>
	<param name="isOutsideAssembly"></param>
</member><member name="M:Roslyn.Compilers.VisualBasic.AccessCheck.VerifyAccessExposureOfBaseClassOrInterface(Roslyn.Compilers.VisualBasic.NamedTypeSymbol,Roslyn.Compilers.VisualBasic.TypeSyntax,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Returns false if there were errors reported due to access exposure, true otherwise.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.AccessCheck">
	<summary>
 Contains the code for determining VB accessibility rules.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CharacterInfo.IsWhitespace(System.Char)">
	<summary>
 Returns true if the Unicode character represents a whitespace.
 </summary>
	<param name="c">The Unicode character.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.CharacterInfo.IsNewLine(System.Char)">
	<summary>
 Returns true if the Unicode character is a newline character.
 </summary>
	<param name="c">The Unicode character.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.CharacterInfo.IsIdentifierStartCharacter(System.Char)">
	<summary>
 Returns true if the Unicode character can be the starting character of a C# identifier.
 </summary>
	<param name="c">The Unicode character.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.CharacterInfo.IsIdentifierPartCharacter(System.Char)">
	<summary>
 Returns true if the Unicode character can be a part of a VB identifier.
 </summary>
	<param name="c">The Unicode character.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.CharacterInfo.IsValidIdentifier(System.String)">
	<summary>
 Check that the name is a valid identifier.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CharacterInfo.MatchOneOrAnother(System.Char,System.Char,System.Char)">
	<summary>
 matches one char or another.
 Typical usage is for matching lowercase and uppercase.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CharacterInfo.MatchOneOrAnotherOrFullwidth(System.Char,System.Char,System.Char)">
	<summary>
 matches one char or another.
 it will try normall width and then fullwidth variations.
 Typical usage is for matching lowercase and uppercase.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Scanner.PeekToken(System.Int32,Roslyn.Compilers.VisualBasic.InternalSyntax.ScannerState)">
	<summary>
 note that state is applied only to the token #1
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Scanner.ScanSurrogatePair(System.Char,System.Int32)">
	<summary>
 0 - not a surrogate, 2 - is valid surrogate 
 1 is an error
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.InternalSyntax.Scanner.Page._pageStart">
	<summary>
 where page maps in the stream. Used to validate pages
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.InternalSyntax.Scanner.Page._arr">
	<summary>
 page's buffer
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.Scanner.Page">
	<summary>
 page represents a cached array of chars.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.InternalSyntax.Scanner._curPage">
	<summary>
 current page we are reading.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Scanner.GetPage(System.Int32)">
	<summary>
 gets a page for the position.
 will initialize it if we have cache miss
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.InternalSyntax.Scanner._sb">
	<summary>
 DO NOT USE DIRECTLY. 
 USE GetScratch() 
 </summary>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Scanner.GetDisabledTextAt(Roslyn.Compilers.TextSpan)">
	<summary>
 Gets a chunk of text as a DisabledCode node.
 </summary>
	<param name="span">The range of text.</param>
	<returns>The DisabledCode node.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Scanner.ScanNewlineAsStatementTerminator(System.Char,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode})">
	<summary>
 Accept a CR/LF pair or either in isolation as a newline.
 Make it a statement separator
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Scanner.ScanNewlineAsTrivia(System.Char)">
	<summary>
 Accept a CR/LF pair or either in isolation as a newline.
 Make it a whitespace
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Scanner.ScanMultilineTrivia">
	<summary>
 Consumes all trivia until a nontrivia char is found
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Scanner.TryScanSinglePieceOfMultilineTrivia(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxListBuilder)">
	<summary>
 Scans a single piece of trivia
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Scanner.ScanSingleLineTrivia">
	<summary>
 Scan trivia on one LOGICAL line
 Will check for whitespace, comment, EoL, implicit line break
 EoL may be consumed as whitespace only as a part of line continuation ( _ )
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Scanner.TryIdentifierAsContextualKeyword(Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax@)">
	<summary>
 Try to convert an Identifier to a Keyword.  Called by the parser when it wants to force
 an identifer to be a keyword.
 </summary>
	<param name="id"></param>
	<remarks></remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.Scanner">
	<summary>
 Creates red tokens for a stream of text
 </summary>
	<remarks></remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.QuickTokenTable.Entry">
	<summary>
 Matches token with its spelling.
 Used in shared token cache.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.QuickTokenTable.EqualText(System.String,System.Char[],System.Int32,System.Int32)">
	<summary>
 Compare a string and a char array/length for exact equality.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.Scanner.AccumulatorState">
	<summary>
 The possible states that the mini scanning can be in.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.InternalSyntax.Blender._nodeStack">
	<summary>
 Candidate nodes that may be reused.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.InternalSyntax.Blender._change">
	<summary>
 we currently support only one change.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.InternalSyntax.Blender._currentNode">
	<summary>
 Current node. Not necessarily reusable or even a NonTerminal.
 Can be null if we are out of nodes.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.InternalSyntax.Blender._affectedRangeOld">
	<summary>
 Affected ranges are ranges from which we cannot reuse nodes.
 Old and New are actually the same range defined in terms of old text and new text.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Blender.SetAffectedRanges(Roslyn.Compilers.TextChangeRange[])">
	<summary>
 Sets affected ranges. 
 Because of look-aheads the actual range from which nodes canot be used is 
 slightly bigger than region that was actually edited.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Blender.CollapseChanges(Roslyn.Compilers.TextChangeRange[])">
	<summary>
 API currently allows for multiple changes, but we can handle only one, 
 so we will collapse them into one big change for now.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Blender.TryPopNode">
	<summary>
 Moving to the next node on the stack.
 returns false if we are out of nodes.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Blender.TryCrumbleOnce">
	<summary>
 Crumbles current node onto the stack and pops one node into current.
 Returns false if current node cannot be crumbled.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Blender.GetCurrentNode(System.Int32)">
	<summary>
 Advances to given position if needed (note: no way back)
 Gets a nonterminal that can be used for incremental.
 May return Nothing if such node is not available.
 Typically it is _currentNode.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Blender.GetCurrentNonterminal">
	<summary>
 Returns current candidate for reuse if there is one.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Blender.CanReuseNode(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode)">
	<summary>
 Checks if node is reusable.
 The reasons for it not be usable are typically that it intersects affected range.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Parser.VerifyExpectedToken``1(Roslyn.Compilers.VisualBasic.SyntaxKind,``0@)">
	<summary>
 Check that the current token is the expected kind, the curren node is consumed and optionally a new line
 after the token.
 </summary>
	<param name="kind">Theexpected node kind.</param>
	<returns>A token of the expected kind.  This node may be an empty token with an error attached to it</returns>
	<remarks>Since nodes are immutable, the only way to create nodes with errors attached is to create a node without an error,
 then add an error with this method to create another node.</remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Parser.ParseStringLiteral">
	<summary>
 Parses StringLiteral
 </summary>
	<returns>LiteralNode</returns>
	<remarks>If the current Token is not StringLiteral then returns LiteralNode with missing token.</remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Parser.ResyncAtStatementTerminator">
	<summary>
 Resyncs to next statement terminator. Used in Preprocessor
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Parser.TryEatNewLine(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode@,Roslyn.Compilers.VisualBasic.InternalSyntax.ScannerState)">
	<summary>
 If the current token is a newline statement terminator then convert it to trivia and return 
 the trivia.
 <Returns>Trivia or nothing if the statement terminator is not consumed</Returns>
	</summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Parser.ReportUnrecognizedStatementError(Roslyn.Compilers.VisualBasic.ERRID,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.AttributeBlockSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax})">
	<summary>
 Create a bad statement.  Report an error only if the statement doesn't have one already
 </summary>
	<param name="ErrorId"></param>
	<param name="attributes"></param>
	<param name="modifiers"></param>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Parser.ParseCollectionInitializer">
	<summary>
  Parses a CollectionInitializer 
         CollectionInitializer -&gt; "{" CollectionInitializerList "}"
         CollectionInitializerList -&gt;  CollectionElement {"," CollectionElement}*
         CollectionElement -&gt; Expression | CollectionInitializer
 </summary>
	<returns>CollectionInitializerSyntax</returns>
	<remarks>In the grammar ArrayLiteralExpression is a rename of CollectionInitializer</remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Parser.ParseObjectInitializerList(System.Boolean,System.Boolean)">
	<summary>
 Parses
 "With "{" FieldInitializerList "}"
 FieldInitializerList -&gt; FieldInitializer {"," FieldInitializer}*
 FieldInitializer -&gt; {Key? "." IdentifierOrKeyword "="}? Expression
 
  e.g.
  Dim x as new Customer With {.Id = 1, .Name = "A"}
 </summary>
	<returns>ObjectMemberInitializer</returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Parser.ParseObjectCollectionInitializer(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode)">
	<summary>
   Parses an ObjectCollectionInitializer
         ObjectCollectionInitializer -&gt; "from" CollectionInitializer
 
 </summary>
	<returns>ObjectCollectionInitializer</returns>
	<remarks>In Dev10 this was called ParseInitializerList.  It also took several boolean parameters.  
  These were always set as 
       AllowExpressionInitializers = true
       AllowAssignmentInitializers = false
       AnonymousTypeInitializer = false
       RequireAtleastOneInitializer = false
 
  While the grammar uses the nonterminal CollectionInitializer is modeled as an
  AnnonymousArrayCreationExpression which has the identical syntax "{" Expression {"," Expression }* "}"
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Parser.ParseAssignmentInitializer(System.Boolean)">
	<summary>
 Parses a FieldInitializer
 
 FieldInitializer -&gt; ("key"? "." IdentifierOrKeyword "=")? Expression
 </summary>
	<param name="anonymousTypeInitializer">If true then allow the keyword "key" to prefix the field initializer</param>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Parser.ParseTypeName(System.Boolean,System.Boolean@)">
	<summary>
 Parse and return a TypeName.  Assumes the CurrentToken is on the name.
 </summary>
	<param name="AllowEmptyGenericArguments">Controls generic argument parsing</param>
	<param name="AllowedEmptyGenericArguments">Controls generic argument parsing</param>
	<returns>TypeName</returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Parser.ParseParameter(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.AttributeBlockSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax})">
	<summary>
     Parameter -&gt; Attributes? ParameterModifiers* ParameterIdentifier ("as" TypeName)? ("=" ConstantExpression)?
 </summary>
	<param name="attributes"></param>
	<param name="modifiers"></param>
	<returns></returns>
	<remarks>&gt;This replaces both ParseParameter and ParseOptionalParameter in Dev10</remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Parser.ParseCustomEventDefinition(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.AttributeBlockSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax})">
	<summary>
 Parse a CustomEventMemberDeclaration
 </summary>
	<param name="attributes"></param>
	<param name="modifiers"></param>
	<returns></returns>
	<remarks>This code used to be in ParseEventDefinition.</remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Parser.PeekToken(System.Int32)">
	<summary>
 Peeks in a stream of VB tokens.
 Note that the first token will be picked according to _allowLeadingMultilineTrivia
 The rest will be picked as regular VB as scanner does not always know what to do with
 line terminators and we assume that multiple token lookahead makes sense inside a single statement.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Parser.GetNextToken(Roslyn.Compilers.VisualBasic.InternalSyntax.ScannerState)">
	<summary>
 Consumes current token and gets the next one with desired state.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Parser.GetNextSyntaxNode">
	<summary>
 Consumes current node and gets next one. 
 </summary>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Parser.ParseGetType">
	<summary>
 Parse GetType, 
 GetTypeExpression -&gt; GetType OpenParenthesis GetTypeTypeName CloseParenthesis 
 </summary>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Parser.ParseTypeOf">
	<summary>
 Parse TypeOf ... Is ... 
 TypeOfIsExpression -&gt; "TypeOf" Expression "Is" LineTerminator? TypeName
 </summary>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Parser.ParseCast">
	<summary>
 ParseCast parses CType, DirectCast, TryCast.
 CCCastExpression -&gt;   DirectCast ( CCExpression , TypeName ) 
                     | TryCast ( CCExpression , TypeName ) 
                     | CType ( CCExpression , TypeName ) 
                     { | CastTarget ( CCExpression ) }
 </summary>
	<returns>Cast</returns>
	<remarks>Dev10 ParseCType does not parse exact grammar in the spec, since dev10 accepts Epxression whereas the grammar uses CCExpression.
 This function only does not parse CastTarget ( ... ), it is parsed in ParseTerm
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ParseOptions.PreprocessorSymbols">
	<summary>
 The preprocessor symbols to parse with
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ParseOptions.GetOptionNames">
	<summary>
 Get the list of option names.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ParseOptions.HasOption(System.String)">
	<summary>
 True if the CompilationOptions has the specified option.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ParseOptions.GetOption(System.String)">
	<summary>
 Get the option value for the specified option.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ParseOptions.SetOption(System.String,System.String)">
	<summary>
 Create a new CompilationOptions instance including the specified option value.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Location.InSource">
	<summary>
 Indicates if the location refers to a particular place in source code.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Location.InMetadata">
	<summary>
 Indicates if the location refers to metadata.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Location.SourceSpan">
	<summary>
 The location within the syntax tree that this error is associated with.
 Throws an InvalidOperationException unless InSource is true.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Location.SourceTree">
	<summary>
 The syntax tree this error is located in. Throws
 an InvalidOperationException unless InSource is true.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Location.MetadataModule">
	<summary>
 Returns the metadata module the error is associated with. 
 Throws an InvalidOperationException unless InMetadata is true.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Location.GetLineSpan(System.Boolean)">
	<summary>
 Gets the location in terms of file name/line/column.
 Throws an InvalidOperationException unless InSource is true.
 </summary>
	<param name="usePreprocessorDirectives">If true, the filename/line/column
 reported takes into account #line directivees. If false, #line directives
 are ignored.</param>
	<returns></returns>
</member><member name="T:Roslyn.Compilers.VisualBasic.Location">
	<summary>
 Represents a location in source code or metadata. Used for the location of diagnostics and symbols.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SourceLocation">
	<summary>
 A program location in source code.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SourceLocationWithAssociatedNode">
	<summary>
 A program location in source code with an associated syntax node.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SpeculativeLocation">
	<summary>
 A program location in speculative bound code. Right now, speculatively bound code
 doesn't have a syntax tree associated with it. This probably will change in the future, but
 for now this works.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SpeculativeLocationWithAssociatedNode">
	<summary>
 A program location in speculative bound code with an associated syntax node. Right now, speculatively
 bound code doesn't have a syntax tree associated with it. This probably will change in the future, but
 for now this works.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.MetadataLocation">
	<summary>
 A program location in metadata.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.NoLocation">
	<summary>
 A class that represents no location at all. Useful for errors in command line options, for example.
 </summary>
	<remarks></remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.CompoundDiagnosticInfo">
	<summary>
 Concatenates messages for a set of DiagnosticInfo.
 </summary>
	<remarks></remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.BadSymbolDiagnostic">
	<summary>
 This diagnostic indicates when a symbol is not good for binding against.
 
 Client code can obtain the bad symbol via the BadSymbol property.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.AmbiguousSymbolDiagnostic">
	<summary>
 This diagnostics indicates when a lookup is ambiguous between multiple
 equally good symbols, for example in different imported namespaces, or different
 modules.
 
 Client code can obtain the set of ambiguous symbols via the AmbiguousSymbols property.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Emit.Module.GetCompilerGeneratedTypes(Roslyn.Compilers.VisualBasic.NamedTypeSymbol)">
	<summary>
 Returns null if there are no compiler generated types.
 </summary>
	<param name="container"></param>
	<returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Emit.Module.GetCompilerGeneratedMethods(Roslyn.Compilers.VisualBasic.NamedTypeSymbol)">
	<summary>
 Returns null if there are no compiler generated methods.
 </summary>
	<param name="container"></param>
	<returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Emit.Module.GetCompilerGeneratedFields(Roslyn.Compilers.VisualBasic.NamedTypeSymbol)">
	<summary>
 Returns null if there are no compiler generated fields.
 </summary>
	<param name="container"></param>
	<returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Symbol.IsDefinitionOrDistinct">
	<summary>
 Return whether the symbol is either the original definition
 or distinct from the original. Intended for use in Debug.Assert
 only since it may include a deep comparison.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Emit.SpecializedNestedTypeReference">
	<summary>
 Represents a reference to a type nested in an instantiation of a generic type.
 e.g. 
 A{int}.B
 A.B{int}.C.D
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Emit.SpecializedMethodReference">
	<summary>
 Represents a method of a generic type instantiation.
 e.g. 
 A{int}.M()
 A.B{int}.C.M()
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Emit.SpecializedGenericNestedTypeInstanceReference">
	<summary>
 Represents a reference to an instantiation of a generic type nested in an instantiation of another generic type.
 e.g. 
 A{int}.B{string}
 A.B{int}.C.D{string}
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Emit.SpecializedFieldReference">
	<summary>
 Represents a reference to a field of a generic type instantiation.
 e.g.
 A{int}.Field
 A{int}.B{string}.C.Field
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Emit.Module.CompilerGeneratedDefinitions">
	<summary>
 Captures the set of compiler generated definitions that should be added to a type
 during emit process.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Emit.GenericTypeInstanceReference">
	<summary>
 Represents a reference to a generic type instantiation.
 Subclasses represent nested and namespace types.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Emit.GenericNestedTypeInstanceReference">
	<summary>
 Represents a reference to a generic type instantiation that is nested in a non-generic type.
 e.g. A.B{int}
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Emit.GenericNamespaceTypeInstanceReference">
	<summary>
 Represents a reference to a generic type instantiation that is not nested.
 e.g. MyNamespace.A{int}
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Emit.GenericMethodInstanceReference">
	<summary>
 Represents a reference to a generic method instantiation, closed over type parameters, 
 e.g. MyNamespace.Class.Method{T}()
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.DeclarationTable">
	<summary>
 A declaration table is a device which keeps track of type and namespace declarations from
 parse trees. It is optimized for the case where there is one set of declarations that stays
 constant, and a specific root namespace declaration corresponding to the currently edited
 file which is being added and removed repeatedly. It maintains a cache of information for
 "merging" the root declarations into one big summary declaration; this cache is efficiently
 re-used provided that the pattern of adds and removes is as we expect.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.GlobalImport.Clause">
	<summary>
 The import clause (a namespace name, an alias, or an XML namespace alias).
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.DiagnosticBagExtensions.SealDiagnostics(Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Get all the diagnostics in the diagnostic bag, as an enumerable of Diagnostic. DiagnosticBag
 implements IEnumerable&lt;IDiagnostic&gt; instead of IEnumerable&lt;Diagnostic&gt;.
 </summary>
	<param name="diagBag"></param>
	<returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.DiagnosticBagExtensions.GetDiagnostics(Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Get all the diagnostics in the diagnostic bag, as an enumerable of Diagnostic. DiagnosticBag
 implements IEnumerable&lt;IDiagnostic&gt; instead of IEnumerable&lt;Diagnostic&gt;.
 </summary>
	<param name="diagBag"></param>
	<returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.DiagnosticBagExtensions.Add(Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.VisualBasic.ERRID,Roslyn.Compilers.VisualBasic.Location,System.Object[])">
	<summary>
 Add a diagnostic to the bag.
 </summary>
	<param name="diagnostics"></param>
	<param name="code"></param>
	<param name="location"></param>
	<param name="args"></param>
	<returns></returns>
</member><member name="T:Roslyn.Compilers.VisualBasic.Emit.SpecializedGenericMethodInstanceReference">
	<summary>
 Represents a generic method of a generic type instantiation, closed over type parameters.
 e.g. 
 A{T}.M{S}()
 A.B{T}.C.M{S}()
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Declaration">
	<summary>
 A Declaration summarizes the declaration structure of a source file. Each entity declaration
 in the program that is a container (specifically namespaces, classes, interfaces, structs,
 and delegate declarations) is represented by a node in this tree.  At the top level, the
 compilation unit is treated as a declaration of the unnamed namespace.

 Special treatment is required for namespace declarations, because a single namespace
 declaration can declare more than one namespace.  For example, in the declaration

namespace A.B.C {}

we see that namespaces A and B and C are declared.  This declaration is represented as three
 declarations. All three of these ContainerDeclaration objects contain a reference to the
 syntax tree for the declaration.

 A "single" declaration represents a specific namespace or type declaration at a point in
 source code. A "root" declaration is a special single declaration which summarizes the
 contents of an entire file's types and namespaces.  Each source file is represented as a tree
 of single declarations.

 A "merged" declaration merges together one or more declarations for the same symbol.  For
 example, the root namespace has multiple single declarations (one in each source file) but
 there is a single merged declaration for them all.  Similarly partial classes may have
 multiple declarations, grouped together under the umbrella of a merged declaration.  In the
 common trivial case, a merged declaration for a single declaration contains only that single
 declaration.  The whole program, consisting of the set of all declarations in all of the
 source files, is represented by a tree of merged declarations.'''
</summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.GlobalNamespaceDeclaration">
	<summary>
 Represents global namespace. Namespace's name is always empty
 </summary>
	<remarks></remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.SyntaxTreeSemanticModel.Compilation">
	<summary> 
 The compilation associated with this binding.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SyntaxTreeSemanticModel.Root">
	<summary> 
 The root node of the syntax tree that this binding is based on.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SyntaxTreeSemanticModel.SyntaxTree">
	<summary> 
 The SyntaxTree that is bound
 </summary>
	<remarks>
 Returns null if this is a binding returned by GetSpeculativeSemanticModel.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTreeSemanticModel.GetDiagnostics(System.Threading.CancellationToken)">
	<summary>
 Get all the errors within the syntax tree associated with this object. Includes errors involving compiling
 method bodies or initializers, in addition to the errors returned by GetDeclarationDiagnostics.
 </summary>
	<param name="cancellationToken">A cancellation token that can be used to cancel the process of obtaining the
 diagnostics.</param>
	<remarks>
 Because this method must semantically all method bodies and initializers to check for diagnostics, it may
 take a significant amount of time. Unlike GetDeclarationDiagnostics, diagnostics for method bodies and
 initializers are not cached, the any semantic information used to obtain the diagnostics is discarded.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTreeSemanticModel.GetDeclarationDiagnostics(System.Threading.CancellationToken)">
	<summary>
 Get all the syntax and declaration errors within the syntax tree associated with this object. Does not get
 errors involving compiling method bodies or initializers.
 </summary>
	<param name="cancellationToken">A cancellation token that can be used to cancel the process of obtaining the
 diagnostics.</param>
	<remarks>The declaration errors for a syntax tree are cached. The first time this method is called, a ll
 declarations are analyzed for diagnostics. Calling this a second time will return the cached diagnostics.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTreeSemanticModel.OldGetSemanticInfo(Roslyn.Compilers.VisualBasic.ExpressionSyntax,System.Threading.CancellationToken)">
	<summary>
 Gets semantic information, such as type, symbols, and diagnostics, about a syntax node.
 </summary>
	<param name="expression">The syntax node to get semantic information for.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTreeSemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.DelegateStatementSyntax,System.Threading.CancellationToken)">
	<summary>
 Given a delegate declaration, get the corresponding type symbol.
 </summary>
	<param name="declarationSyntax">The syntax node that declares a type.</param>
	<returns>The type symbol that was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTreeSemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.TypeStatementSyntax,System.Threading.CancellationToken)">
	<summary>
 Given a type declaration, get the corresponding type symbol.
 </summary>
	<param name="declarationSyntax">The syntax node that declares a type.</param>
	<returns>The type symbol that was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTreeSemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.EnumStatementSyntax,System.Threading.CancellationToken)">
	<summary>
 Given a enum declaration, get the corresponding type symbol.
 </summary>
	<param name="declarationSyntax">The syntax node that declares an enum.</param>
	<returns>The type symbol that was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTreeSemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.NamespaceStatementSyntax,System.Threading.CancellationToken)">
	<summary>
 Given a namespace declaration, get the corresponding type symbol.
 </summary>
	<param name="declarationSyntax">The syntax node that declares a namespace.</param>
	<returns>The namespace symbol that was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTreeSemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.MethodBaseSyntax,System.Threading.CancellationToken)">
	<summary>
 Given a method, property, or event declaration, get the corresponding symbol.
 </summary>
	<param name="declarationSyntax">The syntax node that declares a method, property, or event.</param>
	<returns>The method, property, or event symbol that was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTreeSemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.ParameterSyntax,System.Threading.CancellationToken)">
	<summary>
 Given a parameter declaration, get the corresponding parameter symbol.
 </summary>
	<param name="parameter">The syntax node that declares a parameter.</param>
	<returns>The parameter symbol that was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTreeSemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.TypeParameterSyntax,System.Threading.CancellationToken)">
	<summary>
 Given a type parameter declaration, get the corresponding type parameter symbol.
 </summary>
	<param name="typeParameter">The syntax node that declares a type parameter.</param>
	<returns>The type parameter symbol that was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTreeSemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.ModifiedIdentifierSyntax,System.Threading.CancellationToken)">
	<summary>
 Given a variable declaration, get the corresponding  symbol.
 </summary>
	<param name="declarationSyntax">The syntax node that declares a variable.</param>
	<returns>The symbol that was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTreeSemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.AliasImportsClauseSyntax,System.Threading.CancellationToken)">
	<summary>
 Given an import clause get the corresponding symbol for the import alias that was introduced.
 </summary>
	<param name="declarationSyntax">The import statement syntax node.</param>
	<returns>The alias symbol that was declared or Nothing if no alias symbol was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTreeSemanticModel.ClassifyConversion(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 Determines what type of conversion, if any, would be used if a given expression was converted to a given
 type.
 </summary>
	<param name="expression">An expression which much occur within the syntax tree associated with this
 object.</param>
	<param name="destination">The type to attempt conversion to.</param>
	<returns>Returns a Conversion object that summarizes whether the conversion was possible, and if so, what
 kind of conversion it was. If no conversion was possible, a Conversion object with a false "Exists "
 property is returned.</returns>
	<remarks>To determine the conversion between two types (instead of an expression and a type), use
 Compilation.ClassifyConversion.</remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTreeSemanticModel.OldGetSemanticInfoInParent(Roslyn.Compilers.VisualBasic.ExpressionSyntax,System.Threading.CancellationToken)">
	<summary>
 Gets the semantic information for a syntax node as seen from the perspective of the node's parent. 
 </summary>
	<param name="expression"></param>
	<remarks>
 This method allows observing the result of implicit conversions that do not have syntax node's directly
 associated with them. For example, consider the following code:
 <code>
 Sub f(x As Long) 
 Dim i As Integer = 17 
 f(i)
 </code>
 A call to GetSemanticInfo on the syntax node for "i" in "f(i)" would have a Type of "Integer". A call to
 GetSemanticInfoInParent on the same syntax node would have a Type of "Long", since there is an widening
 conversion from Integer to Long as part of the call to f.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTreeSemanticModel.GetSpeculativeSemanticModel(System.Int32,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Get a SemanticModel object that is associated with an expression that did not appear in
 this source code. This can be used to get detailed semantic information about sub-parts
 of an expression that did not appear in source code. 
 </summary>
	<param name="position">The character position for determining the enclosing declaration scope and
 accessibility.</param>
	<param name="expression">The expression to analyze. This expression does not need to be present in the
 syntax tree associated with this object.</param>
	<returns>A SemanticModel object that can be used to inquire about the semantic information associated with
 syntax nodes within "expression".</returns>
	<remarks>
 If semantic information about just the root node of "expression", the BindExpression method can be used
 instead.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTreeSemanticModel.GetSpeculativeSemanticModel(System.Int32,Roslyn.Compilers.VisualBasic.StatementSyntax)">
	<summary>
 Get a SemanticModel object that is associated with an expression that did not appear in
 this source code. This can be used to get detailed semantic information about sub-parts
 of an expression that did not appear in source code. 
 </summary>
	<param name="position">The character position for determining the enclosing declaration scope and
 accessibility.</param>
	<param name="statement">The statement to analyze. This statement does not need to be present in the syntax
 tree associated with this object.</param>
	<returns>A SemanticModel object that can be used to inquire about the semantic information associated with
 syntax nodes within "statement".</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTreeSemanticModel.AnalyzeRegionControlFlow(Roslyn.Compilers.TextSpan)">
	<summary>
 Analyze control-flow within a part of a method body. 
 </summary>
	<param name="span">The span of code within the associated SyntaxTree to analyze. The span must be fully
 inside a method body.</param>
	<returns>An object that can be used to obtain the result of the control flow analysis.</returns>
	<exception cref="T:System.ArgumentException">The span is not with a method body.</exception>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTreeSemanticModel.AnalyzeRegionDataFlow(Roslyn.Compilers.TextSpan)">
	<summary>
 Analyze data-flow within a part of a method body. 
 </summary>
	<param name="span">The span of code within the associated SyntaxTree to analyze. The span must be fully
 inside a method body.</param>
	<returns>An object that can be used to obtain the result of the data flow analysis.</returns>
	<exception cref="T:System.ArgumentException">The span is not with a method body.</exception>
</member><member name="T:Roslyn.Compilers.VisualBasic.SyntaxTreeSemanticModel">
	<summary>
 Allows asking semantic questions about any node in a SyntaxTree within a Compilation.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SemanticModel.Compilation">
	<summary> 
 The compilation associated with this binding.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SemanticModel.Root">
	<summary> 
 The root node of the syntax tree that this binding is based on.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.OldGetSemanticInfo(Roslyn.Compilers.VisualBasic.ExpressionSyntax,System.Threading.CancellationToken)">
	<summary>
 Gets semantic information, such as type, symbols, and diagnostics, about a syntax node.
 </summary>
	<param name="expression">The syntax node to get semantic information for.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.OldGetSemanticInfoInParent(Roslyn.Compilers.VisualBasic.ExpressionSyntax,System.Threading.CancellationToken)">
	<summary>
 Gets the semantic information for a syntax node as seen from the perspective of the
 node's parent. 
 </summary>
	<param name="expression"></param>
	<remarks>
 This method allows observing the result of implicit conversions that do not have syntax
 node's directly associated with them. For example, consider the following code:
 <code>
 Sub f(x As Long) 
 Dim i As Integer = 17 
 f(i)
 </code>
 A call to GetSemanticInfo on the syntax node for "i" in "f(i)" would have a Type of
 "Integer". A call to GetSemanticInfoInParent on the same syntax node would have a Type
 of "Long", since there is an widening conversion from Integer to Long as part of the
 call to f.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetSemanticInfo(Roslyn.Compilers.VisualBasic.SyntaxNode,System.Threading.CancellationToken)">
	<summary>
 Gets semantic information, such as type, symbols, and diagnostics, about a syntax node.
 </summary>
	<param name="node">The syntax node to get semantic information for.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetSemanticInfo(Roslyn.Compilers.VisualBasic.ExpressionSyntax,System.Threading.CancellationToken)">
	<summary>
 Gets semantic information, such as type, symbols, and diagnostics, about an expression.
 </summary>
	<param name="expression">The syntax node to get semantic information for.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetEnclosingBinder(System.Int32)">
	<summary>
 Gets the binder that encloses the position. See comment on LookupSymbols for how
 positions are interpreted.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.OldBindExpression(System.Int32,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Binds the expression in the context of the specified location and get semantic
 information such as type, symbols and diagnostics. This method is used to get semantic
 information about an expression that did not actually appear in the source code.
 </summary>
	<param name="position">A character position used to identify a declaration scope and
 accessibility. This character position must be within the FullSpan of the Root syntax
 node in this SemanticModel.
 </param>
	<param name="expression">A syntax node that represents a parsed expression. This syntax
 node need not and typically does not appear in the source code referred to  SemanticModel
 instance.</param>
	<returns>The semantic information for the topmost node of the expression.</returns>
	<remarks>The passed in expression is interpreted as a stand-alone expression, as if it
 appeared by itself somewhere within the scope that encloses "position".</remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.OldBindType(System.Int32,Roslyn.Compilers.VisualBasic.TypeSyntax)">
	<summary>
 Bind a type in the context of the specified location. This method is used to get
 semantic information about a type that did not actually appear in the source code.
 </summary>
	<param name="position">A character position used to identify a declaration scope and
 accessibility. This character position must be within the FullSpan of the Root syntax
 node in this SemanticModel.
 </param>
	<param name="typeSyntax">The syntax node for the type expression to be bound. This
 syntax node need not appear with the source code.</param>
	<returns>The semantic information for the topmost node of the type.</returns>
	<remarks>The symbol lookup rules for type expressions are used when interpreting the
 given syntax. Symbols that are not types and namespaces are not considered.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.BindType(System.Int32,Roslyn.Compilers.VisualBasic.TypeSyntax)">
	<summary>
 Bind a type in the context of the specified location. This method is used to get
 semantic information about a type that did not actually appear in the source code.
 </summary>
	<param name="position">A character position used to identify a declaration scope and
 accessibility. This character position must be within the FullSpan of the Root syntax
 node in this SemanticModel.
 </param>
	<param name="typeSyntax">The syntax node for the type expression to be bound. This
 syntax node need not appear with the source code.</param>
	<returns>The semantic information for the topmost node of the type.</returns>
	<remarks>The symbol lookup rules for type expressions are used when interpreting the
 given syntax. Symbols that are not types and namespaces are not considered.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.OldBindNamespaceOrType(System.Int32,Roslyn.Compilers.VisualBasic.TypeSyntax)">
	<summary>
 Bind a namespace or type in the context of the specified location. This method is used
 to get semantic information about an type or namespace that did not actually appear in
 the source code.
 </summary>
	<param name="position">A character position used to identify a declaration scope and
 accessibility. This character position must be within the FullSpan of the Root syntax
 node in this SemanticModel.
 </param>
	<param name="namespaceOrTypeSyntax">The syntax node for the type expression to be bound.
 This syntax node need not appear with the source code.</param>
	<returns>The semantic information for the topmost node of the namespace or type.</returns>
	<remarks>The symbol lookup rules for type or namespace expressions are used when
 interpreting the given syntax. Symbols that are not types and namespaces are not
 considered.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.BindNamespaceOrType(System.Int32,Roslyn.Compilers.VisualBasic.TypeSyntax)">
	<summary>
 Bind a namespace or type in the context of the specified location. This method is used
 to get semantic information about an type or namespace that did not actually appear in
 the source code.
 </summary>
	<param name="position">A character position used to identify a declaration scope and
 accessibility. This character position must be within the FullSpan of the Root syntax
 node in this SemanticModel.
 </param>
	<param name="namespaceOrTypeSyntax">The syntax node for the type expression to be bound.
 This syntax node need not appear with the source code.</param>
	<returns>The semantic information for the topmost node of the namespace or type.</returns>
	<remarks>The symbol lookup rules for type or namespace expressions are used when
 interpreting the given syntax. Symbols that are not types and namespaces are not
 considered.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.OldBindExpression(System.Int32,Roslyn.Compilers.VisualBasic.SyntaxTree,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Binds the expression in the context of the specified location and get semantic
 information such as type, symbols and diagnostics. This method is used to get semantic
 information about an expression that did not actually appear in the source code.
 </summary>
	<param name="position">A character position used to identify a declaration scope and
 accessibility. This character position must be within the FullSpan of the Root syntax
 node in this SemanticModel.
 </param>
	<param name="expression">A syntax node that represents a parsed expression. This syntax
 node need not and typically does not appear in the source code referred to  SemanticModel
 instance.</param>
	<returns>The semantic information for the topmost node of the expression.</returns>
	<remarks>The passed in expression is interpreted as a stand-alone expression, as if it
 appeared by itself somewhere within the scope that encloses "position".</remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.LookupSymbols(System.Int32,Roslyn.Compilers.VisualBasic.NamespaceOrTypeSymbol,System.String,System.Nullable{System.Int32},Roslyn.Compilers.VisualBasic.LookupOptions,System.Collections.Generic.List{Roslyn.Compilers.VisualBasic.Symbol})">
	<summary>
 Gets the available named symbols in the context of the specified location and optional
 container. Only symbols that are accessible and visible from the given location are
 returned.
 </summary>
	<param name="position">The character position for determining the enclosing declaration
 scope and accessibility.</param>
	<param name="container">The container to search for symbols within. If null then the
 enclosing declaration scope around position is used.</param>
	<param name="name">The name of the symbol to find. If null is specified then symbols
 with any names are returned.</param>
	<param name="arity">The number of generic type parameters the symbol has. If null is
 specified then symbols with any arity are returned.</param>
	<param name="options">Additional options that affect the lookup process.</param>
	<param name="results">An optional list for storing the results. If this is specified as
 is non-null, then returns are added to this list and it is returned. If this is null, a
 new list is created to hold the results and is returned.</param>
	<returns>A list of symbols that were found. If no symbols were found, an empty list is
 returned.</returns>
	<remarks>
 The "position" is used to determine what variables are visible and accessible. Even if
 "container" is specified, the "position" location is significant for determining which
 members of "containing" are accessible. 
 
 Locations are character locations, just as used as the Syntax APIs such as FindToken, or 
 returned from the Span property on tokens and syntax node.
 
 The text of the program is divided into scopes, which nest but don't otherwise
 intersect. When doing an operation such as LookupSymbols, the code first determines the
 smallest scope containing the position, and from there all containing scopes. 
 
 Scopes that span an entire block statement start at the beginning of the first token of 
 the block header, and end immediately before the statement terminator token following
 the end statement of the block. If the end statement of the block is missing, it ends
 immediately before the next token. Examples of these include members and type parameters
 of a type, type parameters of a method, and variables declared in a For statement.
 
 Scopes that span the interior of a block statement start at the statement terminator of 
 the block header statement, and end immediately before the first token of the end
 statement of the block. If the end statement of the block is missing, it ends
 immediately before the next statement. Examples of these include local variables, method
 parameters, and members of a namespace.
 
 Scopes of variables declared in a single-line If statement start at the beginning of the
 "Then" token, and end immediately before the Else token or statement terminator. 
 
 Scopes of variables declared in the Else part of a single-line If start at the beginning
 of the "Else" token, and end immediately before the statement terminator.
 
 Some specialized binding rules are in place for a single statement, like Imports or
 Inherits. These specialized binding rules begin at the start of the first token of the
 statement, and end immediately before the statement terminator of that statement.
 
 In all of the above, the "start" means the start of a token without considering leading
 trivia. In other words, Span.Start, not FullSpan.Start. With the exception of
 documentation comments, all scopes begin at the start of a token, and end immediately
 before the start of a token.
 
 The scope of the default namespace, and all symbols introduced via Imports statements,
 is the entire file.
 
 Positions within a documentation comment that is correctly attached to a symbol take on
 the binding scope of that symbol. 
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.LookupNames(System.Int32,Roslyn.Compilers.VisualBasic.NamespaceOrTypeSymbol,Roslyn.Compilers.VisualBasic.LookupOptions,System.Collections.Generic.List{System.String})">
	<summary>
 Gets the names of the available named symbols in the context of the specified location
 and optional container. Only symbols that are accessible and visible from the given
 location are returned.
 </summary>
	<param name="position">A character position used to identify a declaration scope and
 accessibility. This character position must be within the FullSpan of the Root syntax
 node in this SemanticModel.
 </param>
	<param name="container">The container to search for symbols within. If null then the
 enclosing declaration scope around position is used.</param>
	<param name="options">Additional options that affect the lookup process.</param>
	<param name="results">An optional list for storing the results. If this is specified as
 is non-null, then returns are added to this list and it is returned. If this is null, a
 new list is created to hold the results and is returned.</param>
	<returns>A list of names of symbols that were found. If no symbols were found, an empty list is returned.
 </returns>
	<remarks>
 The "position" is used to determine what variables are visible and accessible. Even if
 "container" is specified, the "position" location is significant for determining which
 members of "containing" are accessible. 
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.IsAccessible(System.Int32,Roslyn.Compilers.VisualBasic.Symbol)">
	<summary>
 Determines if the symbol is accessible from the specified location.
 </summary>
	<param name="position">A character position used to identify a declaration scope and
 accessibility. This character position must be within the FullSpan of the Root syntax
 node in this SemanticModel.
 </param>
	<param name="symbol">The symbol that we are checking to see if it accessible.</param>
	<returns>
 True if "symbol is accessible, false otherwise.</returns>
	<remarks>
 This method only checks accessibility from the point of view of the accessibility
 modifiers on symbol and its containing types. Even if true is returned, the given symbol
 may not be able to be referenced for other reasons, such as name hiding.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.ResolveOverloads(System.Int32,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.MethodSymbol},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.TypeSymbol},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.ArgumentSyntax})">
	<summary>
 Resolves the set of provided arguments against set of provided methods to determine the
 appropriate overload.  The arguments are bound as if they were at 'position' within this
 binding.  An OverloadResolutionResult is returned that gives the result of the compiler's
 overload resolution analysis.
 </summary>
	<param name="position">A character position used to identify a declaration scope and
 accessibility. This character position must be within the FullSpan of the Root syntax
 node in this SemanticModel. This position is used when binding the arguments.
 </param>
	<param name="methods">The set of method to resolve overloads among.</param>
	<param name="arguments">The list of arguments, in order, to use when resolving the
 overloads. The arguments are interpreted as if they occurred within the declaration
 scope that encloses "position".</param>
	<param name="typeArguments">If present, the type argument provided. If not provided,
 type inference is done.</param>
	<remarks>
 This can be used to resolve constructors as well as methods.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.AnalyzeRegionControlFlow(Roslyn.Compilers.TextSpan)">
	<summary>
 Analyze control-flow within a part of a method body. 
 </summary>
	<param name="span">The span of code within the associated SyntaxTree to analyze. The
 span must be fully inside a method body.</param>
	<returns>An object that can be used to obtain the result of the control flow analysis.</returns>
	<exception cref="T:System.ArgumentException">The span is not with a method body.</exception>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.AnalyzeRegionDataFlow(Roslyn.Compilers.TextSpan)">
	<summary>
 Analyze data-flow within a part of a method body. 
 </summary>
	<param name="span">The span of code within the associated SyntaxTree to analyze. The
 span must be fully inside a method body.</param>
	<returns>An object that can be used to obtain the result of the data flow analysis.</returns>
	<exception cref="T:System.ArgumentException">The span is not with a method body.</exception>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetSpeculativeSemanticModel(System.Int32,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Get a SemanticModel object that is associated with an expression that did not appear in
 this source code. This can be used to get detailed semantic information about sub-parts
 of an expression that did not appear in source code. 
 </summary>
	<param name="position">The character position for determining the enclosing declaration
 scope and accessibility.</param>
	<param name="expression">The expression to analyze. This expression does not need to be
 present in the syntax tree associated with this object.</param>
	<returns>A SemanticModel object that can be used to inquire about the semantic
 information associated with syntax nodes within "expression".</returns>
	<remarks>
 If semantic information about just the root node of "expression", the BindExpression
 method can be used instead.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetSpeculativeSemanticModel(System.Int32,Roslyn.Compilers.VisualBasic.StatementSyntax)">
	<summary>
 Get a SemanticModel object that is associated with an expression that did not appear in
 this source code. This can be used to get detailed semantic information about sub-parts
 of an expression that did not appear in source code. 
 </summary>
	<param name="position">The character position for determining the enclosing declaration
 scope and accessibility.</param>
	<param name="statement">The statement to analyze. This statement does not need to be
 present in the syntax tree associated with this object.</param>
	<returns>A SemanticModel object that can be used to inquire about the semantic
 information associated with syntax nodes within "statement".</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.ClassifyConversion(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 Determines what type of conversion, if any, would be used if a given expression was
 converted to a given type.
 </summary>
	<param name="expression">An expression which much occur within the syntax tree
 associated with this object.</param>
	<param name="destination">The type to attempt conversion to.</param>
	<returns>Returns a Conversion object that summarizes whether the conversion was
 possible, and if so, what kind of conversion it was. If no conversion was possible, a
 Conversion object with a false "Exists " property is returned.</returns>
	<remarks>To determine the conversion between two types (instead of an expression and a
 type), use Compilation.ClassifyConversion.</remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.ClassifyConversion(System.Int32,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 Determines what type of conversion, if any, would be used if a given expression was
 converted to a given type.
 </summary>
	<param name="position">The character position for determining the enclosing declaration scope and accessibility.</param>
	<param name="expression">An expression to classify. This expression does not need to be
 present in the syntax tree associated with this object.</param>
	<param name="destination">The type to attempt conversion to.</param>
	<returns>Returns a Conversion object that summarizes whether the conversion was
 possible, and if so, what kind of conversion it was. If no conversion was possible, a
 Conversion object with a false "Exists " property is returned.</returns>
	<remarks>To determine the conversion between two types (instead of an expression and a
 type), use Compilation.ClassifyConversion.</remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetDeclarationDiagnostics(System.Threading.CancellationToken)">
	<summary>
 Get all the syntax and declaration errors within the syntax tree associated with this
 object. Does not get errors involving compiling method bodies or initializers.
 </summary>
	<param name="cancellationToken">A cancellation token that can be used to cancel the
 process of obtaining the diagnostics.</param>
	<remarks>The declaration errors for a syntax tree are cached. The first time this method
 is called, a ll declarations are analyzed for diagnostics. Calling this a second time
 will return the cached diagnostics.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetDiagnostics(System.Threading.CancellationToken)">
	<summary>
 Get all the errors within the syntax tree associated with this object. Includes errors
 involving compiling method bodies or initializers, in addition to the errors returned by
 GetDeclarationDiagnostics.
 </summary>
	<param name="cancellationToken">A cancellation token that can be used to cancel the
 process of obtaining the diagnostics.</param>
	<remarks>
 Because this method must semantically all method bodies and initializers to check for
 diagnostics, it may take a significant amount of time. Unlike GetDeclarationDiagnostics,
 diagnostics for method bodies and initializers are not cached, the any semantic
 information used to obtain the diagnostics is discarded.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.SyntaxNode,System.Threading.CancellationToken)">
	<summary>
 Gets the symbol associated with a declaration syntax node.
 </summary>
	<param name="node">A syntax node that is a declaration. This can be a
 NamespaceStatementSyntax, TypeStatementSyntax, EnumStatementSyntax, MethodBaseSyntax (or
 anything derived from it), ParameterSyntax, TypeParameterSyntax, or a
 ModifiedIdentifierSyntax that is part of a variable declaration. </param>
	<returns>The symbol declared by the node or null if the node is not a declaration.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.ModifiedIdentifierSyntax,System.Threading.CancellationToken)">
	<summary>
 Given an modified identifier that is part of a variable declaration, get the
 corresponding symbol.
 </summary>
	<param name="identifierSyntax">The modified identifier that declares a variable.</param>
	<returns>The symbol that was declared, or Nothing if no such symbol exists.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.EnumMemberDeclarationSyntax,System.Threading.CancellationToken)">
	<summary>
 Given a declarationSyntax that is part of a enum constant declaration, get the
 corresponding symbol.
 </summary>
	<param name="declarationSyntax">The declarationSyntax that declares a variable.</param>
	<returns>The symbol that was declared, or Nothing if no such symbol exists.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.TypeStatementSyntax,System.Threading.CancellationToken)">
	<summary>
 Given a type declaration, get the corresponding type symbol.
 </summary>
	<param name="declarationSyntax">The syntax node that declares a type.</param>
	<returns>The type symbol that was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.TypeBlockSyntax,System.Threading.CancellationToken)">
	<summary>
 Given a type block, get the corresponding type symbol.
 </summary>
	<param name="declarationSyntax">The syntax node that declares a type block.</param>
	<returns>The type symbol that was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.EnumStatementSyntax,System.Threading.CancellationToken)">
	<summary>
 Given a enum declaration, get the corresponding type symbol.
 </summary>
	<param name="declarationSyntax">The syntax node that declares an enum.</param>
	<returns>The type symbol that was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.EnumBlockSyntax,System.Threading.CancellationToken)">
	<summary>
 Given a enum block, get the corresponding type symbol.
 </summary>
	<param name="declarationSyntax">The syntax node that declares an enum block.</param>
	<returns>The type symbol that was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.NamespaceStatementSyntax,System.Threading.CancellationToken)">
	<summary>
 Given a namespace declaration, get the corresponding type symbol.
 </summary>
	<param name="declarationSyntax">The syntax node that declares a namespace.</param>
	<returns>The namespace symbol that was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.NamespaceBlockSyntax,System.Threading.CancellationToken)">
	<summary>
 Given a namespace block, get the corresponding type symbol.
 </summary>
	<param name="declarationSyntax">The syntax node that declares a namespace block.</param>
	<returns>The namespace symbol that was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.MethodBaseSyntax,System.Threading.CancellationToken)">
	<summary>
 Given a method, property, or event declaration, get the corresponding symbol.
 </summary>
	<param name="declarationSyntax">The syntax node that declares a method, property, or event.</param>
	<returns>The method, property, or event symbol that was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.ParameterSyntax,System.Threading.CancellationToken)">
	<summary>
 Given a parameter declaration, get the corresponding parameter symbol.
 </summary>
	<param name="parameter">The syntax node that declares a parameter.</param>
	<returns>The parameter symbol that was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.TypeParameterSyntax,System.Threading.CancellationToken)">
	<summary>
 Given a type parameter declaration, get the corresponding type parameter symbol.
 </summary>
	<param name="typeParameter">The syntax node that declares a type parameter.</param>
	<returns>The type parameter symbol that was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.ConstructorStatementSyntax,System.Threading.CancellationToken)">
	<summary>
 Given a constructor statement syntax get the corresponding method symbol.
 </summary>
	<param name="declarationSyntax">The syntax node that declares a constructor.</param>
	<returns>The method symbol that was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.MethodStatementSyntax,System.Threading.CancellationToken)">
	<summary>
 Given a method statement syntax get the corresponding method symbol.
 </summary>
	<param name="declarationSyntax">The syntax node that declares a method.</param>
	<returns>The method symbol that was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.MethodBlockSyntax,System.Threading.CancellationToken)">
	<summary>
 Given a method block syntax get the corresponding method, property or event symbol.
 </summary>
	<param name="declarationSyntax">The syntax node that declares method, property or event.</param>
	<returns>The method, property or event symbol that was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.PropertyStatementSyntax,System.Threading.CancellationToken)">
	<summary>
 Given a property statement syntax get the corresponding property symbol.
 </summary>
	<param name="declarationSyntax">The syntax node that declares a property.</param>
	<returns>The property symbol that was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.PropertyBlockSyntax,System.Threading.CancellationToken)">
	<summary>
 Given a property block syntax get the corresponding property symbol.
 </summary>
	<param name="declarationSyntax">The syntax node that declares property.</param>
	<returns>The property symbol that was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.AccessorStatementSyntax,System.Threading.CancellationToken)">
	<summary>
 Given a property block syntax get the corresponding property symbol.
 </summary>
	<param name="declarationSyntax">The syntax node that declares property.</param>
	<returns>The property symbol that was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.AliasImportsClauseSyntax,System.Threading.CancellationToken)">
	<summary>
 Given an import clause get the corresponding symbol for the import alias that was introduced.
 </summary>
	<param name="declarationSyntax">The import statement syntax node.</param>
	<returns>The alias symbol that was declared or Nothing if no alias symbol was declared.</returns>
</member><member name="P:Roslyn.Compilers.VisualBasic.SemanticModel.SyntaxTree">
	<summary> 
 The SyntaxTree that is bound
 </summary>
	<remarks>
 Returns null if this is a binding returned by GetSpeculativeSemanticModel.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.SemanticModel">
	<summary>
 Allows asking semantic questions about a tree of syntax nodes in a Compilation. Typically,
 an instance is obtained by a call to Compilation.GetBinding. 
 </summary>
	<remarks>
		<para>An instance of SemanticModel caches local symbols and semantic information. Thus, it
 is much more efficient to use a single instance of SemanticModel when asking multiple
 questions about a syntax tree, because information from the first question may be reused.
 This also means that holding onto an instance of SemanticModel for a long time may keep a
 significant amount of memory from being garbage collected.
 </para>
		<para>
 When an answer is a named symbol that is reachable by traversing from the root of the symbol
 table, (that is, from an AssemblySymbol of the Compilation), that symbol will be returned
 (i.e. the returned value will be reference-equal to one reachable from the root of the
 symbol table). Symbols representing entities without names (e.g. array-of-int) may or may
 not exhibit reference equality. However, some named symbols (such as local variables) are
 not reachable from the root. These symbols are visible as answers to semantic questions.
 When the same SemanticModel object is used, the answers exhibit reference-equality.  
 </para>
	</remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.OldSemanticInfo.GetNonErrorGuessForErrorType(Roslyn.Compilers.VisualBasic.Symbol)">
	<summary>
 Guess the non-error type that the given type was intended to represent.
 If the type itself is not an error type, then it will be returned.
 Otherwise, the underlying type (if any) of the error type will be returned.
 </summary>
	<remarks>
 Any non-null type symbol returned is guaranteed not to be an error type.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.OldSemanticInfo.Type">
	<summary>
 The type of the expression represented by the syntax node. For expressions that do not
 have a type, null is returned. If the type could not be determined due to an error, then
 an object derived from ErrorTypeSymbol is returned.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.OldSemanticInfo.Symbols">
	<summary>
 The set of symbols of that are referred to by the syntax node. For example, for a syntax node that is the
 name of a field, the symbol that represents that field would be returned. Some expressions, such as built-in
 operators, do not refer to symbols; in this case, an empty collection is returned. 
 </summary>
	<remarks>
 In some cases, multiple symbols are returned. For example, when examining a name that refers to a method
 group, all the methods in the group are returned. When examining an invocation syntax node, however, only
 the method that overload resolution chose will be returned. 
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.OldSemanticInfo.Diagnostics">
	<summary>
 Any semantic diagnostics that were directly related to the syntax node. 
 </summary>
	<remarks>
 Does not return syntax errors, or errors relating to sub-expressions.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.OldSemanticInfo.AllErrorDiagnostics">
	<summary>
 All error diagnostics that are inside the given node. Includes syntax errors, and errors on sub-expressions
 of the node.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.OldSemanticInfo.AllWarningDiagnostics">
	<summary>
 All warning diagnostics that are inside the given node. Includes syntax warning, and warnings on sub-expressions
 of the node.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.OldSemanticInfo.None">
	<summary>
 A pre-created instance of SemanticInfo that has a "null" type, no symbols, and no diagnostics.  
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.OldSemanticInfo">
	<summary>
 Summarizes the semantic information about a syntax node. Includes the symbol(s),
 the type, and any errors resulting from binding.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.OverloadResolutionResult.Succeeded">
	<summary>
 True if overload resolution successfully selected a single best method.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.OverloadResolutionResult.ValidResult">
	<summary>
 If overload resolution successfully selected a single best method, returns information
 about that method. Otherwise returns Nothing.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.OverloadResolutionResult.BestResult">
	<summary>
 If there was a method that overload resolution considered better than all others,
 returns information about that method. A method may be returned even if that method was
 not considered a successful overload resolution, as long as it was better than any other
 potential method considered.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.OverloadResolutionResult.Results">
	<summary>
 Returns information about each method that was considered during overload resolution,
 and what the results of overload resolution were for that method.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.OverloadResolutionResult">
	<summary>
 Summarizes the results of an overload resolution analysis. Describes whether overload resolution 
 succeeded, and which method was selected if overload resolution succeeded.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.MethodResolutionKind">
	<summary>
 Indicates whether the compiler accepted or rejected the method during overload resolution.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodResolutionResult.Method">
	<summary>
 The method considered during overload resolution.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodResolutionResult.Resolution">
	<summary>
 Indicates why the compiler accepted or rejected the method during overload resolution.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodResolutionResult.IsValid">
	<summary>
 Returns true if the compiler accepted this method as the sole correct result of overload resolution.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodResolutionResult.IsExpandedParamArrayForm">
	<summary>
 Returns true if the method is considered in its expanded param array form.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.MethodResolutionResult">
	<summary>
 Represents the results of overload resolution for a single method.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SemanticInfo.Type">
	<summary>
 The type of the expression represented by the syntax node. For expressions that do not
 have a type, null is returned. If the type could not be determined due to an error, than
 an object derived from ErrorTypeSymbol is returned.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SemanticInfo.ConvertedType">
	<summary>
 The type of the expression after it has undergone an implicit conversion. If the type
 did not undergo an implicit conversion, returns the same as Type.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SemanticInfo.ImplicitConversion">
	<summary>
 If the expression underwent an implicit conversion, return information about that
 conversion. Otherwise, returns an identity conversion.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SemanticInfo.Symbol">
	<summary>
 The symbol that was referred to by the syntax node, if any. Returns null if the given
 expression did not bind successfully to a single symbol. If null is returned, it may
 still be that case that we have one or more "best guesses" as to what symbol was
 intended. These best guesses are available via the CandidateSymbols property.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SemanticInfo.CandidateSymbols">
	<summary>
 If the expression did not successfully resolve to a symbol, but there were one or more
 symbols that may have been considered but discarded, this property returns those
 symbols. The reason that the symbols did not successfully resolve to a symbol are
 available in the CandidateReason property. For example, if the symbol was inaccessible,
 ambiguous, or used in the wrong context.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SemanticInfo.CandidateReason">
	<summary>
 If the expression did not successfully resolve to a symbol, but there were one or more
 symbols that may have been considered but discarded, this property describes why those
 symbol or symbols were not considered suitable.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SemanticInfo.MemberGroup">
	<summary>
 When getting information for a symbol that resolves to a method or property group, from which a
 method or property is then chosen; the chosen method or property is present in Symbol; all methods in the
 group that was consulted are placed in this property.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SemanticInfo.IsCompileTimeConstant">
	<summary>
 Returns true if the expression is a compile-time constant. The value of the constant can
 be obtained with the ConstantValue property.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SemanticInfo.ConstantValue">
	<summary>
 If IsCompileTimeConstant returns true, then returns the constant value of the field or
 enum member. If IsCompileTimeConstant returns false, then returns null.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticInfo.GetPossibleGuessForErrorType(Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 Guess the non-error type that the given type was intended to represent, or return
 the type itself. If a single, non-ambiguous type is a guess-type inside the type symbol, 
 return that; otherwise return the type itself (even if it is an error type).
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SemanticInfo">
	<summary>
 Summarizes the semantic information about a syntax node. 
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.EmitResult.Diagnostics">
	<summary> 
 A list of all the diagnostics associated with compilations. This include parse errors, declaration errors,
 compilation errors, and emitting errors.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.EmitResult.Success">
	<summary> 
 Returns whether or not the compilation successfully produced an executable. If this is false, the
 Diagnostics should include at least one error diagnostic indicating why.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.EmitResult">
	<summary>
 The result of the Compilation Emit operation. 
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.BoundNodeSummary">
	<summary>
 This structure holds the relevant bound node information relating to a particular syntax
 node, used temporarily for GetSemanticInfo and similar APIs. 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CompilationOptions.#ctor(System.Collections.Generic.IEnumerable{Roslyn.Compilers.VisualBasic.GlobalImport},System.String,Roslyn.Compilers.VisualBasic.OptionStrict,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,Roslyn.Compilers.AssemblyKind)">
	<summary>
 Create a new CompilationOptions instance.
 </summary>
	<param name="globalImports"></param>
	<param name="rootNamespace"></param>
	<param name="optionStrict"></param>
	<param name="optionInfer"></param>
	<param name="optionExplicit"></param>
	<param name="optionCompareText"></param>
	<param name="optionRemoveIntegerOverflowChecks"></param>
	<param name="isNetModule"></param>
	<param name="assemblyKind"></param>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.CompilationOptions.Copy(System.Collections.Generic.IEnumerable{Roslyn.Compilers.VisualBasic.GlobalImport},System.String,System.Nullable{Roslyn.Compilers.VisualBasic.OptionStrict},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{Roslyn.Compilers.AssemblyKind})">
	<summary>
 Create a new CompilationOptions instance based on this instance with specific options updated to the
 corresponding argument value if the corresponding argument is not null. Any argument not specified result in
 the corresponding option value being retained from the option value in this instance.
 </summary>
	<param name="globalImports"></param>
	<param name="rootNamespace"></param>
	<param name="optionStrict"></param>
	<param name="optionInfer"></param>
	<param name="optionExplicit"></param>
	<param name="optionCompareText"></param>
	<param name="optionRemoveIntegerOverflowChecks"></param>
	<param name="isNetModule"></param>
	<param name="assemblyKind"></param>
	<returns></returns>
	<remarks></remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.CompilationOptions.GlobalImports">
	<summary>
 The list of global imports.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CompilationOptions.RootNamespace">
	<summary>
 The default namespace for all source code in the project. Corresponds to the 
 "RootNamespace" project option or the "/rootnamespace" command line option.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CompilationOptions.OptionStrict">
	<summary>
 True if Option Strict On is in effect by default. False if Option Strict Off is in effect by default.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CompilationOptions.OptionInfer">
	<summary>
 True if Option Infer On is in effect by default. False if Option Infer Off is in effect by default.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CompilationOptions.IsNetModule">
	<summary>
 Retrieves the TargetValue setting of this compilation
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CompilationOptions.AssemblyKind">
	<summary>
 The kind of assembly that will be generated when emitted.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CompilationOptions.OptionExplicit">
	<summary>
 True if Option Explicit On is in effect by default. False if Option Explicit Off is in
 effect by default.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CompilationOptions.OptionCompareText">
	<summary>
 True if Option Compare Text is in effect by default. False if Option Compare Binary is
 in effect by default.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CompilationOptions.OptionRemoveIntegerOverflowChecks">
	<summary>
 True if integer overflow checking is off. 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CompilationOptions.GetOptionNames">
	<summary>
 Get the list of option names.
 </summary>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.CompilationOptions.HasOption(System.String)">
	<summary>
 True if the CompilationOptions has the specified option.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CompilationOptions.GetOption(System.String)">
	<summary>
 Get the option value for the specified option.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CompilationOptions.SetOption(System.String,System.String)">
	<summary>
 Create a new CompilationOptions instance including the specified option value.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CommandLineArguments.ParseConditionalCompilationSymbols(System.String)">
	<summary>
 Given the string of conditional compilation symbols from the project system, parse them into an IDictionary
 ready to be given to the compilation.
 </summary>
	<param name="symbolList">The conditional compilation string. This takes the form of a comma delimited list
 of NAME=Value pairs, where Value may be a quoted string or integer.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.CodeGen.CodeGenerator.GetLocal(Roslyn.Compilers.VisualBasic.BoundLocal)">
	<summary>
 Gets already declared and initialized local.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CodeGen.CodeGenerator.AllocateTemp(Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 Allocates a temp without identity.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CodeGen.CodeGenerator.FreeTemp(Roslyn.Compilers.CodeGen.LocalDefinition)">
	<summary>
 Frees a temp without identity.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CodeGen.CodeGenerator.CanUseCallOnRefTypeReceiver(Roslyn.Compilers.VisualBasic.BoundExpression)">
	<summary>
 Used to decide if we need to emit call or callvirt.
 It basically checks if the receiver expression cannot be null, but it is not 100% precise. 
 There are cases where it really can be null, but we do not care.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CodeGen.CodeGenerator.EmitVectorElementStore(Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 Emit an element store instruction for a single dimensional array.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CodeGen.CodeGenerator.EmitAddress(Roslyn.Compilers.VisualBasic.BoundExpression,System.Boolean)">
	<summary>
 Emits address as in &amp; 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CodeGen.CodeGenerator.EmitAddressOfTempClone(Roslyn.Compilers.VisualBasic.BoundExpression)">
	<summary>
 Emits address of a temp.
 Used in cases where taking address directly is not possible 
 (typically because expression does not have a home)
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CodeGen.CodeGenerator.HasHome(Roslyn.Compilers.VisualBasic.BoundExpression)">
	<summary>
 Checks if expression represents directly or indirectly a value with its own home.
 In such cases it is possible to get a reference without loading into a temporary.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CodeGen.CodeGenerator.HasHome(Roslyn.Compilers.VisualBasic.BoundFieldAccess)">
	<summary>
 Special HasHome for fields. Fields have homes when they are writeable.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CodeGen.CodeGenerator.EmitReceiverRef(Roslyn.Compilers.VisualBasic.BoundExpression,System.Boolean)">
	<summary>
 Emits receiver in a form that allows member accesses ( O or &amp;  ). For verifiably
 reference types it is the actual reference. For generic types it is a address of the
 receiver with readonly intent. For the value types it is an address of the receiver.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.UnboundLambda.IsSingleLine">
	<summary>
 Should this lambda be treated as a single line lambda?
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.UnboundLambda.IsFunctionLambda">
	<summary>
 Is this a function lambda
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.UnboundLambda.AllowRelaxationSemantics">
	<summary>
 Should delegate relaxation behavior be allowed for this lambda.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.BoundNode.WasCompilerGenerated">
	<summary>
 The node should not be treated as a direct semantical representation of the syntax it is associated with. 
 Some examples: 
 - implicit call for base constructor is associated with the constructor syntax.
 - code in compiler generated constructor is associated with the type declaration.
 
 Nodes marked this way are likely to be skipped by SemanticModel, Sequence Point rewriter, etc.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.BoundFieldAccess.CreateSimple(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.SyntaxTree,Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.FieldSymbol)">
	<summary>
 Create access node for a 'simple' read-write field.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.BoundExpressionExtensions.IsPropertySupportingAssignment(Roslyn.Compilers.VisualBasic.BoundExpression)">
	<summary>
 Does this node represent a property with Set accessor and AccessKind not yet bound to Get?
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.BoundExpressionExtensions.IsIntegerZeroLiteral(Roslyn.Compilers.VisualBasic.BoundExpression)">
	<summary>
 Return true if and only if an expression is a integral literal with a value of zero.
 Non-literal constant value zero does not qualify.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.BoundExpressionExtensions.IsIntegerZeroLiteral(Roslyn.Compilers.VisualBasic.BoundLiteral)">
	<summary>
 Return true if and only if an expression is a integral literal with a value of zero.
 Non-literal constant value zero does not qualify.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.BoundExpressionExtensions.IsNegativeIntegerConstant(Roslyn.Compilers.VisualBasic.BoundExpression)">
	<summary>
 Checks if the expression is a negative integer constant value.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.BoundExpressionExtensions.GetIntegerConstantValue(Roslyn.Compilers.VisualBasic.BoundExpression)">
	<summary>
 Return the integer constant value (if any) from a BoundExpression
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.BoundExpressionExtensions.IsNothingLiteral(Roslyn.Compilers.VisualBasic.BoundExpression)">
	<summary>
 Return true if and only if an expression is a semantical Nothing literal, 
 which is defined as follows (the definition is consistent with 
 definition used by Dev10 compiler):
 - A Nothing literal according to the language grammar, or
 - A parenthesized expression, for which IsNothingLiteral returns true, or
 - An expression of type Object with constant value == Nothing.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.BoundExpressionExtensions.IsNothingLiteral(Roslyn.Compilers.VisualBasic.BoundLiteral)">
	<summary>
 Return true if target BoundLiteral represents Nothing literal as defined by the language grammar.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.BoundExpressionExtensions.IsStrictNothingLiteral(Roslyn.Compilers.VisualBasic.BoundExpression)">
	<summary>
 Return true if and only if an expression represents optionally 
 parenthesized Nothing literal as defined by the language grammar. 
 I.e. implicit conversions are Ok, but explicit conversions aren't.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.BoundExpression.IsLValue">
	<summary>
 Does expression refer to a physical memory location that can be modified?
 
 Note, Dev10 uses SXF_LVALUE flag on bound nodes to represent this concept.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindTypeSyntax(Roslyn.Compilers.VisualBasic.TypeSyntax,Roslyn.Compilers.DiagnosticBag,System.Boolean)">
	<summary>
 Bind a type name using the given binder. Returns a type symbol if the binding bound to something,
 or an error symbol if the binding failed. In either case, errors may be reported via the
 context. For example, if an inaccessible type or type with the wrong arity was found, the best possible
 type is returned, but an error is also generated.
 </summary>
	<param name="typeSyntax">The syntax to bind.</param>
	<param name="diagBag">Place to put diagnostics. If no reasonable type was found, an undefined type
 diagnostic is placed in here. Other diagnostics (both related to the type being bound, or
 type arguments thereof) can be placed here also. </param>
	<returns>The best type that can be found, or and ErrorTypeSymbol if no reasonable type can be found.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindTypeSyntaxForGetType(Roslyn.Compilers.VisualBasic.TypeSyntax,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Binding helper that is supposed to be called when GetType is bound.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindNamespaceOrTypeSyntax(Roslyn.Compilers.VisualBasic.TypeSyntax,Roslyn.Compilers.DiagnosticBag,System.Boolean)">
	<summary>
 Bind a type or namespace using the given binder. 
 </summary>
	<param name="typeSyntax">The syntax to bind.</param>
	<returns>The best type or namespace that can be found, or and ErrorTypeSymbol if no reasonable type can be found.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.ConstructAndValidateConstraints(Roslyn.Compilers.VisualBasic.NamedTypeSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol[],Roslyn.Compilers.VisualBasic.SyntaxNode,System.Collections.Generic.IEnumerable{Roslyn.Compilers.VisualBasic.SyntaxNode})">
	<summary>
 Apply generic type arguments, returning the constructed type. Produces errors for constraints
 that aren't validated. If the wrong number of type arguments are supplied, the set of types
 is silently truncated or extended with the type parameters.
 </summary>
	<param name="genericType">The type to construct from</param>
	<param name="typeArguments">The types to apply</param>
	<param name="syntaxWhole">The place to report errors for the generic type as a whole</param>
	<param name="syntaxArguments">The place to report errors for each generic type argument.</param>
	<returns>The constructed generic type.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.ResolveOverloadedMethodsOrConstructors(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.MethodSymbol},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.TypeSymbol},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.ArgumentSyntax})">
	<summary>
 Resolves overloaded methods or constructors for SemanticModel.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.TypeBinder.BindTypeSyntax(Roslyn.Compilers.VisualBasic.TypeSyntax,Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.DiagnosticBag,System.Boolean)">
	<summary>
 Bind a type name using the given binder. Returns a type symbol if the binding bound
 to something, or an error symbol if the binding failed. In either case, errors may
 be reported via the context. For example, if an inaccessible type or type with the
 wrong arity was found, the best possible type is returned, but an error is also
 generated.
 </summary>
	<param name="typeSyntax">The syntax to bind.</param>
	<param name="binder">The binder to bind within. This binder is used for looking up
 unqualified names, accessibility checking, reporting errors, and probably other
 stuff too.</param>
	<returns>The best type that can be found, or and ErrorTypeSymbol if no reasonable type can be found.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.TypeBinder.BindNamespaceOrTypeSyntax(Roslyn.Compilers.VisualBasic.TypeSyntax,Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.DiagnosticBag,System.Boolean)">
	<summary>
 Bind a type or namespace using the given binder. 
 </summary>
	<param name="typeSyntax">The syntax to bind.</param>
	<param name="binder">The binder to bind within. This binder is used for looking up
 unqualified names, accessibility checking, reporting errors, and probably other stuff too.</param>
	<returns>The best type or namespace that can be found, or and ErrorTypeSymbol if no reasonable type can be found.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.TypeBinder.LookupTypeOrNamespaceSyntax(Roslyn.Compilers.VisualBasic.LookupResult,Roslyn.Compilers.VisualBasic.TypeSyntax,Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.DiagnosticBag,System.Boolean@,System.Boolean,System.Boolean)">
	<summary>
 Lookup a typeSyntax, confining the lookup to namespaces or types. Returns a LookupResult
 that summarizes the results of the lookup, which might contain a Diagnostic associated with the lookup.
 However, other diagnostics associated with parts of the binding process (i.e., binding type arguments) 
 will be emitted via the diagnostic bag.
 
 The LookupResult will always have at most one symbol in it, since types and namespaces are not overloadable symbols.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.TypeBinder.CheckSymbolIsType(Roslyn.Compilers.VisualBasic.NamespaceOrTypeSymbol,Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Check that the given symbol is a type. If it is a namespace, report an error into the diagnostic bag
 and return an error symbol.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.TypeBinder.LookupPredefinedTypeName(Roslyn.Compilers.VisualBasic.PredefinedTypeSyntax,Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.DiagnosticBag,System.Boolean@,System.Boolean)">
	<summary>
 Bind a built in type name to the correct type symbol.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.TypeBinder.LookupArrayType(Roslyn.Compilers.VisualBasic.ArrayTypeSyntax,Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.DiagnosticBag,System.Boolean)">
	<summary>
 Bind array type syntax to the correct type symbol.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.TypeBinder.LookupNullableType(Roslyn.Compilers.VisualBasic.NullableTypeSyntax,Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.DiagnosticBag,System.Boolean)">
	<summary>
 Bind Nullable (?) type syntax to the correct type symbol.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.TypeBinder.LookupBasicName(Roslyn.Compilers.VisualBasic.LookupResult,Roslyn.Compilers.VisualBasic.IdentifierNameSyntax,Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Bind a basic name to a type or namespace.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.TypeBinder.LookupGenericName(Roslyn.Compilers.VisualBasic.LookupResult,Roslyn.Compilers.VisualBasic.GenericNameSyntax,Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.DiagnosticBag,System.Boolean)">
	<summary>
 Bind a generic name to a type.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.TypeBinder.LookupDottedName(Roslyn.Compilers.VisualBasic.LookupResult,Roslyn.Compilers.VisualBasic.QualifiedNameSyntax,Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.DiagnosticBag,System.Boolean@,System.Boolean)">
	<summary>
 Bind a dotted name to a type or namespace.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.TypeBinder.LookupGenericDottedName(Roslyn.Compilers.VisualBasic.LookupResult,Roslyn.Compilers.VisualBasic.QualifiedNameSyntax,Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.DiagnosticBag,System.Boolean@,System.Boolean)">
	<summary>
 Bind a generic dotted name to a type or namespace.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.TypeBinder.LookupGlobalName(Roslyn.Compilers.VisualBasic.GlobalNameSyntax,Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 Bind to the global namespace.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.TypeBinder.BindTypeArguments(Roslyn.Compilers.VisualBasic.TypeArgumentListSyntax,Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.DiagnosticBag,System.Boolean)">
	<summary>
 Bind a list of type arguments to their types.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.TypeBinder.GetBaseNamesForDiagnostic(Roslyn.Compilers.VisualBasic.TypeSyntax)">
	<summary>
 Given a type syntax, strip out ?, (), (of xxx) stuff and return a string of the form
 x.y.z, for use in an error message.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Binder.TypeBinder">
	<summary>
 The type binder class handles binding of type names.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.DisallowTypeCharacter(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.VisualBasic.ERRID)">
	<summary>
 If the identifier has a type character, report an error on it.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.FindFirstKeyword(Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxKind[])">
	<summary>
 Given a list of keywords and an set of keywords kinds to search, return the first keyword
 in the list, if any, that matches one of the keyword kinds.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.DecodeModifiers(Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SourceMemberFlags,Roslyn.Compilers.VisualBasic.ERRID,Roslyn.Compilers.VisualBasic.Accessibility,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Decodes a set of modifier flags, reported any errors with the flags.
 </summary>
	<param name="syntax">The syntax list of the modifiers.</param>
	<param name="allowableModifiers">A bit-flag of the allowable modifiers. If a bit isn't set, an error occurs.</param>
	<param name="errIdBadModifier">Error ID to report if a bad modifier is found.</param>
	<param name="defaultAccessibility">The default accessibility. </param>
	<returns>Flags for the modifiers.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.DecodeParameterModifiers(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.Binder.CheckParameterModifierDelegate,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Decode a list of parameter modifiers, and return the flags associated with it.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.CreateNullableOf(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Create the Nullable version of a type.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.ApplyArrayRankSpecifersToType(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.ArrayRankSpecifierSyntax})">
	<summary>
 Possible create the array version of type, given the element type and the array modifier syntax.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.ApplyArrayRankSpecifiersAndBoundsToType(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.ArrayRankSpecifierSyntax},Roslyn.Compilers.VisualBasic.ArgumentListSyntax)">
	<summary>
 Possibly create the array version of type, given the element type and the array modifier syntax.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.CreateArrayOf(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.ArrayRankSpecifierSyntax},Roslyn.Compilers.VisualBasic.ArgumentListSyntax)">
	<summary>
 Create the array version of type, given the element type and the array modifier syntax. Throws if
 there aren't any array modifiers and the result is not an array type.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.HasDefaultType(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 Given an identifier and an As clause, return true if the identifier does not have a type
 declared for it (e.g., no type character and no as clause).
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.HasDefaultType(Roslyn.Compilers.VisualBasic.ModifiedIdentifierSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 Given an identifier and an As clause, return true if the identifier does not have a type
 declared for it (e.g., no type character and no as clause).
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.DecodeModifiedIdentifierType(Roslyn.Compilers.VisualBasic.ModifiedIdentifierSyntax,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.AsClauseSyntax,System.Func{Roslyn.Compilers.DiagnosticInfo},Roslyn.Compilers.DiagnosticBag,System.Boolean)">
	<summary>
 Given a modified identifier and a type, return the actual type to use. Applies the type character
 and type modifiers to the given type.
 </summary>
	<param name="modifiedIdentifier">The modified identifier.</param>
	<param name="asClauseType">Bound type after the As. Can be nothing if no type was supplied.</param>
	<param name="getRequireTypeDiagnosticInfoFunc">Delegate to get diagnostic info to generate if a required type is missing (Option Strict On/Custom) </param>
	<returns>The type, as modified by the type character, type modifiers. Uses Object as default if needed.</returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.DecodeModifiedIdentifierType(Roslyn.Compilers.VisualBasic.ModifiedIdentifierSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax,System.Func{Roslyn.Compilers.DiagnosticInfo},Roslyn.Compilers.DiagnosticBag,System.Boolean)">
	<summary>
 Given a modified identifier and a type syntax, return the actual type to use. Applies the type character
 and type modifiers to the given type.
 </summary>
	<param name="modifiedIdentifier">The modified identifier.</param>
	<param name="asClause"> As clause syntax. Can be nothing if no type was supplied.</param>
	<param name="getRequireTypeDiagnosticInfoFunc">Delegate to get diagnostic info to generate if a required type is missing (Option Strict On/Custom) </param>
	<returns>The type, as modified by the type character, type modifiers. Uses Object as default if needed.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.DecodeIdentifierType(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.AsClauseSyntax,System.Func{Roslyn.Compilers.DiagnosticInfo},Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Given a identifier and as clause syntax, return the actual type to use. Uses the type character or the type syntax.
 </summary>
	<param name="identifier">The identifier.</param>
	<param name="asClause">Syntax for optional as clause. Can be nothing if no type was supplied.</param>
	<param name="getRequireTypeDiagnosticInfoFunc">Delegate to get diagnostic info to generate if a required type is missing (Option Strict On/Custom) </param>
	<returns>The type, either from the type character or the as clause. Uses Object as default if needed.</returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.DecodeIdentifierType(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeSymbol,System.Func{Roslyn.Compilers.DiagnosticInfo},Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Given a identifier and a type, return the actual type to use. Uses the type character or the given type.
 </summary>
	<param name="identifier">The identifier.</param>
	<param name="asClauseType">Bound type after the As. Can be nothing if no type was supplied.</param>
	<param name="getRequireTypeDiagnosticInfoFunc">Delegate to get diagnostic info to generate if a required type is missing (Option Strict On/Custom) </param>
	<returns>The type, either from the type character or the as clause type. Uses Object as default if needed.</returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.DecodeOnOff(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Decode an option "On" or "Off" values into true or false. Not specified is considered true.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.DecodeTextBinary(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Decode an option "Text" or "Binary" value into true or false. The syntax is not optional.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.DecodeParameterListOfDelegateDeclaration(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.DiagnosticBag,System.Threading.CancellationToken)">
	<summary>
 Decode a parameter list from a delegate declaration into a list of parameter symbols.
 </summary>
	<param name="container">Containing method declaration.</param>
	<param name="syntaxOpt">Optional parameter list syntax</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.DecodeParameterList(Roslyn.Compilers.VisualBasic.Symbol,System.Boolean,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.DiagnosticBag,System.Threading.CancellationToken)">
	<summary>
 Decode a parameter list into a list of parameter symbols.
 </summary>
	<param name="container">Containing method declaration.</param>
	<param name="isFromLambda">Parameter is for a lambda expression rather than a regular method.</param>
	<param name="syntaxOpt">Optional parameter list syntax</param>
	<remarks>DO NOT call this to get the parameters of a delegate declaration (<see>DecodeParameterListOfDelegateDeclaration</see>).</remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.DecodePropertyParameterList(Roslyn.Compilers.VisualBasic.PropertySymbol,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.DiagnosticBag,System.Threading.CancellationToken)">
	<summary>
 Decode a parameter list into a list of parameter symbols.
 </summary>
	<param name="container">Containing property declaration.</param>
	<param name="syntaxOpt">Optional parameter list syntax</param>
</member><member name="T:Roslyn.Compilers.VisualBasic.SourceMemberFlags">
	<summary>
 Holds information about a member in a compact form. Used for all non-type members for simplicity
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.MemberModifiers._foundFlags">
	<summary>
 These are the flags that are found in the syntax.  They must correspond to the modifiers list.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.MemberModifiers._computedFlags">
	<summary>
 These are flags that are implied or computed
 </summary>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindFieldAndEnumConstantInitializer(Roslyn.Compilers.VisualBasic.FieldSymbol,Roslyn.Compilers.VisualBasic.SyntaxNode,System.Boolean,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Binds constant initialization value of the field.
 </summary>
	<param name="fieldSymbol">The symbol.</param>
	<param name="equalsValueOrAsNewSyntax">The initialization syntax.</param>
	<param name="diagnostics">The diagnostics.</param><returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.ReportDiagnosticsForNonConstantExpression(Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Report diagnostics for non constant expressions in boundInitValue.
 </summary>
	<param name="node">The bound node representing the value that should be constant</param>
	<param name="diagnostics">The diagnostics bag.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindBlock(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Binds a list of statements and puts in a scope.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ExecutableCodeSemanticModel.GetOutermostLambda(Roslyn.Compilers.VisualBasic.SyntaxNode)">
	<summary>
 Get outermost lambda containing this node. Inclusively.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ExecutableCodeSemanticModel.UpdateGuardedMap(Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.DiagnosticBag,System.Func{Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.VisualBasic.BoundNode})">
	<summary> Expose guarded map update so that inheritors can use it without access to guardedNodeMap </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.MemberLookup.Lookup(Roslyn.Compilers.VisualBasic.LookupResult,Roslyn.Compilers.VisualBasic.NamespaceOrTypeSymbol,System.String,System.Int32,Roslyn.Compilers.VisualBasic.LookupOptions,Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 Lookup a member name in a namespace or type, returning a LookupResult that
 summarizes the results of the lookup. See LookupResult structure for a detailed
 discussing of the meaning of the results. The supplied binder is used for accessibility
 checked and base class suppression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.MemberLookup.Lookup(Roslyn.Compilers.VisualBasic.LookupResult,Roslyn.Compilers.VisualBasic.NamespaceSymbol,System.String,System.Int32,Roslyn.Compilers.VisualBasic.LookupOptions,Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 Lookup a member name in a namespace, returning a LookupResult that
 summarizes the results of the lookup. See LookupResult structure for a detailed
 discussing of the meaning of the results. The supplied binder is used for accessibility
 checked and base class suppression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.MemberLookup.LookupImmediate(Roslyn.Compilers.VisualBasic.LookupResult,Roslyn.Compilers.VisualBasic.NamespaceSymbol,System.String,System.Int32,Roslyn.Compilers.VisualBasic.LookupOptions,Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 Lookup an immediate (without decending into modules) member name in a namespace, 
 returning a LookupResult that summarizes the results of the lookup. 
 See LookupResult structure for a detailed discussion of the meaning of the results. 
 The supplied binder is used for accessibility checks and base class suppression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.MemberLookup.LookupInModules(Roslyn.Compilers.VisualBasic.LookupResult,Roslyn.Compilers.VisualBasic.NamespaceSymbol,System.String,System.Int32,Roslyn.Compilers.VisualBasic.LookupOptions,Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 Lookup a member name in modules of a namespace, 
 returning a LookupResult that summarizes the results of the lookup. 
 See LookupResult structure for a detailed discussion of the meaning of the results. 
 The supplied binder is used for accessibility checks and base class suppression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.MemberLookup.Lookup(Roslyn.Compilers.VisualBasic.LookupResult,Roslyn.Compilers.VisualBasic.TypeSymbol,System.String,System.Int32,Roslyn.Compilers.VisualBasic.LookupOptions,Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 Lookup a member name in a type, returning a LookupResult that
 summarizes the results of the lookup. See LookupResult structure for a detailed
 discussing of the meaning of the results. The supplied binder is used for accessibility
 checked and base class suppression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.MemberLookup.LookupInClass(Roslyn.Compilers.VisualBasic.LookupResult,Roslyn.Compilers.VisualBasic.TypeSymbol,System.String,System.Int32,Roslyn.Compilers.VisualBasic.LookupOptions,Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 Lookup a member name in a module, class, struct, enum, or delegate, returning a LookupResult that
 summarizes the results of the lookup. See LookupResult structure for a detailed
 discussing of the meaning of the results. The supplied binder is used for accessibility
 checked and base class suppression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.MemberLookup.IsDerivedInterface(Roslyn.Compilers.VisualBasic.NamedTypeSymbol,Roslyn.Compilers.VisualBasic.NamedTypeSymbol,Roslyn.Compilers.ConsList{Roslyn.Compilers.VisualBasic.Symbol})">
	<summary>
 Checks if two interfaces have a base-derived relationship
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.MemberLookup.MergeInterfaceLookupResults(Roslyn.Compilers.VisualBasic.LookupResult,Roslyn.Compilers.VisualBasic.LookupResult,Roslyn.Compilers.ConsList{Roslyn.Compilers.VisualBasic.Symbol})">
	<summary>
 Merges two lookup results while eliminating symbols that are shadowed.
 Note that the final result may contain unrelated and possibly conflicting symbols as
 this helper is not intended to catch ambiguities.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.MemberLookup.CompactAndAppend(Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.Symbol},Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.Symbol})">
	<summary>
 first.Where(t IsNot Nothing).Concat(second.Where(t IsNot Nothing))
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.MemberLookup.AddBaseInterfacesToTheSearch(Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.VisualBasic.NamedTypeSymbol,System.Collections.Generic.Queue{Roslyn.Compilers.VisualBasic.NamedTypeSymbol},System.Collections.Generic.HashSet{Roslyn.Compilers.VisualBasic.NamedTypeSymbol})">
	<summary>
	</summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.MemberLookup.AnyShadows(Roslyn.Compilers.VisualBasic.LookupResult)">
	<summary>
 if any symbol in the list Shadows. This implies that name is not visible through the base.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.MemberLookup.LookupWithoutInheritance(Roslyn.Compilers.VisualBasic.LookupResult,Roslyn.Compilers.VisualBasic.TypeSymbol,System.String,System.Int32,Roslyn.Compilers.VisualBasic.LookupOptions,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 Lookup a member name in a type without considering inheritance, returning a LookupResult that
 summarizes the results of the lookup. See LookupResult structure for a detailed
 discussing of the meaning of the results.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Binder.MemberLookup">
	<summary>
 This class handles binding of members of namespaces and types.
 The key member is Lookup, which handles looking up a name
 in a namespace or type, by name and arity, and produces a 
 lookup result. 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MemberSemanticModel.GetBoundNode(Roslyn.Compilers.VisualBasic.SyntaxNode)">
	<summary> 
 Gets the bound node associated with the syntax node
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MemberSemanticModel.GetUpperBoundNodeInContext(Roslyn.Compilers.VisualBasic.SyntaxNode)">
	<summary>
 Binds a node in proper 'enclosing' context and returns an 'upper' bound node referencing the original syntax.
 To be used in GetSemanticInfoInParent.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MemberSemanticModel.GetLowerBoundNodeInContext(Roslyn.Compilers.VisualBasic.SyntaxNode)">
	<summary>
 Binds a node in proper 'enclosing' context and returns an 'lower' bound node referencing the original syntax.
 To be used in GetSemanticInfo.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MemberSemanticModel.GetBoundNodeInEnclosingContext(Roslyn.Compilers.VisualBasic.SyntaxNode,System.Func{Roslyn.Compilers.VisualBasic.BoundNode,Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.BoundNode})">
	<summary>
 Whenever we want to get semantic info for a syntax node we need to build a bound tree for proper
 syntax subtree which includes this node. GetSemanticInfo and GetSemanticInfoInParent then will find
 proper bound nodes in this tree to return.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MemberSemanticModel.AnalyzeRegionControlFlow(Roslyn.Compilers.TextSpan)">
	<summary>
 Analyze control-flow within a part of a method body. 
 </summary>
	<param name="span">The span of code within the associated SyntaxTree to analyze. The span must be fully
 inside a method body.</param>
	<returns>An object that can be used to obtain the result of the control flow analysis.</returns>
	<exception cref="T:System.ArgumentException">The span is not with a method body.</exception>
</member><member name="M:Roslyn.Compilers.VisualBasic.MemberSemanticModel.AnalyzeRegionDataFlow(Roslyn.Compilers.TextSpan)">
	<summary>
 Analyze data-flow within a part of a method body. 
 </summary>
	<param name="span">The span of code within the associated SyntaxTree to analyze. The span must be fully
 inside a method body.</param>
	<returns>An object that can be used to obtain the result of the data flow analysis.</returns>
	<exception cref="T:System.ArgumentException">The span is not with a method body.</exception>
</member><member name="M:Roslyn.Compilers.VisualBasic.MemberSemanticModel.GetDeclarationDiagnostics(System.Threading.CancellationToken)">
	<summary>
 Get all the syntax and declaration errors within the syntax tree associated with this object. Does not get
 errors involving compiling method bodies or initializers.
 </summary>
	<param name="cancellationToken">A cancellation token that can be used to cancel the process of obtaining the
 diagnostics.</param>
	<remarks>The declaration errors for a syntax tree are cached. The first time this method is called, a ll
 declarations are analyzed for diagnostics. Calling this a second time will return the cached diagnostics.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.MemberSemanticModel.GetDiagnostics(System.Threading.CancellationToken)">
	<summary>
 Get all the errors within the syntax tree associated with this object. Includes errors involving compiling
 method bodies or initializers, in addition to the errors returned by GetDeclarationDiagnostics.
 </summary>
	<param name="cancellationToken">A cancellation token that can be used to cancel the process of obtaining the
 diagnostics.</param>
	<remarks>
 Because this method must semantically all method bodies and initializers to check for diagnostics, it may
 take a significant amount of time. Unlike GetDeclarationDiagnostics, diagnostics for method bodies and
 initializers are not cached, the any semantic information used to obtain the diagnostics is discarded.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.MemberSemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.TypeStatementSyntax,System.Threading.CancellationToken)">
	<summary>
 Given a type declaration, get the corresponding type symbol.
 </summary>
	<param name="declarationSyntax">The syntax node that declares a type.</param>
	<returns>The type symbol that was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.MemberSemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.EnumStatementSyntax,System.Threading.CancellationToken)">
	<summary>
 Given a enum declaration, get the corresponding type symbol.
 </summary>
	<param name="declarationSyntax">The syntax node that declares an enum.</param>
	<returns>The type symbol that was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.MemberSemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.NamespaceStatementSyntax,System.Threading.CancellationToken)">
	<summary>
 Given a namespace declaration, get the corresponding type symbol.
 </summary>
	<param name="declarationSyntax">The syntax node that declares a namespace.</param>
	<returns>The namespace symbol that was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.MemberSemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.MethodBaseSyntax,System.Threading.CancellationToken)">
	<summary>
 Given a method, property, or event declaration, get the corresponding symbol.
 </summary>
	<param name="declarationSyntax">The syntax node that declares a method, property, or event.</param>
	<returns>The method, property, or event symbol that was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.MemberSemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.ParameterSyntax,System.Threading.CancellationToken)">
	<summary>
 Given a parameter declaration, get the corresponding parameter symbol.
 </summary>
	<param name="parameter">The syntax node that declares a parameter.</param>
	<returns>The parameter symbol that was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.MemberSemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.AliasImportsClauseSyntax,System.Threading.CancellationToken)">
	<summary>
 Given an import clause get the corresponding symbol for the import alias that was introduced.
 </summary>
	<param name="declarationSyntax">The import statement syntax node.</param>
	<returns>The alias symbol that was declared or Nothing if no alias symbol was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.MemberSemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.TypeParameterSyntax,System.Threading.CancellationToken)">
	<summary>
 Given a type parameter declaration, get the corresponding type parameter symbol.
 </summary>
	<param name="typeParameter">The syntax node that declares a type parameter.</param>
	<returns>The type parameter symbol that was declared.</returns>
</member><member name="P:Roslyn.Compilers.VisualBasic.MemberSemanticModel.SyntaxTree">
	<summary> 
 The SyntaxTree that is bound
 </summary>
	<remarks>
 Returns null if this is a binding returned by GetSpeculativeSemanticModel.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.MemberSemanticModel.LowerBoundNodeFinder">
	<summary>
 Searches for the LOWER bound node referencing the syntax
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.MemberSemanticModel.UpperBoundNodeFinder">
	<summary>
 Searches for the UPPER bound node referencing the syntax
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.MemberSemanticModel.BaseBoundNodeFinder">
	<summary>
 Calls ProcessBoundNode for all the nodes referencing the syntax 
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.MemberSemanticModel">
	<summary>
 Binding info for expressions and statements that are part of a member declaration.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SingleLookupResult">
	<summary> 
 Represents a result of lookup operation over a 0 or 1 symbol (as opposed to a scope).
 The typical use is to represent that a particular symbol is good/bad/unavailable.

For more explanation of Kind, Symbol, Error - see LookupResult.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LookupResult.SetFrom(Roslyn.Compilers.VisualBasic.SingleLookupResult)">
	<summary>
 Set current result according to another
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LookupResult.SetFrom(Roslyn.Compilers.VisualBasic.LookupResult)">
	<summary>
 Set current result according to another
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LookupResult.SetFrom(Roslyn.Compilers.VisualBasic.Symbol)">
	<summary>
 Set current result according to a given symbol    
 </summary>
	<param name="s"></param>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.LookupResult.ReplaceSymbol(Roslyn.Compilers.VisualBasic.Symbol)">
	<summary>
 Replace the symbol replaced with a new one, but the kind
 and diagnostics retained from the current result. Typically used when constructing
 a type from a symbols and type arguments.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.LookupResult">
	<summary>
 A LookupResult summarizes the result of a name lookup, and allows combining name lookups
 from different scopes in an easy way.
 
 A LookupResult can be ONE OF:
    empty - nothing found.
    a non-accessible result - this kind of result means that search continues into further scopes of lower priority for
                      a viable result. An error is attached with the inaccessibility errors. Non-accessible results take priority over
                      non-viable results.
    a non-viable result - a result that that means that the search continues into further scopes of lower priority for
                          a viable or non-accessible result. An error is attached with the error that indicates
                          why the result is non-viable.
    a bad symbol that stops further lookup -  this kind of result prevents lookup into further scopes of lower priority.
                      a diagnostic is attached explaining why the symbol is bad.
    ambiguous symbols.- In this case, an AmbiguousSymbolDiagnostic diagnostic has the other symbols. 
    a good symbol, or set of good overloaded symbols - no diagnostic is attached in this case
 
 Occasionally, good or ambiguous results are referred to as "viable" results.
 
 Multiple symbols can be represented in a single LookupResult. Multiple symbols are ONLY USED for overloadable
 entities, such an methods or properties, and represent all the symbols that overload resolution needs to consider.
 When ambiguous symbols are encountered, a single representative symbols is returned, with an attached AmbiguousSymbolDiagnostic
 from which all the ambiguous symbols can be retrieved. This implies that Lookup operations that are restricted to namespaces
 and/or types always create a LookupResult with 0 or 1 symbol.
 
 Note that the class is poolable so its instances can be obtained from a pool vai GetInstance.
 Also it is a good idea to call Free on instances after they no longer needed.
 
 The typical pattern is "caller allocates / caller frees" -
    
    Dim result = LookupResult.GetInstance()
  
    scope.Lookup(result, "foo")
    ... use result ...
         
    result.Clear()
    anotherScope.Lookup(result, "moo")
    ... use result ...
 
    result.Free()   'result and its content is invalid after this
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Binder.ImportsBinder">
	<summary>
 The Imports binder handles binding of Imports statements in files, and also the project-level imports.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.BinderCache">
	<summary>
 The BinderCache class finds the correct Binder to use for a node in a syntax tree, down to method
 level. Within a method, the MethodOrLambdaBodyBinder has a cache of further binders within the method.
 
 The BinderCache caches results so that binders are efficiently reused between queries.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.BinderBuilder.CreateBinderForSourceFileImports(Roslyn.Compilers.VisualBasic.SourceModuleSymbol,Roslyn.Compilers.VisualBasic.SyntaxTree)">
	<summary>
 Creates a binder for a binding global imports in a source file. This includes the following binders:
    BackstopBinder
    SourceModuleBinder
    SourceFileBinder
    NamespaceBinder (for the global namespace)
    IgnoreBaseClassesBinder (so that base classes are ignore during binding)
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.BinderBuilder.CreateBinderForProjectImports(Roslyn.Compilers.VisualBasic.SourceModuleSymbol,Roslyn.Compilers.VisualBasic.SyntaxTree)">
	<summary>
 Creates a binder for a binding project-level imports. This includes the following binders:
    BackstopBinder
    SourceModuleBinder
    ProjectImportsBinder
    NamespaceBinder (for the global namespace)
    IgnoreBaseClassesBinder (so that base classes are ignore during binding)
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.BinderBuilder.CreateBinderForSourceFile(Roslyn.Compilers.VisualBasic.SourceModuleSymbol,Roslyn.Compilers.VisualBasic.SyntaxTree)">
	<summary>
 Creates a binder for a source file. This includes the following binders:
    BackstopBinder
    SourceModuleBinder
    ImportMembersBinder (for project-level imported namespaces)
    ImportAliasesBinder (for project-level import aliases)
    SourceFileBinder
    ImportMembersBinder (for file-level import members)
    ImportAliasesBinder (for file-level import aliases)
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.BinderBuilder.CreateBinderForProjectLevelNamespace(Roslyn.Compilers.VisualBasic.SourceModuleSymbol,Roslyn.Compilers.VisualBasic.SyntaxTree)">
	<summary>
 Creates a binder for a project level namespace declaration 
 This includes the following binders:
    BackstopBinder
    SourceModuleBinder
    ImportMembersBinder (for project-level imported namespaces)
    SourceFileBinder
    ImportMembersBinder (for file-level import members)
    ImportAliasesBinder (for file-level import aliases)
    NamespaceBinder... (for each namespace, starting at the global namespace)
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.BinderBuilder.CreateBinderForNamespace(Roslyn.Compilers.VisualBasic.SourceModuleSymbol,Roslyn.Compilers.VisualBasic.SyntaxTree,Roslyn.Compilers.VisualBasic.NamespaceSymbol)">
	<summary>
 Creates a binder for a source namespace declaration (the part of a namespace
 in a single namespace declaration). This includes the following binders:
    BackstopBinder
    SourceModuleBinder
    ImportMembersBinder (for project-level imported namespaces)
    SourceFileBinder
    ImportMembersBinder (for file-level import members)
    ImportAliasesBinder (for file-level import aliases)
    NamespaceBinder... (for each namespace, starting at the global namespace)
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.BinderBuilder.CreateBinderForType(Roslyn.Compilers.VisualBasic.SourceModuleSymbol,Roslyn.Compilers.VisualBasic.SyntaxTree,Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol)">
	<summary>
 Creates a binder for a source type declaration (the part of a type in a single
 type declaration. For partial types this include just one part). This includes the following binders:
    BackstopBinder
    SourceModuleBinder
    ImportMembersBinder (for project-level imported namespaces)
    SourceFileBinder
    ImportMembersBinder (for file-level import members)
    ImportAliasesBinder (for file-level import aliases)
    NamespaceBinder... (for each namespace, starting at the global namespace)
    NamedTypeBinder... (for each type, and nested type)
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.BinderBuilder.CreateSourceModuleBinder(Roslyn.Compilers.VisualBasic.SourceModuleSymbol)">
	<summary>
 Create a binder for the source module. Includes the following:
    BackstopBinder
    SourceModuleBinder
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.BinderBuilder">
	<summary>
 A BinderBuilder builds a linked list of Binder objects for various typical binders.
 
 Typically the binder chain looks something like this:
    BackstopBinder
    SourceModuleBinder
    ImportMembersBinder (for project-level imported namespaces)
    ImportAliasesBinder (for project-level import aliases)
    SourceFileBinder
    ImportMembersBinder (for file-level import members)
    ImportAliasesBinder (for file-level import aliases)
    NamespaceBinder... (for each namespace, starting at the global namespace)
    TypeBinder... (for each type, and nested type)
  (maybe more)
    DiagnosticBagBinder 
 
  Note: Binders are also built by the BinderCache class. Changes to how namespace and type Binders
  are built may need changes there also.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.LookupOptions.Default">
	<summary>
 Consider all symbols, using normal accessibility rules.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.LookupOptions.NamespacesOrTypesOnly">
	<summary>
 Consider only namespaces and types.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.LookupOptions.LabelsOnly">
	<summary>
 Consider only labels. If this is not set, labels are not considered at all.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.LookupOptions.MustBeInstance">
	<summary>
 Do not consider symbols that are shared members.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.LookupOptions.MustNotBeInstance">
	<summary>
 Do not consider symbols that are instance members.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.LookupOptions.MustNotBeReturnValueVariable">
	<summary>
 Do not consider the return value local variable.
 This is similar to the C# LookupOption.MustBeInvocableMember.
 
 The only non-invocable member in Visual Basic is the function return variable 
 (see language specification 10.1.1). If this flag is set, lookup will not 
 return the function return variable, but instead return the containing function or property,
 and any overloads thereof.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.LookupOptions.NoBaseClassLookup">
	<summary>
 Do not do lookup in base classes (similar to how types in Imports are bound).
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.LookupOptions.IgnoreAccessibility">
	<summary>
 Ignore accessibility checking when determining if a symbol is a viable match.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.LookupOptions.AllMethodsOfAnyArity">
	<summary>
 Consider methods of any arity (but still consider arity for other types of symbols).
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.LookupOptions">
	<summary>
 Options that can be used to modify the symbol lookup mechanism. Multiple options can be combined together.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.ConstantFieldsInProgressBinder">
	<summary>
 This binder keeps track of the set of constant fields that are currently being evaluated
 so that the set can be passed into the next call to SourceFieldSymbol.ConstantValue (and
 its callers).
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.ConstantFieldsInProgress">
	<summary>
 This is used while computing the values of constant fields.  Since they can depend on each other,
 we need to keep track of which ones we are currently computing in order to avoid (and report) cycles.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.BoundLambda.IsSingleLine">
	<summary>
 Should this lambda be treated as a single line lambda?
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.BoundAddressOfOperator.GetDelegateResolutionResult(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.Binder.DelegateResolutionResult@)">
	<summary>
 Gets the <see>Binder.DelegateResolutionResult</see> for the given targetType. 
 </summary>
	<remarks>
 One needs to call <see>GetConversionClassification</see> before in order to fill the cache.
 </remarks>
	<param name="targetType">Type of the target.</param>
	<returns>The <see cref="T:Roslyn.Compilers.VisualBasic.Binder.DelegateResolutionResult">Binder.DelegateResolutionResult</see> for the conversion 
 of the AddressOf operand to the target type
 </returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.BoundAddressOfOperator.GetConversionClassification(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 Gets the conversion classification.
 </summary>
	<param name="targetType">The destination type to convert to.</param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ForBlockBinder">
	<summary>
 Binder used to bind For and ForEach blocks. 
 It hosts the control variable (if one is declared) 
 and inherits ExitableStatementBinder to provide Continue/Exit labels if needed. 
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.FieldOrPropertyInitializerBinder.m_fieldOrProperty">
	<summary>
 Backing field for the ContainingMember property
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.FieldOrPropertyInitializerBinder._root">
	<summary> Root syntax node </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.FieldOrPropertyInitializerBinder.#ctor(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.VisualBasic.SyntaxNode)">
	<summary>
 Initializes a new instance of the <see cref="T:Roslyn.Compilers.VisualBasic.FieldOrPropertyInitializerBinder"/> class.
 </summary>
	<param name="fieldOrProperty">The field or property.</param>
	<param name="next">The next binder.</param>
	<param name="root">Root syntax node</param>
</member><member name="P:Roslyn.Compilers.VisualBasic.FieldOrPropertyInitializerBinder.ContainingMember">
	<summary>
 The member containing the binding context. 
 This property is the main reason for this binder, because the binding context for an initialization 
 needs to be the field or property symbol.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.FieldOrPropertyInitializerBinder.Root">
	<summary> Field or property declaration statement syntax node </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.FieldOrPropertyInitializerBinder">
	<summary>
 Binder used for field and auto property initializations.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.DescendantBinderFactory">
	<summary>
 Provides a way to obtain binders for decsendant scops in method or lambda body.
 Factory for a method body does not create binders for scopes inside a lambda, 
 contained by the method. A dedicated factory must be created for each lambda body.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.UseTwice(Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.BoundExpression@,Roslyn.Compilers.VisualBasic.BoundExpression@,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.TempLocalSymbol})">
	<summary>
 Given an expression that produces some result (not restricted to a BoundValueExpression) and 
 has some observable evaluation sideffects, return two expressions:
   1) First - produces the same result with the same observable sideefects,
   2) Second - produces the same result, but without observable sideefects, whenever possible.
 
 This is used for compound assignement, method call ByRef parameter copy back, etc.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.Report_ERRID_ReadOnlyInClosure(Roslyn.Compilers.VisualBasic.BoundExpression)">
	<summary>
 If we are inside a lambda in a constructor and are passing ByRef a non-LValue field, which 
 would be an LValue field, if it were referred to in the constructor outside of a lambda, 
 we need to report an error because the operation will result in a simulated pass by
 ref (through a temp, without a copy back), which might be not the intent.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.InferLambdaReturnTypeAndVerify(Roslyn.Compilers.VisualBasic.UnboundLambda,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.ParameterSymbol})">
	<summary>
 Returns inferred type or Nothing if inference failed.
 
 TODO: Need to figure out how diagnostic is reported.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.InferLambdaReturnType(Roslyn.Compilers.VisualBasic.UnboundLambda,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.ParameterSymbol},Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Returns inferred type or Nothing if inference failed.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.LambdaBodyBinder">
	<summary>
 Provides context for binding body of a Lambda.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Binder.ProcessedFieldOrPropertyInitializers.HasAnyErrors">
	<summary> Indicate the fact that binding or lowering of initializers produced error diagnostics. </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Binder.ProcessedFieldOrPropertyInitializers">
	<summary>
 Used to store the bound field and property initializers and the associated list of
 bound assignment statements because they are reused for multiple constructors
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BadExpression(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 Create a BoundBadExpression node for the given syntax node. No symbols or bound nodes are associated with it.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BadExpression(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.BoundNode,Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 Create a BoundBadExpression node for the given childexpression, which is preserved as a sub-expression. Symbols
 associated with the child node are not given a result kind.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BadExpression(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.BoundNode},Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 Create a BoundBadExpression node for the given child expression, which is preserved as a sub-expression. Symbols
 associated with the child node are not given a result kind.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BadExpression(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.LookupResultKind,Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.TypeSymbol,System.Boolean)">
	<summary>
 Create a BoundBadExpression node for the given expression. Symbols
 associated with the given expression are preserved for the binding API with the given result kind explaining why they are bad.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.ValidateAndConvertIsExpressionArgument(Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.BoundExpression,System.Boolean,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Validate and apply appropriate conversion for the target argument of Is/IsNot expression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindValue(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.DiagnosticBag,System.Boolean)">
	<summary>
 BindValue evaluates the node and returns a BoundExpression.  BindValue snaps expressions to values.  For now that means that method groups
 become invocations.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindRValue(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.DiagnosticBag,System.Boolean)">
	<summary>
 BindRValue evaluates the node and returns a BoundExpression.  
 It ensures that the expression is a value that can be used on the right hand side of an assignment.  
 If not, it reports an error.
 
 Note that this function will reclassify all expressions to have their "default" type, i.e.
 Anonymous Delegate for a lambda, default array type for an array literal, will report an error 
 for an AddressOf, etc. So, if you are in a context where there is a known target type for the 
 expression, do not use this function. Instead, use BindValue followed by 
 ApplyImplicitConversion/ApplyConversion.  
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.IsLValueFieldAccess(Roslyn.Compilers.VisualBasic.FieldSymbol,Roslyn.Compilers.VisualBasic.BoundExpression)">
	<summary>
 Determine whether field access should be treated as LValue. 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.SubstituteDBNullWithNothingString(Roslyn.Compilers.VisualBasic.BoundExpression@,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Returns Symbol for String type.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.GetSpecialTypeForBinaryOperator(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.SpecialType,System.Boolean,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Get symbol for a special type, reuse symbols for operand types to avoid type 
 lookups and construction of new instances of symbols.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.GetNullableTypeForBinaryOperator(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 Get symbol for a Nullable type of particular type, reuse symbols for operand types to avoid type 
 lookups and construction of new instances of symbols.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.ConvertNothingLiterals(Roslyn.Compilers.VisualBasic.BinaryOperatorKind,Roslyn.Compilers.VisualBasic.BoundExpression@,Roslyn.Compilers.VisualBasic.BoundExpression@,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 §11.12.2 Object Operands
 The value Nothing is treated as the default value of the type of 
 the other operand in a binary operator expression. In a unary operator expression, 
 or if both operands are Nothing in a binary operator expression, 
 the type of the operation is Integer or the only result type of the operator, 
 if the operator does not result in Integer.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.GenerateDiagnosticsForDominantTypeInferenceInIfExpression(Roslyn.Compilers.VisualBasic.TypeSymbol,System.Int32,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.DiagnosticBag)">
	<summary> Process the result of dominant type inference, generate diagnostics </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.ApplyImplicitConversion(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.DiagnosticBag,System.Boolean)">
	<summary>
 This function must return a BoundConversion node in case of non-identity conversion.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.ApplyConversion(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.BoundExpression,System.Boolean,Roslyn.Compilers.DiagnosticBag,System.Boolean)">
	<summary>
 This function must return a BoundConversion node in case of explicit or non-identity conversion.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.ShouldBindWithoutArguments(Roslyn.Compilers.VisualBasic.BoundMethodOrPropertyGroup@)">
	<summary>
 Tests whether or not the method or property group should be bound without arguments. 
 In case of method group it may also update the group by filtering out all subs
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.OptimizeLibraryCall(Roslyn.Compilers.VisualBasic.MethodSymbol,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.BoundExpression},Roslyn.Compilers.VisualBasic.SyntaxNode,System.Boolean@,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Optimizes some runtime library calls through replacing them with a literal if possible.
 VB Spec 11.2 defines the following runtime functions as being constant:
  - Microsoft.VisualBasic.Strings.ChrW
  - Microsoft.VisualBasic.Strings.Chr, if the constant value is between 0 and 128
  - Microsoft.VisualBasic.Strings.AscW, if the constant string is not empty
  - Microsoft.VisualBasic.Strings.Asc, if the constant string is not empty
 </summary>
	<param name="method">The method.</param>
	<param name="arguments">The arguments of the method call.</param>
	<param name="syntax">The syntax node for report errors.</param>
	<param name="diagnostics">The diagnostics.</param>
	<param name="hasErrors">Set to true if there are conversion errors (e.g. Asc("")). Otherwise it's not written to.</param>
	<returns>The constant value that replaces this node, or nothing.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.GetSetOfTheBestCandidates(Roslyn.Compilers.VisualBasic.OverloadResolution.OverloadResolutionResult@,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.Symbol}@)">
	<summary>
Figure out the set of best candidates in the following preference order:
  1) Applicable
  2) TypeInferenceFailed
  3) ArgumentMismatch, GenericConstraintsViolated
  4) ArgumentCountMismatch
  5) BadGenericArity
  6) HasUseSiteError
 
 Also return the set of unique symbols behind the set.
 
 Returns type symbol for the common type, if any.
 Otherwise returns ErrorTypeSymbol.UnknownResultType.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.ReportOverloadResolutionFailureForASingleCandidate(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult@,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.BoundExpression},Roslyn.Compilers.ReadOnlyArray{System.String},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.Location},System.Boolean,System.Boolean,System.Boolean,System.Boolean,Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.VisualBasic.Symbol,System.Boolean,Roslyn.Compilers.VisualBasic.SyntaxNode)">
	<summary>
 Should be kept in sync with OverloadResolution.MatchArguments. Anything that 
 OverloadResolution.MatchArguments flags as an error should be detected by 
 this function as well. 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.ReportByRefConversionErrors(Roslyn.Compilers.VisualBasic.OverloadResolution.Candidate,Roslyn.Compilers.VisualBasic.ParameterSymbol,Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.TypeSymbol,System.Boolean,Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.Symbol,System.Boolean)">
	<summary>
 Should be in sync with OverloadResolution.MatchArgumentToByRefParameter
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.ReportByValConversionErrors(Roslyn.Compilers.VisualBasic.OverloadResolution.Candidate,Roslyn.Compilers.VisualBasic.ParameterSymbol,Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.TypeSymbol,System.Boolean,Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.Symbol,System.Boolean)">
	<summary>
 Should be in sync with OverloadResolution.MatchArgumentToByValParameter.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.PassArguments(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult@,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.BoundExpression},Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.LocalSymbol}@,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.BoundExpression}@)">
	<summary>
 Should be kept in sync with OverloadResolution.MatchArguments, which populates 
 data this function operates on.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.CreateConversionAndReportDiagnostic(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.ConversionKind,System.Boolean,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.VisualBasic.ParameterSymbol,Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.Symbol,System.Boolean)">
	<summary>
 This function must return a BoundConversion node in case of non-identity conversion.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.ReclassifyExpression(Roslyn.Compilers.VisualBasic.BoundExpression@,Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.ConversionKind,System.Boolean,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Handle expression reclassification, if any applicable.
 
 If function returns True, the "argument" parameter has been replaced
 with result of reclassification (possibly an error node) and appropriate
 diagnostic, if any, has been reported.
 
 If function returns false, the "argument" parameter must be unchanged and no 
 diagnostic should be reported. 
 
 conversionSemantics can be one of these: 
       SyntaxKind.CTypeKeyword, SyntaxKind.DirectCastKeyword, SyntaxKind.TryCastKeyword
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindArrayCreationExpression(Roslyn.Compilers.VisualBasic.ArrayCreationExpressionSyntax,Roslyn.Compilers.DiagnosticBag)">
	<summary>
  Handle ArrayCreationExpressionSyntax
   new integer(n)(,) {...}
   new integer() {...}
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindArrayInitializerList(Roslyn.Compilers.VisualBasic.CollectionInitializerSyntax,Roslyn.Compilers.VisualBasic.ArrayTypeSymbol,System.Nullable{System.Int32}[],System.Int32,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Binds CollectionInitializeSyntax. i.e. { expr, ... } from an ArrayCreationExpressionSyntax
 </summary>
	<param name="node">The collection initializer syntax</param>
	<param name="type">The type of array</param>
	<param name="knownSizes">This is in out.  It comes in with sizes from explicit bounds but will be updated based on the number of initializes for dimensions without bounds</param>
	<param name="dimension">The current array dimension that is being processed</param>
	<param name="diagnostics">Where to put errors</param>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindArrayBounds(Roslyn.Compilers.VisualBasic.ArgumentListSyntax,System.Nullable{System.Int32}[],Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Bind the array bounds and return the sizes for each dimension.
 </summary>
	<param name="arrayBoundsOpt">The bounds</param>
	<param name="knownSizes">The bounds if they are constants</param>
	<param name="diagnostics">Where to put the errors</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindFieldAndPropertyInitializers(Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.FieldOrPropertyInitializer}},Roslyn.Compilers.VisualBasic.Binder.ProcessedFieldOrPropertyInitializers@,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Binds all field initializers of a <see cref="T:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol"/>.
 </summary>
	<param name="symbol">The named type symbol where the field initializers are declared.</param>
	<param name="Initializers">The initializers itself. For each partial type declaration there is an array of 
 field initializers</param>
	<param name="processedFieldInitializers">The structure storing the list of processed field initializers.</param>
	<param name="diagnostics">The diagnostics.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindFieldInitializer(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.Symbol},Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.BoundFieldOrPropertyInitializer},Roslyn.Compilers.DiagnosticBag,System.Boolean)">
	<summary>
 Binds the field initializer. A bound field initializer contains the bound field access and bound init value.
 </summary>
	<param name="fieldSymbols">The field symbol.</param>
	<param name="equalsValueOrAsNewSyntax">The syntax node for the optional initialization.</param>
	<param name="boundInitializers">The array of bound initializers to add the newly bound ones to.</param>
	<param name="diagnostics">The diagnostics.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindConstFieldInitializer(Roslyn.Compilers.VisualBasic.SourceFieldSymbol,Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.BoundFieldOrPropertyInitializer},Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Checks for errors in the constant initialization of a field, and only returns a BoundFieldOrPropertyInitializer for
 decimals and dates because they aren't compile time constant in CLR. Other data type end up directly in metadata and 
 do not cause a BoundFieldOrPropertyInitializer node.
 </summary>
	<param name="fieldSymbol">The field symbol.</param>
	<param name="equalsValueOrAsNewSyntax">The syntax node for the optional initialization.</param>
	<param name="boundInitializers">The array of bound initializers to add the newly bound ones to.</param>
	<param name="diagnostics">The diagnostics.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.IsCallStatementContext(Roslyn.Compilers.VisualBasic.InvocationExpressionSyntax)">
	<summary>
 Return true if the node is an immediate child of a call statement.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Binder.DelegateResolutionResult">
	<summary>
 Structure is used to store all information which is needed to construct and classify a Delegate creation 
 expression later on.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindAddressOfExpression(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Binds the AddressOf expression.
 </summary>
	<param name="node">The AddressOf expression node.</param>
	<param name="diagnostics">The diagnostics.</param><returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindDelegateCreationExpression(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.ArgumentListSyntax,Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Binds the delegate creation expression.
 This comes in form of e.g.
 Dim del as new DelegateType(AddressOf methodName)
 </summary>
	<param name="delegateType">Type of the delegate.</param>
	<param name="argumentListOpt">The argument list.</param>
	<param name="node">Syntax node to attach diagnostics to in case the argument list is nothing.</param>
	<param name="diagnostics">The diagnostics.</param><returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.InterpretDelegateBinding(Roslyn.Compilers.VisualBasic.BoundAddressOfOperator,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 Resolves the target method for the delegate and classifies the conversion
 </summary>
	<param name="addressOfExpression">The bound AddressOf expression itself.</param>
	<param name="targetType">The delegate type to assign the result of the AddressOf operator to.</param>
	<returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.ResolveMethodForDelegateInvokeFullAndRelaxed(Roslyn.Compilers.VisualBasic.BoundAddressOfOperator,Roslyn.Compilers.VisualBasic.MethodSymbol,System.Boolean,Roslyn.Compilers.VisualBasic.MethodConversionKind@,Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Resolves the method for delegate invoke with all or relaxed arguments / return types. It also determines 
 the method conversion kind.
 </summary>
	<param name="addressOfExpression">The AddressOf expression.</param>
	<param name="toMethod">The delegate invoke method.</param>
	<param name="ignoreMethodReturnType">Ignore method's return type for the purpose of calculating 'methodConversions'.</param>
	<param name="methodConversions">The method conversion kind needed.</param>
	<param name="diagnostics">The diagnostics.</param>
	<returns>The resolved method if any.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.ResolveMethodForDelegateInvokeFullOrRelaxed(Roslyn.Compilers.VisualBasic.BoundAddressOfOperator,Roslyn.Compilers.VisualBasic.MethodSymbol,System.Boolean,Roslyn.Compilers.VisualBasic.MethodConversionKind@,Roslyn.Compilers.DiagnosticBag,System.Boolean,System.Boolean@,Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 Resolves the method for delegate invoke with all or relaxed arguments / return types. It also determines 
 the method conversion kind.
 </summary>
	<param name="addressOfExpression">The AddressOf expression.</param>
	<param name="toMethod">The delegate invoke method.</param>
	<param name="ignoreMethodReturnType">Ignore method's return type for the purpose of calculating 'methodConversions'.</param>
	<param name="methodConversions">The method conversion kind needed.</param>
	<param name="diagnostics">The diagnostics.</param>
	<param name="useZeroArgumentRelaxation">if set to <c>true</c> use zero argument relaxation.</param>
	<returns>The resolved method if any.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.GetDelegateMethodConversionBasedOnArguments(Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult,Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.MethodSymbol,Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 Determines the method conversion for delegates based on the arguments.
 </summary>
	<param name="bestResult">The resolution result.</param>
	<param name="diagnostics">The diagnostics.</param>
	<param name="addressOfNode">Node to attach the diagnostics to</param>
	<param name="delegateInvoke">The delegate invoke method.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.GetDelegateMethodConversionBasedOnReturnType(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 Determines the method conversion kind for delegates based on the return type.
 </summary>
	<param name="targetMethodReturnType">The return type of the method to convert from (target method).</param>
	<param name="invokeMethodReturnType">The return type of the method to convert to (delegate invoke method).</param>
	<param name="diagnostics">The diagnostics.</param>
	<param name="addressOfNode">Node to attach the diagnostics to</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.ClassifyAddressOfConversion(Roslyn.Compilers.VisualBasic.BoundAddressOfOperator,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 Classifies the address of conversion. 
 </summary>
	<param name="source">The bound AddressOf expression.</param>
	<param name="destination">The target type to convert this AddressOf expression to.</param><returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.CheckDelegateParameterModifier(Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SourceParameterFlags,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Checks if a parameter is a ParamArray and reports this as an error.
 </summary>
	<param name="binder">The binder.</param>
	<param name="container">The containing type.</param>
	<param name="token">The current parameter token.</param>
	<param name="flag">The flags of this parameter.</param>
	<param name="diagnostics">The diagnostics.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.ReclassifyAddressOf(Roslyn.Compilers.VisualBasic.BoundAddressOfOperator,Roslyn.Compilers.VisualBasic.Binder.DelegateResolutionResult@,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Reclassifies the bound address of operator into a delegate creation expression (if there is no delegate 
 relaxation required) or into a bound lambda expression (which gets a delegate creation expression later on)
 </summary>
	<param name="addressOfExpression">The AddressOf expression.</param>
	<param name="delegateResolutionResult">The delegate resolution result.</param>
	<param name="targetType">Type of the target.</param>
	<param name="diagnostics">The diagnostics.</param><returns></returns>
</member><member name="T:Roslyn.Compilers.VisualBasic.Binder.AttributeExpressionVisitor">
	<summary>
 Walk a custom attribute argument bound node and return a TypedConstant.  Verify that the expression is a constant expression.
 </summary>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.Lookup(Roslyn.Compilers.VisualBasic.LookupResult,System.String,System.Int32,Roslyn.Compilers.VisualBasic.LookupOptions)">
	<summary>
 Lookup the given name in the binder and containing binders.
 Returns the result of the lookup. See the definition of LookupResult for details.
 </summary>
	<remarks>
 This implementation is not virtual. It 
 calls the virtual LookupInSingleBinder for each binder in turn, and merges the results. 
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.LookupInSingleBinder(Roslyn.Compilers.VisualBasic.LookupResult,System.String,System.Int32,Roslyn.Compilers.VisualBasic.LookupOptions,Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 Lookup in just a single binder, without delegating to containing binder. The original
 binder passed in is used for accessibility checking and so forth.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.LookupNamesInSingleBinder(System.Collections.Generic.HashSet{System.String},Roslyn.Compilers.VisualBasic.LookupOptions,Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 Lookup all names that are available from a single binder, without delegating
 to containing bindiner. The original binder passed in is used for accessibility checking
 and so forth. 
 Names that are available are inserted into "nameSet". This is a hashSet that accumulates
 names, and should be created with the VB identifierComparer.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.LookupNonZeroArities(System.Collections.Generic.HashSet{System.Int32},System.String)">
	<summary>
 Determine if "name" is available with a non-zero arity; if so, add the
 arities to the set.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.LookupNonZeroAritiesInSingleBinder(System.Collections.Generic.HashSet{System.Int32},System.String)">
	<summary>
 Determine if "name" is available with a non-zero arity in this binder; if so, add the
 arities to the set.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.IsAccessible(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.ConsList{Roslyn.Compilers.VisualBasic.Symbol})">
	<summary>
 Determine if "sym" is accessible from the location represented by this binder. For protected
 access, use the qualifier type "accessThroughType" if not Nothing (if Nothing just check protected
 access with no qualifier).
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.GetBinder(Roslyn.Compilers.VisualBasic.SyntaxNode)">
	<summary>
 Some nodes have special binder's for their contents 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.GetBinder(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Some nodes have special binder's for their contents 
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Binder.ContainingMember">
	<summary>
 The member containing the binding context
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Binder.ContainingType">
	<summary>
 The type containing the binding context
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Binder.ContainingNamespaceOrType">
	<summary>
 The namespace or type containing the binding context
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.GetSpecialType(Roslyn.Compilers.SpecialType,Roslyn.Compilers.VisualBasic.SyntaxNodeOrToken,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Get the built-in MSCORLIB type identified. If it's not available (an error type), then report the
 error with the given syntax and diagnostic bag. If the node and diagBag are Nothing, then don't report the error (not recommended).
 </summary>
	<param name="typeId">Type to get</param>
	<param name="node">Where to report the error, if any.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.GetWellKnownType(Roslyn.Compilers.WellKnownType,Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 This is a layer on top of the Compilation version that generates a diagnostic if the well-known
 type isn't found.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.GetWellKnownTypeMember(Roslyn.Compilers.WellKnownMember,Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 This is a layer on top of the Compilation version that generates a diagnostic if the well-known
 member isn't found.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Binder.SourceModule">
	<summary>
 Get the source module.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Binder.Compilation">
	<summary>
 Get the compilation.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.GetErrorSymbol(System.String,Roslyn.Compilers.DiagnosticInfo,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.Symbol},Roslyn.Compilers.VisualBasic.LookupResultKind)">
	<summary>
 Get an error symbol.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.GetLocation(Roslyn.Compilers.VisualBasic.SyntaxNodeOrToken)">
	<summary>
 Get the Location associated with a given syntax node.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.GetLocation(Roslyn.Compilers.VisualBasic.SyntaxNodeOrToken,Roslyn.Compilers.VisualBasic.SyntaxNode,System.Boolean)">
	<summary>
 Get the Location associated with a given syntax node.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.GetSyntaxReference(Roslyn.Compilers.VisualBasic.SyntaxNode)">
	<summary>
 Get a SyntaxReference associated with a given syntax node.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Binder.SyntaxTree">
	<summary>
 Returns the syntax tree.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BasesBeingResolved">
	<summary>
 Called in member lookup right before going into the base class of a type. Results a set of named types whose
 bases classes are currently in the process of being resolved, so we shouldn't look into their bases 
 again to prevent/detect circular references.
 </summary>
	<returns>Nothing if no bases being resolved, otherwise the set of bases being resolved.</returns>
</member><member name="P:Roslyn.Compilers.VisualBasic.Binder.IgnoreBaseClassesInLookup">
	<summary>
 Called during member lookup before going into the base class of a type. If returns
 true, the base class is ignored. Primarily used for binding Imports.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Binder.OptionStrict">
	<summary>
 Current Option Strict mode.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Binder.OptionInfer">
	<summary>
 True if Option Infer On is in effect. False if Option Infer Off is in effect.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Binder.OptionExplicit">
	<summary>
 True if Option Explicit On is in effect. False if Option Explicit Off is in effect.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Binder.OptionCompareText">
	<summary>
 True if Option Compare Text is in effect. False if Option Compare Binary is in effect.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Binder.OptionRemoveIntegerOverflowChecks">
	<summary>
 True if integer overflow checking is off. 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.GetExitLabel(Roslyn.Compilers.VisualBasic.SyntaxKind)">
	<summary>
 Get the label that a Exit XXX statement should branch to, or Nothing if we are 
 not inside a context that would be exited by that kind of statement. The passed in kind
 is the SyntaxKind for the exit statement that would target the label (e.g. SyntaxKind.ExitDoStatement).
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.GetContinueLabel(Roslyn.Compilers.VisualBasic.SyntaxKind)">
	<summary>
 Get the label that a Continue XXX statement should branch to, or Nothing if we are 
 not inside a context that would be exited by that kind of statement. The passed in kind
 is the SyntaxKind for the exit statement that would target the label (e.g. SyntaxKind.ContinueDoStatement).
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.GetReturnLabel">
	<summary>
 Get the label that a Return statement should branch to, or Nothing if we are
 not inside a context that would be exited by that kind of statement. This method
 is equivalent to calling <see cref="M:Roslyn.Compilers.VisualBasic.Binder.GetExitLabel(Roslyn.Compilers.VisualBasic.SyntaxKind)"/> with the appropriate exit
 <see cref="T:Roslyn.Compilers.VisualBasic.SyntaxKind"/>.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.GetLocalForFunctionValue">
	<summary>
 Get the special local symbol with the same name as the enclosing function.  
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.GetContainingNamedTypeBinder">
	<summary>
 Get first containing binder that provides context for looking up names
 inside the type.
 
 Can return Nothing if such binder is not found. 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.ReportParentDiagnostic(Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.ERRID)">
	<summary>
 Create a diagnostic associated in the parent of the passed in node, and the squiggle on the node.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.ReportAssociatedDiagnostic(Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.VisualBasic.SyntaxNodeOrToken,Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.ERRID)">
	<summary>
 Create a diagnostic associated with a specific syntax node, but with a squiggle somewhere else. THe syntax node
 binding is used for returning the diagnostic through GetSemanticInfo correctly.
 "syntaxSquiggle" is where the the user will see the error reported on
 "syntaxAssociated" is which node the error is associated with for GetSemanticInfo.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.ReportDiagnostic(Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.VisualBasic.SyntaxNodeOrToken,Roslyn.Compilers.VisualBasic.ERRID)">
	<summary>
 Create a diagnostic at a particular syntax node and place it in a diagnostic bag.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Binder">
	<summary>
 A Binder object represents a general location from where binding is happening, and provides
 virtual methods for looking up unqualified names, reporting errors, and also other operations that need to know about where
 binding happened from (accessibility checking, etc.) It also contains most of the methods related to
 general binding of constructs, although some large sections are factored into their own classes.
 
 Yes, Binder is a big grab bag of features. The reason for this is that binders are threaded through essentially
 ALL binding functions. So, basically Binder has all the features that need to be threaded through binding.
 
 Binder objects form a linked list and each binder links to its containing binder. Each binder only handles
 operations that it knows how to handles, and passes on other calls to its containing binder. This
 maintains separation of concerns and allows binders to be strung together in various configurations
 to enable different binding scenarios (e.g., debugger expression evaluator).
 
 In general, binder objects should be constructed via the BinderBuilder class.
 
 Binder class has GetBinder methods that return binders for scopes nested into the current binder scope.
 One should not expect to get a binder from the functions unless a syntax that originates a scope is passed 
 as the argument. Also, the functions do not cross lambda boundaries, if binder's scope contains a lambda 
 expression, binder will not return any binders for nodes contained in the lambda body. In order to get them,
 the lambda must be bound to BoundLambda node, which exposes LambdaBinder, which can be asked for binders in the
 lambda body (but it will not descend into nested lambdas). Currently, only MethodOrLambdaBodyBinder, 
 IncrementalBinder and SpeculativeBinder have special implementation of GetBinder functions, the rest just 
 delegate to containing binder.  
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.BackstopBinder">
	<summary>
 Backstop that forms the end of the binder chain. Does nothing, and should never actually get hit. Provides
 asserts that methods never get called.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SourceModuleBinder">
	<summary>
 A source module binder provides the context associated with a source module.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SourceFileBinder">
	<summary>
 A SourceFileBinder provides the context associated with a give source file, not including the
 Imports statements (which have their own binders). It primarily provides the services of getting
 locations of node, since it holds onto a SyntaxTree.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.ProjectImportsBinder">
	<summary>
 A ProjectImportsBinder provides the equivalent of a SourceFileBinder, but for the project-level
 imports, which don't live in any file.
 It primarily provides the services of getting locations of nodes, since it holds onto a SyntaxTree, although
 that tree isn't technically a source tree.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.NamespaceBinder">
	<summary>
 A namespace binder provides the context for a namespace symbol; e.g., looking up names
 inside the namespace.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedTypeBinder.LookupInSingleBinder(Roslyn.Compilers.VisualBasic.LookupResult,System.String,System.Int32,Roslyn.Compilers.VisualBasic.LookupOptions,Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 Gets all symbols of the particular name as 
 a) members of this type
 b) members of base types 
 c) type parameters in this type (but not outer or base types)
 In that order.
 
 Note, that section "11.4.4 Simple Name Expression" of VB Language spec 
 implies that type parameters are examined first, and only then members 
 of the type are examined. But this is inconsistent with Dev10 behavior.
 
 Returns all members of that name, or empty list if none.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.NamedTypeBinder">
	<summary>
 A NamedTypeBinder provides the context for a type symbol; e.g., looking up names
 inside the type.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MethodTypeParametersBinder.LookupInSingleBinder(Roslyn.Compilers.VisualBasic.LookupResult,System.String,System.Int32,Roslyn.Compilers.VisualBasic.LookupOptions,Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 Looks up the name in the type parameters
 a) type parameters in this type (but not outer or base types)
 Returns all members of that name, or empty list if none.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.MethodTypeParametersBinder">
	<summary>
 A MethodTypeParametersBinder provides the context for looking up type parameters on a method.
 It is split out since binding of type in the parameters and return value need to happen with a context
 that includes the type parameters, but we don't have a fully complete method symbol yet.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MethodOrLambdaBodyBinder.LookupInSingleBinder(Roslyn.Compilers.VisualBasic.LookupResult,System.String,System.Int32,Roslyn.Compilers.VisualBasic.LookupOptions,Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 Looks up the name in the parameters
 Returns all members of that name, or empty if none.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.MethodOrLambdaBodyBinder">
	<summary>
 A MethodOrLambdaBodyBinder provides context for looking up parameters/labels on a method or a lambda, and also for the implementation
 of ContainingMember, GetLocalForFunctionValue and GetBinder. 
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.MethodBodyBinder">
	<summary>
 Provides context for binding body of a SourceMethodSymbol.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.ImportMembersBinder">
	<summary>
 Provides lookup for imported namespaces and types (not the alias kind),
 either at file level or project level.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.ImportAliasesBinder">
	<summary>
 A ImportAliasesBinder provides lookup for looking up import aliases (A = Foo.Bar),
 either at file level or project level.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.IgnoreBaseClassesBinder">
	<summary>
 Causes lookups to ignore base classes. Used for binding
 Imports statements.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.BasesBeingResolvedBinder">
	<summary>
 Causes lookups to assume that the given set of classes are having their 
 bases being resolved, so lookups should not check for base classes.
 </summary>
	<remarks></remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.SpeculativeBinder">
	<summary>
 We don't have a way to represent locations inside speculative binding right now. For now:
 causes locations to be NoLocation.
 
 Also redirects GetBinder calls to a speculativeBinding.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.LocalBinderBuilder">
	<summary>The LocalBinderFactory is used to build up the map of all Binders within a method body, and the associated
 SyntaxNode. To do so it traverses all the statements, handling blocks and other
 statements that create scopes. For efficiency reasons, it does not traverse into
 expressions. This means that blocks within lambdas and queries are not created. 
 Blocks within lambdas are bound by their own LocalBinderFactory when they are 
 analyzed.

 For reasons of lifetime management, this type is distinct from the BinderFactory 
 which also creates a map from SyntaxNode to Binder. That type owns it's binders
 and that type's lifetime is that of the compilation. Therefore we do not store
 binders local to method bodies in that type's cache. </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.RewritePass.AfterLambdasRewrite(Roslyn.Compilers.VisualBasic.MethodSymbol,Roslyn.Compilers.VisualBasic.BoundNode,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Lambda bodies may be rewritten as methods or quoted as expression trees.
 There are certain reductions that are not supposed to be done if expression trees are
 generated. For example operators should be represented as operators in ETs and should 
 not be lowered to method calls.
 
 This step contains rewrites that are applicable only to bound trees with no lambdas
 Rewrite pass calls this for the outer method body after doing the lambda reduction pass.
 Lambda rewriter will also apply this rewrite to lambda bodies when they are 
 rewritten as synthetic methods.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.VBSemanticsRewriter.ReportMissingOrBadRuntimeHelper(Roslyn.Compilers.VisualBasic.BoundNode,Roslyn.Compilers.WellKnownMember,Roslyn.Compilers.VisualBasic.Symbol)">
	<summary>
 Checks for well known member and reports diagnostc if the member is Nothing or has UseSiteError.
 Returns True in case diagnostics was actually reported
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.VBSemanticsRewriter.ReportMissingOrBadRuntimeHelper(Roslyn.Compilers.VisualBasic.BoundNode,Roslyn.Compilers.SpecialMember,Roslyn.Compilers.VisualBasic.Symbol)">
	<summary>
 Checks for special member and reports diagnostc if the member is Nothing or has UseSiteError.
 Returns True in case diagnostics was actually reported
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.VBSemanticsRewriter.VisitAssignmentOperator(Roslyn.Compilers.VisualBasic.BoundAssignmentOperator)">
	<summary>
 Make sure GetObjectValue calls are injected.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.VBSemanticsRewriter.VisitCall(Roslyn.Compilers.VisualBasic.BoundCall)">
	<summary>
 Make sure GetObjectValue calls are injected.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.VBSemanticsRewriter.VisitObjectCreationExpression(Roslyn.Compilers.VisualBasic.BoundObjectCreationExpression)">
	<summary>
 Make sure GetObjectValue calls are injected.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.VBSemanticsRewriter.VisitAndGenerateObjectClone(Roslyn.Compilers.VisualBasic.BoundExpression)">
	<summary>
 Visit expression node and apply GetObjectValue call if needed.
 
 Why we are doing this rewrite during this phase?
 It would be OK to do this rewrite during earlier phase, but not after this phase
 because:
   - This phase introduces various helper calls, which should not be affected by 
     GetObjectValue injection.
   - This is the last phase where we can see operators not yet replaced with helper calls, 
     this simplifies logic that determines if GetObjectValue call can be omitted.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.VBSemanticsRewriter">
	<summary>
 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 !!! Within this particular rewriter there is a contract:               !!!
 !!! newly produced nodes (this doesn�t include nodes updated in place) !!!
 !!! should be in their final form, i.e. shouldn�t require any other    !!!
 !!! rewrites handled by this rewriter.                                 !!!
 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 
 Rewrites Decimal/Date constant expressions into 
 field references/constructor invocations.
 
 Rewrites VB intrinsic conversion into a helper call,
 if one is required. 
 
 Injects GetObjectValue calls for assignments and for arguments 
 passed to method calls. See VisitAndGenerateObjectClone for more information. 
 TODO: Note, that Dev10 compiler injects GetObjectValue during IL generation, which means that
 LINQ expression trees do not contain those calls.
 
 TODO: It is possible to consolidate constant folding in one place if we change code generator for 
       BoundTreeRewriter to call base implementation first. Then DefaultVisit will be able to do constant 
       folding and constant rewrite for all nodes. Something to consider for future changes in this area.
 
 TODO: If we bound to the Length or LongLength member of a one-dimensional array,
       transform this into a special tree which generates better IL (ldlen opcode).
 </summary>
	<remarks></remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.SequencePointCreator">
	<summary>
 Visit the tree while annotating it with sequence point nodes. 
 Typical rewrite is:  Node ===&gt; SequencePoint{Syntax, Node}, 
 but some more complicated nodes require more elaborate rewrites - 
 may introduce multiple sequence points, map to syntax different from what bound node is pointing to etc...
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ControlFlowRewriter.NegateIfStepNegative(Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.BoundExpression)">
	<summary>
 Negates the value if step is negative
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ControlFlowRewriter.RewriteForLoopCondition(Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.BoundExpression)">
	<summary>
 Given the control variable, limit and step, produce the loop condition.
 The principle is simle - 
       if step is negative (stepping "Up") then it is "control &gt;= limit"
       otherwise it is "control &lt;= limit"
 
 It gets more complicated when step is not a constant or not a numeric or 
 involves overloaded comparison/IsTrue operators
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ControlFlowRewriter.HoistToTempIfNotConst(Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.LocalSymbol},Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.BoundStatement})">
	<summary>
 If value is const, returns the value unchanged.
 
 In a case if value is not a const, a proxy temp is created and added to "locals"
 In addition to that, code that evaluates and stores the value is added to "statements"
 The access expression to the proxy temp is returned.
 
 Purpose:
 Limit and Step are supposed to be captured for the duration of the loop.
 To ensure that behavior nonconstant values are hoisted into temps before entering the loop
 which avoids re-fetching potentially changed values.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LambdaRewriter.Rewrite(Roslyn.Compilers.VisualBasic.BoundBlock,Roslyn.Compilers.VisualBasic.MethodSymbol,Roslyn.Compilers.VisualBasic.Emit.Module,Roslyn.Compilers.ArrayBuilder{System.Tuple{Roslyn.Compilers.VisualBasic.MethodSymbol,Roslyn.Compilers.VisualBasic.BoundStatement}},Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Rewrite the given node to eliminate lambda expressions.  Also returned are the method symbols and their
 bound bodies for the extracted lambda bodies. These would typically be emitted by the caller such as
 MethodBodyCompiler.  See this class' documentation
 for a more thorough explanation of the algorithm and its use by clients.
 </summary>
	<param name="node">The bound node to be rewritten</param>
	<param name="method">The containing method of the node to be rewritten</param>
	<param name="emitModule">The emit module in which compiler-generated symbols are to be placed</param>
	<param name="generatedMethods">The caller's buffer into which we produce additional methods to be emitted by the caller</param>
	<param name="diagnostics">The caller's buffer into which we place any diagnostics for problems encountered</param>
	<returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.LambdaRewriter.MakeFrames">
	<summary>
 Create the frame types.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LambdaRewriter.FrameOfType(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.SyntaxTree,Roslyn.Compilers.VisualBasic.NamedTypeSymbol)">
	<summary>
 Produces a bound expression representing a pointer to a frame of a particular frame type.
 </summary>
	<param name="syntax">The syntax to attach to the bound nodes produced</param>
	<param name="frameType">The type of frame to be returned</param>
	<returns>A bound node that computes the pointer to the required frame</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.LambdaRewriter.FramePointer(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.SyntaxTree,Roslyn.Compilers.VisualBasic.NamedTypeSymbol)">
	<summary>
 Produce a bound expression representing a pointer to a frame of a particular frame class.
 Note that for generic frames, the frameClass parameter is the generic definition, but
 the resulting expression will be constructed with the current type parameters.
 </summary>
	<param name="syntax">The syntax to attach to the bound nodes produced</param>
	<param name="frameClass">The class type of frame to be returned</param>
	<returns>A bound node that computes the pointer to the required frame</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.LambdaRewriter.ConstructFrameType``1(Roslyn.Compilers.VisualBasic.LambdaRewriter.Frame,Roslyn.Compilers.ReadOnlyArray{``0})">
	<summary>
 Constructs a concrete frame type if needed.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LambdaRewriter.IntroduceFrame(Roslyn.Compilers.VisualBasic.BoundNode,Roslyn.Compilers.VisualBasic.LambdaRewriter.Frame,System.Func{Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.BoundStatement},Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.LocalSymbol},Roslyn.Compilers.VisualBasic.BoundNode},Roslyn.Compilers.VisualBasic.LambdaSymbol)">
	<summary>
 Introduce a frame around the translation of the given node.
 </summary>
	<param name="node">The node whose translation should be translated to contain a frame</param>
	<param name="frame">The frame for the translated node</param>
	<param name="F">A function that computes the translation of the node.  It receives lists of added statements and added symbols</param>
	<returns>The translated statement, as returned from F</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.LambdaRewriter.InitParameterProxy(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.SyntaxTree,Roslyn.Compilers.VisualBasic.ParameterSymbol,Roslyn.Compilers.VisualBasic.LocalSymbol,Roslyn.Compilers.VisualBasic.NamedTypeSymbol,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.BoundStatement})">
	<summary>
 If parameter is lifted, initializes its proxy
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LambdaRewriter.BlockDepth(Roslyn.Compilers.VisualBasic.BoundNode)">
	<summary>
 Compute the nesting depth of a given block.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LambdaRewriter.RewriteMethodSymbol(Roslyn.Compilers.VisualBasic.MethodSymbol)">
	<summary>
 Rewrites method.
 TODO: consider making this more general VisitMethod like VisitType above.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LambdaRewriter.RewriteLambdaAsMethod(Roslyn.Compilers.VisualBasic.MethodSymbol,Roslyn.Compilers.VisualBasic.BoundLambda)">
	<summary>
 Rewrites lambda body into a body of a method.
 </summary>
	<param name="method">Method symbol for the rewritten lambda body.</param>
	<param name="lambda">Original lambda node.</param>
	<returns>Lambda body rewritten as a body of the given method symbol.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.LambdaRewriter.IsLegalBranch(Roslyn.Compilers.VisualBasic.BoundNode,Roslyn.Compilers.VisualBasic.BoundNode)">
	<summary>
 It is illegal to jump into blocks that reference lifted variable
 as that could leave closure frames of the target block uninitialized.
 
 The fact that closure could be created as high as the declaration level of the variable
 and well above goto block (thus making the jump safe) is considered an optional optimization 
 and ignored. 
 For the purpose of this analysis just having lifting lambdas already means 
 that block may require initialization and cannot be jumped into.
 
 Note that when you are jumping into a block you are essentially jumping into ALL blocks
 on the path from LowestCommonAncestor(goto, label) to the actual label block.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.LambdaRewriter">
	<summary>
 The rewriter for removing lambda expressions from method bodies and introducing closure classes
 as containers for captured variables along the lines of the example in section 6.5.3 of the
 C# language specification.
 
 The entry point is the public method Rewrite.  It operates as follows:
 
 First, an analysis of the whole method body is performed that determines which variables are
 captured, what their scopes are, and what the nesting relationship is between scopes that
 have captured variables.  The result of this analysis is left in LambdaRewriter.analysis.
 
 Then we make frame, or compiler-generated class, represented by an instance of
 LambdaRewriter.Frame for each scope with captured variables.  The generated frames are kept
 in LambdaRewriter.frames.  Each frame is given a single field for each captured
 variable in the corresponding scope.  These are are maintained in LambdaRewriter.proxies.
 
 Finally, we walk and rewrite the input bound tree, keeping track of the following:
 (1) The current set of active frame pointers, in LambdaRewriter.framePointers
 (2) The current method being processed (this changes within a lambda's body), in LambdaRewriter.currentMethod
 (3) The "this" symbol for the current method in LambdaRewriter.currentFrameThis, and
 (4) The symbol that is used to access the innermost frame pointer (it could be a local variable or "this" parameter)
 
 There are a few key transformations done in the rewriting.
 (1) Lambda expressions are turned into delegate creation expressions, and the body of the lambda is
     moved into a new, compiler-generated method of a selected frame class.
 (2) On entry to a scope with captured variables, we create a frame object and store it in a local variable.
 (3) References to captured variables are transformed into references to fields of a frame class.
 
 In addition, the rewriting deposits into the field LambdaRewriter.generatedMethods a (MethodSymbol, BoundStatement)
 pair for each generated method.
 
 LambdaRewriter.Rewrite produces its output in two forms.  First, it returns a new bound statement
 for the caller to use for the body of the original method.  Second, it returns a collection of
 (MethodSymbol, BoundStatement) pairs for additional method that the lambda rewriter produced.
 These additional methods contain the bodies of the lambdas moved into ordinary methods of their
 respective frame classes, and the caller is responsible for processing them just as it does with
 the returned bound node.  For example, the caller will typically perform iterator method and
 asynchronous method transformations, and emit IL instructions into an assembly.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LambdaRewriter.Frame.#ctor(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.SyntaxTree,Roslyn.Compilers.VisualBasic.NamedTypeSymbol,Roslyn.Compilers.VisualBasic.MethodSymbol,System.Boolean)">
	<summary>
 Creates a Frame definition
 </summary>
	<param name="containingType">Type that contains Frame type.</param>
	<param name="enclosingMethod">Method that contains lambda expression for which we do the rewrite.</param>
	<param name="copyConstructor">Specifies whether the Frame needs a copy-constructor.</param>
	<remarks></remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.LambdaRewriter.Frame">
	<summary>
 A class that represents the set of variables in a scope that have been
 captured by lambdas within that scope.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.LambdaRewriter.CapturedVariable">
	<summary>
 A field of a frame class that represents a variable that has been captured in a lambda.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.LambdaRewriter.FrameReference">
	<summary>
 A local variable used to store a reference to the frame objects in which captured
 local variables have become fields.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.LambdaRewriter.SynthesizedLambdaCopyConstructor">
	<summary>
 Copy constructor has one parameter of the same type as the enclosing type.
 The purpose is to copy all the lifted values from previous version of the 
 frame if there was any into the new one.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LambdaRewriter.SynthesizedLambdaMethod.#ctor(Roslyn.Compilers.VisualBasic.InstanceTypeSymbol,Roslyn.Compilers.VisualBasic.MethodSymbol,Roslyn.Compilers.VisualBasic.SyntaxTree,Roslyn.Compilers.VisualBasic.BoundLambda,System.Boolean)">
	<summary>
 Creates a symbol for a synthesized lambda method
 </summary>
	<param name="containingType">Type that contains lambda method 
 - it is either Frame or enclosing class in a case if we do not lift anything.</param>
	<param name="enclosingMethod">Method that contains lambda expression for which we do the rewrite.</param>
	<param name="syntaxTree">Syntax tree. Used for diagnostics.</param>
	<param name="lambdaNode">Lambda expression which is represented by this method.</param>
	<param name="isShared">Specifies whether lambda method should be shared.</param>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.LambdaRewriter.SynthesizedLambdaMethod.WithNewContainerAndType(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.ParameterSymbol)">
	<summary>
 Creates a clone of the local with a new containing symbol and type.
 Note that the new parameter gets no syntaxRef as it is supposed to get 
 all the values it needs from the original parameter.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.LambdaRewriter.SynthesizedLambdaMethod">
	<summary>
 A method that results from the translation of a single lambda expression.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.LambdaRewriter.SynthesizedMethod">
	<summary>
 Base for synthesised Lambda methods. 
 Just provides a bunch of defaults
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.LambdaRewriter.MappedTypeParameterSymbol">
	<summary>
 Type parameter that represents another type parameter 
 while being applied on a different symbol
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.LambdaRewriter.Analysis.seenLambda">
	<summary>
 Set to true of any lambda expressions were seen in the analyzed method body.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.LambdaRewriter.Analysis.seenBackBranches">
	<summary>
 Set to true if method body contains any back branches (loops).
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.LambdaRewriter.Analysis.blockParent">
	<summary>
 For each statement with captured variables, identifies the nearest enclosing statement with captured variables.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.LambdaRewriter.Analysis.variableBlock">
	<summary>
 For each captured variable, identifies the statement in which it will be moved to a frame class.  This is
 normally the block where the variable is introduced, but method parameters are moved
 to a frame class within the body of the method.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.LambdaRewriter.Analysis.labelBlock">
	<summary>
 For a given label, the nearest enclosing block that captures variables
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.LambdaRewriter.Analysis.gotoBlock">
	<summary>
 For a given goto, the nearest enclosing block that captures variables
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.LambdaRewriter.Analysis.containsLiftingLambda">
	<summary>
 Blocks that contain (recursively) a lambda that is lifting. 
 Such blocks are considered as potentially needing closure initialization when doing jump verification.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.LambdaRewriter.Analysis.needsParentFrame">
	<summary>
 Blocks that are positioned between a block declaring some lifted variables
 and a block that contains the lambda that lifts said variables.
 If such block itself requires a closure, then it must lift parent frame pointer into the closure
 in addition to whatever else needs to be lifted.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.LambdaRewriter.Analysis.captured">
	<summary>
 The set of captured variables seen in the method body.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.LambdaRewriter.Analysis.captures">
	<summary>
 For each lambda in the code, the set of variables that it captures.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LambdaRewriter.Analysis.AnalyzeMethodBody(Roslyn.Compilers.VisualBasic.BoundBlock,Roslyn.Compilers.VisualBasic.MethodSymbol,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Analyses method body that belongs to the given method symbol.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LambdaRewriter.Analysis.Analyze(Roslyn.Compilers.VisualBasic.BoundNode,Roslyn.Compilers.VisualBasic.MethodSymbol,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Analyses any random bound node.
 Results will contain variable capture information, but may not be suitable for lambda rewrite.
 Used by region analysis for figuring what was captured.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LambdaRewriter.Analysis.RecordCaptureInIntermediateBlocks(Roslyn.Compilers.VisualBasic.Symbol)">
	<summary>
 Once we see a lambda lifting something
 We mark all blocks from the current up to the one that declares lifted symbol as
 containing a lifting lambda.
 This is needed so that we could reject jumps that might jump over frame allocations.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LambdaRewriter.Analysis.ReferenceVariable(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.SyntaxTree)">
	<summary>
 This method is called on every variable reference.
 It checks for cases where variable is declared outside of the lambda in which it is being accessed
 If capture is detected, than it marks variable as capturED and all lambdas involved as capturING
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LambdaRewriter.Analysis.MayParticipateInIllegalBranch(Roslyn.Compilers.VisualBasic.BoundGotoStatement)">
	<summary>
 For performance reason we may not want to check if synthetic gotos are legal.
 Those are the majority, but should not be ever illegal (how user would fix them?).
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.LambdaRewriter.Analysis">
	<summary>
 Perform a first analysis pass in preparation for removing all lambdas from a method body.  The entry point is Analyze.
 The results of analysis are placed in the fields seenLambda, blockParent, variableBlock, captured, and captures.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InitializerRewriter.Rewrite(Roslyn.Compilers.VisualBasic.MethodSymbol,Roslyn.Compilers.VisualBasic.BoundStatement,Roslyn.Compilers.VisualBasic.Binder.ProcessedFieldOrPropertyInitializers@,Roslyn.Compilers.VisualBasic.BoundBlock,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Rewrites the specified bound initializers.
 In case the method is a constructor or shared constructor, it tries to lower the BoundFieldOrPropertyInitializer expressions 
 to a list of assignment statements. If the method body does not contain a call to another constructor of this class, 
 these statements will be prepended to the statements of the given BoundBlock.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InitializerRewriter.LowerInitializers(Roslyn.Compilers.VisualBasic.MethodSymbol,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.BoundFieldOrPropertyInitializer},Roslyn.Compilers.DiagnosticBag)">
	<summary>
	</summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InitializerRewriter.HasMeConstructorCall(Roslyn.Compilers.VisualBasic.BoundBlock,Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 Determines if this method calls into another constructor of the method's containing class.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InitializerRewriter.BoundInitializerRewriter">
	<summary> Rewrites bound initializers before they are inserted into .ctor </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InitializerRewriter">
	<summary>
 Turns the bound initializers into a list of bound assignment statements
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.VariablesDeclaredWalker">
	<summary>
 A region analysis walker that records declared variables.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.UnassignedVariablesWalker">
	<summary>
 An analysis that computes the set of variables that may be used
 before being assigned anywhere within a method.
 </summary>
	<remarks></remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.ThisSymbolCache">
	<summary>
 A cache that keeps track of the unique "this" symbol for each instance method, field or property.  
 Note that this is a temporary solution until binding makes these symbols itself.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ReturnStatementsWalker.Analyze(Roslyn.Compilers.VisualBasic.Compilation,Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.BoundNode,Roslyn.Compilers.TextSpan)">
	<summary>
 A collection of return, exit sub, exit function, exit operator and exit property statements found within the region that return to the enclosing method.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.RegionDataFlowAnalysis.VariablesDeclared">
	<summary>
 A collection of the local variables that are declared within the region. Note that the region must be 
 bounded by a method's body or a field's initializer, so parameter symbols are never included in the result.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.RegionDataFlowAnalysis.DataFlowsIn">
	<summary>
 A collection of the local variables for which a value assigned outside the region may be used inside the region.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.RegionDataFlowAnalysis.DataFlowsOut">
	<summary>
 A collection of the local variables for which a value assigned inside the region may be used outside the region.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.RegionDataFlowAnalysis.AlwaysAssigned">
	<summary>
 A collection of the local variables for which a value is always assigned inside the region.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.RegionDataFlowAnalysis.ReadInside">
	<summary>
 A collection of the local variables that are read inside the region.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.RegionDataFlowAnalysis.WrittenInside">
	<summary>
 A collection of local variables that are written inside the region.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.RegionDataFlowAnalysis.ReadOutside">
	<summary>
 A collection of the local variables that are read outside the region.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.RegionDataFlowAnalysis.WrittenOutside">
	<summary>
 A collection of local variables that are written inside the region.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.RegionDataFlowAnalysis.Captured">
	<summary>
 A collection of the local variables that have been referenced in anonymous functions
 and therefore must be moved to a field of a frame class.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.RegionDataFlowAnalysis">
	<summary>
 This class implements the region data flow analysis operations.  Region data flow analysis provides information
 how data flows into and out of a region.  The analysis is done lazily. When created, it performs no analysis, but
 simply caches the arguments. Then, the first time one of the analysis results is used it computes that one
 result and caches it. Each result is computed using a custom algorithm.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.RegionControlFlowAnalysis.JumpsIntoRegion">
	<summary>
 A collection of statements outside the region that jump into the region.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.RegionControlFlowAnalysis.JumpsOutOfRegion">
	<summary>
 A collection of statements inside the region that jump to locations outside the region.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.RegionControlFlowAnalysis.RegionEndPointIsReachable">
	<summary>
 Returns true if and only if the last statement in the region can complete normally or the region contains no
 statements.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.RegionControlFlowAnalysis.ReturnStatements">
	<summary>
 A collection of return, exit sub, exit function, exit operator and exit property statements found within the region that return to the enclosing method.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.RegionControlFlowAnalysis">
	<summary>
 This class implements the region control flow analysis operations.  Region control flow analysis provides
 information about statements which enter and leave a region. The analysis done lazily. When created, it performs
 no analysis, but simply caches the arguments. Then, the first time one of the analysis results is used it
 computes that one result and caches it. Each result is computed using a custom algorithm.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.RegionEndPointIsReachableWalker">
	<summary>
 A region analysis walker that computes whether or not the region completes normally.  It does this by determining
 if the point at which the region ends is reachable.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.ReadWriteWalker">
	<summary>
 A region analysis walker that records reads and writes of all variables, both inside and outside the region.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.JumpsOutOfRegionWalker">
	<summary>
 A region analysis walker that records jumps out of the region.
 </summary>
	<remarks></remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.JumpsIntoRegionWalker">
	<summary>
 A region analysis walker that records jumps into the region.  Works by overriding NoteBranch, which is
 invoked by a superclass when the two endpoints of a jump have been identified.
 </summary>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.FlowAnalysisPass.Rewrite(Roslyn.Compilers.VisualBasic.MethodSymbol,Roslyn.Compilers.VisualBasic.BoundBlock,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 The flow analysis pass.  This pass reports required diagnostics for unreachable
 statements and uninitialized variables (through the call to FlowAnalysisWalker.Analyze).
 </summary>
	<param name="method">the method to be analyzed</param>
	<param name="block">the method's body</param>
	<param name="diagnostics">the receiver of the reported diagnostics</param>
	<returns>the rewritten block for the method (with a return statement possibly inserted)</returns>
</member><member name="T:Roslyn.Compilers.VisualBasic.DataFlowsOutWalker">
	<summary>
 A region analysis walker that computes the set of variables for which their assigned values flow out of the region.
 A variable assigned inside is used outside if an analysis that
 treats assignments in the region as unassigning the variable would
 cause "unassigned" errors outside the region.</summary>
	<remarks></remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.DataFlowsInWalker">
	<summary>
 A region analysis walker that computes the set of variables whose values flow into (are used in)
 the region.
 An variable assigned outside is used inside if an analysis
 that leaves the variable unassigned on entry to the region would cause the
 generation of "unassigned" errors within the region.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.DataFlowAnalysis.SlotKind.NotTracked">
	<summary>
  Special slot for untracked variables
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.DataFlowAnalysis.SlotKind.Unreachable">
	<summary>
 Special slot for tracking whether code is reachable
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.DataFlowAnalysis.SlotKind.FunctionValue">
	<summary>
 Special slot for tracking the implicit local for the function return value
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.DataFlowAnalysis.SlotKind.FirstAvailable">
	<summary>
 The first available slot for variables
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.DataFlowAnalysis.initiallyAssignedVariables">
	<summary>
 Some variables that should be considered initially assigned.  Used for region analysis.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.DataFlowAnalysis.usedVariables">
	<summary>
 Variables that were used anywhere, in the sense required to suppress warnings about unused variables.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.DataFlowAnalysis.writtenVariables">
	<summary>
 Variables that were initialized or written anywhere.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.DataFlowAnalysis.variableBySlot">
	<summary>
 A mapping from the local variable slot to the symbol for the local variable itself.  This is used in the
 implementation of region analysis (support for extract method) to compute the set of variables "always
 assigned" in a region of code.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.DataFlowAnalysis.nextVariableSlot">
	<summary>
 Variable slots are allocated to local variables sequentially and never reused.  This is
 the index of the next slot number to use.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.DataFlowAnalysis.alreadyReported">
	<summary>
 Tracks variables for which we have already reported a definite assignment error.  This
 allows us to report at most one such error per variable.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.DataFlowAnalysis.Diagnostics">
	<summary>
 Where all diagnostics are deposited.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.DataFlowAnalysis.Analyze(Roslyn.Compilers.VisualBasic.Compilation,Roslyn.Compilers.VisualBasic.MethodSymbol,Roslyn.Compilers.VisualBasic.BoundStatement,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Perform data flow analysis, reporting all necessary diagnostics.
 </summary>
	<param name="compilation"></param>
	<param name="method"></param>
	<param name="block"></param>
	<param name="diagnostics"></param>
</member><member name="M:Roslyn.Compilers.VisualBasic.DataFlowAnalysis.Analyze(Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Analyze the body, reporting all necessary diagnostics.
 </summary>
	<param name="diagnostics"></param>
</member><member name="M:Roslyn.Compilers.VisualBasic.DataFlowAnalysis.VariableSlot(Roslyn.Compilers.VisualBasic.Symbol)">
	<summary>
 Locals are given slots when their declarations are encountered.  We only need give slots to local variables,
 out parameters, and the "this" variable of a structure constructs. Other variables are not given slots, and
 are therefore not tracked by the analysis.  This returns -1 for a variable that is not tracked.  We do not
 need to track references to variables that occur before the variable is declared, as those are reported in
 an earlier phase as "use before declaration". That allows us to avoid giving slots to local variables before
 processing their declarations.
 </summary>
	<param name="local"></param>
	<returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.DataFlowAnalysis.MakeSlot(Roslyn.Compilers.VisualBasic.Symbol)">
	<summary>
 Force a variable to have a slot.
 </summary>
	<param name="local"></param>
	<returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.DataFlowAnalysis.CheckAssigned(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.SyntaxTree,System.Boolean)">
	<summary>
 Check that the given variable is definitely assigned.  If not, produce an error.
 </summary>
	<param name="symbol"></param>
	<param name="node"></param>
</member><member name="M:Roslyn.Compilers.VisualBasic.DataFlowAnalysis.ReportUnassigned(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.SyntaxTree,System.Boolean)">
	<summary>
 Report a given variable as not definitely assigned.  Once a variable has been so
 reported, we suppress further reports of that variable.
 </summary>
	<param name="sym"></param>
	<param name="node"></param>
</member><member name="M:Roslyn.Compilers.VisualBasic.DataFlowAnalysis.Assign(Roslyn.Compilers.VisualBasic.BoundNode,Roslyn.Compilers.VisualBasic.BoundExpression,System.Boolean)">
	<summary>
 Mark a variable as assigned (or unassigned).
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.DataFlowAnalysis.LocalState.Clone">
	<summary>
 Produce a duplicate of this flow analysis state.
 </summary>
	<returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.ControlFlowAnalysis.LocalState.Clone">
	<summary>
 Produce a duplicate of this flow analysis state.
 </summary>
	<returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.ControlFlowAnalysis.Analyze(Roslyn.Compilers.VisualBasic.Compilation,Roslyn.Compilers.VisualBasic.MethodSymbol,Roslyn.Compilers.VisualBasic.BoundStatement,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Perform control flow analysis, reporting all necessary diagnostics.  Returns true if the end of
 the body might be reachable..
 </summary>
	<param name="compilation"></param>
	<param name="method"></param>
	<param name="block"></param>
	<param name="diagnostics"></param>
	<returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.ControlFlowAnalysis.Analyze(Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Analyze the body, reporting all necessary diagnostics.  Returns true if the end of the
 body might be reachable.
 </summary>
	<param name="diagnostics"></param>
	<returns></returns>
</member><member name="P:Roslyn.Compilers.VisualBasic.ControlFlowAnalysis.Diagnostics">
	<summary>
 Where all diagnostics are deposited.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.AnalysisContext.Compilation">
	<summary> Current compilation </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.AnalysisContext.Symbol">
	<summary> Method, field or property symbol </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.AnalysisContext.BoundNode">
	<summary> Bound node </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.AnalysisContext.Region">
	<summary> Region being analyzed </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AnalysisContext.#ctor(Roslyn.Compilers.VisualBasic.SyntaxTreeSemanticModel,Roslyn.Compilers.TextSpan)">
	<summary>
 Construct context from model and region
 </summary>
	<param name="model"></param>
	<param name="region"></param>
</member><member name="T:Roslyn.Compilers.VisualBasic.AnalysisContext">
	<summary>
 Represents analysis context attributes such as compilation, region, etc...
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.AlwaysAssignedWalker">
	<summary>
 A region analysis walker that computes the set of variables that are always assigned a value in the region.
 A variable is "always assigned" in a region if an analysis of the
 region that starts with the variable unassigned ends with the variable
 assigned.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AbstractRegionDataFlowAnalysis.NoteLocation(Roslyn.Compilers.TextSpan)">
	<summary>
 Used to keep track of whether we are currently within the region or not.
 </summary>
	<param name="currentLocation"></param>
</member><member name="M:Roslyn.Compilers.VisualBasic.AbstractRegionDataFlowAnalysis.EnterRegion">
	<summary>
 Subclasses may override EnterRegion to perform any actions at the entry to the region.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AbstractRegionDataFlowAnalysis.LeaveRegion">
	<summary>
 Subclasses may override LeaveRegion to perform any action at the end of the region.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AbstractRegionDataFlowAnalysis.LeaveRegionIfNotEnclosed(Roslyn.Compilers.VisualBasic.BoundNode)">
	<summary>
 This method to be called whenever we want to check if we are still inside the region and we need to leave it 
 because the node is not fully enclosed by the region. It should be called in two situations:  (a) after we visited 
 condition and before we split the state in order to finish processing the condition if the region embraces it; 
 and (b) before we switch or unsplit the sates to ensure that the previous bound node is processed properly before 
 the state is switched or unsplit.
 </summary>
	<param name="node">node to check for being enclosed</param>
	<remarks>This method should be called in cases then the bound node's children can be considered 
 'isolated' and 'mutually excluside', which means that either the parent node is enclosed by the region
 or one and only one of it's children is enclosed (in case we are inside the region at the time of the call) </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.AbstractRegionDataFlowAnalysis.Scan">
	<summary>
 To scan the whole body, we start outside (before) the region.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AbstractRegionControlFlowAnalysis.NoteLocation(Roslyn.Compilers.TextSpan)">
	<summary>
 Used to keep track of whether we are currently within the region or not.
 </summary>
	<param name="currentLocation"></param>
</member><member name="M:Roslyn.Compilers.VisualBasic.AbstractRegionControlFlowAnalysis.EnterRegion">
	<summary>
 Subclasses may override EnterRegion to perform any actions at the entry to the region.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AbstractRegionControlFlowAnalysis.LeaveRegion">
	<summary>
 Subclasses may override LeaveRegion to perform any action at the end of the region.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AbstractRegionControlFlowAnalysis.LeaveRegionIfNotEnclosed(Roslyn.Compilers.VisualBasic.BoundNode)">
	<summary>
 This method to be called whenever we want to check if we are still inside the region and we need to leave it 
 because the node is not fully enclosed by the region. It should be called in two situations:  (a) after we visited 
 condition and before we split the state in order to finish processing the condition if the region embraces it; 
 and (b) before we switch or unsplit the sates to ensure that the previous bound node is processed properly before 
 the state is switched or unsplit.
 </summary>
	<param name="node">node to check for being enclosed</param>
	<remarks>This method should be called in cases then the bound node's children can be considered 
 'isolated' and 'mutually excluside', which means that either the parent node is enclosed by the region
 or one and only one of it's children is enclosed (in case we are inside the region at the time of the call) </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.AbstractRegionControlFlowAnalysis.Scan">
	<summary>
 To scan the whole body, we start outside (before) the region.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AbstractFlowAnalysis`1.AbstractLocalState.Clone">
	<summary>
 Produce a duplicate of this flow analysis state.
 </summary>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.AbstractFlowAnalysis`1.AbstractLocalState.IntersectWith(`0)">
	<summary>
 Mutate this flow analysis state to reflect the fact that there is a control-flow
 convergence with the other flow analysis state.  Return true if and only if the
 state has changed as a result of the Join.
 </summary>
	<param name="other"></param>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.AbstractFlowAnalysis`1.AbstractLocalState.UnionWith(`0)">
	<summary>
 Mutate this flow analysis state to reflect the fact that there is a control-flow
 sequence with the other flow analysis state - in other words, this occurs and then
 the other.
 </summary>
	<param name="other"></param>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.AbstractFlowAnalysis`1.AbstractLocalState.Split">
	<summary>
 Turn this state into a conditional (boolean) state, to be used for control-flow.
 </summary>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.AbstractFlowAnalysis`1.AbstractLocalState.Unsplit">
	<summary>
 Turn this state into a non-conditional state (i.e. not to be used for control-flow).
 </summary>
	<remarks></remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.AbstractFlowAnalysis`1.BlockNesting">
	<summary>
 BlockLevel is used to keep track of the lexical nesting level of label and goto statements. 
 The other most block has a path of {}
 </summary>
	<remarks></remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.AbstractFlowAnalysis`1.LabelStateAndNesting">
	<summary>
 The state associated with a label includes the statement itself, the local state and the nesting.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.AbstractFlowAnalysis`1.compilation">
	<summary>
 The compilation in which the analysis is taking place.  This is needed to determine which
 conditional methods will be compiled and which will be omitted.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.AbstractFlowAnalysis`1.symbol">
	<summary>
 The symbol of method whose body is being analyzed or field or property whose initializer is being analyzed
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.AbstractFlowAnalysis`1._meParameter">
	<summary>
 The Me parameter
 </summary>
	<remarks></remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.AbstractFlowAnalysis`1.ShouldAnalyzeByRefParameters">
	<summary>
 Specifies whether or not method's ByRef parameters should be analyzed. If there's more than one location in
 the method being analyzed, then the method is partial and we prefer to report an out parameter in partial
 method error.
 Note: VB doesn't support "out" so it doesn't warn for unassigned parameters. However, check variables passed
 byref are assigned so that data flow analysis detects parameters flowing out.
 </summary>
	<returns>true if the out parameters of the method should be analyzed</returns>
</member><member name="P:Roslyn.Compilers.VisualBasic.AbstractFlowAnalysis`1.MethodParameters">
	<summary>
 If analysis is being performed in a context of a method returns method's parameters, 
 otherwise returns an empty array
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AbstractFlowAnalysis`1.MethodSymbol">
	<summary>
 Method symbol or nothing
 TODO: Need to try and get rid of this property
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AbstractFlowAnalysis`1.MeParameter">
	<summary>
 'Me' parameter, relevant for methods, fields, properties
 otherwise returns Nothing
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AbstractFlowAnalysis`1.MethodReturnType">
	<summary>
 If analysis is being performed in a context of a method returns method's return type, 
 otherwise returns Nothing
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.AbstractFlowAnalysis`1.node">
	<summary>
 The bound code of the method being analyzed.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.AbstractFlowAnalysis`1.loopHeadState">
	<summary>
 A cache of the state at the backward branch point of each loop.  This is not needed
 during normal flow analysis, but is needed for region analysis.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.AbstractFlowAnalysis`1.nesting">
	<summary>
 The current lexical nesting in the BoundTree. 
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.AbstractFlowAnalysis`1.labels">
	<summary>
 The flow analysis state at each label, computed by merging the state from branches to
 that label with the state when we fall into the label.  Entries are created when the
 label is encountered.  One case deserves special attention: when the destination of the
 branch is a label earlier in the code, it is possible (though rarely occurs in practice)
 that we are changing the state at a label that we've already analyzed. In that case we
 run another pass of the analysis to allow those changes to propagate. This repeats until
 no further changes to the state of these labels occurs.  This can result in quadratic
 performance in unlikely but possible code such as this: "int x; if (cond) goto l1; x =
 3; l5: print x; l4: goto l5; l3: goto l4; l2: goto l3; l1: goto l2;"
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.AbstractFlowAnalysis`1.backwardBranchChanged">
	<summary>
 Set to true after an analysis scan if the analysis was incomplete due to a backward
 "goto" branch changing some analysis result.  In this case the caller scans again (until
 this is false). Since the analysis proceeds by monotonically changing the state computed
 at each label, this must terminate.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.AbstractFlowAnalysis`1.pendingBranches">
	<summary>
 Pending escapes generated in the current scope (or more deeply nested scopes). When jump
 statements (goto, break, continue, return) are processed, they are placed in the
 pendingBranches buffer to be processed later by the code handling the destination
 statement. As a special case, the processing of try-finally statements might modify the
 contents of the pendingBranches buffer to take into account the behavior of
 "intervening" finally clauses.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.AbstractFlowAnalysis`1.state">
	<summary>
 The definite assignment and reachability state at the point currently being analyzed.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AbstractFlowAnalysis`1.Scan">
	<summary>
 Perform a single pass of flow analysis.  Note that after this pass,
 this.backwardBranchChanged indicates if a further pass is required.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.AbstractFlowAnalysis`1.PendingBranch">
	<summary>
 A pending branch.  There are created for a return, break, continue, or goto statement.  The
 idea is that we don't know if the branch will eventually reach its destination because of an
 intervening finally block that cannot complete normally.  So we store them up and handle them
 as we complete processing each construct.  At the end of a block, if there are any pending
 branches to a label in that block we process the branch.  Otherwise we relay it up to the
 enclosing construct as a pending branch of the enclosing construct.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AbstractFlowAnalysis`1.LabelState(Roslyn.Compilers.VisualBasic.LabelSymbol)">
	<summary>
 Return the flow analysis state associated with a label.
 </summary>
	<param name="label"></param>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.AbstractFlowAnalysis`1.SetUnreachable">
	<summary>
 Set the current state to one that indicates that it is unreachable.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AbstractFlowAnalysis`1.LeaveRegionIfNotEnclosed(Roslyn.Compilers.VisualBasic.BoundNode)">
	<summary>
 This method to be called whenever we want to check if we are still inside the region and we need to leave it 
 because the node is not fully enclosed by the region. It should be called in two situations:  (a) after we visited 
 condition and before we split the state in order to finish processing the condition if the region embraces it; 
 and (b) before we switch or unsplit the sates to ensure that the previous bound node is processed properly before 
 the state is switched or unsplit.
 </summary>
	<param name="node">node to check for being enclosed</param>
	<remarks>This method should be called in cases then the bound node's children can be considered 
 'isolated' and 'mutually excluside', which means that either the parent node is enclosed by the region
 or one and only one of it's children is enclosed (in case we are inside the region at the time of the call) </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.AbstractFlowAnalysis`1.Visit(Roslyn.Compilers.VisualBasic.BoundNode)">
	<summary>
 Visit a node.
 </summary>
	<param name="node"></param>
</member><member name="M:Roslyn.Compilers.VisualBasic.AbstractFlowAnalysis`1.VisitCondition(Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.BoundNode)">
	<summary>
 Visit a boolean condition expression.
 </summary>
	<param name="node"></param>
	<param name="parent"></param>
</member><member name="M:Roslyn.Compilers.VisualBasic.AbstractFlowAnalysis`1.VisitRvalue(Roslyn.Compilers.VisualBasic.BoundExpression,System.Boolean)">
	<summary>
 Visit a general expression, where we will only need to determine if variables are
 assigned (or not). That is, we will not be needing AssignedWhenTrue and
 AssignedWhenFalse.
 </summary>
	<param name="node"></param>
	<param name="isByRef"></param>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.AbstractFlowAnalysis`1.VisitStatement(Roslyn.Compilers.VisualBasic.BoundStatement)">
	<summary>
 Visit a statement.
 </summary>
	<param name="statement"></param>
</member><member name="M:Roslyn.Compilers.VisualBasic.AbstractFlowAnalysis`1.LoopHead(Roslyn.Compilers.VisualBasic.BoundLoopStatement)">
	<summary>
 Called at the point in a loop where the backwards branch would go to.
 </summary>
	<param name="node"></param>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.AbstractFlowAnalysis`1.LoopTail(Roslyn.Compilers.VisualBasic.BoundLoopStatement)">
	<summary>
 Called at the point in a loop where the backward branch is placed.
 </summary>
	<param name="node"></param>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.AbstractFlowAnalysis`1.ResolveBreaks(`0,Roslyn.Compilers.VisualBasic.LabelSymbol)">
	<summary>
 Used to resolve break statements in each statement form that has a break statement
 (loops, switch).
 </summary>
	<param name="breakState"></param>
	<param name="breakLabel"></param>
</member><member name="M:Roslyn.Compilers.VisualBasic.AbstractFlowAnalysis`1.ResolveContinues(Roslyn.Compilers.VisualBasic.LabelSymbol)">
	<summary>
 Used to resolve continue statements in each statement form that supports it.
 </summary>
	<param name="continueLabel"></param>
</member><member name="M:Roslyn.Compilers.VisualBasic.AbstractFlowAnalysis`1.NoteBranch(Roslyn.Compilers.VisualBasic.AbstractFlowAnalysis{`0}.PendingBranch,Roslyn.Compilers.VisualBasic.BoundGotoStatement,Roslyn.Compilers.VisualBasic.BoundLabelStatement)">
	<summary>
 Subclasses override this if they want to take special actions on processing a goto
 statement, when both the jump and the label have been located.
 </summary>
	<param name="pending"></param>
	<param name="gotoStmt"></param>
	<param name="labelStmt"></param>
</member><member name="M:Roslyn.Compilers.VisualBasic.AbstractFlowAnalysis`1.ResolveBranches(Roslyn.Compilers.VisualBasic.BoundLabelStatement)">
	<summary>
 To handle a label, we resolve all pending forward references to branches to that label.  Returns true if the state of
 the label changes as a result. 
 </summary>
	<param name="target"></param>
	<returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.AbstractFlowAnalysis`1.ResolveBranches">
	<summary>
 To handle a block, we look at all pending branches and attempt to resolve the branches with labels
 if the nesting of the block is the nearest common parent to the branch and the label.  Because
 the code is evaluated recursively outward we only need to check if the current nesting is a prefix
 of both the branch and the label nesting.
 </summary>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.AbstractFlowAnalysis`1.SavePending">
	<summary>
 When branching into constructs that don't support jumps into/out of (i.e. lambdas), we save the pending branches when visiting more nested constructs.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AbstractFlowAnalysis`1.RestorePending(Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.AbstractFlowAnalysis{`0}.PendingBranch})">
	<summary>
 We use this to restore the old set of pending branches after visiting a construct that contains nested statements.
 </summary>
	<param name="oldPending">The old pending branches, which are to be merged with the current ones</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.AbstractFlowAnalysis`1.Unimplemented(Roslyn.Compilers.VisualBasic.BoundNode,System.String)">
	<summary>
 Report an unimplemented language construct.
 </summary>
	<param name="node"></param>
	<param name="feature"></param>
	<returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.AbstractFlowAnalysis`1.DefaultVisit(Roslyn.Compilers.VisualBasic.BoundNode)">
	<summary>
 Since each language construct must be handled according to the rules of the language specification,
 the default visitor reports that the construct for the node is not implemented in the compiler.
 </summary>
	<param name="node"></param>
	<returns></returns>
</member>
</members>
</doc>