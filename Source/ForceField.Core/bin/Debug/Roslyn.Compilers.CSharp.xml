<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Roslyn.Compilers.CSharp</name>
    </assembly>
    <members>
        <member name="T:Roslyn.Compilers.CSharp.ControlFlowRewriter">
            <summary>
            Lowers foreach-loops to simpler loops enclosed in try-finally blocks (for disposal).
            </summary>
            <remarks>
            This is not a separate rewrite pass.  It simply encapsulates ControlFlowRewriter functionality
            that is specific to foreach-loops.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ControlFlowRewriter.VisitForEachStatement(Roslyn.Compilers.CSharp.BoundForEachStatement)">
            <summary>
            This is the entry point for foreach-loop lowering.  It delegates to
              RewriteEnumeratorForEachStatement
              RewriteSingleDimensionalArrayForEachStatement
              RewriteMultiDimensionalArrayForEachStatement
              RewriteStringForEachStatement
            </summary>
            <remarks>
            NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE
            We are diverging from the C# 4 spec (and Dev10) to follow the C# 5 spec.
            The iteration variable will be declared *inside* each loop iteration,
            rather than outside the loop.
            NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ControlFlowRewriter.RewriteEnumeratorForEachStatement(Roslyn.Compilers.CSharp.BoundForEachStatement)">
            <summary>
            Lower a foreach loop that will enumerate a collection using an enumerator.
            
            E e = ((C)(x)).GetEnumerator()
            try {
                while (e.MoveNext()) {
                    V v = (V)(T)e.Current;
                    // body
                }
            }
            finally {
                // clean up e
            }
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ControlFlowRewriter.SynthesizeCall(Roslyn.Compilers.CSharp.BoundExpression,Roslyn.Compilers.CSharp.MethodSymbol,Roslyn.Compilers.CSharp.Conversion,Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            Synthesize a no-argument call to a given method, possibly applying a conversion to the receiver.
            
            If the receiver is of struct type and the method is an interface method, then skip the conversion
            and just call the interface method directly - the code generator will detect this and generate a 
            constrained virtual call.
            </summary>
            <param name="receiver">Receiver of method call.</param>
            <param name="method">Method to invoke.</param>
            <param name="receiverConversion">Conversion to be applied to the receiver if not calling an interface method on a struct.</param>
            <param name="convertedReceiverType">Type of the receiver after applying the conversion.</param>
            <returns>A BoundExpression representing the call.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ControlFlowRewriter.SynthesizeConversion(Roslyn.Compilers.CSharp.BoundExpression,Roslyn.Compilers.CSharp.Conversion,Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            Helper method that synthesizes a BoundConversion, unless the conversion would be an identity conversion.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ControlFlowRewriter.RewriteStringForEachStatement(Roslyn.Compilers.CSharp.BoundForEachStatement)">
            <summary>
            Lower a foreach loop that will enumerate the characters of a string.
            
            string s = x;
            for (int p = 0; p &lt; s.Length; p = p + 1) {
                V v = (V)s.Chars[p];
                // body
            }
            </summary>
            <remarks>
            We will follow Dev10 in diverging from the C# 4 spec by ignoring string's 
            implementation of IEnumerable and just indexing into its characters.
            
            NOTE: We're assuming that sequence points have already been generated.
            Otherwise, lowering to for-loops would generated spurious ones.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ControlFlowRewriter.RewriteSingleDimensionalArrayForEachStatement(Roslyn.Compilers.CSharp.BoundForEachStatement)">
            <summary>
            Lower a foreach loop that will enumerate a single-dimensional array.
            
            A[] a = x;
            for (int p = 0; p &lt; a.Length; p = p + 1) {
                V v = (V)a[p];
                // body
            }
            </summary>
            <remarks>
            We will follow Dev10 in diverging from the C# 4 spec by ignoring Array's 
            implementation of IEnumerable and just indexing into its elements.
            
            NOTE: We're assuming that sequence points have already been generated.
            Otherwise, lowering to for-loops would generated spurious ones.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ControlFlowRewriter.RewriteMultiDimensionalArrayForEachStatement(Roslyn.Compilers.CSharp.BoundForEachStatement)">
            <summary>
            Lower a foreach loop that will enumerate a multi-dimensional array.
            
            A[...] a = x;
            for (int p_0 = a.GetLowerBound(0); p_0 &lt;= a.GetUpperBound(0); p_0 = p_0 + 1)
                for (int p_1 = a.GetLowerBound(1); p_1 &lt;= a.GetUpperBound(0); p_1 = p_1 + 1)
                    ...
                        { V v = (V)a[p_0, p_1, ...]; /* body */ }
            </summary>
            <remarks>
            We will follow Dev10 in diverging from the C# 4 spec by ignoring Array's 
            implementation of IEnumerable and just indexing into its elements.
            
            NOTE: We're assuming that sequence points have already been generated.
            Otherwise, lowering to nested for-loops would generated spurious ones.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ControlFlowRewriter.AddForEachExpressionSequencePoint(Roslyn.Compilers.CSharp.ForEachStatementSyntax,Roslyn.Compilers.CSharp.SyntaxTree,Roslyn.Compilers.CSharp.BoundStatement@)">
            <summary>
            Add sequence point |here|:
            
            foreach (Type var in |expr|) { }
            </summary>
            <remarks>
            Hit once, before looping begins.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ControlFlowRewriter.AddForEachIterationVariableSequencePoint(Roslyn.Compilers.CSharp.ForEachStatementSyntax,Roslyn.Compilers.CSharp.SyntaxTree,Roslyn.Compilers.CSharp.BoundStatement@)">
            <summary>
            Add sequence point |here|:
            
            foreach (|Type var| in expr) { }
            </summary>
            <remarks>
            Hit every iteration.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ControlFlowRewriter.AddForEachKeywordSequencePoint(Roslyn.Compilers.CSharp.ForEachStatementSyntax,Roslyn.Compilers.CSharp.SyntaxTree,Roslyn.Compilers.CSharp.BoundStatement@)">
            <summary>
            Add sequence point |here|:
            
            |foreach| (Type var in expr) { }
            </summary>
            <remarks>
            Hit once, before looping begins.
            </remarks>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.AbstractFlowAnalysis`1.compilation">
            <summary>
            The compilation in which the analysis is taking place.  This is needed to determine which
            conditional methods will be compiled and which will be omitted.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.AbstractFlowAnalysis`1.method">
            <summary>
            The method whose body is being analyzed. Method attribute is only being used for
            references to method parameters. Thus, 'method' should not be used directly, but
            'MethodParameters', 'MethodThisParameter' and 'AnalyzeOutParameters(...)' should be used
            instead.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.AbstractFlowAnalysis`1.methodMainNode">
            <summary>
            The bound node of the method or initializer being analyzed.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.AbstractFlowAnalysis`1.labels">
            <summary>
            The flow analysis state at each label, computed by merging the state from branches to
            that label with the state when we fall into the label.  Entries are created when the
            label is encountered.  One case deserves special attention: when the destination of the
            branch is a label earlier in the code, it is possible (though rarely occurs in practice)
            that we are changing the state at a label that we've already analyzed. In that case we
            run another pass of the analysis to allow those changes to propagate. This repeats until
            no further changes to the state of these labels occurs.  This can result in quadratic
            performance in unlikely but possible code such as this: "int x; if (cond) goto l1; x =
            3; l5: print x; l4: goto l5; l3: goto l4; l2: goto l3; l1: goto l2;"
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.AbstractFlowAnalysis`1.backwardBranchChanged">
            <summary>
            Set to true after an analysis scan if the analysis was incomplete due to a backward
            "goto" branch changing some analysis result.  In this case the caller scans again (until
            this is false). Since the analysis proceeds by monotonically changing the state computed
            at each label, this must terminate.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.AbstractFlowAnalysis`1.pendingBranches">
            <summary>
            Pending escapes generated in the current scope (or more deeply nested scopes). When jump
            statements (goto, break, continue, return) are processed, they are placed in the
            pendingBranches buffer to be processed later by the code handling the destination
            statement. As a special case, the processing of try-finally statements might modify the
            contents of the pendingBranches buffer to take into account the behavior of
            "intervening" finally clauses.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.AbstractFlowAnalysis`1.state">
            <summary>
            The definite assignment and reachability state at the point currently being analyzed.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.AbstractFlowAnalysis`1.loopHeadState">
            <summary>
            A cache of the state at the backward branch point of each loop.  This is not needed
            during normal flow analysis, but is needed for DataFlowsOut region analysis.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AbstractFlowAnalysis`1.NoteLocation(Roslyn.Compilers.TextSpan)">
            <summary>
            Used to keep track of whether we are currently within the region or not.
            </summary>
            <param name="currentLocation"></param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AbstractFlowAnalysis`1.LeaveRegionIfNotEnclosed(Roslyn.Compilers.CSharp.BoundNode)">
            <summary>
            This method to be called whenever we want to check if we are still inside the region and we need to leave it 
            because the node is not fully enclosed by the region. It should be called in two situations:  (a) after we visited 
            condition and before we split the state in order to finish processing the condition if the region embraces it; 
            and (b) before we switch or unsplit the sates to ensure that the previous bound node is processed properly before 
            the state is switched or unsplit.
            </summary>
            <param name="node">node to check for being enclosed</param>
            <remarks>This method should be called in cases then the bound node's children can be considered 
            'isolated' and 'mutually excluside', which means that either the parent node is enclosed by the region
            or one and only one of it's children is enclosed (in case we are inside the region at the time of the call) </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AbstractFlowAnalysis`1.EnterRegion">
            <summary>
            Subclasses may override EnterRegion to perform any actions at the entry to the region.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AbstractFlowAnalysis`1.LeaveRegion">
            <summary>
            Subclasses may override LeaveRegion to perform any action at the end of the region.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AbstractFlowAnalysis`1.Scan">
            <summary>
            Perform a single pass of flow analysis.  Note that after this pass,
            this.backwardBranchChanged indicates if a further pass is required.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AbstractFlowAnalysis`1.ShouldAnalyzeOutParameters(Roslyn.Compilers.CSharp.Location@)">
            <summary>
            Specifies whether or not method's out parameters should be analyzed. If there's more
            than one location in the method being analyzed, then the method is partial and we prefer
            to report an out parameter in partial method error.
            </summary>
            <param name="location">location to be used</param>
            <returns>true if the out parameters of the method should be analyzed</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AbstractFlowAnalysis`1.LabelState(Roslyn.Compilers.CSharp.LabelSymbol)">
            <summary>
            Return the flow analysis state associated with a label.
            </summary>
            <param name="label"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AbstractFlowAnalysis`1.RemoveReturns">
            <summary>
            Return to the caller the set of pending return statements.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AbstractFlowAnalysis`1.SetUnreachable">
            <summary>
            Set the current state to one that indicates that it is unreachable.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AbstractFlowAnalysis`1.VisitCondition(Roslyn.Compilers.CSharp.BoundExpression,Roslyn.Compilers.CSharp.BoundNode)">
            <summary>
            Visit a boolean condition expression.
            </summary>
            <param name="node"></param>
            <param name="parent"></param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AbstractFlowAnalysis`1.VisitRvalue(Roslyn.Compilers.CSharp.BoundExpression)">
            <summary>
            Visit a general expression, where we will only need to determine if variables are
            assigned (or not). That is, we will not be needing AssignedWhenTrue and
            AssignedWhenFalse.
            </summary>
            <param name="node"></param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AbstractFlowAnalysis`1.VisitStatement(Roslyn.Compilers.CSharp.BoundStatement)">
            <summary>
            Visit a statement.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AbstractFlowAnalysis`1.LoopHead(Roslyn.Compilers.CSharp.BoundLoopStatement)">
            <summary>
            Called at the point in a loop where the backwards branch would go to.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AbstractFlowAnalysis`1.LoopTail(Roslyn.Compilers.CSharp.BoundLoopStatement)">
            <summary>
            Called at the point in a loop where the backward branch is placed.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AbstractFlowAnalysis`1.ResolveBreaks(Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.CSharp.AbstractFlowAnalysis{`0}.PendingBranch},`0,Roslyn.Compilers.CSharp.LabelSymbol)">
            <summary>
            Used to resolve break statements in each statement form that has a break statement
            (loops, switch).
            </summary>
            <param name="oldPendingBranches"></param>
            <param name="breakState"></param>
            <param name="breakLabel"></param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AbstractFlowAnalysis`1.ResolveContinues(Roslyn.Compilers.CSharp.LabelSymbol)">
            <summary>
            Used to resolve continue statements in each statement form that supports it.
            </summary>
            <param name="continueLabel"></param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AbstractFlowAnalysis`1.NoteBranch(Roslyn.Compilers.CSharp.AbstractFlowAnalysis{`0}.PendingBranch,Roslyn.Compilers.CSharp.BoundGotoStatement,Roslyn.Compilers.CSharp.BoundLabeledStatement)">
            <summary>
            Subclasses override this if they want to take special actions on processing a goto
            statement, when both the jump and the label have been located.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AbstractFlowAnalysis`1.ResolveBranches(Roslyn.Compilers.CSharp.BoundLabeledStatement)">
            <summary>
            To handle a label, we resolve all branches to that label.  Returns true if the state of
            the label changes as a result.
            </summary>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AbstractFlowAnalysis`1.SavePending">
            <summary>
            Since branches cannot branch into constructs, only out, we save the pending branches
            when visiting more nested constructs.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AbstractFlowAnalysis`1.RestorePending(Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.CSharp.AbstractFlowAnalysis{`0}.PendingBranch})">
            <summary>
            We use this to restore the old set of pending branches after visiting a construct that contains nested statements.
            </summary>
            <param name="oldPending">The old pending branches, which are to be merged with the current ones</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AbstractFlowAnalysis`1.Unimplemented(Roslyn.Compilers.CSharp.BoundNode,System.String)">
            <summary>
            Report an unimplemented language construct.
            </summary>
            <param name="node"></param>
            <param name="feature"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AbstractFlowAnalysis`1.DefaultVisit(Roslyn.Compilers.CSharp.BoundNode)">
            <summary>
            Since each language construct must be handled according to the rules of the language specification,
            the default visitor reports that the construct for the node is not implemented in the compiler.
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AbstractFlowAnalysis`1.MethodParameters">
            <summary>
            If a method is currently being analyzed returns its parameters, returns an empty array
            otherwise.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AbstractFlowAnalysis`1.MethodThisParameter">
            <summary>
            If a method is currently being analyzed returns its 'this' parameter, returns null
            otherwise.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AbstractFlowAnalysis`1.AbstractLocalState.Clone">
            <summary>
            Produce a duplicate of this flow analysis state.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AbstractFlowAnalysis`1.AbstractLocalState.IntersectWith(`0)">
            <summary>
            Mutate this flow analysis state to reflect the fact that there is a control-flow
            convergence with the other flow analysis state.  Return true if and only if the
            state has changed as a result of the Join.
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AbstractFlowAnalysis`1.AbstractLocalState.UnionWith(`0)">
            <summary>
            Mutate this flow analysis state to reflect the fact that there is a control-flow
            sequence with the other flow analysis state - in other words, this occurs and then
            the other.
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AbstractFlowAnalysis`1.AbstractLocalState.Split">
            <summary>
            Turn this state into a conditional (boolean) state, to be used for control-flow.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AbstractFlowAnalysis`1.AbstractLocalState.Unsplit">
            <summary>
            Turn this state into a non-conditional state (i.e. not to be used for control-flow).
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.AbstractFlowAnalysis`1.PendingBranch">
            <summary>
            A pending branch.  There are created for a return, break, continue, or goto statement.
            The idea is that we don't know if the branch will eventually reach its destination
            because of an intervening finally block that cannot complete normally.  So we store them
            up and handle them as we complete processing each construct.  At the end of a block, if
            there are any pending branches to a label in that block we process the branch.  Otherwise
            we relay it up to the enclosing construct as a pending branch of the enclosing
            construct.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.DataFlowAnalysis.initiallyAssignedVariables">
            <summary>
            Some variables that should be considered initially assigned.  Used for region analysis.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.DataFlowAnalysis.usedVariables">
            <summary>
            Variables that were used anywhere, in the sense required to suppress warnings about
            unused variables.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.DataFlowAnalysis.writtenVariables">
            <summary>
            Variables that were initialized or written anywhere.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.DataFlowAnalysis.variableSlot">
            <summary>
            A mapping from local variables to the index of their slot in a flow analysis local state.
            TODO: represent fields of locals of struct type too.
            TODO: could we store this as a field of the LocalSymbol for performance?
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.DataFlowAnalysis.variableBySlot">
            <summary>
            A mapping from the local variable slot to the symbol for the local variable itself.  This
            is used in the implementation of region analysis (support for extract method) to compute
            the set of variables "always assigned" in a region of code.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.DataFlowAnalysis.nextVariableSlot">
            <summary>
            Variable slots are allocated to local variables sequentially and never reused.  This is
            the index of the next slot number to use.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.DataFlowAnalysis.alreadyReported">
            <summary>
            Tracks variables for which we have already reported a definite assignment error.  This
            allows us to report at most one such error per variable.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.DataFlowAnalysis.Analyze(Roslyn.Compilers.CSharp.Compilation,Roslyn.Compilers.CSharp.MethodSymbol,Roslyn.Compilers.CSharp.BoundNode,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Perform data flow analysis, reporting all necessary diagnostics.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.DataFlowAnalysis.Analyze(Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Analyze the body, reporting all necessary diagnostics.
            </summary>
            <param name="diagnostics"></param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.DataFlowAnalysis.VariableSlot(Roslyn.Compilers.CSharp.Symbol,System.Int32)">
            <summary>
            Locals are given slots when their declarations are encountered.  We only need give slots
            to local variables, out parameters, and the "this" variable of a struct constructs.
            Other variables are not given slots, and are therefore not tracked by the analysis.  This
            returns -1 for a variable that is not tracked.  We do not need to track references to
            variables that occur before the variable is declared, as those are reported in an
            earlier phase as "use before declaration". That allows us to avoid giving slots to local
            variables before processing their declarations.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.DataFlowAnalysis.MakeSlot(Roslyn.Compilers.CSharp.Symbol,System.Int32)">
            <summary>
            Force a variable to have a slot.
            </summary>
            <param name="local"></param>
            <param name="containingSlot"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.DataFlowAnalysis.CheckAssigned(Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.CSharp.SyntaxNode,Roslyn.Compilers.CSharp.SyntaxTree)">
            <summary>
            Check that the given variable is definitely assigned.  If not, produce an error.
            </summary>
            <param name="local"></param>
            <param name="node"></param>
            <param name="syntaxTree"></param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.DataFlowAnalysis.ReportUnassigned(Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.CSharp.SyntaxNode,Roslyn.Compilers.CSharp.SyntaxTree)">
            <summary>
            Report a given variable as not definitely assigned.  Once a variable has been so
            reported, we suppress further reports of that variable.
            </summary>
            <param name="local"></param>
            <param name="node"></param>
            <param name="syntaxTree"></param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.DataFlowAnalysis.Assign(Roslyn.Compilers.CSharp.BoundNode,Roslyn.Compilers.CSharp.BoundExpression,System.Boolean)">
            <summary>
            Mark a variable as assigned (or unassigned).
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.DataFlowAnalysis.FieldsAllSet(System.Int32)">
            <summary>
            Does the struct variable at the given slot have all of its instance fields assigned?
            </summary>
            <param name="containingSlot"></param>
            <returns></returns>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.DataFlowAnalysis.Diagnostics">
            <summary>
            Where all diagnostics are deposited.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.DataFlowAnalysis.LocalState.Clone">
            <summary>
            Produce a duplicate of this flow analysis state.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LocalRewriter.RewriteArguments(Roslyn.Compilers.CSharp.MethodSymbol,System.Boolean,Roslyn.Compilers.ReadOnlyArray{System.Int32},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.RefKind}@,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.BoundExpression}@,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.LocalSymbol}@)">
            <summary>
            Rewrites arguments of an invocation according to the receiving method. It is assumed
            that arguments match parameters, but may need to be expanded/reordered.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LocalRewriter.MergeArgumentsAndSideEffects(Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.CSharp.BoundAssignmentOperator},Roslyn.Compilers.CSharp.BoundExpression[])">
            <summary>
            Process tempStores and add them as sideeffects to arguments where needed. The return
            value tells how many temps are actually needed. For unnecesary temps the corresponding
            temp store will be cleared.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LocalRewriter.VisitUnaryOperator(Roslyn.Compilers.CSharp.BoundUnaryOperator)">
            <summary>
            This rewriter lowers pre-/post- increment/decrement operations (initially represented as
            unary operators). We use BoundSequenceExpressions because we need to capture the RHS of the
            assignment in a temp variable.
            </summary>
            <remarks>
            This rewriter assumes that it will be run before decimal rewriting (so that it does not have
            to lower decimal constants and operations) and call rewriting (so that it does not have to
            lower property accesses).
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LocalRewriter.RewriteIncrementOperator(Roslyn.Compilers.CSharp.BoundUnaryOperator,System.Boolean,System.Boolean)">
            <summary>
            The rewrites are as follows:
            
            x++
                temp = x
                x = temp + 1
                return temp
            x--
                temp = x
                x = temp - 1
                return temp
            ++x
                temp = x + 1
                x = temp
                return temp
            --x
                temp = x - 1
                x = temp
                return temp
                
            In each case, the literal 1 is of the type required by the builtin addition/subtraction operator that
            will be used.  The temp is of the same type as x, but the sum/difference may be wider, in which case a
            conversion is required.
            </summary>
            <param name="node">The unary operator expression representing the increment/decrement.</param>
            <param name="isPrefix">True for prefix, false for postfix.</param>
            <param name="isIncrement">True for increment, false for decrement.</param>
            <returns>A bound sequence that uses a temp to acheive the correct side effects and return value.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LocalRewriter.MakeRValue(Roslyn.Compilers.CSharp.BoundExpression)">
            <summary>
            Transform an expression from a form suitable as an lvalue to a form suitable as an rvalue.
            </summary>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LocalRewriter.MakeConstantAndOperatorKind(Roslyn.Compilers.CSharp.UnaryOperatorKind,Roslyn.Compilers.CSharp.BoundUnaryOperator,Roslyn.Compilers.ConstantValue@,Roslyn.Compilers.CSharp.BinaryOperatorKind@)">
            <summary>
            By examining the node and the UnaryOperatorKind detemine which builtin operator should be used
            and create an appropriately-typed constant 1.
            </summary>
            <param name="unaryOperatorKindType">The operand type of the built-in increment/decrement operator.</param>
            <param name="node">The unary operation - used to extract an underlying enum type, if necessary.</param>
            <param name="constantOne">Will contain a constant of the type expected by the built-in operator corresponding to binaryOperatorKindType.</param>
            <param name="binaryOperatorKindType">The built-in binary operator that will be used to implement the built-in increment/decrement operator.  May have wider types.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LocalRewriter.VisitConditionalOperator(Roslyn.Compilers.CSharp.BoundConditionalOperator)">
            <summary>
            If the condition has a constant value, then just use the selected branch.
            e.g. "true ? x : y" becomes "x".
            
            In some special cases, it is also necessary to make implicit reference conversions
            explicit to satisfy CLR verification rules.  See IsUpdateRequiredForExplicitConversion.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LocalRewriter.IsUpdateRequiredForExplicitConversion(Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.CSharp.BoundExpression@,Roslyn.Compilers.CSharp.BoundExpression@)">
            <summary>
            Determines whether it is necessary to perform an explicit conversion so that the
            types of two conditional branches will verifiably reconcile.
            </summary>
            <param name="destinationType">The expected type of both branches.</param>
            <param name="expr1">The first branch.  Ready to be used (i.e. visited, converted, etc) if the return value is true.</param>
            <param name="expr2">The second branch.  Ready to be used (i.e. visited, converted, etc) if the return value is true.</param>
            <returns>True if the the BoundNode containing the conditional branches should be updated.</returns>
            <remarks>
            From ILGENREC::GenQMark
            See VSWhideby Bugs #49619 and 108643. If the destination type is an interface we need
            to force a static cast to be generated for any cast result expressions. The static cast
            should be done before the unifying jump so the code is verifiable and to allow the JIT to
            optimize it away. NOTE: Since there is no staticcast instruction, we implement static cast
            with a stloc / ldloc to a temporary.
            http://bugcheck/bugs/VSWhidbey/49619
            http://bugcheck/bugs/VSWhidbey/108643
            http://bugcheck/bugs/DevDivBugs/42645
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LocalRewriter.TransformCompoundAssignmentLHS(Roslyn.Compilers.CSharp.BoundExpression,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.CSharp.BoundExpression},Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.CSharp.LocalSymbol})">
            <summary>
            In the expanded form of a compound assignment (or increment/decrement), the LHS appears multiple times.
            If we aren't careful, this can result in repeated side-effects.  This creates (ordered) temps for all of the
            subexpressions that could result in side-effects and returns a side-effect-free expression that can be used
            in place of the LHS in the expanded form.
            </summary>
            <param name="originalLHS">The LHS sub-expression of the compound assignment (or increment/decrement).</param>
            <param name="stores">Populated with a list of assignment expressions that initialize the temporary locals.</param>
            <param name="temps">Populated with a list of temporary local symbols.</param>
            <returns>A side-effect-free expression representing the LHS.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LocalRewriter.Rewrite(System.Boolean,Roslyn.Compilers.CSharp.MethodSymbol,Roslyn.Compilers.CSharp.NamedTypeSymbol,Roslyn.Compilers.CSharp.BoundStatement,Roslyn.Compilers.CSharp.Emit.Module,Roslyn.Compilers.CSharp.SynthesizedSubmissionFields,System.Boolean@)">
            <summary>
            Lower a block of code by performing local rewritings.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ControlFlowAnalysis.Analyze(Roslyn.Compilers.CSharp.Compilation,Roslyn.Compilers.CSharp.MethodSymbol,Roslyn.Compilers.CSharp.BoundNode,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Perform control flow analysis, reporting all necessary diagnostics.  Returns true if the end of
            the body might be reachable..
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ControlFlowAnalysis.Analyze(Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Analyze the body, reporting all necessary diagnostics.  Returns true if the end of the
            body might be reachable.
            </summary>
            <param name="diagnostics"></param>
            <returns></returns>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ControlFlowAnalysis.Diagnostics">
            <summary>
            Where all diagnostics are deposited.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ControlFlowAnalysis.LocalState.Clone">
            <summary>
            Produce a duplicate of this flow analysis state.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.AnalysisContext">
            <summary>
            Represents analysis context attributes such as compilation, region, etc...
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.AnalysisContext.Compilation">
            <summary> Compilation to use </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.AnalysisContext.Method">
            <summary> Method symbol if available, null otherwise </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.AnalysisContext.BoundNode">
            <summary> Bound node, not null </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.AnalysisContext.Region">
            <summary> Region to be used </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AnalysisContext.#ctor(Roslyn.Compilers.CSharp.SyntaxTreeSemanticModel,Roslyn.Compilers.TextSpan)">
            <summary>
            Construct context from model and region
            </summary>
            <param name="model"></param>
            <param name="region"></param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AbstractRegionDataFlowAnalysis.Scan">
            <summary>
            To scan the whole body, we start outside (before) the region.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.AlwaysAssignedWalker">
            <summary>
            A region analysis walker that computes the set of variables that are always assigned a value
            in the region. A variable is "always assigned" in a region if an analysis of the region that
            starts with the variable unassigned ends with the variable assigned.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.DataFlowsInWalker">
            <summary>
            A region analysis walker that computes the set of variables whose values flow into (are used
            in) the region. A variable assigned outside is used inside if an analysis that leaves the
            variable unassigned on entry to the region would cause the generation of "unassigned" errors
            within the region.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.DataFlowsOutWalker">
            <summary>
            A region analysis walker that computes the set of variables for which their assigned values flow out of the region.
            A variable assigned inside is used outside if an analysis that
            treats assignments in the region as unassigning the variable would
            cause "unassigned" errors outside the region.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.JumpsIntoRegionWalker">
            <summary>
            A region analysis walker that records jumps into the region.  Works by overriding NoteBranch, which is
            invoked by a superclass when the two endpoints of a jump have been identified.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.JumpsOutOfRegionWalker">
            <summary>
            A region analysis walker that records jumps out of the region.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ReadWriteWalker">
            <summary>
            A region analysis walker that records reads and writes of all variables, both inside and outside the region.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.RegionEndPointIsReachableWalker">
            <summary>
            A region analysis walker that computes whether or not the region completes normally.  It does this by determining
            if the point at which the region ends is reachable.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.RegionDataFlowAnalysis">
            <summary>
            This class implements the region data flow analysis operations.  Region data flow analysis
            provides information how data flows into and out of a region.  The analysis is done lazily.
            When created, it performs no analysis, but simply caches the arguments. Then, the first time
            one of the analysis results is used it computes that one result and caches it. Each result
            is computed using a custom algorithm.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.RegionDataFlowAnalysis.VariablesDeclared">
            <summary>
            A collection of the local variables that are declared within the region. Note that the region must be
            bounded by a method's body or a field's initializer, so method parameter symbols are never included
            in the result, but lambda parameters might appear in the result.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.RegionDataFlowAnalysis.DataFlowsIn">
            <summary>
            A collection of the local variables for which a value assigned outside the region may be used inside the region.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.RegionDataFlowAnalysis.DataFlowsOut">
            <summary>
            A collection of the local variables for which a value assigned inside the region may be used outside the region.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.RegionDataFlowAnalysis.AlwaysAssigned">
            <summary>
            A collection of the local variables for which a value is always assigned inside the region.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.RegionDataFlowAnalysis.ReadInside">
            <summary>
            A collection of the local variables that are read inside the region.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.RegionDataFlowAnalysis.WrittenInside">
            <summary>
            A collection of local variables that are written inside the region.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.RegionDataFlowAnalysis.ReadOutside">
            <summary>
            A collection of the local variables that are read outside the region.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.RegionDataFlowAnalysis.WrittenOutside">
            <summary>
            A collection of local variables that are written outside the region.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.RegionDataFlowAnalysis.Captured">
            <summary>
            A collection of the non-constant local variables that have been referenced in anonymous functions
            and therefore must be moved to a field of a frame class.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ReturnStatementsWalker">
            <summary>
            A region analysis walker that records returns out of the region.  It works by processing the set of pending jumps
            at the end of the region, which will contain all return statements within the region.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ThisSymbolCache">
            <summary>
             A cache that keeps track of the unique "this" symbol for each instance method.  Note that
            this is a temporary solution until method body binding makes these symbols itself.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ParameterSymbol">
            <summary>
            Represents a parameter of a method or indexer.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Symbol">
            <summary>
            The base class for all symbols (namespaces, classes, method, parameters, etc.) that are 
            exposed by the compiler.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Symbol.ForceComplete(Roslyn.Compilers.CSharp.SourceLocation,System.Threading.CancellationToken)">
            <summary>
            Used to force (source) symbols to a given state of completion.
            </summary>
            <param name="locationOpt">The location within which binders should be completed</param>
            <param name="cancellationToken">A cancellation token that can be used to cancel out of
            this operation early at the behest of the caller.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Symbol.IsDefinitionOrDistinct">
            <summary>
            Return whether the symbol is either the original definition
            or distinct from the original. Intended for use in Debug.Assert
            only since it may include a deep comparison.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Symbol.MakeMetadataName(System.String@)">
            <summary>
            The CLI spec puts limits the maximum length of name and paths
            (when encoded as UTF-8).  The Metadata name of a symbol is the
            name after having been modified to satisfy the length restrictions.
            </summary>
            <param name="metadataName">The truncated name.</param>
            <returns>True if truncation occurred.</returns>
            <remarks>Not guaranteed to be unique.</remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Symbol.GetAttributes">
            <summary>
            Gets the attributes for this symbol. Returns an empty <see cref="T:Roslyn.Compilers.ReadOnlyArray`1"/> if
            there are no attributes.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Symbol.GetAttributes(Roslyn.Compilers.CSharp.NamedTypeSymbol)">
            <summary>
            Gets the attributes of a given attribute class on this symbol. Returns an empty
            array if there are no attributes.
            </summary>
            <param name="attributeType">The type of attribute to check for.</param>
            <returns>All attributes of the given type, or an empty array if none.</returns>
            
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Symbol.GetAttributes(Roslyn.Compilers.CSharp.MethodSymbol)">
            <summary>
            Gets the attributes on this symbol which are specified with the given attribute constructor.
            Returns an empty array if there are no such attributes.
            </summary>
            <param name="attributeConstructor">Attribute constructor to check for.</param>
            <returns>Attributes specified with the given constructor, or an empty array if none.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Symbol.AttributeTarget">
            <summary>
            Gets the attribute target kind corresponding to the symbol kind
            If attributes cannot be applied to this symbol kind, returns
            an invalid AttributeTargets value of 0
            </summary>
            <returns>AttributeTargets or 0</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Symbol.op_Equality(Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.CSharp.Symbol)">
            <summary>
            Compare two symbol objects to see if they refer to the same symbol. You should always
            use == and !=, or the Equals method, to compare two symbols for equality.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Symbol.op_Inequality(Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.CSharp.Symbol)">
            <summary>
            Compare two symbol objects to see if they refer to the same symbol. You should always
            use == and !=, or the Equals method, to compare two symbols for equality.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Symbol.ToString">
            <summary>
            Returns a string representation of this symbol, suitable for debugging purposes, or
            for placing in an error message.
            </summary>
            <remarks>
            This will provide a useful representation, but it would be clearer to call ToDisplayString
            directly and provide an explicit format.
            Sealed so that ToString and ToDisplayString can't get out of sync.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Symbol.System#IFormattable#ToString(System.String,System.IFormatProvider)">
            <summary>
            This is intended primarily for inserting localized descriptions of symbols into
            user-facing error messages.  If you need more fine-grained control of the output, try
            calling Symbol.ToDisplayString directly.
            </summary>
            <remarks>
            Generally speaking, this method should not be called directly.  Instead, they should be
            passed directly to errors/diagnostics.  To use a different format string, update the
            error message (e.g. Change "Problem with {0}" to "Problem with {0:S}" to display the
            short name of a symbol).
            
            We could have subclasses do their own parsing of the format string (to accept other
            formats), but we can probably do everything from here using Symbol.Kind.
            </remarks>
            <param name="format">
                G - general: default (determined by SymbolDisplay.ToDisplayString)
                E - error: format to be used in compiler error messages
                T - test: includes lots of qualification, parameters, modifiers, etc
                S - short: just the (user-facing) name of the symbol
                I - IL: to be used when visualizing IL
            </param>
            <param name="formatProvider">Usually a CultureInfo object.</param>
            <returns>A description of this symbol.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Symbol.GetSynthesizedAttributes(Roslyn.Compilers.CSharp.Emit.Module)">
            <summary>
            Gets the synthesized attributes for this symbol.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Symbol.GetDocumentationCommentID">
            <summary>
            Returns the Documentation Comment ID for the symbol.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown if the symbol does not support
            documentation comments.</exception>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Symbol.GetDocumentationComment(System.Globalization.CultureInfo,System.Threading.CancellationToken)">
            <summary>
            Fetches the documentation comment for this element with a cancellation token.
            </summary>
            <returns>A DocumentationComment object.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Symbol.GetUseSiteErrorInfo">
            <summary>
            Returns error info for an error, if any, that should be reported at the use site of the symbol.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Symbol.DeriveUseSiteErrorInfoFromType(Roslyn.Compilers.CSharp.TypeSymbol,System.Collections.Generic.HashSet{Roslyn.Compilers.CSharp.TypeSymbol}@)">
            <summary>
            Derive error info from a type symbol.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Symbol.Name">
            <summary>
            Gets the name of this symbol. Symbols without a name return the empty string; null is
            never returned.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Symbol.Kind">
            <summary>
            Gets the kind of this symbol.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Symbol.ContainingSymbol">
            <summary>
            Get the symbol that logically contains this symbol. 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Symbol.ContainingType">
            <summary>
            Returns the containing type, if this symbol is immediately contained by a type.
            Otherwise returns null.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Symbol.ContainingNamespace">
            <summary>
            Gets the nearest enclosing namespace for this namespace or type. For a nested type,
            returns the namespace that contains its container.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Symbol.ContainingAssembly">
            <summary>
            Returns the assembly containing this symbol. If this symbol is shared across multiple
            assemblies, or doesn't belong to an assembly, returns null.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Symbol.ContainingModule">
            <summary>
            Returns the module containing this symbol. If this symbol is shared across multiple
            modules, or doesn't belong to a module, returns null.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Symbol.OriginalDefinition">
            <summary>
            The original definition of this symbol. If this symbol is constructed from another
            symbol by type substitution then OriginalDefinition gets the original symbol as it was defined in
            source or metadata.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Symbol.IsDefinition">
            <summary>
            Returns whether this the original definition of this symbol.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Symbol.Locations">
            <summary>
            Gets the locations where this symbol was originally defined, either in source or
            metadata. Some symbols (for example, partial classes) may be defined in more than one
            location.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Symbol.DeclaredAccessibility">
            <summary>
            Get this accessibility that was declared on this symbol. For symbols that do not have
            accessibility declared on them, returns NotApplicable.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Symbol.IsStatic">
            <summary>
            Returns true if this symbol is "static"; i.e., declared with the "static" modifier or
            implicitly static.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Symbol.IsVirtual">
            <summary>
            Returns true if this symbol is "virtual", has an implementation, and does not override a
            base class member; i.e., declared with the "virtual" modifier. Does not return true for
            members declared as abstract or override.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Symbol.IsOverride">
            <summary>
            Returns true if this symbol was declared to override a base class member; i.e., declared
            with the "override" modifier. Still returns true if member was declared to override
            something, but (erroneously) no member to override exists.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Symbol.IsAbstract">
            <summary>
            Returns true if this symbol was declared as requiring an override; i.e., declared with
            the "abstract" modifier. Also returns true on a type declared as "abstract", all
            interface types, and members of interface types.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Symbol.IsSealed">
            <summary>
            Returns true if this symbol was declared to override a base class member and was also
            sealed from further overriding; i.e., declared with the "sealed" modifier.  Also set for
            types that do not allow a derived class (declared with "sealed" or "static" or "struct"
            or "enum" or "delegate").
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Symbol.IsExtern">
            <summary>
            Returns true if this symbol has external implementation; i.e., declared with the 
            "extern" modifier. 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Symbol.IsSynthesized">
            <summary>
            Returns true if this symbol was automatically synthesized by the compiler.  This is
            intended for symbols that are not internal compilation details, but are instead
            ordinary symbols that can be consumed without requiring the user to manually supply them
            themselves.  For example, the default constructor for a class or struct that is created
            if the user does not provide one themselves.  Or the Invoke method for a delegate.
            Or the generated backing field for an auto property.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Symbol.CanBeReferencedByName">
            <summary>
            Returns true if this symbol can be referenced by its name in code. Examples of symbols
            that cannot be referenced by name are:
               constructors, destructors, operators, explicit interface implementations,
               accessor methods for properties and events, array types.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Symbol.CanBeReferencedByNameIgnoringIllegalCharacters">
            <summary>
            As an optimization, viability checking in the lookup code should use this property instead
            of CanBeReferencedByName.  The full name check will then be performed in the SemanticModel.
            </summary>
            <remarks>
            This property exists purely for performance reasons.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Symbol.IsFromSource">
            <summary>
            True if and only if the symbol is the one original symbol resulting from some
            declaration in the source. The declaration might be implicit, for example a synthesized
            constructor is considered to come from source. This is not true for constructed members,
            substituted members (e.g. members of a constructed type), alpha-renamed type parameters,
            or anything not from source.  This applies to named type symbols, field symbols, method
            symbols, parameter symbols, type parameter symbols, property symbols, event symbols,
            etc. Array types never return true for this property, as they are not "declared" in the
            source.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Symbol.HighestPriorityUseSiteError">
            <summary>
            Return error code that has highest priority while calculating use site error for this symbol. 
            Supposed to be ErrorCode, but it causes inconsistent accessibility error.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Symbol.CompletionPart">
            <summary>
            This enum describes the types of components that could give
            us diagnostics.  We shouldn't read the list of diagnostics
            until all of these types are accounted for.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ParameterSymbol.Accept``2(Roslyn.Compilers.CSharp.SymbolVisitor{``0,``1},``0)">
            <summary>
            Implements visitor pattern. 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParameterSymbol.Type">
            <summary>
            Gets the type of the parameter.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParameterSymbol.RefKind">
            <summary>
            Determines if the parameter ref, out or neither.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParameterSymbol.CustomModifiers">
            <summary>
            The list of custom modifiers, if any, associated with the parameter.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParameterSymbol.Ordinal">
            <summary>
            Gets the ordinal position of the parameter. The first parameter has ordinal zero.
            The "'this' parameter has ordinal -1.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParameterSymbol.IsParams">
            <summary>
            Returns true if the parameter was declared as a parameter array. 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParameterSymbol.IsOptional">
            <summary>
            Returns true if the parameter is optional.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParameterSymbol.HasDefaultValue">
            <summary>
            Returns true if the parameter specifies a default value to be passed
            when no value is provided as an argument to a call. The default value
            can be obtained with the DefaultValue property.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParameterSymbol.DefaultValue">
            <summary>
            Returns the default value of the parameter. If HasDefaultValue
            returns false then DefaultValue throws an InvalidOperationException.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParameterSymbol.Kind">
            <summary>
            Gets the kind of this symbol.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParameterSymbol.DeclaredAccessibility">
            <summary>
            Get this accessibility that was declared on this symbol. For symbols that do not have
            accessibility declared on them, returns NotApplicable.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParameterSymbol.IsAbstract">
            <summary>
            Returns true if this symbol was declared as requiring an override; i.e., declared with
            the "abstract" modifier. Also returns true on a type declared as "abstract", all
            interface types, and members of interface types.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParameterSymbol.IsSealed">
            <summary>
            Returns true if this symbol was declared to override a base class member and was also
            sealed from further overriding; i.e., declared with the "sealed" modifier.  Also set for
            types that do not allow a derived class (declared with "sealed" or "static" or "struct"
            or "enum" or "delegate").
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParameterSymbol.IsVirtual">
            <summary>
            Returns true if this symbol is "virtual", has an implementation, and does not override a
            base class member; i.e., declared with the "virtual" modifier. Does not return true for
            members declared as abstract or override.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParameterSymbol.IsOverride">
            <summary>
            Returns true if this symbol was declared to override a base class member; i.e., declared
            with the "override" modifier. Still returns true if member was declared to override
            something, but (erroneously) no member to override exists.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParameterSymbol.IsStatic">
            <summary>
            Returns true if this symbol is "static"; i.e., declared with the "static" modifier or
            implicitly static.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParameterSymbol.IsExtern">
            <summary>
            Returns true if this symbol has external implementation; i.e., declared with the 
            "extern" modifier. 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParameterSymbol.IsThis">
            <summary>
            Returns true if the parameter is the hidden 'this' parameter.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.UnassignedVariablesWalker">
            <summary>
            An analysis that computes the set of variables that may be used
            before being assigned anywhere within a method.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.VariablesDeclaredWalker">
            <summary>
            A region analysis walker that records declared variables.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.LambdaRewriter">
            <summary>
            The rewriter for removing lambda expressions from method bodies and introducing closure classes
            as containers for captured variables along the lines of the example in section 6.5.3 of the
            C# language specification.
            
            The entry point is the public method Rewrite.  It operates as follows:
            
            First, an analysis of the whole method body is performed that determines which variables are
            captured, what their scopes are, and what the nesting relationship is between scopes that
            have captured variables.  The result of this analysis is left in LambdaRewriter.analysis.
            
            Then we make frame, or compiler-generated class, represented by an instance of
            LambdaRewriter.Frame for each scope with captured variables.  The generated frames are kept
            in LambdaRewriter.frames.  Each frame is given a single field for each captured
            variable in the corresponding scope.  These are are maintained in LambdaRewriter.proxies.
            
            Finally, we walk and rewrite the input bound tree, keeping track of the following:
            (1) The current set of active frame pointers, in LambdaRewriter.framePointers
            (2) The current method being processed (this changes within a lambda's body), in LambdaRewriter.currentMethod
            (3) The "this" symbol for the current method in LambdaRewriter.currentFrameThis, and
            (4) The symbol that is used to access the innermost frame pointer (it could be a local variable or "this" parameter)
            
            There are a few key transformations done in the rewriting.
            (1) Lambda expressions are turned into delegate creation expressions, and the body of the lambda is
                moved into a new, compiler-generated method of a selected frame class.
            (2) On entry to a scope with captured variables, we create a frame object and store it in a local variable.
            (3) References to captured variables are transformed into references to fields of a frame class.
            
            In addition, the rewriting deposits into the field LambdaRewriter.generatedMethods a (MethodSymbol, BoundStatement)
            pair for each generated method.
            
            LambdaRewriter.Rewrite produces its output in two forms.  First, it returns a new bound statement
            for the caller to use for the body of the original method.  Second, it returns a collection of
            (MethodSymbol, BoundStatement) pairs for additional method that the lambda rewriter produced.
            These additional methods contain the bodies of the lambdas moved into ordinary methods of their
            respective frame classes, and the caller is responsible for processing them just as it does with
            the returned bound node.  For example, the caller will typically perform iterator method and
            asynchronous method transformations, and emit IL instructions into an assembly.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LambdaRewriter.Rewrite(Roslyn.Compilers.CSharp.BoundNode,Roslyn.Compilers.CSharp.MethodSymbol,Roslyn.Compilers.CSharp.Emit.Module,Roslyn.Compilers.ArrayBuilder{System.Tuple{Roslyn.Compilers.CSharp.MethodSymbol,Roslyn.Compilers.CSharp.BoundStatement}},Roslyn.Compilers.CSharp.LambdaRewriter.Analysis)">
            <summary>
            Rewrite the given node to eliminate lambda expressions.  Also returned are the method symbols and their
            bound bodies for the extracted lambda bodies. These would typically be emitted by the caller such as
            MethodBodyCompiler.  See this class' documentation
            for a more thorough explanation of the algorithm and its use by clients.
            </summary>
            <param name="node">The bound node to be rewritten</param>
            <param name="method">The containing method of the node to be rewritten</param>
            <param name="emitModule">The emit module in which compiler-generated symbols are to be placed</param>
            <param name="generatedMethods">The caller's buffer into which we produce additional methods to be emitted by the caller</param>
            <param name="analysis">A caller-provided analysis of the node's lambdas</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LambdaRewriter.MakeFrames">
            <summary>
            Create the frame types.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LambdaRewriter.FrameOfType(Roslyn.Compilers.CSharp.SyntaxNode,Roslyn.Compilers.CSharp.SyntaxTree,Roslyn.Compilers.CSharp.NamedTypeSymbol)">
            <summary>
            Produce a bound expression representing a pointer to a frame of a particular frame type.
            </summary>
            <param name="syntax">The syntax to attach to the bound nodes produced</param>
            <param name="syntaxTree">The syntax tree to attach to the bound nodes produced</param>
            <param name="frameType">The type of frame to be returned</param>
            <returns>A bound node that computes the pointer to the required frame</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LambdaRewriter.FramePointer(Roslyn.Compilers.CSharp.SyntaxNode,Roslyn.Compilers.CSharp.SyntaxTree,Roslyn.Compilers.CSharp.NamedTypeSymbol)">
            <summary>
            Produce a bound expression representing a pointer to a frame of a particular frame class.
            Note that for generic frames, the frameClass parameter is the generic definition, but
            the resulting expression will be constructed with the current type parameters.
            </summary>
            <param name="syntax">The syntax to attach to the bound nodes produced</param>
            <param name="syntaxTree">The syntax tree to attach to the bound nodes produced</param>
            <param name="frameClass">The class type of frame to be returned</param>
            <returns>A bound node that computes the pointer to the required frame</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LambdaRewriter.IntroduceFrame``1(Roslyn.Compilers.CSharp.BoundNode,Roslyn.Compilers.CSharp.LambdaRewriter.Frame,System.Func{Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.CSharp.BoundStatement},Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.CSharp.LocalSymbol},Roslyn.Compilers.CSharp.BoundStatement,``0})">
            <summary>
            Introduce a frame around the translation of the given node.
            </summary>
            <param name="node">The node whose translation should be translated to contain a frame</param>
            <param name="frame">The frame for the translated node</param>
            <param name="F">A function that computes the translation of the node.  It receives lists of added statements and added symbols</param>
            <returns>The translated statement, as returned from F</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LambdaRewriter.BlockDepth(Roslyn.Compilers.CSharp.BoundNode)">
            <summary>
            Compute the nesting depth of a given block.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LambdaRewriter.ContainsConstructorInitializer(Roslyn.Compilers.CSharp.BoundStatement)">
            <summary>
            This helper method checks if the given statement contains the constructor initializer
            </summary>
            <param name="s">Statement to verify</param>
            <returns>Boolean stating whether the statement contains constructor initializer</returns>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.LambdaRewriter.Analysis">
            <summary>
            Perform a first analysis pass in preparation for removing all lambdas from a method body.  The entry point is Analyze.
            The results of analysis are placed in the fields seenLambda, blockParent, variableBlock, captured, and captures.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.LambdaRewriter.Analysis.seenLambda">
            <summary>
            Set to true of any lambda expressions were seen in the analyzed method body.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.LambdaRewriter.Analysis.blockParent">
            <summary>
            For each statement that defines variables, identifies the nearest enclosing statement that defines variables.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.LambdaRewriter.Analysis.variableBlock">
            <summary>
            For each captured variable, identifies the statement in which it will be moved to a frame class.  This is
            normally the block where the variable is introduced, but method parameters are moved
            to a frame class within the body of the method.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.LambdaRewriter.Analysis.needsParentFrame">
            <summary>
            Blocks that are positioned between a block declaring some lifted variables
            and a block that contains the lambda that lifts said variables.
            If such block itself requires a closure, then it must lift parent frame pointer into the closure
            in addition to whatever else needs to be lifted.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.LambdaRewriter.Analysis.captured">
            <summary>
            The set of captured variables seen in the method body.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.LambdaRewriter.Analysis.captures">
            <summary>
            For each lambda in the code, the set of variables that it captures.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LambdaRewriter.Analysis.RecordCaptureInIntermediateBlocks(Roslyn.Compilers.CSharp.Symbol)">
            <summary>
            Once we see a lambda lifting something
            We mark all blocks from the current up to the one that declares lifted symbol as
            needing a parent frame.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.LambdaRewriter.Frame">
            <summary>
            A class that represents the set of variables in a scope that have been
            captured by lambdas within that scope.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.NamedTypeSymbol">
            <summary>
            Represents a type other than an array, a pointer, a type parameter.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.TypeSymbol">
            <summary>
            A TypeSymbol is a base class for all the symbols that represent a type
            in C#.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.NamespaceOrTypeSymbol">
            <summary>
            Represents either a namespace or a type.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamespaceOrTypeSymbol.GetMembers(System.Threading.CancellationToken)">
            <summary>
            Get all the members of this symbol.
            </summary>
            <returns>A ReadOnlyArray containing all the members of this symbol. If this symbol has no members,
            returns an empty ReadOnlyArray. Never returns Null.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamespaceOrTypeSymbol.GetMembers(System.String,System.Threading.CancellationToken)">
            <summary>
            Get all the members of this symbol that have a particular name.
            </summary>
            <returns>A ReadOnlyArray containing all the members of this symbol with the given name. If there are
            no members with this name, returns an empty ReadOnlyArray. Never returns Null.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamespaceOrTypeSymbol.GetTypeMembers(System.Threading.CancellationToken)">
            <summary>
            Get all the members of this symbol that are types.
            </summary>
            <returns>An IEnumerable containing all the types that are members of this symbol. If this symbol has no type members,
            returns an empty IEnumerable. Never returns Nothing.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamespaceOrTypeSymbol.GetTypeMembers(System.String,System.Threading.CancellationToken)">
            <summary>
            Get all the members of this symbol that are types that have a particular name, of any arity.
            </summary>
            <returns>A ReadOnlyArray containing all the types that are members of this symbol with the given name.
            If this symbol has no type members with this name,
            returns an empty ReadOnlyArray. Never returns Null.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamespaceOrTypeSymbol.GetTypeMembers(System.String,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Get all the members of this symbol that are types that have a particular name and arity
            </summary>
            <returns>An IEnumerable containing all the types that are members of this symbol with the given name and arity.
            If this symbol has no type members with this name and arity,
            returns an empty IEnumerable. Never returns Nothing.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamespaceOrTypeSymbol.GetSourceTypeMember(Roslyn.Compilers.CSharp.SyntaxTree,Roslyn.Compilers.CSharp.TypeDeclarationSyntax)">
            <summary>
            Get a source type symbol for the given declaration syntax.
            </summary>
            <returns>Null if there is no matching declaration.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamespaceOrTypeSymbol.GetSourceTypeMember(Roslyn.Compilers.CSharp.SyntaxTree,Roslyn.Compilers.CSharp.DelegateDeclarationSyntax)">
            <summary>
            Get a source type symbol for the given declaration syntax.
            </summary>
            <returns>Null if there is no matching declaration.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamespaceOrTypeSymbol.GetSourceTypeMember(System.String,System.Int32,Roslyn.Compilers.CSharp.SyntaxKind,Roslyn.Compilers.CSharp.SyntaxTree,Roslyn.Compilers.CSharp.SyntaxNode)">
            <summary>
            Get a source type symbol of given name, arity and kind.  If a tree and syntax are provided, restrict the results
            to those that are declared within the given syntax.
            </summary>
            <returns>Null if there is no matching declaration.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamespaceOrTypeSymbol.LookupMetadataType(System.String,System.Int32)">
            <summary>
            Lookup an immediately nested type referenced from metadata, names should be
            compared case-sensitively.
            </summary>
            <param name="typeName">
            Simple type name with generic name mangling removed.
            </param>
            <param name="arity">
            Target arity of the type.
            </param>
            <returns>
            Symbol for the type, or MissingMetadataSymbol if the type isn't found.
            </returns>
            <remarks></remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamespaceOrTypeSymbol.IsNamespace">
            <summary>
            Returns true if this symbol is a namespace. If its not a namespace, it must be a type.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamespaceOrTypeSymbol.IsType">
            <summary>
            Returns true if this symbols is a type. Equivalent to !IsNamespace.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamespaceOrTypeSymbol.IsVirtual">
            <summary>
            Returns true if this symbol is "virtual", has an implementation, and does not override a
            base class member; i.e., declared with the "virtual" modifier. Does not return true for
            members declared as abstract or override.
            </summary>
            <returns>
            Always returns false.
            </returns>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamespaceOrTypeSymbol.IsOverride">
            <summary>
            Returns true if this symbol was declared to override a base class member; i.e., declared
            with the "override" modifier. Still returns true if member was declared to override
            something, but (erroneously) no member to override exists.
            </summary>
            <returns>
            Always returns false.
            </returns>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamespaceOrTypeSymbol.IsExtern">
            <summary>
            Returns true if this symbol has external implementation; i.e., declared with the 
            "extern" modifier. 
            </summary>
            <returns>
            Always returns false.
            </returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeSymbol.MakeAllInterfaces">
            Produce all implemented interfaces in topologically sorted order. We use
            TypeSymbol.Interfaces as the source of edge data, which has had cycles and infinitely
            long dependency cycles removed. Consequently, it is possible (and we do) use the
            simplest version of Tarjan's topological sorting algorithm.
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeSymbol.FindImplementationForInterfaceMember(Roslyn.Compilers.CSharp.Symbol)">
            <summary>
            Returns the corresponding symbol in this type or a base type that implements 
            interfaceMember (either implicitly or explicitly), or null if no such symbol exists
            (which might be either because this type doesn't implement the container of
            interfaceMember, or this type doesn't supply a member that successfully implements
            interfaceMember).
            </summary>
            <param name="interfaceMember">
            Must be an interface property, method, or event.
            </param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeSymbol.GetUseSiteErrorInfo">
            <summary>
            Returns error info for an error, if any, that should be reported at the use site of the symbol.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeSymbol.GetUseSiteErrorInfo(System.Collections.Generic.HashSet{Roslyn.Compilers.CSharp.TypeSymbol}@)">
            <summary>
            Has the same purpose as the one above, but carries a hash set of types that are being checked or have been checked
            already in order to avoid duplicate work and, more importantly, avoid infinit loops due to cyclic type references.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeSymbol.ComputeImplementationForInterfaceMember``1(``0,Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Performs interface mapping (spec 13.4.4).
            </summary>
            <remarks>
            CONSIDER: we could probably do less work in the metadata and retargeting cases - we won't use the diagnostics.
            </remarks>
            <typeparam name="T">MethodSymbol or PropertySymbol (an interface member).</typeparam>
            <param name="interfaceMember">A non-null property on an interface type.</param>
            <param name="implementingType">The type implementing the interface property (usually "this").</param>
            <param name="diagnostics">Bag to which to add diagnostics.</param>
            <returns>The implementing property or null, if there isn't one.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeSymbol.CheckForImplementationOfCorrespondingProperty``1(``0,Roslyn.Compilers.CSharp.TypeSymbol,System.Boolean,``0@)">
            <summary>
            If we were looking for an accessor, then look for an accessor on the implementation of the
            corresponding interface property.  If it is valid as an implementation (ignoring the name),
            then prefer it to our current result if:
              1) our current result is null; or
              2) our current result is on the same type.
              
            If there is no corresponding accessor on the implementation of the corresponding interface
            property and we found an accessor, then the accessor we found is invalid, so clear it.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeSymbol.ReportImplicitImplementationMatchDiagnostics``1(``0,System.Boolean,Roslyn.Compilers.CSharp.TypeSymbol,``0,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            These diagnostics are for members that do implicitly implement an interface member, but do so
            in an undesirable way.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeSymbol.ReportImplicitImplementationMismatchDiagnostics``1(``0,Roslyn.Compilers.CSharp.TypeSymbol,System.Boolean,``0,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            These diagnostics are for members that almost, but not actually, implicitly implement an interface member.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeSymbol.FindImplementationForInterfaceMethod(Roslyn.Compilers.CSharp.MethodSymbol)">
            <summary>
            Return the method on this type (or a base type) that implements the specified
            interface method, or null if there isn't one.
            </summary>
            <remarks>
            This layer handles caching, ComputeImplementationForInterfaceMethod does the work.
            </remarks>
            <param name="interfaceMethod">A non-null method on an interface type.</param>
            <returns>The implementing method (or null) plus the corresponding diagnostics.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeSymbol.FindPotentialImplicitImplementationMethodDeclaredInType``1(Roslyn.Compilers.CSharp.MethodSymbol,System.Boolean,Roslyn.Compilers.CSharp.TypeSymbol,``0@,``0@)">
            <summary>
            Search the declared methods of a type for one that could be an implementation
            of a given interface method (depending on interface declarations).
            </summary>
            <typeparam name="T">Should always be MethodSymbol, but the type parameter makes things easier for the caller.</typeparam>
            <param name="interfaceMethod">The interface method being implemented.</param>
            <param name="implementingTypeIsFromSource">The value of implementingType.IsFromSource (avoid recomputing repeatedly).</param>
            <param name="currType">The type on which we are looking for a declared implementation of the interface method.</param>
            <param name="implicitImpl">A method on currType that could implement the interface, or null.</param>
            <param name="closeMismatch">A method on currType that could have been an attempt to implement the interface, or null.</param>
            <remarks>
            There is some similarity between this method and MethodSymbol.FindOverriddenOrHiddenMembersInType.
            When making changes to this method, think about whether or not they should also be applied in MethodSymbol.
            One key difference is that custom modifiers are considered when looking up overridden methods, but
            not when looking up implicit implementations.  We're preserving this behavior from Dev10.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeSymbol.IsInterfaceMethodImplementation(Roslyn.Compilers.CSharp.MethodSymbol,Roslyn.Compilers.CSharp.MethodSymbol,System.Boolean)">
            <summary>
            To implement an interface method, a candidate method must be public, non-static, and have
            the same signature.  "Have the same signature" has a looser definition if the type implementing
            the interface is from source.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeSymbol.FindImplementationForInterfaceProperty(Roslyn.Compilers.CSharp.PropertySymbol)">
            <summary>
            Return the property on this type (or a base type) that implements the specified
            interface property, or null if there isn't one.
            </summary>
            <remarks>
            This layer handles caching, ComputeImplementationForInterfaceProperty does the work.
            </remarks>
            <param name="interfaceProperty">A non-null property on an interface type.</param>
            <returns>The implementing property (or null) plus the corresponding diagnostics.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeSymbol.FindPotentialImplicitImplementationPropertyDeclaredInType``1(Roslyn.Compilers.CSharp.PropertySymbol,System.Boolean,Roslyn.Compilers.CSharp.TypeSymbol,``0@,``0@)">
            <summary>
            Search the declared properties of a type for one that could be an implementation
            of a given interface property (depending on interface declarations).
            </summary>
            <typeparam name="T">Should always be PropertySymbol, but the type parameter makes things easier for the caller.</typeparam>
            <param name="interfaceProperty">The interface property being implemented.</param>
            <param name="implementingTypeIsFromSource">The value of implementingType.IsFromSource (avoid recomputing repeatedly).</param>
            <param name="currType">The type on which we are looking for a declared implementation of the interface property.</param>
            <param name="implicitImpl">A property on currType that could implement the interface, or null.</param>
            <param name="closeMismatch">A property on currType that could have been an attempt to implement the interface, or null.</param>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeSymbol.BaseType">
            <summary>
            Gets the BaseType of this type. If the base type could not be determined, then 
            an instance of ErrorType is returned. If this kind of type does not have a base type
            (for example, interfaces), null is returned. Also the special class System.Object
            always has a BaseType of null.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeSymbol.Interfaces">
            <summary>
            Gets the set of interfaces that this type directly implements. This set does not include
            interfaces that are base interfaces of directly implemented interfaces.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeSymbol.AllInterfaces">
            <summary>
            The list of all interfaces of which this type is a declared subtype, excluding this type
            itself. This includes all declared base interfaces, all declared base interfaces of base
            types, and all declared base interfaces of those results (recursively).  Each result
            appears exactly once in the list. This list is topologically sorted by the inheritance
            relationship: if interface type A extends interface type B, then A precedes B in the
            list. This is not quite the same as "all interfaces of which this type is a proper
            subtype" because it does not take into account variance: AllInterfaces for
            IEnumerable&lt;string&gt; will not include IEnumerble&lt;object&gt;
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeSymbol.InterfacesAndTheirBaseInterfaces">
            <summary>
            Gets the set of interfaces that this type directly implements, plus the base interfaces
            of all such types.
            </summary>
            <remarks>
            CONSIDER: it probably isn't truly necessary to cache this.  If space gets tight, consider
            alternative approaches (recompute every time, cache on the side, only store on some types,
            etc).
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeSymbol.IsReferenceType">
            <summary>
            Returns true if this type is known to be a reference type. It is never the case that
            IsReferenceType and IsValueType both return true. However, for an unconstrained type
            parameter, IsReferenceType and IsValueType will both return false.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeSymbol.IsValueType">
            <summary>
            Returns true if this type is known to be a value type. It is never the case that
            IsReferenceType and IsValueType both return true. However, for an unconstrained type
            parameter, IsReferenceType and IsValueType will both return false.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeSymbol.TypeKind">
            <summary>
            Gets the kind of this type.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeSymbol.IsScriptClass">
            <summary>
            Returns true if the type is a Script class. 
            It might be an interactive submission class or a Script class in a csx file.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeSymbol.SpecialType">
            <summary>
            Gets corresponding special TypeId of this type.
            </summary>
            <remarks>
            Not preserved in types constructed from this one.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeSymbol.PrimitiveTypeCode">
            <summary>
            Gets corresponding primitive type code for this type declaration.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeSymbol.HighestPriorityUseSiteError">
            <summary>
            Return error code that has highest priority while calculating use site error for this symbol. 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeSymbol.AbstractMembers">
            <summary>
            The set of abstract members in declared in this type or declared in a base type and not overridden.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.TypeSymbol.SymbolAndDiagnostics">
            <summary>
            Represents the method by which this type implements a given interface type
            and/or the corresponding diagnostics.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamedTypeSymbol.InterfacesVisit(Roslyn.Compilers.CSharp.NamedTypeSymbol,Roslyn.Compilers.CSharp.Emit.Module,Roslyn.Compilers.ArrayBuilder{Microsoft.Cci.ITypeReference},System.Collections.Generic.HashSet{Roslyn.Compilers.CSharp.NamedTypeSymbol}@)">
            <summary>
            Add the type to the builder and then recurse on its interfaces.
            </summary>
            <remarks>
            Pre-order depth-first search.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamedTypeSymbol.AttributeUsageInfo(Roslyn.Compilers.CSharp.Compilation)">
            <summary>
            Gets the associated attribute usage info if this represents an attribute type,
            otherwise returns null
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamedTypeSymbol.GetMembers(System.Threading.CancellationToken)">
            <summary>
            Get all the members of this symbol.
            </summary>
            <returns>A ReadOnlyArray containing all the members of this symbol. If this symbol has no members,
            returns an empty ReadOnlyArray. Never returns Null.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamedTypeSymbol.GetMembers(System.String,System.Threading.CancellationToken)">
            <summary>
            Get all the members of this symbol that have a particular name.
            </summary>
            <returns>A ReadOnlyArray containing all the members of this symbol with the given name. If there are
            no members with this name, returns an empty ReadOnlyArray. Never returns Null.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamedTypeSymbol.GetTypeMembers(System.Threading.CancellationToken)">
            <summary>
            Get all the members of this symbol that are types.
            </summary>
            <returns>An IEnumerable containing all the types that are members of this symbol. If this symbol has no type members,
            returns an empty IEnumerable. Never returns Nothing.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamedTypeSymbol.GetTypeMembers(System.String,System.Threading.CancellationToken)">
            <summary>
            Get all the members of this symbol that are types that have a particular name, of any arity.
            </summary>
            <returns>A ReadOnlyArray containing all the types that are members of this symbol with the given name.
            If this symbol has no type members with this name,
            returns an empty ReadOnlyArray. Never returns Null.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamedTypeSymbol.GetTypeMembers(System.String,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Get all the members of this symbol that are types that have a particular name and arity
            </summary>
            <returns>An IEnumerable containing all the types that are members of this symbol with the given name and arity.
            If this symbol has no type members with this name and arity,
            returns an empty IEnumerable. Never returns Nothing.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamedTypeSymbol.Accept``2(Roslyn.Compilers.CSharp.SymbolVisitor{``0,``1},``0)">
            <summary>
            Used to implement visitor pattern.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamedTypeSymbol.Equals(System.Object)">
            <summary>
            Compares this symbol to an object.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamedTypeSymbol.EqualsComplicatedCases(Roslyn.Compilers.CSharp.NamedTypeSymbol)">
            <summary>
            Helper for more complicated cases Equals like when we have generic instantiations or types nested within them.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamedTypeSymbol.GetHashCode">
            <summary>
            Returns hash code of this symbol.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamedTypeSymbol.Construct(Roslyn.Compilers.CSharp.TypeSymbol[])">
            <summary>
            Returns a constructed type given its type arguments.
            </summary>
            <param name="arguments">The immediate type arguments to be replaced for type
            parameters in the type.</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamedTypeSymbol.AllTypeParameters">
            <summary>
            Return all of the type parameters of enclosing classes and the class itself
            </summary>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamedTypeSymbol.GenerateTempNumber">
            <summary>
            Generate a number to use in compiler-generated names, unique within this named type.
            </summary>
            <returns>A distinct integer value each time it is called on this type</returns>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamedTypeSymbol.Arity">
            <summary>
            Returns the arity of this type, or the number of type parameters it takes.
            A non-generic type has zero arity.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamedTypeSymbol.TypeParameters">
            <summary>
            Returns the type parameters that this type has. If this is a non-generic type,
            returns an empty ReadOnlyArray.  
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamedTypeSymbol.TypeArguments">
            <summary>
            Returns the type arguments that have been substituted for the type parameters. 
            If nothing has been substituted for a give type parameters,
            then the type parameter itself is consider the type argument.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamedTypeSymbol.ConstructedFrom">
            <summary>
            Returns the type symbol that this type was constructed from. This type symbol
            has the same containing type (if any), but has type arguments that are the same
            as the type parameters (although its containing type might not).
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamedTypeSymbol.EnumUnderlyingType">
            <summary>
            For enum types, gets the underlying type. Returns null on all other
            kinds of types.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamedTypeSymbol.DelegateInvokeMethod">
            <summary>
            For delegate types, gets the delegate's invoke method.  Returns null on
            all other kinds of types.  Note that is is possible to have an ill-formed
            delegate type imported from metadata which does not have an Invoke method.
            Such a type will be classified as a delegate but its DelegateInvokeMethod
            would be null.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamedTypeSymbol.InstanceConstructors">
            <summary>
            Get the instance constructors for this type.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamedTypeSymbol.MightContainExtensionMethods">
            <summary>
            If this property returns false, it is certain that there are no extension
            methods inside this type. If this property returns true, it is highly likely
            (but not certain) that this type contains extension methods. This property allows
            the search for extension methods to be narrowed much more quickly.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamedTypeSymbol.IsReferenceType">
            <summary>
            Returns true if this type is known to be a reference type. It is never the case that
            IsReferenceType and IsValueType both return true. However, for an unconstrained type
            parameter, IsReferenceType and IsValueType will both return false.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamedTypeSymbol.IsValueType">
            <summary>
            Returns true if this type is known to be a value type. It is never the case that
            IsReferenceType and IsValueType both return true. However, for an unconstrained type
            parameter, IsReferenceType and IsValueType will both return false.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamedTypeSymbol.IsImplicitClass">
            <summary>
            Returns true if the type is the implicit class that holds onto invalid global members (like methods or
            statements in a non script file).
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamedTypeSymbol.Name">
            <summary>
            Gets the name of this symbol. Symbols without a name return the empty string; null is
            never returned.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamedTypeSymbol.MemberNames">
            <summary>
            Collection of names of members declared within this type.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamedTypeSymbol.DeclaredAccessibility">
            <summary>
            Get this accessibility that was declared on this symbol. For symbols that do not have
            accessibility declared on them, returns NotApplicable.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamedTypeSymbol.Kind">
            <summary>
            Gets the kind of this symbol.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamedTypeSymbol.IsGenericType">
            <summary>
            True if this type or some containing type has type parameters.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.LambdaRewriter.CapturedVariable">
            <summary>
            A field of a frame class that represents a variable that has been captured in a lambda.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.FieldSymbol">
            <summary>
            Represents a field in a class, struct or enum
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.FieldSymbol.Type">
            <summary>
            Gets the type of this field.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.FieldSymbol.CustomModifiers">
            <summary>
            Gets the list of custom modifiers, if any, associated with the field.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.FieldSymbol.AssociatedProperty">
            <summary>
            If this field serves as a backing variable for an automatically generated
            property, returns that property. Otherwise returns null.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.FieldSymbol.IsReadOnly">
            <summary>
            Returns true if this field was declared as "readonly". 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.FieldSymbol.IsVolatile">
            <summary>
            Returns true if this field was declared as "volatile". 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.FieldSymbol.IsConst">
            <summary>
            Returns true if this field was declared as "const" (i.e. is a constant declaration).
            Also returns true for an enum member.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.FieldSymbol.HasConstantValue">
            <summary>
            Returns false if the field wasn't declared as "const", or constant value was omitted or erroneous.
            True otherwise.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.FieldSymbol.ConstantValue">
            <summary>
            If IsConst returns true, then returns the constant value of the field or enum member. If IsConst returns
            false, then returns null.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.FieldSymbol.Kind">
            <summary>
            Gets the kind of this symbol.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.FieldSymbol.IsAbstract">
            <summary>
            Returns false because field can't be abstract.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.FieldSymbol.IsExtern">
            <summary>
            Returns false because field can't be defined externally.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.FieldSymbol.IsOverride">
            <summary>
            Returns false because field can't be overridden.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.FieldSymbol.IsSealed">
            <summary>
            Returns false because field can't be sealed.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.FieldSymbol.IsVirtual">
            <summary>
            Returns false because field can't be virtual.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.FieldSymbol.IsSpecialName">
            <summary>
            Called from IFieldDefinition.IsSpecialName to allow
            derived types to override default implementation.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.FieldSymbol.IsRuntimeSpecial">
            <summary>
            Called from IFieldDefinition.IsRuntimeSpecial to allow
            derived types to override default implementation.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.FieldSymbol.HighestPriorityUseSiteError">
            <summary>
            Return error code that has highest priority while calculating use site error for this symbol. 
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.LambdaRewriter.SimpleLocalSymbol">
            <summary>
            A local variable used to store a reference to the frame objects in which captured
            local variables have become fields.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.LocalSymbol">
            <summary>
            Represents a local variable in a method body.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LocalSymbol.Type">
            <summary>
            Gets the type of this local.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LocalSymbol.IsExtern">
            <summary>
            Returns false because local variable can't be defined externally.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LocalSymbol.IsSealed">
            <summary>
            Returns false because local variable can't be sealed.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LocalSymbol.IsAbstract">
            <summary>
            Returns false because local variable can't be abstract.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LocalSymbol.IsOverride">
            <summary>
            Returns false because local variable can't be overridden.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LocalSymbol.IsVirtual">
            <summary>
            Returns false because local variable can't be virtual.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LocalSymbol.IsStatic">
            <summary>
            Returns false because local variable can't be declared as static in C#.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LocalSymbol.DeclaredAccessibility">
            <summary>
            Returns 'NotApplicable' because local variable can't be used outside the member body..
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LocalSymbol.ContainingSymbol">
            <summary>
            Gets the immediately containing symbol of the <see cref="T:Roslyn.Compilers.CSharp.LocalSymbol"/>.
            It should be the member symbol containing this local variable in its body; such as <see cref="T:Roslyn.Compilers.CSharp.MethodSymbol"/>. 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LocalSymbol.Kind">
            <summary>
            Returns value 'Local' of the <see cref="T:Roslyn.Compilers.CSharp.SymbolKind"/>
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LocalSymbol.IsCatch">
            <summary>
            Returns true if this local variable was declared in a catch clause. 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LocalSymbol.IsConst">
            <summary>
            Returns true if this local variable was declared as "const" (i.e. is a constant declaration).
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LocalSymbol.IsUsing">
            <summary>
            Returns true if the local variable is declared in resource-acquisition of a 'using statement';
            otherwise false
            </summary>
            <exmaple>
            <code>
                using (var localVariable = new StreamReader("C:\\Temp\\MyFile.txt")) { ... } 
            </code>
            </exmaple>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LocalSymbol.IsFixed">
            <summary>
            Returns true if the local variable is declared in fixed-pointer-initializer (in unsafe context)
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LocalSymbol.IsFor">
            <summary>
            Returns true if this local variable is declared in for-initializer
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LocalSymbol.IsForEach">
            <summary>
            Returns true if this local variable is declared as iteration variable
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LocalSymbol.IsWriteable">
            <summary>
            Returns false if <see ref="LocalSymbol.IsUsing" />, <see ref="LocalSymbol.IsFixed" />,
            <see ref="LocalSymbol.IsFor" />, <see ref="LocalSymbol.IsForEach" /> or 
            <see ref="LocalSymbol.IsConst" /> return true
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LocalSymbol.HasConstantValue">
            <summary>
            Returns false if the field wasn't declared as "const", or constant value was omitted or errorneous.
            True otherwise.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LocalSymbol.ConstantValue">
            <summary>
            If IsConst returns true, then returns the constant value of the field or enum member. If IsConst returns
            false, then returns null.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.LambdaRewriter.SynthesizedLambdaMethod">
            <summary>
            A method that results from the translation of a single lambda expression.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.MethodSymbol">
            <summary>
            Represents a method or method-like symbol (including constructor,
            destructor, operator, or property/event accessor).
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MethodSymbol.GetReturnTypeAttributes">
            <summary>
            Gets the attributes on method's return type.
            Returns an empty <see cref="T:Roslyn.Compilers.ReadOnlyArray`1"/> if
            there are no attributes.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MethodSymbol.GetReturnTypeAttributes(Roslyn.Compilers.CSharp.NamedTypeSymbol)">
            <summary>
            Gets the attributes of a given attribute class on method's return type.
            Returns an empty array if there are no attributes.
            </summary>
            <param name="attributeType">The type of attribute to check for.</param>
            <returns>All attributes of the given type, or an empty array if none.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MethodSymbol.GetReturnTypeAttributes(Roslyn.Compilers.CSharp.MethodSymbol)">
            <summary>
            Gets the attributes on method's return type which are specified with the given attribute constructor.
            Returns an empty array if there are no such attributes.
            </summary>
            <param name="attributeConstructor">Attribute constructor to check for.</param>
            <returns>Attributes specified with the given constructor, or an empty array if none.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MethodSymbol.CallsAreOmitted(Roslyn.Compilers.CSharp.Compilation)">
            <summary>
            Returns true if calls to this method are omitted in this compilation.  Calls are omitted
            when the called method is a partial method with no implementation part, or when the called
            method is a conditional method whose condition is not true in the given compilation.
            </summary>
            <param name="compilation"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MethodSymbol.CanOverrideOrHide(Roslyn.Compilers.CSharp.MethodKind)">
            <summary>
            Some method kinds do not participate in overriding/hiding (e.g. constructors).
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MethodSymbol.MakeOverriddenOrHiddenMembers">
            <summary>
            Walk up the type hierarchy from ContainingType and list members that this
            method either overrides (accessible properties with the same signature, if this
            method is declared "override") or hides (accessible non-method members 
            with the same name, plus methods that would be in the overrides list if
            this property is not declared "override").
            
            Methods in the overridden list may not be virtual or may have different
            accessibities, types, accessors, etc.  They are really candidates to be
            overridden.
            
            Members in the hidden list are definitely hidden.
            
            Members in the runtime overridden list are indistinguishable from the methods
            in the overridden list from the point of view of the runtime (see
            FindOtherOverriddenMethodsInContainingType for details).
            </summary>
            <remarks>
            In the presence of non-C# types, the meaning of "same signature" is rather
            complicated.  If this method isn't from source, then it refers to the runtime's
            notion of signature (i.e. including return type, custom modifiers, etc).
            If this method is from source, then the process is (conceptually) as follows.
            
            1) Walk up the type hierarchy, recording all matching methods with the same
               signature, ignoring custom modifiers and return type.  Stop if a hidden
               member is encountered.
            2) Apply the following "tie-breaker" rules until you have at most one method,
               a) Prefer an exact custom modifier match (i.e. none, for a source method).
               b) Prefer fewer custom modifiers (values/positions don't matter, just count).
               c) Prefer methods in more derived types.
               d) Prefer earlier in GetMembers order (within the same type).
            3) If a method remains, search its containing type for other methods that
               have the same C# signature (overridden methods) or runtime signature
               (runtime overridden members).
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MethodSymbol.MakePropertyAccessorOverriddenOrHiddenMembers(Roslyn.Compilers.CSharp.PropertySymbol)">
            <summary>
            In the CLI, accessors are just regular methods and their overriding/hiding rules are the same as for
            regular methods.  In C#, however, accessors are intimately connected with their corresponding properties.
            Rather than walking up the type hierarchy from the containing type of this accessor, looking for members
            with the same name, MakePropertyAccessorOverriddenOrHiddenMembers delegates to the associated property.
            For an accessor to hide a member, the hidden member must be a corresponding accessor on a property hidden
            by the associated property.  For an accessor to override a member, the overridden member must be a
            corresponding accessor on a property (directly or indirectly) overridden by the associated property.
            
            Example 1:
            
            public class A { public virtual int P { get; set; } }
            public class B : A { public override int P { get { return 1; } } } //get only
            public class C : B { public override int P { set { } } } // set only
            
            C.P.set overrides A.P.set because C.P.set is the setter of C.P, which overrides B.P,
            which overrides A.P, which has A.P.set as a setter.
            
            Example 2:
            
            public class A { public virtual int P { get; set; } }
            public class B : A { public new virtual int P { get { return 1; } } } //get only
            public class C : B { public override int P { set { } } } // set only
            
            C.P.set does not override any method because C.P overrides B.P, which has no setter
            and does not override a property.
            </summary>
            <param name="associatedProperty">The property associated with this accessor.</param>
            <returns>Members overridden or hidden by this accessor.</returns>
            <remarks>
            This method is intended to return values consistent with the definition of C#, which
            may differ from the actual meaning at runtime.
            
            Note: we don't need a different path for interfaces - Property.OverriddenOrHiddenMembers handles that.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MethodSymbol.FindOverriddenOrHiddenMembersInType(System.Boolean,Roslyn.Compilers.CSharp.NamedTypeSymbol,Roslyn.Compilers.CSharp.NamedTypeSymbol,System.Boolean@,Roslyn.Compilers.CSharp.MethodSymbol@,System.Int32@,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.CSharp.Symbol})">
            <summary>
            Look for overridden or hidden members in a specific type.
            </summary>
            <param name="thisIsFromSource">True if this method is from source (this.IsFromSource).</param>
            <param name="thisContainingType">The type that contains this method (this.ContainingType).</param>
            <param name="currType">The type to search.</param>
            <param name="currTypeHasExactMatch">Will be set to true if there's an exact signature match (including custom modifiers).</param>
            <param name="currTypeBestMatch">
            A method with the same signature if currTypeHasExactMatch is true,
            a method with (a minimal number of) different custom modifiers if there is one,
            and null otherwise.</param>
            <param name="minCustomModifierCount">Running minimal custom modifier count.  May not be updated if exact match found.</param>
            <param name="hiddenBuilder">Hidden members (same name, different kind) will be added to this builder.</param>
            <remarks>
            There is some similarity between this method and TypeSymbol.FindPotentialImplicitImplementationMethodDeclaredInType.
            When making changes to this method, think about whether or not they should also be applied in TypeSymbol.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MethodSymbol.FindRelatedMethods(Roslyn.Compilers.CSharp.MethodSymbol,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.MethodSymbol}@,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.MethodSymbol}@,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.CSharp.Symbol})">
            <summary>
            If representative method is non-null and is contained in a constructed type, then find
            other methods in the same type with the same signature.  If this is an override method,
            add them to the overridden and runtime overridden lists.  Otherwise, add them to the
            hidden list.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MethodSymbol.FindOtherOverriddenMethodsInContainingType(Roslyn.Compilers.CSharp.MethodSymbol,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.CSharp.MethodSymbol},Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.CSharp.MethodSymbol})">
            <summary>
            Having found the best method to override, we want to find methods with the same signature on the
            best method's containing type.
            </summary>
            <param name="representativeMethod">
            The method that we consider to be overridden (may have different custom modifiers from the overriding method).
            Assumed to already be in the overridden and runtime overridden lists.
            </param>
            <param name="overriddenBuilder">
            If the declaring type is constructed, it's possible that two (or more) methods have the same signature
            (including custom modifiers).  Return a list of such methods so that we can report the ambiguity.
            </param>
            <param name="runtimeOverriddenBuilder">
            If the declaring type is constructed, it's possible that two (or more) methods have the same signature
            (including custom modifiers) in metadata (no ref/out distinction).  Return a list of such methods so
            that we can report the ambiguity.
            
            From: SymbolPreparer.cpp
            DevDiv Bugs 115384: Both out and ref parameters are implemented as references. In addition, out parameters are 
            decorated with OutAttribute. In CLR when a signature is looked up in virtual dispatch, CLR does not distinguish
            between these to parameter types. The choice is the last method in the vtable. Therefore we check and warn if 
            there would potentially be a mismatch in CLRs and C#s choice of the overriden method. Unfortunately we have no 
            way of communicating to CLR which method is the overriden one. We only run into this problem when the the 
            parameters are generic.
            </param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MethodSymbol.FindOtherHiddenMethodsInContainingType(Roslyn.Compilers.CSharp.MethodSymbol,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.CSharp.Symbol})">
            <summary>
            Having found that we are hiding a method with exactly the same signature
            (including custom modifiers), we want to find methods with the same signature
            on the declaring type because they will also be hidden.
            (If the declaring type is constructed, it's possible that two or more
            methods have the same signature (including custom modifiers).
            </summary>
            <param name="representativeMethod">
            The method that we consider to be hidden (must have exactly the same custom modifiers as the hiding method).
            Assumed to already be in hiddenBuilder.
            </param>
            <param name="hiddenBuilder">
            Will have all other methods with the same signature (including custom modifiers) as 
            representativeMethod added.
            </param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MethodSymbol.HasEntryPointSignature">
            <summary>
            Checks if the method has an entry point compatible signature, i.e.
            - the return type is either void or int
            - has either no parameter or a single parameter of type string[]
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MethodSymbol.Construct(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.TypeSymbol})">
            <summary>
            Apply type substitution to a generic method to create an method symbol with the given type parameters supplied.
            </summary>
            <param name="typeArguments"></param>
            <returns></returns>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodSymbol.IsMetadataVirtual">
            <summary>
            Override this if you want IMethodDefinition.IsVirtual to return something
            other than false.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodSymbol.MethodKind">
            <summary>
            Gets what kind of method this is. There are several different kinds of things in the
            C# language that are represented as methods. This property allow distinguishing those things
            without having to decode the name of the method.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodSymbol.Arity">
            <summary>
            Returns the arity of this method, or the number of type parameters it takes.
            A non-generic method has zero arity.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodSymbol.IsGenericMethod">
            <summary>
            Returns whether this method is generic; i.e., does it have any type parameters?
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodSymbol.IsExtensionMethod">
            <summary>
            Returns true if this method is an extension method. 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodSymbol.HidesBaseMethodsByName">
            <summary>
            Returns true if this method hides base methods by name. This cannot be specified directly
            in the C# language, but can be true for methods defined in other languages imported from
            metadata. The equivalent of the "hidebyname" flag in metadata. 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodSymbol.IsVararg">
             <summary>
             Returns whether this method is using CLI VARARG calling convention. This is used for C-style variable
             argument lists. This is used extremely rarely in C# code and is represented using the undocumented “__arglist” keyword.
            
             Note that methods with “params” on the last parameter are indicated with the “IsParams” property on ParameterSymbol, and
             are not represented with this property.
             </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodSymbol.ReturnsVoid">
            <summary>
            Returns true if this method has no return type; i.e., returns "void".
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodSymbol.ReturnType">
            <summary>
            Gets the return type of the method
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodSymbol.TypeArguments">
            <summary>
            Returns the type arguments that have been substituted for the type parameters. 
            If nothing has been substituted for a given type parameter,
            then the type parameter itself is consider the type argument.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodSymbol.TypeParameters">
            <summary>
            Get the type parameters on this method. If the method has not generic,
            returns an empty list.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodSymbol.ThisParameter">
            <summary>
            Get the "this" parameter for this method.  This is only valid for source methods.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodSymbol.ParameterCount">
            <summary>
            Optimization: in many cases, the parameter count (fast) is sufficient and we
            don't need the actual parameter symbols (slow).
            </summary>
            <remarks>
            The default implementation is always correct, but may be unnecessarily slow.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodSymbol.Parameters">
            <summary>
            Gets the parameters of this method. If this method has no parameters, returns
            an empty list.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodSymbol.ConstructedFrom">
            <summary>
            Returns the method symbol that this method was constructed from. The resulting
            method symbol
            has the same containing type (if any), but has type arguments that are the same
            as the type parameters (although its containing type might not).
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodSymbol.ExplicitInterfaceImplementations">
            <summary>
            Returns interface methods explicitly implemented by this method.
            </summary>
            <remarks>
            Methods imported from metadata can explicitly implement more than one method, 
            that is why return type is ReadOnlyArray.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodSymbol.ReturnTypeCustomModifiers">
            <summary>
            Returns the list of custom modifiers, if any, associated with the returned value. 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodSymbol.AssociatedPropertyOrEvent">
            <summary>
            If this method has MethodKind of MethodKind.PropertyGet or MethodKind.PropertySet,
            returns the property that this method is the getter or setter for.
            If this method has MethodKind of MethodKind.EventAdd or MethodKind.EventRemove,
            returns the event that this method is the adder or remover for.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodSymbol.OverriddenMethod">
            <summary>
            If this method overrides another method (because it both had the override modifier
            on it, and there correctly was a method to override, returns the overridden method.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodSymbol.Kind">
            <summary>
            Returns value 'Method' of the <see cref="T:Roslyn.Compilers.CSharp.SymbolKind"/>
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodSymbol.IsScriptConstructor">
            <summary>
            Returns true if this symbol represents a constructor of a script class.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodSymbol.IsSubmissionConstructor">
            <summary>
            Returns true if this symbol represents a constructor of an interactive submission class.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodSymbol.HighestPriorityUseSiteError">
            <summary>
            Return error code that has highest priority while calculating use site error for this symbol. 
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TempHelpers.StoreToTemp(Roslyn.Compilers.CSharp.BoundExpression,Roslyn.Compilers.RefKind,Roslyn.Compilers.CSharp.MethodSymbol)">
            <summary>
            Takes an expression and returns the bound local expression "temp" 
            and the bound assignment expression "temp = expr".
            </summary>
            <param name="argument"></param>
            <param name="refKind"></param>
            <param name="containingMethod"></param>
            <returns></returns>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Binder">
            <summary>
            A Binder converts names in to symbols and syntax nodes into bound trees. It is context
            dependent, relative to a location in source code.
            </summary>
            <summary>
            This portion of the binder converts an ExpressionSyntax into a BoundExpression
            </summary>
            <summary>
            This portion of the binder converts StatementSyntax nodes into BoundStatements
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.VerifyAttributeUsageTarget(Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.CSharp.NamedTypeSymbol,Roslyn.Compilers.CSharp.AttributeSyntax,Roslyn.Compilers.CSharp.AttributeLocation,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Verify if the attribute type can be applied to given owner symbol.
            Generate a diagnostic if it cannot be applied
            </summary>
            <param name="ownerSymbol">Symbol on which the attribute is applied</param>
            <param name="attributeType">Attribute class for the attribute</param>
            <param name="node">Syntax node for attribute specification</param>
            <param name="attributeLocation">Attribute target specifier location</param>
            <param name="diagnostics">Diagnostics</param>
            <returns>Whether attribute specification is allowed for the given symbol</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.VerifyAttributeSemantics(Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.CSharp.AttributeSyntax,Roslyn.Compilers.CSharp.SourceAttributeData,Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.CSharp.AttributeLocation)">
            <summary>
            Performs some additional semantic verification for attribute specification
            and processes well known attributes.
            </summary>
            <param name="ownerSymbol">Symbol on which attribute is specified</param>
            <param name="node">Syntax node for attribute specification</param>
            <param name="boundAttribute">Bound attribute to be verified</param>
            <param name="diagnostics">Diagnostics</param>
            <param name="attributeLocation">Attribute target specifier location</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.MethodGroupFinalValidation(Roslyn.Compilers.CSharp.BoundExpression,System.Boolean,Roslyn.Compilers.CSharp.MethodSymbol,Roslyn.Compilers.CSharp.SyntaxNode,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            This method implements the algorithm in spec section 7.6.5.1.
            
            For method group conversions, there are situations in which the conversion is
            considered to exist ("Otherwise the algorithm produces a single best method M having
            the same number of parameters as D and the conversion is considered to exist"), but
            application of the conversion fails.  These are the "final validation" steps of
            overload resolution.
            </summary>
            <returns>
            True if there is any error.
            </returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.MethodGroupIsCompatibleWithDelegate(Roslyn.Compilers.CSharp.BoundExpression,System.Boolean,Roslyn.Compilers.CSharp.MethodSymbol,Roslyn.Compilers.CSharp.NamedTypeSymbol,Roslyn.Compilers.CSharp.Location,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            This method implements the checks in spec section 15.2.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.MethodGroupConversionHasErrors(Roslyn.Compilers.CSharp.SyntaxNode,Roslyn.Compilers.CSharp.Conversion,Roslyn.Compilers.CSharp.BoundExpression,System.Boolean,Roslyn.Compilers.CSharp.NamedTypeSymbol,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            This method combines final validation (section 7.6.5.1) and delegate compatibility (section 15.2).
            </summary>
            <param name="syntax">SyntaxNode of the expression requiring method group conversion.</param>
            <param name="conversion">Conversion to be performed.</param>
            <param name="receiverOpt">Optional receiver.</param>
            <param name="isExtensionMethod">Method invoked as extension method.</param>
            <param name="delegateType">Target delegate type.</param>
            <param name="diagnostics">Where diagnostics should be added.</param>
            <returns>True if a diagnostic has been added.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.MethodGroupConversionDoesNotExistOrHasErrors(Roslyn.Compilers.CSharp.BoundMethodGroup,Roslyn.Compilers.CSharp.NamedTypeSymbol,Roslyn.Compilers.CSharp.Location,Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.CSharp.Conversion@)">
            <summary>
            This method is a wrapper around MethodGroupConversionHasErrors.  As a preliminary step,
            it checks whether a conversion exists.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.TryFoldingNullableEquality(Roslyn.Compilers.CSharp.BinaryOperatorKind,Roslyn.Compilers.CSharp.BoundExpression,Roslyn.Compilers.CSharp.BoundExpression)">
            <summary>
            If one of the (unconverted) operands has constant value null and the other has
            a null constant value other than null, then they are definitely not equal
            and we can give a constant value for either == or !=.  This is a spec violation
            that we retain from Dev10.
            </summary>
            <param name="kind">The operator kind.  Nothing will happen if it is not a lifted equality operator.</param>
            <param name="left">The left-hand operand of the operation (possibly wrapped in a conversion).</param>
            <param name="right">The right-hand operand of the operation (possibly wrapped in a conversion).</param>
            <returns>
            If the operator represents lifted equality, then constant value true if both arguments have constant
            value null, constant value false if exactly one argument has constant value null, and null otherwise.
            If the operator represents lifted inequality, then constant value false if both arguments have constant
            value null, constant value true if exactly one argument has constant value null, and null otherwise.
            </returns>
            <remarks>
            SPEC VIOLATION: according to the spec (section 7.19) constant expressions cannot
            include implicit nullable conversions or nullable subexpressions.  However, Dev10
            specifically folds over lifted == and != (see ExpressionBinder::TryFoldingNullableEquality).
            Dev 10 does do compile-time evaluation of simple lifted operators, but it does so
            in a rewriting pass (see NullableRewriter) - they are not treated as constant values.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.BindConditionalOperator(Roslyn.Compilers.CSharp.ConditionalExpressionSyntax,Roslyn.Compilers.DiagnosticBag)">
             <remarks>
             From ExpressionBinder::EnsureQMarkTypesCompatible:
             
             The v2.0 specification states that the types of the second and third operands T and S of a ternary operator
             must be TT and TS such that either (a) TT==TS, or (b), TT->TS or TS->TT but not both.
            
             Unfortunately that is not what we implemented in v2.0.  Instead, we implemented
             that either (a) TT=TS or (b) T->TS or S->TT but not both.  That is, we looked at the
             convertibility of the expressions, not the types.
            
            
             Changing that to the algorithm in the standard would be a breaking change.
            
             b ? (Func&lt;int&gt;)(delegate(){return 1;}) : (delegate(){return 2;})
            
             and
            
             b ? 0 : myenum
            
             would suddenly stop working.  (The first because o2 has no type, the second because 0 goes to
             any enum but enum doesn't go to int.)
            
             It gets worse.  We would like the 3.0 language features which require type inference to use
             a consistent algorithm, and that furthermore, the algorithm be smart about choosing the best
             of a set of types.  However, the language committee has decided that this algorithm will NOT
             consume information about the convertibility of expressions. Rather, it will gather up all
             the possible types and then pick the "largest" of them.
            
             To maintain backwards compatibility while still participating in the spirit of consistency,
             we implement an algorithm here which picks the type based on expression convertibility, but
             if there is a conflict, then it chooses the larger type rather than producing a type error.
             This means that b?0:myshort will have type int rather than producing an error (because 0->short,
             myshort->int).
             </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.FoldConditionalOperator(Roslyn.Compilers.CSharp.BoundExpression,Roslyn.Compilers.CSharp.BoundExpression,Roslyn.Compilers.CSharp.BoundExpression)">
            <summary>
            Constant folding for conditional (aka ternary) operators.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.GetBinder(Roslyn.Compilers.CSharp.SyntaxNode)">
            <summary>
            Some nodes have special binder's for their contents (like Block's)
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.IsOpenTypeAllowed(Roslyn.Compilers.CSharp.GenericNameSyntax)">
            <summary>
            Returns true if the node is in a position where an open type
            (what the spec calls an "unbound generic type" (e.g. (C&lt;,&gt;))
            is allowed.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.ToBadExpression(Roslyn.Compilers.CSharp.BoundExpression,Roslyn.Compilers.CSharp.LookupResultKind)">
            <summary>
            Return a bound expression with hasErrors set. The argument is returned unchanged if the
            expression already has errors.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.BindValue(Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.Binder.BindValueKind,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Bind the expression and verify the expression matches the combination of lvalue and
            rvalue requirements given by valueKind. If the expression was bound successfully, but
            did not meet the requirements, the return value will be a BoundBadExpression that
            (typically) wraps the subexpression.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.GetDefaultInitExpression(Roslyn.Compilers.CSharp.DefaultExpressionSyntax,Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.CSharp.SyntaxTree,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Get a bound expression initialized with a default value for the given type symbol
            </summary>
            <param name="node"></param>
            <param name="type"></param>
            <param name="syntaxTree"></param>
            <param name="diagnostics"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.BindIdentifier(Roslyn.Compilers.CSharp.SimpleNameSyntax,Roslyn.Compilers.CSharp.TypeArgumentListSyntax,System.Boolean,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Binds a simple identifier.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.BindInvocationExpression(Roslyn.Compilers.CSharp.InvocationExpressionSyntax,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Bind an expression as a method invocation.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.BindInvocationExpressionContinued(Roslyn.Compilers.CSharp.InvocationExpressionSyntax,Roslyn.Compilers.CSharp.OverloadResolutionResult,Roslyn.Compilers.CSharp.AnalyzedArguments,Roslyn.Compilers.CSharp.MethodGroup,Roslyn.Compilers.CSharp.NamedTypeSymbol,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Perform overload resolution on the method group or expression (BoundMethodGroup)
            and arguments and return a BoundExpression representing the invocation.
            </summary>
            <param name="node">Invocation syntax node.</param>
            <param name="result">Overload resolution result for method group executed by caller.</param>
            <param name="analyzedArguments">Arguments bound by the caller.</param>
            <param name="methodGroup">Method group if the invocation represents a potentially overloaded member.</param>
            <param name="delegateTypeOpt">Delegate type if method group represents a delegate.</param>
            <param name="diagnostics">Diagnostics.</param>
            <returns>BoundCall, BoundDelegateCall, or error expression representing the invocation.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.GetDelegateType(Roslyn.Compilers.CSharp.BoundExpression)">
            <summary>
            Return the delegate type if this expression represents a delegate.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.GetInvocationExpressionErrorLocation(Roslyn.Compilers.CSharp.InvocationExpressionSyntax)">
            <summary>
            Errors should squiggle the function expresssion, but be
            associated with the entire invocation node.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.GetNameSyntax(Roslyn.Compilers.CSharp.SyntaxNode,System.String@)">
            <summary>
            Gets the NameSyntax associated with the syntax node
            If no syntax is attached it sets the nameString to plain text
            name and returns a null NameSyntax
            </summary>
            <param name="syntax">Syntax node</param>
            <param name="nameString">Plain text name</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.GetName(Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>
            Gets the plain text name associated with the the expression syntax node
            </summary>
            <param name="syntax">Expression syntax node</param>
            <returns>Plain text name</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.BindConstructorInitializer(Roslyn.Compilers.CSharp.ConstructorInitializerSyntax,Roslyn.Compilers.CSharp.MethodSymbol,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Bind the (implicit or explicit) constructor initializer of a constructor symbol (in source).
            </summary>
            <param name="initializerSyntaxOpt">Null for implicit, SyntaxKind BaseConstructorInitializer or ThisConstructorInitializer for explicit.</param>
            <param name="constructor">Constructor containing the initializer.</param>
            <param name="diagnostics">Accumulates errors (e.g. unable to find constructor to invoke).</param>
            <returns>A bound expression for the constructor initializer call.</returns>
            <remarks>
            This method should be kept consistent with Compiler.BindConstructorInitializer (e.g. same error codes).
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.PerformConstructorOverloadResolution(Roslyn.Compilers.CSharp.NamedTypeSymbol,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.MethodSymbol},Roslyn.Compilers.CSharp.AnalyzedArguments,System.String,Roslyn.Compilers.CSharp.Location,System.Boolean,Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.CSharp.MethodResolutionResult@)">
            <summary>
            Given a list of constructors, use overload resolution to determine which one should be called.
            </summary>
            <param name="typeContainingConstructors">The containing type of the constructors.</param>
            <param name="constructors">The candidate constructors.</param>
            <param name="analyzedArguments">The already bound arguments to the constructor.</param>
            <param name="methodName">The name of the constructor method.</param>
            <param name="errorLocation">The location at which to report overload resolution result diagnostics.</param>
            <param name="suppressResultDiagnostics">True to suppress overload resolution result diagnostics (but not argument diagnostics).</param>
            <param name="diagnostics">Where diagnostics will be reported.</param>
            <param name="methodResolutionResult">If this method returns true, then it will contain a valid MethodResolutionResult.
            Otherwise, it may contain a MethodResolutionResult for an inaccessible constructor or nothing at all.</param>
            <returns>True if overload resolution successfully chose an accessible constructor.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.BindMemberAccess(Roslyn.Compilers.CSharp.MemberAccessExpressionSyntax,System.Boolean,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Binds a member access expression
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.BindMemberAccessReportError(Roslyn.Compilers.CSharp.SyntaxNode,Roslyn.Compilers.CSharp.SimpleNameSyntax,Roslyn.Compilers.CSharp.BoundExpression,Roslyn.Compilers.DiagnosticInfo,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Report the error from member access lookup. Or, if there
            was no explicit error from lookup, report "no such member".
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.BindMemberAccessBadResult(Roslyn.Compilers.CSharp.SyntaxNode,Roslyn.Compilers.CSharp.SimpleNameSyntax,Roslyn.Compilers.CSharp.BoundExpression,Roslyn.Compilers.DiagnosticInfo,Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.CSharp.LookupResultKind)">
            <summary>
            Report the error from member access lookup and generate
            a BoundExpression representing the invalid member.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.CombineExtensionMethodArguments(Roslyn.Compilers.CSharp.BoundExpression,Roslyn.Compilers.CSharp.AnalyzedArguments,Roslyn.Compilers.CSharp.AnalyzedArguments)">
            <summary>
            Combine the receiver and arguments of an extension method
            invocation into a single argument list to allow overload resolution
            to treat the invocation as a static method invocation with no receiver.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.BindMemberOfType(Roslyn.Compilers.CSharp.MemberAccessExpressionSyntax,Roslyn.Compilers.CSharp.BoundExpression,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.TypeSymbol},Roslyn.Compilers.CSharp.LookupResult,System.Boolean,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Binds a static or instance member access.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.GetSymbolOrMethodGroup(Roslyn.Compilers.CSharp.LookupResult,Roslyn.Compilers.CSharp.SimpleNameSyntax,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.CSharp.MethodSymbol},Roslyn.Compilers.DiagnosticBag,System.Boolean@)">
            <summary>
            Given a viable LookupResult, report any ambiguity errors and return either a single
            non-method symbol or a method group. If a method group, the method group info is written
            into the 'methodGroup' parameter and the method returns null.
            </summary>
            <param name="result"></param>
            <param name="node"></param>
            <param name="methodGroup"></param>
            <param name="diagnostics"></param>
            <param name="wasError"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.ResolveMethodGroup(Roslyn.Compilers.CSharp.BoundMethodGroup,Roslyn.Compilers.CSharp.AnalyzedArguments,System.Boolean)">
            <summary>
            Perform lookup and overload resolution on methods defined directly on the class and any
            extension methods in scope. Lookup will occur for extension methods in all nested scopes
            as necessary until an appropriate method is found. If analyzedArguments is null, the first
            method group is returned, without overload resolution being performed. That method group
            will either be the methods defined on the receiver class directly (no extension methods)
            or the first set of extension methods.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.LookupSymbols(Roslyn.Compilers.CSharp.LookupResult,System.String,System.Int32,Roslyn.Compilers.ConsList{Roslyn.Compilers.CSharp.Symbol},Roslyn.Compilers.CSharp.LookupOptions)">
            <summary>
            Look for any symbols in scope with the given name and arity
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.LookupMembers(Roslyn.Compilers.CSharp.LookupResult,Roslyn.Compilers.CSharp.NamespaceOrTypeSymbol,System.String,System.Int32,Roslyn.Compilers.ConsList{Roslyn.Compilers.CSharp.Symbol},Roslyn.Compilers.CSharp.LookupOptions)">
            <summary>
            Look for symbols that are members of the specified namespace or type
            </summary>
            <param name="result"></param>
            <param name="nsOrType"></param>
            <param name="name"></param>
            <param name="arity"></param>
            <param name="basesBeingResolved"></param>
            <param name="options"></param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.GetCandidateExtensionMethods(System.Boolean,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.CSharp.MethodSymbol},System.String,System.Nullable{System.Int32})">
            <summary>
            Return the extension methods from this specific binding scope that match the name and optional
            arity. Since the lookup of extension methods is iterative, proceeding one binding scope at a time,
            GetCandidateExtensionMethods should not defer to the next binding scope. Instead, the caller is
            responsible for walking the nested binding scopes from innermost to outermost. This method is overridden
            to search the available members list in binding types that represent types, namespaces, and usings.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.InferExtensionMethodIfEligible(Roslyn.Compilers.CSharp.MethodSymbol,Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            If the extension method is applicable based on the "this" argument type, return the
            extension method with inferred type arguments. (If the method is not generic, the
            original method is returned.) If the method is not applicable, the return value is null.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.IsAccessible(Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.ConsList{Roslyn.Compilers.CSharp.Symbol})">
            <summary>
            Check whether "symbol" is accessible from this binder.
            Also checks protected access via "accessThroughType".
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.IsAccessible(Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.CSharp.TypeSymbol,System.Boolean@,Roslyn.Compilers.ConsList{Roslyn.Compilers.CSharp.Symbol})">
            <summary>
            Check whether "symbol" is accessible from this binder.
            Also checks protected access via "accessThroughType", and sets "failedThroughTypeCheck" if fails
            the protected access check.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.LookupArities(System.Collections.Generic.HashSet{System.Int32},System.String)">
            <summary>
            Look for the possible arities for the named symbol
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.LookupMemberArities(System.Collections.Generic.HashSet{System.Int32},Roslyn.Compilers.CSharp.NamespaceOrTypeSymbol,System.String)">
            <summary>
            Look for the possible arities for the named member
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.LookupSymbolNames(System.Collections.Generic.HashSet{System.String},Roslyn.Compilers.CSharp.LookupOptions)">
            <summary>
            Look for names in scope
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.LookupMemberNames(System.Collections.Generic.HashSet{System.String},Roslyn.Compilers.CSharp.NamespaceOrTypeSymbol,Roslyn.Compilers.CSharp.LookupOptions)">
            <summary>
            Look for names of members
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.CheckValue(Roslyn.Compilers.CSharp.BoundExpression,Roslyn.Compilers.CSharp.Binder.BindValueKind,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Check the expression is of the required lvalue and rvalue specified by valueKind.
            The method returns the original expression if the expression is of the required
            type. Otherwise, an appropriate error is added to the diagnostics bag and the
            method returns a BoundBadExpression node. The method returns the original
            expression without generating any error if the expression has errors.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.LookupLocal(System.String)">
            <summary>
            Look up a local by name. Only call this method when you know that there is 
            a local in scope that will match the name. Use TryLookupLocal if you think 
            that there might not be a match in the local symbols.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.TryLookupLocal(System.String)">
            <summary>
            Look for a local variable or formal parameter of the given name, 
            and return null if there is not one.
            (Use LookupLocal if you know that there is such a local.)
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.BindNamespace(Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.ConsList{Roslyn.Compilers.CSharp.Symbol})">
            <summary>
            May return null if an error is reported.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.BindSimpleName(Roslyn.Compilers.CSharp.SimpleNameSyntax,Roslyn.Compilers.CSharp.SyntaxNode,Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.ConsList{Roslyn.Compilers.CSharp.Symbol},Roslyn.Compilers.CSharp.NamespaceOrTypeSymbol)">
            <summary>
            Binds a simple name or the simple name portion of a qualified name. 
            "diagnosticLocationNode" is the possible parent node for associating errors with.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.GetWellKnownType(Roslyn.Compilers.WellKnownType,Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.CSharp.SyntaxNode)">
            <summary>
            This is a layer on top of the Compilation version that generates a diagnostic if the well-known
            type isn't found.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.GetWellKnownTypeMember(Roslyn.Compilers.WellKnownMember,Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.CSharp.SyntaxNode)">
            <summary>
            This is a layer on top of the Compilation version that generates a diagnostic if the well-known
            member isn't found.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Binder.Next">
            <summary>
            Get the next binder in which to look up a name, if not found by this binder.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Binder.ContainingMember">
            <summary>
            The member containing the binding context.  Note that for the purposes of the compiler,
            a lambda expression is considered a "member" of its enclosing method, field, or lambda.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Binder.VirtualPosition">
            <summary>
             In certain "speculative binding" scenarios we will be binding a 
             syntax node that is lexically unrelated to the context in which 
             it is being bound. This property gives the "virtual" position
             of the expression being bound.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Binder.ContainingType">
            <summary>
            The type containing the binding context
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Binder.BindingTopLevelScriptCode">
            <summary>
            Returns true if the binder is binding top-level script code.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Binder.AttributeExpressionVisitor">
            <summary>
            Walk a custom attribute argument bound node and return a TypedConstant.  Verify that the expression is a constant expression.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Binder.BindValueKind">
            <summary>
            Expression lvalue and rvalue requirements.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Binder.BindValueKind.RValue">
            <summary>
            Expression is the RHS of an assignment operation.
            </summary>
            <remarks>
            The following are rvalues: values, variables, null literals, properties
            and indexers with getters, events. The following are not rvalues:
            namespaces, types, method groups, anonymous functions.
            </remarks>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Binder.BindValueKind.RValueOrMethodGroup">
            <summary>
            Expression is the RHS of an assignment operation
            and may be a method group.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Binder.BindValueKind.Assignment">
            <summary>
            Expression is the LHS of a simple assignment operation.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Binder.BindValueKind.IncrementDecrement">
            <summary>
            Expression is the operand of an increment
            or decrement operation.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Binder.BindValueKind.CompoundAssignment">
            <summary>
            Expression is the LHS of a compound assignment
            operation (such as +=).
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Binder.BindValueKind.OutParameter">
            <summary>
            Expression is an out parameter.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SwitchBinder">
            <summary>
            This type was introduced as part of a change that stops calls to GetSemanticInfo()
            from crashing. If GetSemanticInfo() is called on a local in a switch block, it was crashing
            because the local symbol could not be found. This is because locals in switch blocks were not being
            created. This type creates and stores the locals in a switch block.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ExtensionMethodScope">
            <summary>
            A distinct scope that may expose extension methods. For a particular Binder,  there
            are two possible scopes: one for the namespace, and another for any using statements
            in the namespace. The namespace scope is searched before the using scope.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ExtensionMethodScopes">
            <summary>
            An enumerable collection of extension method scopes in search
            order, from the given Binder, out through containing Binders.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ExtensionMethodScopeEnumerator">
            <summary>
            An enumerator over ExtensionMethodScopes.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ImplicitlyTypedFieldBinder">
            <summary>
            Tracks fields that are being bound while binding their initializers.
            </summary>
            <remarks>
            Used to detect circular references like:
            var x = y;
            var y = x;
            </remarks>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ImplicitlyTypedLocalBinder">
            <summary>
            This binder is for binding the initializer of an implicitly typed 
            local variable. While binding an implicitly typed local variable
            it is illegal to refer to the variable.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ForEachEnumeratorInfo">
            <summary>
            Information to be deduced while binding a foreach loop so that the loop can be lowered
            to a while over an enumerator.  Not applicable to the array or string forms.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ForEachLoopBinder">
            <summary>
            A loop binder that (1) knows how to bind foreach loops and (2) has the foreach iteration variable in scope.
            </summary>
            <remarks>
            This binder produces BoundForEachStatements.  The lowering described in the spec is performed in ControlFlowRewriter.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ForEachLoopBinder.MakeIterationVariableSymbol">
            <summary>
            Create a LocalSymbol representing the iteration variable of the foreach loop.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ForEachLoopBinder.BindForEachParts(Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Bind the ForEachStatementSyntax at the root of this binder.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ForEachLoopBinder.BindForEachParts(Roslyn.Compilers.DiagnosticBag,System.Boolean)">
            <summary>
            Bind the ForEachStatementSyntax at the root of this binder.
            </summary>
            <param name="diagnostics">Will be populated with binding diagnostics.</param>
            <param name="skipBindingBody">
            If this flag is set, then some work will be skipped (specifically, binding of the
            loop body and allocation of a BoundForEachStatement) and the return value will be
            null.  This is useful if the method is only being called for its side-effects - 
            populating this.lazyLocals.
            </param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ForEachLoopBinder.GetEnumeratorInfo(Roslyn.Compilers.CSharp.BoundExpression,Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.CSharp.ForEachEnumeratorInfo.Builder@,Roslyn.Compilers.CSharp.TypeSymbol@,System.Boolean@)">
            <summary>
            The spec describes an algorithm for finding the following types:
              1) Collection type
              2) Enumerator type
              3) Element type
              
            The implementation details are a bit difference.  If we're iterating over a string or an array, then we don't need to record anything
            but the inferredType (in case the iteration variable is implicitly typed).  If we're iterating over anything else, then we want the 
            inferred type plus a ForEachEnumeratorInfo.Builder with:
              1) Collection type
              2) Element type
              3) GetEnumerator method of the collection type (return type will be the enumerator type from the spec)
              4) Current property of the enumerator type
              5) MoveNext method of the enumerator type
              
            The caller will have to do some extra conversion checks before creating a ForEachEnumeratorInfo for the BoundForEachStatement.
            </summary>
            <param name="collectionExpr">The expression over which to iterate.</param>
            <param name="diagnostics">Populated with binding diagnostics.</param>
            <param name="builder">null for strings and arrays, partially populated (all but conversions) for enumerable expressions.</param>
            <param name="inferredType">Type to be used for implicitly typed iteration variables.</param>
            <param name="hasErrors">True if an error was encountered and the out parameters should be ignored.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ForEachLoopBinder.SatisfiesGetEnumeratorPattern(Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.CSharp.ForEachEnumeratorInfo.Builder@)">
            <summary>
            Check for a GetEnumerator method on collectionExprType.  Failing to satisfy the pattern is not an error -
            it just means that we have to check for an interface instead.
            </summary>
            <param name="collectionExprType">Type of the expression over which to iterate.</param>
            <param name="diagnostics">Populated with *warnings* if there are near misses.</param>
            <param name="builder">Null if there is no such method, non-null with GetEnumeratorMethod set otherwise.</param>
            <returns>True if the method was found (still have to verify that the return (i.e. enumerator) type is acceptable).</returns>
            <remarks>
            Only adds warnings, so does not affect control flow (i.e. no need to check for failure).
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ForEachLoopBinder.FindForEachPatternMethod(Roslyn.Compilers.CSharp.TypeSymbol,System.String,Roslyn.Compilers.CSharp.LookupResult,System.Boolean,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Perform a lookup for the specified method on the specified type.  Perform overload resolution
            on the lookup results.
            </summary>
            <param name="patternType">Type to search.</param>
            <param name="methodName">Method to search for.</param>
            <param name="lookupResult">Passed in for reusability.</param>
            <param name="warningsOnly">True if failures should result in warnings; false if they should result in errors.</param>
            <param name="diagnostics">Populated with binding diagnostics.</param>
            <returns>The desired method or null.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ForEachLoopBinder.PerformForEachPatternOverloadResolution(Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.CSharp.MethodSymbol},System.Boolean,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            The overload resolution portion of FindForEachPatternMethod.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ForEachLoopBinder.SatisfiesForEachPattern(Roslyn.Compilers.CSharp.ForEachEnumeratorInfo.Builder,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Called after it is determined that the expression being enumerated is of a type that
            has a GetEnumerator method.  Checks to see if the return type of the GetEnumerator
            method is suitable (i.e. has Current and MoveNext).
            </summary>
            <param name="builder">Must be non-null and contain a non-null GetEnumeratorMethod.</param>
            <param name="diagnostics">Will be populated with pattern diagnostics.</param>
            <returns>True if the return type has suitable members.</returns>
            <remarks>
            It seems that every failure path reports the same diagnostics, so that is left to the caller.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ForEachLoopBinder.AllInterfacesContainsIEnumerable(Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.CSharp.ForEachEnumeratorInfo.Builder@,System.Boolean@)">
            <summary>
            Checks if the given type implements (or extends, in the case of an interface),
            System.Collections.IEnumerable or System.Collections.Generic.IEnumerable&lt;T&gt;,
            for at least one T.
            </summary>
            <param name="type">Type to check.</param>
            <param name="builder">Null if no interface is found, non-null with a non-null CollectionType otherwise.</param>
            <param name="foundMultiple">True if multiple T's are found.</param>
            <returns>True if some IEnumerable is found (may still be ambiguous).</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ForEachLoopBinder.ReportPatternMemberLookupDiagnostics(Roslyn.Compilers.CSharp.LookupResult,Roslyn.Compilers.CSharp.TypeSymbol,System.String,System.Boolean,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Report appropriate diagnostics when lookup of a pattern member (i.e. GetEnumerator, Current, or MoveNext) fails.
            </summary>
            <param name="lookupResult">Failed lookup result.</param>
            <param name="patternType">Type in which member was looked up.</param>
            <param name="memberName">Name of looked up member.</param>
            <param name="warningsOnly">True if failures should result in warnings; false if they should result in errors.</param>
            <param name="diagnostics">Populated appropriately.</param>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ForEachLoopBinder.Locals">
            <remarks>
            If the iteration variable is implicitly typed (i.e. var), then this will trigger
            binding of the expression portion of the loop so that the type can be inferred.
            </remarks>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.MethodGroupResolution">
            <summary>
            Packages up the various parts returned when resolving a method group. 
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.TypeofBinder">
            <summary>
            This binder is for binding the argument to typeof.  It traverses
            the syntax marking each open type ("unbound generic type" in the
            C# spec) as either allowed or not allowed, so that BindType can 
            appropriately return either the corresponding type symbol or an 
            error type.  It also indicates whether the argument as a whole 
            should be considered open so that the flag can be set 
            appropriately in BoundTypeOfOperator.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.TypeofBinder.OpenTypeVisitor">
            <summary>
            This visitor walks over a type expression looking for open types.
            open types are allowed if an only if:
              1) There is no constructed generic type elsewhere in the visited syntax; and
              2) The open type is not used as a type argument or array/pointer/nullable
                   element type.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SyntaxVisitor">
            <summary>
            Represents a <see cref="T:Roslyn.Compilers.CSharp.SyntaxNode"/> visitor that visits only the single SyntaxNode
            passed into its <see cref="M:Roslyn.Compilers.CSharp.SyntaxVisitor.Visit(Roslyn.Compilers.CSharp.SyntaxNode)"/> method.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitIdentifierName(Roslyn.Compilers.CSharp.IdentifierNameSyntax)">
            <summary>Called when the visitor visits a IdentifierNameSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitQualifiedName(Roslyn.Compilers.CSharp.QualifiedNameSyntax)">
            <summary>Called when the visitor visits a QualifiedNameSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitGenericName(Roslyn.Compilers.CSharp.GenericNameSyntax)">
            <summary>Called when the visitor visits a GenericNameSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitTypeArgumentList(Roslyn.Compilers.CSharp.TypeArgumentListSyntax)">
            <summary>Called when the visitor visits a TypeArgumentListSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitAliasQualifiedName(Roslyn.Compilers.CSharp.AliasQualifiedNameSyntax)">
            <summary>Called when the visitor visits a AliasQualifiedNameSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitPredefinedType(Roslyn.Compilers.CSharp.PredefinedTypeSyntax)">
            <summary>Called when the visitor visits a PredefinedTypeSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitArrayType(Roslyn.Compilers.CSharp.ArrayTypeSyntax)">
            <summary>Called when the visitor visits a ArrayTypeSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitArrayRankSpecifier(Roslyn.Compilers.CSharp.ArrayRankSpecifierSyntax)">
            <summary>Called when the visitor visits a ArrayRankSpecifierSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitPointerType(Roslyn.Compilers.CSharp.PointerTypeSyntax)">
            <summary>Called when the visitor visits a PointerTypeSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitNullableType(Roslyn.Compilers.CSharp.NullableTypeSyntax)">
            <summary>Called when the visitor visits a NullableTypeSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitParenthesizedExpression(Roslyn.Compilers.CSharp.ParenthesizedExpressionSyntax)">
            <summary>Called when the visitor visits a ParenthesizedExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitPrefixUnaryExpression(Roslyn.Compilers.CSharp.PrefixUnaryExpressionSyntax)">
            <summary>Called when the visitor visits a PrefixUnaryExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitPostfixUnaryExpression(Roslyn.Compilers.CSharp.PostfixUnaryExpressionSyntax)">
            <summary>Called when the visitor visits a PostfixUnaryExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitMemberAccessExpression(Roslyn.Compilers.CSharp.MemberAccessExpressionSyntax)">
            <summary>Called when the visitor visits a MemberAccessExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitBinaryExpression(Roslyn.Compilers.CSharp.BinaryExpressionSyntax)">
            <summary>Called when the visitor visits a BinaryExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitConditionalExpression(Roslyn.Compilers.CSharp.ConditionalExpressionSyntax)">
            <summary>Called when the visitor visits a ConditionalExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitThisExpression(Roslyn.Compilers.CSharp.ThisExpressionSyntax)">
            <summary>Called when the visitor visits a ThisExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitBaseExpression(Roslyn.Compilers.CSharp.BaseExpressionSyntax)">
            <summary>Called when the visitor visits a BaseExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitLiteralExpression(Roslyn.Compilers.CSharp.LiteralExpressionSyntax)">
            <summary>Called when the visitor visits a LiteralExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitMakeRefExpression(Roslyn.Compilers.CSharp.MakeRefExpressionSyntax)">
            <summary>Called when the visitor visits a MakeRefExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitRefTypeExpression(Roslyn.Compilers.CSharp.RefTypeExpressionSyntax)">
            <summary>Called when the visitor visits a RefTypeExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitRefValueExpression(Roslyn.Compilers.CSharp.RefValueExpressionSyntax)">
            <summary>Called when the visitor visits a RefValueExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitCheckedExpression(Roslyn.Compilers.CSharp.CheckedExpressionSyntax)">
            <summary>Called when the visitor visits a CheckedExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitDefaultExpression(Roslyn.Compilers.CSharp.DefaultExpressionSyntax)">
            <summary>Called when the visitor visits a DefaultExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitTypeOfExpression(Roslyn.Compilers.CSharp.TypeOfExpressionSyntax)">
            <summary>Called when the visitor visits a TypeOfExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitSizeOfExpression(Roslyn.Compilers.CSharp.SizeOfExpressionSyntax)">
            <summary>Called when the visitor visits a SizeOfExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitInvocationExpression(Roslyn.Compilers.CSharp.InvocationExpressionSyntax)">
            <summary>Called when the visitor visits a InvocationExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitElementAccessExpression(Roslyn.Compilers.CSharp.ElementAccessExpressionSyntax)">
            <summary>Called when the visitor visits a ElementAccessExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitArgumentList(Roslyn.Compilers.CSharp.ArgumentListSyntax)">
            <summary>Called when the visitor visits a ArgumentListSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitBracketedArgumentList(Roslyn.Compilers.CSharp.BracketedArgumentListSyntax)">
            <summary>Called when the visitor visits a BracketedArgumentListSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitArgument(Roslyn.Compilers.CSharp.ArgumentSyntax)">
            <summary>Called when the visitor visits a ArgumentSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitNameColon(Roslyn.Compilers.CSharp.NameColonSyntax)">
            <summary>Called when the visitor visits a NameColonSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitCastExpression(Roslyn.Compilers.CSharp.CastExpressionSyntax)">
            <summary>Called when the visitor visits a CastExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitAnonymousMethodExpression(Roslyn.Compilers.CSharp.AnonymousMethodExpressionSyntax)">
            <summary>Called when the visitor visits a AnonymousMethodExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitSimpleLambdaExpression(Roslyn.Compilers.CSharp.SimpleLambdaExpressionSyntax)">
            <summary>Called when the visitor visits a SimpleLambdaExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitParenthesizedLambdaExpression(Roslyn.Compilers.CSharp.ParenthesizedLambdaExpressionSyntax)">
            <summary>Called when the visitor visits a ParenthesizedLambdaExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitInitializerExpression(Roslyn.Compilers.CSharp.InitializerExpressionSyntax)">
            <summary>Called when the visitor visits a InitializerExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitObjectCreationExpression(Roslyn.Compilers.CSharp.ObjectCreationExpressionSyntax)">
            <summary>Called when the visitor visits a ObjectCreationExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitAnonymousObjectCreationExpression(Roslyn.Compilers.CSharp.AnonymousObjectCreationExpressionSyntax)">
            <summary>Called when the visitor visits a AnonymousObjectCreationExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitArrayCreationExpression(Roslyn.Compilers.CSharp.ArrayCreationExpressionSyntax)">
            <summary>Called when the visitor visits a ArrayCreationExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitImplicitArrayCreationExpression(Roslyn.Compilers.CSharp.ImplicitArrayCreationExpressionSyntax)">
            <summary>Called when the visitor visits a ImplicitArrayCreationExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitStackAllocArrayCreationExpression(Roslyn.Compilers.CSharp.StackAllocArrayCreationExpressionSyntax)">
            <summary>Called when the visitor visits a StackAllocArrayCreationExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitQueryExpression(Roslyn.Compilers.CSharp.QueryExpressionSyntax)">
            <summary>Called when the visitor visits a QueryExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitFromClause(Roslyn.Compilers.CSharp.FromClauseSyntax)">
            <summary>Called when the visitor visits a FromClauseSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitLetClause(Roslyn.Compilers.CSharp.LetClauseSyntax)">
            <summary>Called when the visitor visits a LetClauseSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitJoinClause(Roslyn.Compilers.CSharp.JoinClauseSyntax)">
            <summary>Called when the visitor visits a JoinClauseSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitJoinIntoClause(Roslyn.Compilers.CSharp.JoinIntoClauseSyntax)">
            <summary>Called when the visitor visits a JoinIntoClauseSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitWhereClause(Roslyn.Compilers.CSharp.WhereClauseSyntax)">
            <summary>Called when the visitor visits a WhereClauseSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitOrderByClause(Roslyn.Compilers.CSharp.OrderByClauseSyntax)">
            <summary>Called when the visitor visits a OrderByClauseSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitOrdering(Roslyn.Compilers.CSharp.OrderingSyntax)">
            <summary>Called when the visitor visits a OrderingSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitSelectClause(Roslyn.Compilers.CSharp.SelectClauseSyntax)">
            <summary>Called when the visitor visits a SelectClauseSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitGroupClause(Roslyn.Compilers.CSharp.GroupClauseSyntax)">
            <summary>Called when the visitor visits a GroupClauseSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitQueryContinuation(Roslyn.Compilers.CSharp.QueryContinuationSyntax)">
            <summary>Called when the visitor visits a QueryContinuationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitGlobalStatement(Roslyn.Compilers.CSharp.GlobalStatementSyntax)">
            <summary>Called when the visitor visits a GlobalStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitBlock(Roslyn.Compilers.CSharp.BlockSyntax)">
            <summary>Called when the visitor visits a BlockSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitLocalDeclarationStatement(Roslyn.Compilers.CSharp.LocalDeclarationStatementSyntax)">
            <summary>Called when the visitor visits a LocalDeclarationStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitVariableDeclaration(Roslyn.Compilers.CSharp.VariableDeclarationSyntax)">
            <summary>Called when the visitor visits a VariableDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitVariableDeclarator(Roslyn.Compilers.CSharp.VariableDeclaratorSyntax)">
            <summary>Called when the visitor visits a VariableDeclaratorSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitEqualsValueClause(Roslyn.Compilers.CSharp.EqualsValueClauseSyntax)">
            <summary>Called when the visitor visits a EqualsValueClauseSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitExpressionStatement(Roslyn.Compilers.CSharp.ExpressionStatementSyntax)">
            <summary>Called when the visitor visits a ExpressionStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitEmptyStatement(Roslyn.Compilers.CSharp.EmptyStatementSyntax)">
            <summary>Called when the visitor visits a EmptyStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitLabeledStatement(Roslyn.Compilers.CSharp.LabeledStatementSyntax)">
            <summary>Called when the visitor visits a LabeledStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitGotoStatement(Roslyn.Compilers.CSharp.GotoStatementSyntax)">
            <summary>Called when the visitor visits a GotoStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitBreakStatement(Roslyn.Compilers.CSharp.BreakStatementSyntax)">
            <summary>Called when the visitor visits a BreakStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitContinueStatement(Roslyn.Compilers.CSharp.ContinueStatementSyntax)">
            <summary>Called when the visitor visits a ContinueStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitReturnStatement(Roslyn.Compilers.CSharp.ReturnStatementSyntax)">
            <summary>Called when the visitor visits a ReturnStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitThrowStatement(Roslyn.Compilers.CSharp.ThrowStatementSyntax)">
            <summary>Called when the visitor visits a ThrowStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitYieldStatement(Roslyn.Compilers.CSharp.YieldStatementSyntax)">
            <summary>Called when the visitor visits a YieldStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitWhileStatement(Roslyn.Compilers.CSharp.WhileStatementSyntax)">
            <summary>Called when the visitor visits a WhileStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitDoStatement(Roslyn.Compilers.CSharp.DoStatementSyntax)">
            <summary>Called when the visitor visits a DoStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitForStatement(Roslyn.Compilers.CSharp.ForStatementSyntax)">
            <summary>Called when the visitor visits a ForStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitForEachStatement(Roslyn.Compilers.CSharp.ForEachStatementSyntax)">
            <summary>Called when the visitor visits a ForEachStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitUsingStatement(Roslyn.Compilers.CSharp.UsingStatementSyntax)">
            <summary>Called when the visitor visits a UsingStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitFixedStatement(Roslyn.Compilers.CSharp.FixedStatementSyntax)">
            <summary>Called when the visitor visits a FixedStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitCheckedStatement(Roslyn.Compilers.CSharp.CheckedStatementSyntax)">
            <summary>Called when the visitor visits a CheckedStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitUnsafeStatement(Roslyn.Compilers.CSharp.UnsafeStatementSyntax)">
            <summary>Called when the visitor visits a UnsafeStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitLockStatement(Roslyn.Compilers.CSharp.LockStatementSyntax)">
            <summary>Called when the visitor visits a LockStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitIfStatement(Roslyn.Compilers.CSharp.IfStatementSyntax)">
            <summary>Called when the visitor visits a IfStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitElseClause(Roslyn.Compilers.CSharp.ElseClauseSyntax)">
            <summary>Called when the visitor visits a ElseClauseSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitSwitchStatement(Roslyn.Compilers.CSharp.SwitchStatementSyntax)">
            <summary>Called when the visitor visits a SwitchStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitSwitchSection(Roslyn.Compilers.CSharp.SwitchSectionSyntax)">
            <summary>Called when the visitor visits a SwitchSectionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitSwitchLabel(Roslyn.Compilers.CSharp.SwitchLabelSyntax)">
            <summary>Called when the visitor visits a SwitchLabelSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitTryStatement(Roslyn.Compilers.CSharp.TryStatementSyntax)">
            <summary>Called when the visitor visits a TryStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitCatchClause(Roslyn.Compilers.CSharp.CatchClauseSyntax)">
            <summary>Called when the visitor visits a CatchClauseSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitCatchDeclaration(Roslyn.Compilers.CSharp.CatchDeclarationSyntax)">
            <summary>Called when the visitor visits a CatchDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitFinallyClause(Roslyn.Compilers.CSharp.FinallyClauseSyntax)">
            <summary>Called when the visitor visits a FinallyClauseSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitCompilationUnit(Roslyn.Compilers.CSharp.CompilationUnitSyntax)">
            <summary>Called when the visitor visits a CompilationUnitSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitExternAliasDirective(Roslyn.Compilers.CSharp.ExternAliasDirectiveSyntax)">
            <summary>Called when the visitor visits a ExternAliasDirectiveSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitUsingDirective(Roslyn.Compilers.CSharp.UsingDirectiveSyntax)">
            <summary>Called when the visitor visits a UsingDirectiveSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitNamespaceDeclaration(Roslyn.Compilers.CSharp.NamespaceDeclarationSyntax)">
            <summary>Called when the visitor visits a NamespaceDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitAttributeDeclaration(Roslyn.Compilers.CSharp.AttributeDeclarationSyntax)">
            <summary>Called when the visitor visits a AttributeDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitAttributeTargetSpecifier(Roslyn.Compilers.CSharp.AttributeTargetSpecifierSyntax)">
            <summary>Called when the visitor visits a AttributeTargetSpecifierSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitAttribute(Roslyn.Compilers.CSharp.AttributeSyntax)">
            <summary>Called when the visitor visits a AttributeSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitAttributeArgumentList(Roslyn.Compilers.CSharp.AttributeArgumentListSyntax)">
            <summary>Called when the visitor visits a AttributeArgumentListSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitAttributeArgument(Roslyn.Compilers.CSharp.AttributeArgumentSyntax)">
            <summary>Called when the visitor visits a AttributeArgumentSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitNameEquals(Roslyn.Compilers.CSharp.NameEqualsSyntax)">
            <summary>Called when the visitor visits a NameEqualsSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitTypeParameterList(Roslyn.Compilers.CSharp.TypeParameterListSyntax)">
            <summary>Called when the visitor visits a TypeParameterListSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitTypeParameter(Roslyn.Compilers.CSharp.TypeParameterSyntax)">
            <summary>Called when the visitor visits a TypeParameterSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitClassDeclaration(Roslyn.Compilers.CSharp.ClassDeclarationSyntax)">
            <summary>Called when the visitor visits a ClassDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitStructDeclaration(Roslyn.Compilers.CSharp.StructDeclarationSyntax)">
            <summary>Called when the visitor visits a StructDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitInterfaceDeclaration(Roslyn.Compilers.CSharp.InterfaceDeclarationSyntax)">
            <summary>Called when the visitor visits a InterfaceDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitEnumDeclaration(Roslyn.Compilers.CSharp.EnumDeclarationSyntax)">
            <summary>Called when the visitor visits a EnumDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitDelegateDeclaration(Roslyn.Compilers.CSharp.DelegateDeclarationSyntax)">
            <summary>Called when the visitor visits a DelegateDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitEnumMemberDeclaration(Roslyn.Compilers.CSharp.EnumMemberDeclarationSyntax)">
            <summary>Called when the visitor visits a EnumMemberDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitBaseList(Roslyn.Compilers.CSharp.BaseListSyntax)">
            <summary>Called when the visitor visits a BaseListSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitTypeParameterConstraintClause(Roslyn.Compilers.CSharp.TypeParameterConstraintClauseSyntax)">
            <summary>Called when the visitor visits a TypeParameterConstraintClauseSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitConstructorConstraint(Roslyn.Compilers.CSharp.ConstructorConstraintSyntax)">
            <summary>Called when the visitor visits a ConstructorConstraintSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitClassOrStructConstraint(Roslyn.Compilers.CSharp.ClassOrStructConstraintSyntax)">
            <summary>Called when the visitor visits a ClassOrStructConstraintSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitTypeConstraint(Roslyn.Compilers.CSharp.TypeConstraintSyntax)">
            <summary>Called when the visitor visits a TypeConstraintSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitFieldDeclaration(Roslyn.Compilers.CSharp.FieldDeclarationSyntax)">
            <summary>Called when the visitor visits a FieldDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitEventFieldDeclaration(Roslyn.Compilers.CSharp.EventFieldDeclarationSyntax)">
            <summary>Called when the visitor visits a EventFieldDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitExplicitInterfaceSpecifier(Roslyn.Compilers.CSharp.ExplicitInterfaceSpecifierSyntax)">
            <summary>Called when the visitor visits a ExplicitInterfaceSpecifierSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitMethodDeclaration(Roslyn.Compilers.CSharp.MethodDeclarationSyntax)">
            <summary>Called when the visitor visits a MethodDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitOperatorDeclaration(Roslyn.Compilers.CSharp.OperatorDeclarationSyntax)">
            <summary>Called when the visitor visits a OperatorDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitConversionOperatorDeclaration(Roslyn.Compilers.CSharp.ConversionOperatorDeclarationSyntax)">
            <summary>Called when the visitor visits a ConversionOperatorDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitConstructorDeclaration(Roslyn.Compilers.CSharp.ConstructorDeclarationSyntax)">
            <summary>Called when the visitor visits a ConstructorDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitConstructorInitializer(Roslyn.Compilers.CSharp.ConstructorInitializerSyntax)">
            <summary>Called when the visitor visits a ConstructorInitializerSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitDestructorDeclaration(Roslyn.Compilers.CSharp.DestructorDeclarationSyntax)">
            <summary>Called when the visitor visits a DestructorDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitPropertyDeclaration(Roslyn.Compilers.CSharp.PropertyDeclarationSyntax)">
            <summary>Called when the visitor visits a PropertyDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitEventDeclaration(Roslyn.Compilers.CSharp.EventDeclarationSyntax)">
            <summary>Called when the visitor visits a EventDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitIndexerDeclaration(Roslyn.Compilers.CSharp.IndexerDeclarationSyntax)">
            <summary>Called when the visitor visits a IndexerDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitAccessorList(Roslyn.Compilers.CSharp.AccessorListSyntax)">
            <summary>Called when the visitor visits a AccessorListSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitAccessorDeclaration(Roslyn.Compilers.CSharp.AccessorDeclarationSyntax)">
            <summary>Called when the visitor visits a AccessorDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitParameterList(Roslyn.Compilers.CSharp.ParameterListSyntax)">
            <summary>Called when the visitor visits a ParameterListSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitBracketedParameterList(Roslyn.Compilers.CSharp.BracketedParameterListSyntax)">
            <summary>Called when the visitor visits a BracketedParameterListSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitParameter(Roslyn.Compilers.CSharp.ParameterSyntax)">
            <summary>Called when the visitor visits a ParameterSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitIncompleteMember(Roslyn.Compilers.CSharp.IncompleteMemberSyntax)">
            <summary>Called when the visitor visits a IncompleteMemberSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitSkippedTokens(Roslyn.Compilers.CSharp.SkippedTokensSyntax)">
            <summary>Called when the visitor visits a SkippedTokensSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitDocumentationComment(Roslyn.Compilers.CSharp.DocumentationCommentSyntax)">
            <summary>Called when the visitor visits a DocumentationCommentSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitXmlElement(Roslyn.Compilers.CSharp.XmlElementSyntax)">
            <summary>Called when the visitor visits a XmlElementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitXmlElementStartTag(Roslyn.Compilers.CSharp.XmlElementStartTagSyntax)">
            <summary>Called when the visitor visits a XmlElementStartTagSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitXmlElementEndTag(Roslyn.Compilers.CSharp.XmlElementEndTagSyntax)">
            <summary>Called when the visitor visits a XmlElementEndTagSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitXmlEmptyElement(Roslyn.Compilers.CSharp.XmlEmptyElementSyntax)">
            <summary>Called when the visitor visits a XmlEmptyElementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitXmlName(Roslyn.Compilers.CSharp.XmlNameSyntax)">
            <summary>Called when the visitor visits a XmlNameSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitXmlPrefix(Roslyn.Compilers.CSharp.XmlPrefixSyntax)">
            <summary>Called when the visitor visits a XmlPrefixSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitXmlAttribute(Roslyn.Compilers.CSharp.XmlAttributeSyntax)">
            <summary>Called when the visitor visits a XmlAttributeSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitXmlText(Roslyn.Compilers.CSharp.XmlTextSyntax)">
            <summary>Called when the visitor visits a XmlTextSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitXmlCDataSection(Roslyn.Compilers.CSharp.XmlCDataSectionSyntax)">
            <summary>Called when the visitor visits a XmlCDataSectionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitXmlProcessingInstruction(Roslyn.Compilers.CSharp.XmlProcessingInstructionSyntax)">
            <summary>Called when the visitor visits a XmlProcessingInstructionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitXmlComment(Roslyn.Compilers.CSharp.XmlCommentSyntax)">
            <summary>Called when the visitor visits a XmlCommentSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitIfDirective(Roslyn.Compilers.CSharp.IfDirectiveSyntax)">
            <summary>Called when the visitor visits a IfDirectiveSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitElifDirective(Roslyn.Compilers.CSharp.ElifDirectiveSyntax)">
            <summary>Called when the visitor visits a ElifDirectiveSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitElseDirective(Roslyn.Compilers.CSharp.ElseDirectiveSyntax)">
            <summary>Called when the visitor visits a ElseDirectiveSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitEndIfDirective(Roslyn.Compilers.CSharp.EndIfDirectiveSyntax)">
            <summary>Called when the visitor visits a EndIfDirectiveSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitRegionDirective(Roslyn.Compilers.CSharp.RegionDirectiveSyntax)">
            <summary>Called when the visitor visits a RegionDirectiveSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitEndRegionDirective(Roslyn.Compilers.CSharp.EndRegionDirectiveSyntax)">
            <summary>Called when the visitor visits a EndRegionDirectiveSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitErrorDirective(Roslyn.Compilers.CSharp.ErrorDirectiveSyntax)">
            <summary>Called when the visitor visits a ErrorDirectiveSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitWarningDirective(Roslyn.Compilers.CSharp.WarningDirectiveSyntax)">
            <summary>Called when the visitor visits a WarningDirectiveSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitBadDirective(Roslyn.Compilers.CSharp.BadDirectiveSyntax)">
            <summary>Called when the visitor visits a BadDirectiveSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitDefineDirective(Roslyn.Compilers.CSharp.DefineDirectiveSyntax)">
            <summary>Called when the visitor visits a DefineDirectiveSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitUndefDirective(Roslyn.Compilers.CSharp.UndefDirectiveSyntax)">
            <summary>Called when the visitor visits a UndefDirectiveSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitLineDirective(Roslyn.Compilers.CSharp.LineDirectiveSyntax)">
            <summary>Called when the visitor visits a LineDirectiveSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitPragmaWarningDirective(Roslyn.Compilers.CSharp.PragmaWarningDirectiveSyntax)">
            <summary>Called when the visitor visits a PragmaWarningDirectiveSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitPragmaChecksumDirective(Roslyn.Compilers.CSharp.PragmaChecksumDirectiveSyntax)">
            <summary>Called when the visitor visits a PragmaChecksumDirectiveSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitReferenceDirective(Roslyn.Compilers.CSharp.ReferenceDirectiveSyntax)">
            <summary>Called when the visitor visits a ReferenceDirectiveSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeofBinder.OpenTypeVisitor.Visit(Roslyn.Compilers.CSharp.ExpressionSyntax,System.Collections.Generic.Dictionary{Roslyn.Compilers.CSharp.GenericNameSyntax,System.Boolean}@,System.Boolean@)">
            <param name="typeSyntax">The argument to typeof.</param>
            <param name="allowedMap">
            Keys are GenericNameSyntax nodes representing unbound generic types.
            Values are false if the node should result in an error and true otherwise.
            </param>
            <param name="isOpenType">True if no constructed generic type was encountered.</param>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Imports">
            <summary>
            Represents symbols imported to the binding scope via using namespace, using alias, and extern alias.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.LocalBinderFactory">
             <summary>The LocalBinderFactory is used to build up the map of all Binders within a method body, and the associated
             SyntaxNode. To do so it traverses all the statements, handling blocks and other
             statements that create scopes. For efficiency reasons, it does not traverse into
             expressions. This means that blocks within lambdas and queries are not created. 
             Blocks within lambdas are bound by their own LocalBinderFactory when they are 
             analyzed.
            
             For reasons of lifetime management, this type is distinct from the BinderFactory 
             which also creates a map from SyntaxNode to Binder. That type owns it's binders
             and that type's lifetime is that of the compilation. Therefore we do not store
             binders local to method bodies in that type's cache. </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ConstantFieldsInProgressBinder">
            <summary>
            This binder keeps track of the set of constant fields that are currently being evaluated
            so that the set can be passed into the next call to SourceFieldSymbol.ConstantValue (and
            its callers).
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ConstantFieldsInProgress">
            <summary>
            This is used while computing the values of constant fields.  Since they can depend on each
            other, we need to keep track of which ones we are currently computing in order to avoid (and
            report) cycles.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.LocalInProgressBinder">
            <summary>
            This binder keeps track of the local variable (if any) that is currently being evaluated
            so that it can be passed into the next call to LocalSymbol.GetConstantValue (and
            its callers).
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.LookupResultKind">
            <summary>
            Classifies the different ways in which a found symbol might be incorrect.
            Higher values are considered "better" than lower values. These values are used
            in a few different places:
               1) Inside a LookupResult to indicate the quality of a symbol from lookup.
               2) Inside a bound node (for example, BoundBadExpression), to indicate
                  the "binding quality" of the symbols referenced by that bound node.
               3) Inside an error type symbol, to indicate the reason that the candidate symbols
                  in the error type symbols were not good.
                  
            While most of the values can occur in all places, some of the problems are not
            detected at lookup time (e.g., NotAVariable), so only occur in bound nodes.
            </summary>
            <remarks>
            This enumeration is parallel to and almost the same as as the CandidateReason enumeration.
            Changes to one should usually result in changes to the other.
            
            There are two enumerations because:
              1) CandidateReason in language-independent, while this enum is language specific.
              2) The name "CandidateReason" didn't make much sense in the way LookupResultKind is used internally.
              3) Viable isn't used in CandidateReason, but we need it in LookupResultKind, and there isn't a 
                 a way to have internal enumeration values.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LookupResultKindExtensions.ToCandidateReason(Roslyn.Compilers.CSharp.LookupResultKind)">
            <summary>
            Maps a LookupResultKind to a CandidateReason. Should not be called on LookupResultKind.Viable!
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.BestTypeInferrer.InferBestType(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.BoundExpression},Roslyn.Compilers.CSharp.Conversions,System.Boolean@)">
            <remarks>
            This is intended to be a simplification of CExpressionBestTypeInferrer in the native compiler.
            CONSIDER: There may be an opportunity to short-circuit if some or all of the expressions have error types.
            NOTE: keep this in sync with the two-element version.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.BestTypeInferrer.InferBestType(Roslyn.Compilers.CSharp.BoundExpression,Roslyn.Compilers.CSharp.BoundExpression,Roslyn.Compilers.CSharp.Conversions,System.Boolean@)">
            <remarks>
            A special case of the above for the common case of comparing exactly two expressions (e.g. for the ternary operator).
            NOTE: keep this in sync with the array version.
            </remarks>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Conversion">
            <summary>
            Summarizes whether a conversion is allowed, and if so, which kind of conversion (and in some cases, the
            associated symbol).
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Conversion.Exists">
            <summary>
            Returns true if the conversion exists, either as an implicit or explicit conversion.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Conversion.IsImplicit">
            <summary>
            Returns true if the conversion is implicit, as described in section 6.1 of the C# language specification
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Conversion.IsExplicit">
            <summary>
            Returns true if the conversion is explicit, as described in section 6.2 of the C# language specification
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Conversion.IsIdentity">
            <summary>
            Returns true if the conversion is an identity conversion, as described in section 6.1.1 of the C# language specification.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Conversion.IsNumeric">
            <summary>
            Returns true if the conversion is an implicit numeric conversion or explicit numberic conversion, 
            as described in sections 6.1.2 and 6.2.1 of the C# language specification.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Conversion.IsEnumeration">
            <summary>
            Returns true if the conversion is an implicit enumeration conversion or explicit enumeration conversion, 
            as described in sections 6.1.3 and 6.2.2 of the C# language specification.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Conversion.IsNullable">
            <summary>
            Returns true if the conversion is an implicit nullable conversion or explicit nullable conversion, 
            as described in sections 6.1.4 and 6.2.3 of the C# language specification.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Conversion.IsReference">
            <summary>
            Returns true if the conversion is an implicit reference conversion or explicit reference conversion, 
            as described in sections 6.1.6 and 6.2.4 of the C# language specification.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Conversion.IsUserDefined">
            <summary>
            Returns true if the conversion is an implicit user-defined conversion or explicit user-defined conversion, 
            as described in section 6.4 of the C# language specification.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Conversion.IsBoxing">
            <summary>
            Returns true if the conversion is an implicit boxing conversion, 
            as described in section 6.1.7 of the C# language specification.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Conversion.IsUnboxing">
            <summary>
            Returns true if the conversion is an explicit unboxing conversion, 
            as described in section 6.2.5 of the C# language specification.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Conversion.IsNullLiteral">
            <summary>
            Returns true if the conversion is an implicit null literal conversion, 
            as described in section 6.1.5 of the C# language specification.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Conversion.IsDynamic">
            <summary>
            Returns true if the conversion is an implicit dynamic conversion, 
            as described in section 6.1.8 of the C# language specification.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Conversion.IsConstantExpression">
            <summary>
            Returns true if the conversion is an implicit constant expression conversion, 
            as described in section 6.1.9 of the C# language specification.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Conversion.IsAnonymousFunction">
            <summary>
            Returns true if the conversion is an implicit anonymous function conversion, 
            as described in section 6.5 of the C# language specification.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Conversion.IsMethodGroup">
            <summary>
            Returns true if the conversion is an implicit method group conversion, 
            as described in section 6.6 of the C# language specification.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Conversion.Method">
            <summary>
            The conversion's Method is only valid if IsMethodGroup,
            or IsUserDefined is true,
            and indicates the method used to create the delegate (for a MethodGroup conversion),
            or the method used to perform the conversion (for a UserDefined conversion).
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MethodTypeInferrer.GetInferredTypeArguments">
            <summary>
            Return the inferred type arguments with error types
            for any type arguments that were not inferred.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.MethodResolutionKind">
            <summary>
            Indicates why the compiler accepted or rejected the method during overload resolution.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MethodResolutionKind.ApplicableInNormalForm">
            <summary>
            The candidate method was accepted in its normal (non-expanded) form.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MethodResolutionKind.ApplicableInExpandedForm">
            <summary>
            The candidate method was accepted in its expanded form, after expanding a "params" parameter.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MethodResolutionKind.InaccessibleTypeArgument">
            <summary>
            The candidate method was rejected because an inferred type argument is inaccessible.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MethodResolutionKind.NoCorrespondingParameter">
            <summary>
            The candidate method was rejected because an argument was specified that did not have a corresponding
            parameter.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MethodResolutionKind.RequiredParameterMissing">
            <summary>
            The candidate method was rejected because an required parameter had no corresponding argument.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MethodResolutionKind.UseSiteError">
            <summary>
            The candidate method was rejected because it is not supported by the language or cannot be used 
            given the current set of assembly references.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MethodResolutionKind.BadArguments">
            <summary>
            The candidate method was rejected because an argument could not be converted to the appropriate parameter
            type.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MethodResolutionKind.TypeInferenceFailed">
            <summary>
            The candidate method was rejected because type inference failed.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MethodResolutionKind.BadGenericArity">
            <summary>
            The candidate method was rejected because it had the wrong number of type parameters.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MethodResolutionKind.ConstructedParameterFailedConstraintCheck">
            <summary>
            The candidate method was rejected because it a constraint on a type parameter was not satisfied.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MethodResolutionKind.LessDerived">
            <summary>
            The candidate method was rejected because another method further down in the inheritance hierarchy was
            present.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MethodResolutionKind.Worse">
            <summary>
            The candidate method was rejected because it was considered worse that another method (according to sectino
            7.5.3.2 of the language specification).
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.MethodResolutionResult">
            <summary>
            Represents the results of overload resolution for a single method.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodResolutionResult.Method">
            <summary>
            The method considered during overload resolution.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodResolutionResult.Resolution">
            <summary>
            Indicates why the compiler accepted or rejected the method during overload resolution.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodResolutionResult.IsValid">
            <summary>
            Returns true if the compiler accepted this method as the sole correct result of overload resolution.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodResolutionResult.Result">
            <summary>
            The result of method analysis.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.OverloadResolutionResult">
            <summary>
            Summarizes the results of an overload resolution analysis, as described in section 7.5 of
            the language specification. Describes whether overload resolution succeeded, and which
            method was selected if overload resolution succeeded, as well as detailed information about
            each method that was considered. 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.OverloadResolutionResult.Succeeded">
            <summary>
            True if overload resolution successfully selected a single best method.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.OverloadResolutionResult.ValidResult">
            <summary>
            If overload resolution successfully selected a single best method, returns information
            about that method. Otherwise returns null.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.OverloadResolutionResult.BestResult">
            <summary>
            If there was a method that overload resolution considered better than all others,
            returns information about that method. A method may be returned even if that method was
            not considered a successful overload resolution, as long as it was better that any other
            potential method considered.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.OverloadResolutionResult.Results">
            <summary>
            Returns information about each method that was considered during overload resolution,
            and what the results of overload resolution were for that method.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.OverloadResolutionResult.IsApplicable">
            <summary>
            Returns true if one or more of the methods in the group are applicable. (Note that
            Succeeded implies IsApplicable but IsApplicable does not imply Succeeded.)
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SingleLookupResult">
            <summary>
            Represents a result of lookup operation over a 0 or 1 symbol (as opposed to a scope). The
            typical use is to represent that a particular smbol is good/bad/unavailable.
            
            For more explanation of Kind, Symbol, Error - see LookupResult.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.InteractiveUsingsBinder.RebindAndAddUsings(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.NamespaceOrTypeSymbol},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.NamespaceOrTypeSymbol})">
            <summary>
            Returns a new list of usings with all namespace symbols replaced by namespace symbols updated from current compilation references.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BoundNode.HasErrors">
            <summary>
            Determines if a bound node, or any child, grandchild, etc has an error (not warning)
            diagnostic associated with it. The HasError bit is initially set for a node by providing it
            to the node constructor, or using the AsError static method. If any child nodes of a node have
            the HasErrors bit set, then it is automatically set to true on the parent bound node.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BoundExpression.Display">
            <summary>
            Returns a serializable object that is used for displaying this expression in a diagnostic message.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BoundCall.OriginalMethodsOpt">
            <summary>
            The set of method symbols from which this call's method was chosen. 
            Only kept in the tree if the call was an error and overload resolution
            was unable to choose a best method.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.CompatibilityMode">
            <summary>
            Enumeration of the different source code compatibility modes.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.CompatibilityMode.None">
            <summary>
            No defined compatibility mode.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.CompatibilityMode.ECMA1">
            <summary>
            The parser accepts only syntax that is included in the ISO/IEC 23270:2003 C# language specification. This
            mode represents the csc switch /langversion:ISO-1
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.CompatibilityMode.ECMA2">
            <summary>
            The compiler accepts only syntax that is included in the ISO/IEC 23270:2006 C# language specification. This
            mode represents the csc switch /langversion:ISO-2
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.CompilationOptions">
            <summary>
            Represents various options that affect compilation, such as 
            whether to emit an executable or a library, whether to optimize
            generated code, and so on.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CompilationOptions.#ctor(System.String,System.String,Roslyn.Compilers.AssemblyKind,Roslyn.Compilers.ReadOnlyArray{System.String},System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Create a CompilationOptions.
            </summary>
            <param name="mainTypeName">
            The full name of a type that declares static Main method. 
            Must be a valid non-generic namespace-qualified name.
            </param>
            <param name="scriptClassName">
            The full name of a global implicit class (script class). 
            This class implicitly encapsulates top-level statements, type declarations, and member declarations. 
            Could be a namespace qualified name.
            </param>
            <param name="assemblyKind">
            The kind of assembly generated when emitted.
            </param>
            <param name="optimize">
            Whether the emitted IL is to be optimized or not. 
            (This does not affect whether debugger information is emitted.)
            </param>
            <param name="checkOverflow">
            Whether bounds checking on integer arithmetic is enforced by default or not.
            </param>
            <param name="isNetModule">
            Whether the code is emitted as a full assembly or a net module. 
            (An assembly may be composed by linking together multiple net modules.)
            </param>
            <param name="usings">
            Global namespace usings.
            </param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CompilationOptions.Copy(System.String,System.String,System.Nullable{Roslyn.Compilers.AssemblyKind},Roslyn.Compilers.ReadOnlyArray{System.String},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean})">
            <summary>
            Create a copy of this CompilationOptions with certain values changed. 
            To copy a value without changing it, pass null for the corresponding argument.
            </summary>
            <param name="mainTypeName">
            The full name of a type that declares static Main method. 
            Must be a valid non-generic namespace-qualified name.
            </param>
            <param name="scriptClassName">
            The full name of a global implicit class (script class). 
            This class implicitly encapsulates top-level statements, type declarations, and member declarations. 
            Could be a namespace qualified name.
            </param>
            <param name="assemblyKind">
            The kind of assembly to emit: a library, a console executable, and so on.
            </param>
            <param name="optimize">
            Whether the emitted IL is to be optimized or not. 
            (This does not affect whether debugger information is emitted.)
            </param>
            <param name="checkOverflow">
            Whether bounds checking on integer arithmetic is enforced by default or not.
            </param>
            <param name="isNetModule">
            Whether the code is emitted as a full assembly or a net module. 
            (An assembly may be composed by linking together multiple net modules.)
            </param>
            <param name="usings">
            Global namespace usings.
            </param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CompilationOptions.GetOptionNames">
            <summary>
            Gets the names of all the options represented by this collection of options.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CompilationOptions.HasOption(System.String)">
            <summary>
            Determines if this collection of options represents the named option.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CompilationOptions.GetOption(System.String)">
            <summary>
            Gets the value of a particular named option.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CompilationOptions.SetOption(System.String,System.String)">
            <summary>
            Creates a copy of this collection of options, with a given option set to a given value.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.CompilationOptions.ScriptClassName">
            <summary>
            The full name of a global implicit class (script class). This class implicitly encapsulates top-level statements, 
            type declarations, and member declarations. Could be a namespace qualified name.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.CompilationOptions.MainTypeName">
            <summary>
            The full name of a type that declares static Main method. Must be a valid non-generic namespace-qualified name.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.CompilationOptions.AssemblyKind">
            <summary>
            The kind of assembly generated when emitted.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.CompilationOptions.Optimize">
            <summary>
            Whether the emitted IL is to be optimized or not. 
            (This does not affect whether debugger information is emitted.)
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.CompilationOptions.CheckOverflow">
            <summary>
            Whether bounds checking on integer arithmetic is enforced by default or not.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.CompilationOptions.IsNetModule">
            <summary>
            Whether the code is emitted as a full assembly or a net module. 
            (An assembly may be composed by linking together multiple net modules.)
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.CompilationOptions.Usings">
            <summary>
            Global namespace usings.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.BuiltInOperators">
            <summary>
            Internal cahe of built-in operators.
            Cache is compilation-specific becuse it uses compilation-specific SpecialTypes.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.MemberSemanticModel">
            <summary>
            Binding info for expressions and statements that are part of a member declaration.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SemanticModel">
            <summary>
            Allows asking semantic questions about a tree of syntax nodes in a Compilation. Typically,
            an instance is obtained by a call to <see cref="P:Roslyn.Compilers.CSharp.SemanticModel.Compilation"/>.<see cref="M:Compilation.GetSemanticModel"/>. 
            </summary>
            <remarks>
            <para>An instance of <see cref="T:Roslyn.Compilers.CSharp.SemanticModel"/> caches local symbols and semantic
            information. Thus, it is much more efficient to use a single instance of <see cref="T:Roslyn.Compilers.CSharp.SemanticModel"/> when asking multiple questions about a syntax tree, because
            information from the first question may be reused. This also means that holding onto an
            instance of SemanticModel for a long time may keep a significant amount of memory from being
            garbage collected.
            </para>
            <para>
            When an answer is a named symbol that is reachable by traversing from the root of the symbol
            table, (that is, from an <see cref="T:Roslyn.Compilers.CSharp.AssemblySymbol"/> of the <see cref="P:Roslyn.Compilers.CSharp.SemanticModel.Compilation"/>),
            that symbol will be returned (i.e. the returned value will be reference-equal to one
            reachable from the root of the symbol table). Symbols representing entities without names
            (e.g. array-of-int) may or may not exhibit reference equality. However, some named symbols
            (such as local variables) are not reachable from the root. These symbols are visible as
            answers to semantic questions. When the same SemanticModel object is used, the answers
            exhibit reference-equality.  
            </para>
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.OldGetSemanticInfo(Roslyn.Compilers.CSharp.ExpressionSyntax,System.Threading.CancellationToken)">
            <summary>
            Gets semantic information, such as type, symbols, and diagnostics, about a syntax node.
            </summary>
            <param name="expression">The syntax node to get semantic information for.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.OldGetSemanticInfo(Roslyn.Compilers.CSharp.ConstructorInitializerSyntax,System.Threading.CancellationToken)">
            <summary>
            Gets semantic information, such as type, symbols, and diagnostics, about a syntax node.
            </summary>
            <param name="constructorInitializer">The syntax node to get semantic information for.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.OldGetSemanticInfoInParent(Roslyn.Compilers.CSharp.ExpressionSyntax,System.Threading.CancellationToken)">
            <summary>
            Gets the semantic information for a syntax node as seen from the perspective of the
            node's parent.
            </summary>
            <param name="expression"></param>
            <param name="cancellationToken"></param>
            <remarks>
            This method allows observing the result of implicit conversions that do not have syntax
            node's directly associated with them. For example, consider the following code:
            <code>
            void f(long x); 
            int i = 17; 
            f(i);  
            </code>
            A call to GetSemanticInfo on the syntax node for "i" in "f(i)" would have a Type of
            "int". A call to GetSemanticInfoInParent on the same syntax node would have a Type of
            "long", since there is an implicit conversion from int to long as part of the function
            call to f.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetSemanticInfo(Roslyn.Compilers.CSharp.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Gets semantic information, such as type, symbols, and diagnostics, about a syntax node.
            </summary>
            <param name="node">The syntax node to get semantic information for.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetSemanticInfo(Roslyn.Compilers.CSharp.ExpressionSyntax,System.Threading.CancellationToken)">
            <summary>
            Gets semantic information, such as type, symbols, and diagnostics, about an expression.
            </summary>
            <param name="expression">The syntax node to get semantic information for.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetSemanticInfo(Roslyn.Compilers.CSharp.ConstructorInitializerSyntax,System.Threading.CancellationToken)">
            <summary>
            Gets semantic information, such as type, symbols, and diagnostics, about a constructor initializer.
            </summary>
            <param name="constructorInitializer">The syntax node to get semantic information for.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetEnclosingBinder(System.Int32)">
            <summary>
            Gets the binder that encloses the position.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetMemberModel(Roslyn.Compilers.CSharp.SyntaxNode)">
            <summary>
            Gets the MemberSemanticModel that contains the node.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.CheckAndAdjustPosition(System.Int32)">
            <summary>
            Given a position, locates the containing token.  If the position is actually within the
            leading trivia of the containing token or if that token is EOF, moves one token to the
            left.  Returns the start position of the resulting token.
            
            This has the effect of moving the position left until it hits the beginning of a non-EOF
            token.
            
            Throws an ArgumentOutOfRangeException if position is not within the root of this model.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetAdjustedNodePosition(Roslyn.Compilers.CSharp.SyntaxNode)">
            <summary>
            A convenience method that determines a position from a node.  If the node is missing,
            then its position will be adjusted using CheckAndAdjustPosition.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.LookupSymbols(System.Int32,Roslyn.Compilers.CSharp.NamespaceOrTypeSymbol,System.String,System.Nullable{System.Int32},Roslyn.Compilers.CSharp.LookupOptions,System.Collections.Generic.List{Roslyn.Compilers.CSharp.Symbol})">
            <summary>
            Gets the available named symbols in the context of the specified location and optional
            container. Only symbols that are accessible and visible from the given location are
            returned.
            </summary>
            <param name="position">The character position for determining the enclosing declaration
            scope and accessibility.</param>
            <param name="container">The container to search for symbols within. If null then the
            enclosing declaration scope around position is used.</param>
            <param name="name">The name of the symbol to find. If null is specified then symbols
            with any names are returned.</param>
            <param name="arity">The number of generic type parameters the symbol has. If null is
            specified then symbols with any arity are returned.</param>
            <param name="options">Additional options that affect the lookup process.</param>
            <param name="results">An optional list for storing the results. If this is specified as
            is non-null, then returns are added to this list and it is returned. If this is null, a
            new list is created to hold the results and is returned.</param>
            <returns>A list of symbols that were found. If no symbols were found, an empty list is
            returned.</returns>
            <remarks>
            The "position" is used to determine what variables are visible and accessible. Even if
            "container" is specified, the "position" location is significant for determining which
            members of "containing" are accessible. 
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.LookupNames(System.Int32,Roslyn.Compilers.CSharp.NamespaceOrTypeSymbol,Roslyn.Compilers.CSharp.LookupOptions,System.Collections.Generic.List{System.String})">
            <summary>
            Gets the names of the available named symbols in the context of the specified location
            and optional container. Only symbols that are accessible and visible from the given
            location are returned.
            </summary>
            <param name="position">A character position used to identify a declaration scope and
            accessibility. This character position must be within the FullSpan of the Root syntax
            node in this SemanticModel.
            </param>
            <param name="container">The container to search for symbols within. If null then the
            enclosing declaration scope around position is used.</param>
            <param name="options">Additional options that affect the lookup process.</param>
            <param name="results">An optional list for storing the results. If this is specified as
            is non-null, then returns are added to this list and it is returned. If this is null, a
            new list is created to hold the results and is returned.</param>
            <returns>A list of names of symbols that were found. If no symbols were found, an empty
            list is returned. 
            </returns>
            <remarks>
            The "position" is used to determine what variables are visible and accessible. Even if
            "container" is specified, the "position" location is significant for determining which
            members of "containing" are accessible. 
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.IsAccessible(System.Int32,Roslyn.Compilers.CSharp.Symbol)">
            <summary>
            Determines if the symbol is accessible from the specified location. 
            </summary>
            <param name="position">A character position used to identify a declaration scope and
            accessibility. This character position must be within the FullSpan of the Root syntax
            node in this SemanticModel.
            </param>
            <param name="symbol">The symbol that we are checking to see if it accessible.</param>
            <returns>
            True if "symbol is accessible, false otherwise.</returns>
            <remarks>
            This method only checks accessibility from the point of view of the accessibility
            modifiers on symbol and its containing types. Even if true is returned, the given symbol
            may not be able to be referenced for other reasons, such as name hiding.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.OldBindExpression(System.Int32,Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>
            Binds the expression in the context of the specified location and gets semantic
            information such as type, symbols and diagnostics. This method is used to get semantic
            information about an expression that did not actually appear in the source code.
            </summary>
            <param name="position">A character position used to identify a declaration scope and
            accessibility. This character position must be within the FullSpan of the Root syntax
            node in this SemanticModel.
            </param>
            <param name="expression">A syntax node that represents a parsed expression. This syntax
            node need not and typically does not appear in the source code referred to by the
            SemanticModel instance.</param>
            <returns>The semantic information for the topmost node of the expression.</returns>
            <remarks>The passed in expression is interpreted as a stand-alone expression, as if it
            appeared by itself somewhere within the scope that encloses "position".</remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.OldBindType(System.Int32,Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>
            Binds a type in the context of the specified location. This method is used to get
            semantic information about a type that did not actually appear in the source code.
            </summary>
            <param name="position">A character position used to identify a declaration scope and
            accessibility. This character position must be within the FullSpan of the Root syntax
            node in this SemanticModel.
            </param>
            <param name="type">The syntax node for the type expression to be bound. This syntax node
            need not appear within the source code.</param>
            <returns>The semantic information for the topmost node of the type.</returns>
            <remarks>The symbol lookup rules for type expressions are used when interpreting the
            given syntax. Symbols that are not types and namespaces are not considered.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.BindType(System.Int32,Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>
            Binds a type in the context of the specified location. This method is used to get
            semantic information about a type that did not actually appear in the source code.
            </summary>
            <param name="position">A character position used to identify a declaration scope and
            accessibility. This character position must be within the FullSpan of the Root syntax
            node in this SemanticModel.
            </param>
            <param name="type">The syntax node for the type expression to be bound. This syntax node
            need not appear within the source code.</param>
            <returns>The semantic information for the topmost node of the type.</returns>
            <remarks>The symbol lookup rules for type expressions are used when interpreting the
            given syntax. Symbols that are not types and namespaces are not considered.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.OldBindNamespaceOrType(System.Int32,Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>
            Binds a namespace or type in the context of the specified location. This method is used
            to get semantic information about an type or namespace that did not actually appear in
            the source code.
            </summary>
            <param name="position">A character position used to identify a declaration scope and
            accessibility. This character position must be within the FullSpan of the Root syntax
            node in this SemanticModel.
            </param>
            <param name="namespaceOrType">The syntax node for the type expression to be bound. This
            syntax node need not appear with the source code.</param>
            <returns>The semantic information for the topmost node of the namespace or type.</returns>
            <remarks>The symbol lookup rules for type or namespace expressions are used when
            interpreting the given syntax. Symbols that are not types and namespaces are not
            considered.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.OldBindConstructorInitializer(System.Int32,Roslyn.Compilers.CSharp.ConstructorInitializerSyntax)">
            <summary>
            Bind the constructor initializer in the context of the specified location and get semantic information
            such as type, symbols and diagnostics. This method is used to get semantic information about a constructor
            initializer that did not actually appear in the source code.
            </summary>
            <param name="position">A character position used to identify a declaration scope and accessibility. This
            character position must be within the FullSpan of the Root syntax node in this SemanticModel.
            </param>
            <param name="constructorInitializer">A syntax node that represents a parsed constructor initializer. This syntax node
            need not and typically does not appear in the source code referred to SemanticModel instance.</param>
            <returns>The semantic information for the topmost node of the constructor initializer.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.AnalyzeRegionControlFlow(Roslyn.Compilers.TextSpan)">
            <summary>
            Analyze control-flow within a part of a method body. 
            </summary>
            <param name="span">The span of code within the associated SyntaxTree to analyze. The
            span must be fully inside a method body.</param>
            <returns>An object that can be used to obtain the result of the control flow analysis.</returns>
            <exception cref="T:System.ArgumentException">The span is not with a method body.</exception>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.AnalyzeRegionDataFlow(Roslyn.Compilers.TextSpan)">
            <summary>
            Analyze data-flow within a part of a method body. 
            </summary>
            <param name="span">The span of code within the associated SyntaxTree to analyze. The
            span must be fully inside a method body.</param>
            <returns>An object that can be used to obtain the result of the data flow analysis.</returns>
            <exception cref="T:System.ArgumentException">The span is not with a method body.</exception>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetSpeculativeSemanticModel(System.Int32,Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>
            Get a SemanticModel object that is associated with an expression that did not appear in
            this source code. This can be used to get detailed semantic information about sub-parts
            of an expression that did not appear in source code. 
            </summary>
            <param name="position">The character position for determining the enclosing declaration
            scope and accessibility.</param>
            <param name="expression">The expression to analyze. This expression does not need to be
            present in the syntax tree associated with this object.</param>
            <returns>A SemanticModel object that can be used to inquire about the semantic
            information associated with syntax nodes within "expression".</returns>
            <remarks>
            If semantic information about just the root node of "expression", the BindExpression
            method can be used instead.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetSpeculativeSemanticModel(System.Int32,Roslyn.Compilers.CSharp.StatementSyntax)">
            <summary>
            Get a SemanticModel object that is associated with an expression that did not appear in
            this source code. This can be used to get detailed semantic information about sub-parts
            of an expression that did not appear in source code. 
            </summary>
            <param name="position">The character position for determining the enclosing declaration
            scope and accessibility.</param>
            <param name="statement">The statement to analyze. This statement does not need to be
            present in the syntax tree associated with this object.</param>
            <returns>A SemanticModel object that can be used to inquire about the semantic
            information associated with syntax nodes within "statement".</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.ClassifyConversion(Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            Determines what type of conversion, if any, would be used if a given expression was
            converted to a given type.
            </summary>
            <param name="expression">An expression which much occur within the syntax tree
            associated with this object.</param>
            <param name="destination">The type to attempt conversion to.</param>
            <returns>Returns a Conversion object that summarizes whether the conversion was
            possible, and if so, what kind of conversion it was. If no conversion was possible, a
            Conversion object with a false "Exists" property is returned.</returns>
            <remarks>To determine the conversion between two types (instead of an expression and a
            type), use Compilation.ClassifyConversion.</remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.ClassifyConversion(System.Int32,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            Determines what type of conversion, if any, would be used if a given expression was
            converted to a given type.
            </summary>
            <param name="position">The character position for determining the enclosing declaration
            scope and accessibility.</param>
            <param name="expression">The expression to classify. This expression does not need to be
            present in the syntax tree associated with this object.</param>
            <param name="destination">The type to attempt conversion to.</param>
            <returns>Returns a Conversion object that summarizes whether the conversion was
            possible, and if so, what kind of conversion it was. If no conversion was possible, a
            Conversion object with a false "Exists" property is returned.</returns>
            <remarks>To determine the conversion between two types (instead of an expression and a
            type), use Compilation.ClassifyConversion.</remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetDeclarationDiagnostics(System.Threading.CancellationToken)">
            <summary>
            Get all the syntax and declaration errors within the syntax tree associated with this
            object. Does not get errors involving compiling method bodies or initializers.
            </summary>
            <param name="cancellationToken">A cancellation token that can be used to cancel the
            process of obtaining the diagnostics.</param>
            <remarks>The declaration errors for a syntax tree are cached. The first time this method
            is called, all declarations are analyzed for diagnostics. Calling this a second time
            will return the cached diagnostics.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetDiagnostics(System.Threading.CancellationToken)">
            <summary>
            Get all the errors within the syntax tree associated with this object. Includes errors
            involving compiling method bodies or initializers, in addition to the errors returned by
            GetDeclarationDiagnostics.
            </summary>
            <param name="cancellationToken">A cancellation token that can be used to cancel the
            process of obtaining the diagnostics.</param>
            <remarks>
            Because this method must semantically all method bodies and initializers to check for
            diagnostics, it may take a significant amount of time. Unlike GetDeclarationDiagnostics,
            diagnostics for method bodies and initializers are not cached, the any semantic
            information used to obtain the diagnostics is discarded.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.CSharp.NamespaceDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a namespace declaration syntax node, get the corresponding namespace symbol for
            the declaration assembly.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a namespace.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The namespace symbol that was declared by the namespace declaration.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.CSharp.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Gets the symbol associated with a declaration syntax node.
            </summary>
            <param name="declaration">A syntax node that is a declaration. This can be any type
            derived from MemberDeclarationSyntax, TypeDeclarationSyntax, EnumDeclarationSyntax,
            NamespaceDeclarationSyntax, ParameterSyntax, TypeParameterSyntax, or the alias part of a
            UsingDirectiveSyntax.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol declared by the node or null if the node is not a declaration.
            </returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.CSharp.BaseTypeDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a type declaration, get the corresponding type symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a type.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The type symbol that was declared.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.CSharp.DelegateDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a delegate declaration, get the corresponding type symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a delegate.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The type symbol that was declared.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.CSharp.MemberDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a member declaration syntax, get the corresponding symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a member.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.CSharp.AccessorDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a syntax node that declares a property or member accessor, get the corresponding
            symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares an accessor.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.CSharp.VariableDeclaratorSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a variable declarator syntax, get the corresponding symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a variable.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.CSharp.UsingDirectiveSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a using declaration get the corresponding symbol for the using alias that was
            introduced.
            </summary>
            <param name="declarationSyntax"></param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The alias symbol that was declared, or null if no alias symbol was declared or
            a duplicate alias symbol was declared.</returns>
            <remarks>
            If the using directive is an error because it attempts to introduce an alias for which
            an existing alias was previously declared in the same scope, the result is null.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.CSharp.ParameterSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a parameter declaration syntax node, get the corresponding symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a parameter.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The parameter that was declared.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.CSharp.TypeParameterSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a type parameter declaration (field or method), get the corresponding symbol
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
            <param name="typeParameter"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.CSharp.ForEachStatementSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a foreach statement, get the symbol for the iteration variable
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
            <param name="forEachStatement"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.CSharp.CatchDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a catch declaration, get the symbol for the exception variable
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
            <param name="catchDeclaration"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.ResolveOverloads(System.Int32,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.MethodSymbol},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.TypeSymbol},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.ArgumentSyntax})">
            <summary>
            Resolves the set of provided arguments against set of provided methods to determine the
            appropriate overload. The arguments are bound as if they were at 'position' within this
            binding. An OverloadResolutionResult is returned that gives the result of the compiler's
            overload resolution analysis.
            </summary>
            <param name="position">A character position used to identify a declaration scope and
            accessibility. This character position must be within the FullSpan of the Root syntax
            node in this SemanticModel. This position is used when binding the arguments.
            </param>
            <param name="methods">The set of method to resolve overloads among.</param>
            <param name="arguments">The list of arguments, in order, to use when resolving the
            overloads. The arguments are interpreted as if they occurred within the declaration
            scope that encloses "position".</param>
            <param name="typeArguments">If present, the type argument provided. If not provided,
            type inference is done.</param>
            <remarks>
            This can be used to resolve constructors as well as methods.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SemanticModel.Compilation">
            <summary>
            The compilation this object was obtained from.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SemanticModel.Root">
            <summary>
            The root node of the syntax tree that this binding is based on.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SemanticModel.SyntaxTree">
            <summary>
            The SyntaxTree that this object is associated with.
            </summary>
            <remarks>
            Returns null if this is a binding returned by GetSpeculativeSemanticModel.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MemberSemanticModel.GetEnclosingBinder(Roslyn.Compilers.CSharp.SyntaxNode,System.Int32)">
            <summary>
            This overload exists for callers who
              a) Already have a node in hand and don't want to search through the tree
              b) May want to search from an indirect container (e.g. node containing node
                 containing position).
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MemberSemanticModel.GetBoundNode(Roslyn.Compilers.CSharp.SyntaxNode)">
            <summary>
            Gets the bound node associated with the syntax node.
            If node is null, it returns the bound node associated
            with the root SyntaxNode associated with this SemanticModel
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MemberSemanticModel.GetDeclarationDiagnostics(System.Threading.CancellationToken)">
            <summary>
            Get all the syntax and declaration errors within the syntax tree associated with this object. Does not get
            errors involving compiling method bodies or initializers.
            </summary>
            <param name="cancellationToken">A cancellation token that can be used to cancel the process of obtaining the
            diagnostics.</param>
            <remarks>The declaration errors for a syntax tree are cached. The first time this method is called, a ll
            declarations are analyzed for diagnostics. Calling this a second time will return the cached diagnostics.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MemberSemanticModel.GetDiagnostics(System.Threading.CancellationToken)">
            <summary>
            Get all the errors within the syntax tree associated with this object. Includes errors involving compiling
            method bodies or initializers, in addition to the errors returned by GetDeclarationDiagnostics.
            </summary>
            <param name="cancellationToken">A cancellation token that can be used to cancel the process of obtaining the
            diagnostics.</param>
            <remarks>
            Because this method must semantically all method bodies and initializers to check for diagnostics, it may
            take a significant amount of time. Unlike GetDeclarationDiagnostics, diagnostics for method bodies and
            initializers are not cached, the any semantic information used to obtain the diagnostics is discarded.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MemberSemanticModel.AnalyzeRegionControlFlow(Roslyn.Compilers.TextSpan)">
            <summary>
            Analyze control-flow within a part of a method body. 
            </summary>
            <param name="span">The span of code within the associated SyntaxTree to analyze. The span must be fully
            inside a method body.</param>
            <returns>An object that can be used to obtain the result of the control flow analysis.</returns>
            <exception cref="T:System.ArgumentException">The span is not with a method body.</exception>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MemberSemanticModel.AnalyzeRegionDataFlow(Roslyn.Compilers.TextSpan)">
            <summary>
            Analyze data-flow within a part of a method body. 
            </summary>
            <param name="span">The span of code within the associated SyntaxTree to analyze. The span must be fully
            inside a method body.</param>
            <returns>An object that can be used to obtain the result of the data flow analysis.</returns>
            <exception cref="T:System.ArgumentException">The span is not with a method body.</exception>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MemberSemanticModel.MemberSymbol">
            <summary>
            The member symbol 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MemberSemanticModel.RootBinder">
            <summary>
            The root binder (this binder will parent the interior block binders)
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MemberSemanticModel.SyntaxTree">
            <summary>
            The SyntaxTree that this object is associated with.
            </summary>
            <remarks>
            Returns null if this is a binding returned by GetSpeculativeSemanticModel.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ExecutableCodeSemanticModel.GetLambdaEnclosingBinder(System.Int32,Roslyn.Compilers.CSharp.SyntaxNode,Roslyn.Compilers.CSharp.SyntaxNode,Roslyn.Compilers.CSharp.ExecutableCodeBinder)">
            <summary>
            Performs the same function as GetEnclosingBinder, but is known to take place within
            a specified lambda.  Walks up the syntax hierarchy until a node with an associated
            binder is found.
            </summary>
            <remarks>
            CONSIDER: can this share code with MemberSemanticModel.GetEnclosingBinder?
            </remarks>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SemanticInfo">
            <summary>
            Summarizes the semantic information about a syntax node. 
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.SemanticInfo.None">
            <summary>
            A pre-created instance of SemanticInfo that has a "null" type, no symbols, no constant
            value, and no diagnostics.  
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SemanticInfo.Type">
            <summary>
            The type of the expression represented by the syntax node. For expressions that do not
            have a type, null is returned. If the type could not be determined due to an error, than
            an object derived from ErrorTypeSymbol is returned.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SemanticInfo.ConvertedType">
            <summary>
            The type of the expression after it has undergone an implicit conversion. If the type
            did not undergo an implicit conversion, returns the same as Type.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SemanticInfo.ImplicitConversion">
            <summary>
            If the expression underwent an implicit conversion, return information about that
            conversion. Otherwise, returns an identity conversion.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SemanticInfo.Symbol">
            <summary>
            The symbol that was referred to by the syntax node, if any. Returns null if the given
            expression did not bind successfully to a single symbol. If null is returned, it may
            still be that case that we have one or more "best guesses" as to what symbol was
            intended. These best guesses are available via the CandidateSymbols property.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SemanticInfo.CandidateSymbols">
            <summary>
            If the expression did not successfully resolve to a symbol, but there were one or more
            symbols that may have been considered but discarded, this property returns those
            symbols. The reason that the symbols did not successfully resolve to a symbol are
            available in the CandidateReason property. For example, if the symbol was inaccessible,
            ambiguous, or used in the wrong context.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SemanticInfo.CandidateReason">
            <summary>
             If the expression did not successfully resolve to a symbol, but there were one or more
             symbols that may have been considered but discarded, this property describes why those
             symbol or symbols were not considered suitable.
             </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SemanticInfo.MethodGroup">
            <summary>
            When getting information for a symbol that resolves to a method group, from which a
            method is then chosen; the chosen method is present in Symbol; all methods in the
            group that was consulted are placed in this property.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SemanticInfo.IsCompileTimeConstant">
            <summary>
            Returns true if the expression is a compile-time constant. The value of the constant can
            be obtained with the ConstantValue property.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SemanticInfo.ConstantValue">
            <summary>
            If IsCompileTimeConstant returns true, then returns the constant value of the field or
            enum member. If IsCompileTimeConstant returns false, then returns null.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InitializerSemanticModel">
            <summary>
            A binding for a field or construction initializer.  Represents the result of binding an initial
            value expression rather than an block (for that, use a MethodBodySemanticModel).
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SynthesizedMethodMetadataCompiler">
            <summary>
            When compiling in metadata-only mode, MethodBodyCompiler is not run.  This is problematic
            because MethodBody compiler adds synthesized explicit implementations to the list of
            compiler generated definitions.  In lieu of running MethodBodyCompiler, this class performs
            a quick traversal of the symbol table and calls Module.AddCompilerGeneratedDefinition on each
            synthesized explicit implementation.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SymbolVisitor`2">
            <summary>
            Virtual dispatch based on a symbol's particular class. 
            </summary>
            <typeparam name="TArgument">Additional argument type</typeparam>
            <typeparam name="TResult">Result type</typeparam>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.Visit(Roslyn.Compilers.CSharp.Symbol,`0)">
            <summary>
            Call the correct VisitXXX method in this class based on the particular type of symbol that is passed in.
            Return default(TResult) if symbol is null
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.VisitSymbol(Roslyn.Compilers.CSharp.Symbol,`0)">
            <summary>
            The default Visit method called when visiting any <see cref="T:Roslyn.Compilers.CSharp.Symbol"/> and 
            if visiting specific symbol method VisitXXX is not overridden
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">if this method is called directly</exception>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.VisitAssembly(Roslyn.Compilers.CSharp.AssemblySymbol,`0)">
            <summary>
            Called when visiting an <see cref="T:Roslyn.Compilers.CSharp.AssemblySymbol"/>; Override this method with
            specific implementation; Calling default <see cref="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.VisitSymbol(Roslyn.Compilers.CSharp.Symbol,`0)"/> if it's not
            overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.VisitModule(Roslyn.Compilers.CSharp.ModuleSymbol,`0)">
            <summary>
            Called when visiting a <see cref="T:Roslyn.Compilers.CSharp.ModuleSymbol"/>; Override this method with specific
            implementation; Calling default <see cref="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.VisitSymbol(Roslyn.Compilers.CSharp.Symbol,`0)"/> if it's not overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.VisitNamespace(Roslyn.Compilers.CSharp.NamespaceSymbol,`0)">
            <summary>
            Called when visiting a <see cref="T:Roslyn.Compilers.CSharp.NamespaceSymbol"/>; Should override this method if
            want to visit members of the namespace; Calling <see cref="M:Roslyn.Compilers.CSharp.NamespaceOrTypeSymbol.GetMembers(System.Threading.CancellationToken)"/>
            and loop over each member; calling <see cref="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.Visit(Roslyn.Compilers.CSharp.Symbol,`0)"/> on it Or override this with
            specific implementation; Calling <see cref="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.VisitSymbol(Roslyn.Compilers.CSharp.Symbol,`0)"/> if it's not
            overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.VisitNamedType(Roslyn.Compilers.CSharp.NamedTypeSymbol,`0)">
            <summary>
            Called when visiting a <see cref="T:Roslyn.Compilers.CSharp.NamedTypeSymbol"/>; Override this with specific
            implementation; Calling <see cref="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.VisitSymbol(Roslyn.Compilers.CSharp.Symbol,`0)"/> if it's not overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.VisitArrayType(Roslyn.Compilers.CSharp.ArrayTypeSymbol,`0)">
            <summary>
            Called when visiting an <see cref="T:Roslyn.Compilers.CSharp.ArrayTypeSymbol"/>; Override this with specific
            implementation; Calling <see cref="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.VisitSymbol(Roslyn.Compilers.CSharp.Symbol,`0)"/> if it's not overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.VisitPointerType(Roslyn.Compilers.CSharp.PointerTypeSymbol,`0)">
            <summary>
            Called when visiting a <see cref="T:Roslyn.Compilers.CSharp.PointerTypeSymbol"/>; Override this with specific
            implementation; Calling <see cref="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.VisitSymbol(Roslyn.Compilers.CSharp.Symbol,`0)"/> if it's not overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.VisitErrorType(Roslyn.Compilers.CSharp.ErrorTypeSymbol,`0)">
            <summary>
            Called when visiting an <see cref="T:Roslyn.Compilers.CSharp.ErrorTypeSymbol"/> 
            Error symbol is created when there is compiler error; Override this with specific
            implementation; Calling <see cref="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.VisitSymbol(Roslyn.Compilers.CSharp.Symbol,`0)"/> if it's not overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.VisitTypeParameter(Roslyn.Compilers.CSharp.TypeParameterSymbol,`0)">
            <summary>
            Called when visiting a <see cref="T:Roslyn.Compilers.CSharp.TypeParameterSymbol"/>; Override this with specific
            implementation; Calling <see cref="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.VisitSymbol(Roslyn.Compilers.CSharp.Symbol,`0)"/> if it's not overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.VisitDynamicType(Roslyn.Compilers.CSharp.DynamicTypeSymbol,`0)">
            <summary>
            Called when visiting a <see cref="T:Roslyn.Compilers.CSharp.DynamicTypeSymbol"/>; Override this with specific
            implementation; Calling <see cref="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.VisitSymbol(Roslyn.Compilers.CSharp.Symbol,`0)"/> if it's not overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.VisitMethod(Roslyn.Compilers.CSharp.MethodSymbol,`0)">
            <summary>
            Called when visiting a <see cref="T:Roslyn.Compilers.CSharp.MethodSymbol"/>; Override this with specific
            implementation; Calling default <see cref="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.VisitSymbol(Roslyn.Compilers.CSharp.Symbol,`0)"/> if it's not overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.VisitField(Roslyn.Compilers.CSharp.FieldSymbol,`0)">
            <summary>
            Called when visiting a <see cref="T:Roslyn.Compilers.CSharp.FieldSymbol"/>; Override this with specific
            implementation; Calling default <see cref="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.VisitSymbol(Roslyn.Compilers.CSharp.Symbol,`0)"/> if it's not overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.VisitProperty(Roslyn.Compilers.CSharp.PropertySymbol,`0)">
            <summary>
            Called when visiting a <see cref="T:Roslyn.Compilers.CSharp.PropertySymbol"/>; Override this with specific
            implementation; Calling default <see cref="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.VisitSymbol(Roslyn.Compilers.CSharp.Symbol,`0)"/> if it's not overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.VisitParameter(Roslyn.Compilers.CSharp.ParameterSymbol,`0)">
            <summary>
            Called when visiting a <see cref="T:Roslyn.Compilers.CSharp.ParameterSymbol"/>; Override this with specific
            implementation; Calling default <see cref="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.VisitSymbol(Roslyn.Compilers.CSharp.Symbol,`0)"/> if it's not overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.VisitLocal(Roslyn.Compilers.CSharp.LocalSymbol,`0)">
            <summary>
            Called when visiting a <see cref="T:Roslyn.Compilers.CSharp.LocalSymbol"/>; Override this with specific
            implementation; Calling default <see cref="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.VisitSymbol(Roslyn.Compilers.CSharp.Symbol,`0)"/> if it's not overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.VisitLabel(Roslyn.Compilers.CSharp.LabelSymbol,`0)">
            <summary>
            Called when visiting a <see cref="T:Roslyn.Compilers.CSharp.LabelSymbol"/>; Override this with specific
            implementation; Calling default <see cref="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.VisitSymbol(Roslyn.Compilers.CSharp.Symbol,`0)"/> if it's not overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.VisitAlias(Roslyn.Compilers.CSharp.AliasSymbol,`0)">
            <summary>
            Called when visiting an <see cref="T:Roslyn.Compilers.CSharp.AliasSymbol"/>; Override this with specific
            implementation; Calling default <see cref="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.VisitSymbol(Roslyn.Compilers.CSharp.Symbol,`0)"/> if it's not overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ReferenceDirective">
            <summary>
            Represents the value of #r reference along with its source location.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.DocumentationCommentIDVisitor.PartVisitor">
            <summary>
            A visitor that generates the part of the documentation comment after the initial type
            and colon.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.AttributeData">
            <summary>
            A Symbol attribute represents a .NET attribute applied to a symbol.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AttributeData.PositionalArgument``1(System.Int32,Roslyn.Compilers.SpecialType,``0)">
            <summary>
            Positional argument converted to specified special type OR default value
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AttributeData.NamedArgument``1(System.String,Roslyn.Compilers.SpecialType,``0)">
            <summary>
            Positional argument converted to specified special type OR default value
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AttributeData.ToString">
            <summary>
            Returns the System.String that represents the current AttributeData.
            </summary>
            <returns>A System.String that represents the current AttributeData.</returns>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AttributeData.AttributeClass">
            <summary>
            The attribute class.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AttributeData.AttributeConstructor">
            <summary>
            The constructor on the attribute class.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AttributeData.PositionalArguments">
            <summary>
            Positional (constructor) arguments on the attribute.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AttributeData.NamedArguments">
            <summary>
            Named (property value) arguments on the attribute. 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AttributeData.WellKnownAttribute">
            <summary>
            WellKnownType if the attribute represents a Well known attribute class
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.NameTruncation.MAX_UTF8_NAME_LENGTH">
            <summary>
            This is the maximum length of a type or member name in metadata, assuming
            the name is in UTF-8 format and not (yet) null-terminated.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.NameTruncation.MAX_UTF8_PATH_LENGTH">
            <summary>
            This is the maximum length of a path in metadata, assuming the path is in UTF-8
            format and not (yet) null-terminated.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.NameTruncation.Utf8Encoding">
            <summary>
            This is the same as the default UTF-8 encoding except that the decoder fallback
            behavior has been changed.  Instead of replacing unknown byte sequences with question
            marks, this encoding omits them completely.  Since the only unknown byte sequences
            we expect to see are partial characters on the truncation boundary (since we are
            doing the encoding ourselves), this has the effect of removing partial characters.
            
            For example, suppose you begin with the string "abc\uFFFF".  In UTF-8, this is encoded
            in six bytes (without the null terminator) - one for each of 'a', 'b', and 'c' and 
            three for '\uFFFF'.  If you truncate to 5 bytes, then you end up with 'a', 'b', 'c',
            and the first two bytes of '\uFFFF'.  The decoder replacement fallback simply deletes
            these unrecognized bytes, leaving "abc".
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NameTruncation.Truncate(System.Int32,System.String,System.String@)">
            <summary>
            Truncate the given name so that it fits in metadata.
            </summary>
            <param name="maxLength">Max length for name.  (Expected to be at least 5.)</param>
            <param name="fullName">Name to truncate.</param>
            <param name="truncatedName">The name after truncation.</param>
            <returns>True if truncation was required.</returns>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Emit.SpecializedGenericMethodInstanceReference">
            <summary>
            Represents a generic method of a generic type instantiation, closed over type parameters.
            e.g. 
            A{T}.M{S}()
            A.B{T}.C.M{S}()
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Emit.SpecializedMethodReference">
            <summary>
            Represents a method of a generic type instantiation.
            e.g. 
            A{int}.M()
            A.B{int}.C.M()
            </summary>
        </member>
        <member name="M:Roslyn.Scripting.CSharp.SubmissionCompilationFactory.ValidateReferences(Roslyn.Compilers.CSharp.Compilation,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Checks that the compilation doesn't have any references whose name start with the reserved prefix.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Metadata.PE.PEAttributeData">
            <summary>
            Represents a PE custom attribute
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.MissingAssemblySymbol">
            <summary>
            A <see cref="T:Roslyn.Compilers.CSharp.MissingAssemblySymbol"/> is a special kind of <see cref="T:Roslyn.Compilers.CSharp.AssemblySymbol"/> that represents
            an assembly that couldn't be found.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.AssemblySymbol">
            <summary>
            Represents a .NET assembly, consisting of one or more modules.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.AssemblySymbol.corLibrary">
            <summary>
            The system assembly, which provides primitive types like Object, String, etc., think mscorlib.dll. 
            The value is provided by AssemblyManager and must not be modified. For SourceAssemblySymbol, non-missing 
            coreLibrary must match one of the referenced assemblies returned by GetReferencedAssemblySymbols() method of 
            the main module. If there is no existing assembly that can be used as a source for the primitive types, 
            the value is a Compilation.MissingCorLibrary. 
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AssemblySymbol.SetCorLibrary(Roslyn.Compilers.CSharp.AssemblySymbol)">
            <summary>
            A helper method for AssemblyManager to set the system assembly, which provides primitive 
            types like Object, String, etc., think mscorlib.dll. 
            </summary>
            <param name="corLibrary"></param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AssemblySymbol.LookupTopLevelMetadataType(System.String,System.Int32)">
            <summary>
            Lookup a top level type referenced from metadata, names should be
            compared case-sensitively.
            </summary>
            <param name="emittedName">
            Full type name with generic name mangling.
            </param>
            <param name="arity"></param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AssemblySymbol.LookupForwardedMetadataType(System.String,System.Int32)">
            <summary>
            Lookup type among forwarded types.
            </summary>
            <param name="emittedName"></param>
            <param name="arity"></param>
            <returns>
            Symbol for forwarded type or Nothing if type is not one of forwarded types.
            </returns>
            <remarks></remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AssemblySymbol.GetDeclaredSpecialType(Roslyn.Compilers.SpecialType)">
            <summary>
            Lookup declaration for predefined CorLib type in this Assembly.
            </summary>
            <param name="type"></param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AssemblySymbol.RegisterDeclaredSpecialType(Roslyn.Compilers.CSharp.NamedTypeSymbol)">
            <summary>
            Register declaration of predefined CorLib type in this Assembly.
            </summary>
            <param name="corType"></param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AssemblySymbol.GetNoPiaResolutionAssemblies">
            <summary>
            Return an array of assemblies involved in canonical type resolution of
            NoPia local types defined within this assembly. In other words, all 
            references used by previous compilation referencing this assembly.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AssemblySymbol.GetLinkedReferencedAssemblies">
            <summary>
            Return an array of assemblies referenced by this assembly, which are linked (/l-ed) by 
            each compilation that is using this AssemblySymbol as a reference. 
            If this AssemblySymbol is linked too, it will be in this array too.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AssemblySymbol.GetSpecialType(Roslyn.Compilers.SpecialType)">
            <summary>
            Gets the symbol for the pre-defined type from core library associated with this assembly.
            </summary>
            <returns>The symbol for the pre-defined type or null if the type is not defined in the core library.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AssemblySymbol.GetPrimitiveType(Microsoft.Cci.PrimitiveTypeCode)">
            <summary>
            Get symbol for predefined type from Cor Library used by this assembly.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AssemblySymbol.GetTypeByMetadataName(System.String)">
            <summary>
            Lookup a type within the assembly using the canonical CLR metadata name of the type.
            </summary>
            <param name="metadataName">Type name.</param>
            <returns>Symbol for the type or null if type cannot be found or is ambiguous. </returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AssemblySymbol.GetTypeByMetadataName(System.String,System.Boolean)">
            <summary>
            Lookup a type within the assembly using its canonical CLR metadata name.
            </summary>
            <param name="metadataName"></param>
            <param name="includeReferences">
            If search within assembly fails, lookup in assemblies referenced by the primary module.
            For source assembly, this is equivalent to all assembly references given to compilation.
            </param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AssemblySymbol.GetTypeByReflectionType(System.Type,System.Boolean)">
            <summary>
            Resolves <see cref="T:System.Type"/> to a <see cref="T:Roslyn.Compilers.CSharp.TypeSymbol"/> available in this assembly
            its referenced assemblies.
            </summary>
            <param name="type">The type to resolve.</param>
            <param name="includeReferences">Use referenced assemblies for resolution.</param>
            <returns>The resolved symbol if successful or null on failure.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AssemblySymbol.GetDeclaredSpecialTypeMember(Roslyn.Compilers.SpecialMember)">
            <summary>
            Lookup member declaration in predefined CorLib type in this Assembly. Only valid if this 
            assembly is the Cor Library
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AssemblySymbol.GetSpecialTypeMember(Roslyn.Compilers.SpecialMember)">
            <summary>
            Lookup member declaration in predefined CorLib type used by this Assembly.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AssemblySymbol.CorLibrary">
            <summary>
            The system assembly, which provides primitive types like Object, String, etc., think mscorlib.dll. 
            The value is MissingAssemblySymbol if none of the referenced assemblies can be used as a source for the 
            primitive types and the owning assembly cannot be used as the source too. Otherwise, it is one of 
            the referenced assemblies returned by GetReferencedAssemblySymbols() method or the owning assembly.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AssemblySymbol.BaseName">
            <summary>
            Get the base name of the assembly. This is equivalent to AssemblyName.Name, but may be 
            much faster to retrieve for source code assemblies, since it does not require binding
            the assembly-level attributes that contain the version number and other assembly
            information.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AssemblySymbol.AssemblyName">
            <summary>
            Gets the name of this assembly.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AssemblySymbol.GlobalNamespace">
            <summary>
            Gets the merged root namespace that contains all namespaces and types defined in the modules
            of this assembly. If there is just one module in this assembly, this property just returns the 
            GlobalNamespace of that module.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AssemblySymbol.Modules">
            <summary>
            Gets a read-only list of all the modules in this assembly. (There must be at least one.) The first one is the main module
            that holds the assembly manifest.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AssemblySymbol.IsMissing">
            <summary>
            Does this symbol represent a missing assembly.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AssemblySymbol.IsInteractive">
            <summary>
            True if the assembly contains interactive code.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AssemblySymbol.KeepLookingForDeclaredSpecialTypes">
            <summary>
            Continue looking for declaration of predefined CorLib type in this Assembly
            while symbols for new type declarations are constructed.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AssemblySymbol.IsLinked">
            <summary>
            Assembly is /l-ed by compilation that is using it as a reference.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AssemblySymbol.TypeNames">
            <summary>
            Gets the set of type identifiers from this assembly.
            </summary>
            <remarks>
            These names are the simple identifiers for the type, and do not include namespaces,
            outer type names, or type parameters.
            
            This functionality can be used for features that want to quickly know if a name could be
            a type for performance reasons.  For example, classification does not want to incur an
            expensive binding call cost if it knows that there is no type with the name that they
            are looking at.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AssemblySymbol.NamespaceNames">
            <summary>
            Gets the set of namespace names from this assembly.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.MissingCorLibrarySymbol">
            <summary>
            AssemblySymbol to represent missing, for whatever reason, CorLibrary.
            The symbol is created by AssemblyManager on as needed basis and is shared by all compilations
            with missing CorLibraries.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MissingCorLibrarySymbol.lazySpecialTypes">
            <summary>
            An array of cached Cor types defined in this assembly.
            Lazily filled by GetDeclaredSpecialType method.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MissingCorLibrarySymbol.GetDeclaredSpecialType(Roslyn.Compilers.SpecialType)">
            <summary>
            Lookup declaration for predefined CorLib type in this Assembly. Only should be
            called if it is know that this is the Cor Library (mscorlib).
            </summary>
            <param name="type"></param>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.MissingModuleSymbol">
            <summary>
            A <see cref="T:Roslyn.Compilers.CSharp.MissingModuleSymbol"/> is a special kind of <see cref="T:Roslyn.Compilers.CSharp.ModuleSymbol"/> that represents
            a module that couldn't be found.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ModuleSymbol">
            <summary>
            Represents a module within an assembly. Every assembly contains one or more modules.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ModuleSymbol.GetReferencedAssemblies">
            <summary>
            Returns an array of assembly identities for assemblies referenced by this module.
            Items at the same position from GetReferencedAssemblies and from GetReferencedAssemblySymbols 
            should correspond to each other.
            
            The array and its content is provided by AssemblyManager and must not be modified.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ModuleSymbol.GetReferencedAssemblySymbols">
            <summary>
            Returns an array of AssemblySymbol objects corresponding to assemblies referenced 
            by this module. Items at the same position from GetReferencedAssemblies and 
            from GetReferencedAssemblySymbols should correspond to each other. If reference is 
            not resolved by compiler, GetReferencedAssemblySymbols returns MissingAssemblySymbol in the
            correspnding item.
            
            The array and its content is provided by AssemblyManager and must not be modified.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ModuleSymbol.SetReferences(Roslyn.Compilers.ReadOnlyArray{System.Reflection.AssemblyName},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.AssemblySymbol})">
            <summary>
            A helper method for AssemblyManager to set assembly identities for assemblies 
            referenced by this module and corresponding AssemblySymbols.
            </summary>
            <param name="names"></param>
            <param name="symbols"></param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ModuleSymbol.LookupTopLevelMetadataType(System.String,System.Int32)">
            <summary>
            Lookup a top level type referenced from metadata, names should be
            compared case-sensitively.
            </summary>
            <param name="actualName">
            Full type name with generic name mangling removed.
            </param>
            <param name="arity">
            Type's arity.
            </param>
            <returns>
            Symbol for the type, or MissingMetadataSymbol if the type isn't found.
            </returns>
            <remarks></remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ModuleSymbol.GetModuleNamespace(Roslyn.Compilers.Common.INamespaceSymbol)">
            <summary>
            Given a namespace symbol, returns the corresponding module specific namespace symbol
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ModuleSymbol.GlobalNamespace">
            <summary>
            Returns a NamespaceSymbol representing the global (root) namespace, with
            module extent, that can be used to browse all of the symbols defined in this module.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ModuleSymbol.ContainingAssembly">
            <summary>
            Returns the containing assembly. Modules are always directly contained by an assembly,
            so this property always returns the same as ContainingSymbol.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ModuleSymbol.Kind">
            <summary>
            Returns value 'NetModule' of the <see cref="T:Roslyn.Compilers.CSharp.SymbolKind"/>
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ModuleSymbol.IsMissing">
            <summary>
            Does this symbol represent a missing module.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ModuleSymbol.DeclaredAccessibility">
            <summary>
            Returns 'NotApplicable'
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ModuleSymbol.IsStatic">
            <summary>
            Returns false because module can't be declared as 'static'.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ModuleSymbol.IsVirtual">
            <summary>
            Returns false because module can't be virtual.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ModuleSymbol.IsOverride">
            <summary>
            Returns false because module can't be overridden.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ModuleSymbol.IsAbstract">
            <summary>
            Returns false because module can't be abstract.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ModuleSymbol.IsSealed">
            <summary>
            Returns false because module can't be sealed.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ModuleSymbol.IsExtern">
            <summary>
            Returns false because module can't be defined externally.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.MissingNamespaceSymbol">
            <summary>
            A <see cref="T:Roslyn.Compilers.CSharp.MissingNamespaceSymbol"/> is a special kind of <see cref="T:Roslyn.Compilers.CSharp.NamespaceSymbol"/> that represents
            a namespace that couldn't be found.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.NamespaceSymbol">
            <summary>
            Represents a namespace.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamespaceSymbol.GetNamespaceMembers(System.Threading.CancellationToken)">
            <summary>
            Get all the members of this symbol that are namespaces.
            </summary>
            <returns>An IEnumerable containing all the namespaces that are members of this symbol.
            If this symbol has no namespace members, returns an empty IEnumerable. Never returns
            null.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamespaceSymbol.Accept``2(Roslyn.Compilers.CSharp.SymbolVisitor{``0,``1},``0)">
            <summary>
            Implements visitor pattern.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamespaceSymbol.LookupNestedNamespace(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Lookup a nested namespace.
            </summary>
            <param name="names">
            Sequence of names for nested child namespaces.
            </param>
            <returns>
            Symbol for the most nested namespace, if found. Nothing 
            if namespace or any part of it can not be found.
            </returns>
            <remarks></remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamespaceSymbol.IsGlobalNamespace">
            <summary>
            Returns whether this namespace is the unnamed, global namespace that is 
            at the root of all namespaces.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamespaceSymbol.Extent">
            <summary>
            Namespaces are by their nature open-ended, but a NamespaceSymbol contains a specific set
            of members. The set of members contained by a NamespaceSymbol is denoted by the Extent
            of the namespace. If a Namespace has an module Extent, it contains members of the
            namespace that are present in a particular module. If a Namespace has an compilation
            extent, it contains all members of the namespace in a compilation, including those
            defined in source and all directly referenced metadata assemblies (or added metadata
            modules). 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamespaceSymbol.ContainingAssembly">
            <summary>
            Containing assembly.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamespaceSymbol.Kind">
            <summary>
            Gets the kind of this symbol.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamespaceSymbol.DeclaredAccessibility">
            <summary>
            Get this accessibility that was declared on this symbol. For symbols that do not have
            accessibility declared on them, returns NotApplicable.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamespaceSymbol.IsStatic">
            <summary>
            Returns true if this symbol is "static"; i.e., declared with the "static" modifier or
            implicitly static.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamespaceSymbol.IsAbstract">
            <summary>
            Returns true if this symbol was declared as requiring an override; i.e., declared with
            the "abstract" modifier. Also returns true on a type declared as "abstract", all
            interface types, and members of interface types.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamespaceSymbol.IsSealed">
            <summary>
            Returns true if this symbol was declared to override a base class member and was also
            sealed from further overriding; i.e., declared with the "sealed" modifier.  Also set for
            types that do not allow a derived class (declared with "sealed" or "static" or "struct"
            or "enum" or "delegate").
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamespaceSymbol.ImplicitType">
            <summary>
            Returns an implicit type symbol for this namespace or null if there is none. This type
            wraps misplaced global code.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.NonMissingAssemblySymbol">
            <summary>
            A <see cref="T:Roslyn.Compilers.CSharp.NonMissingAssemblySymbol"/> is a special kind of <see cref="T:Roslyn.Compilers.CSharp.AssemblySymbol"/> that represents
            an assembly that is not missing, i.e. the "real" thing.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.NonMissingAssemblySymbol.EmittedNameToTypeMap">
            <summary>
            This is a cache similar to the one used by MetaImport::GetTypeByName
            in native compiler. The difference is that native compiler pre-populates 
            the cache when it loads types. Here we are populating the cache only
            with things we looked for, so that next time we are looking for the same 
            thing, the lookup is fast. This cache also takes care of TypeForwarders. 
            Gives about 8% win on subsequent lookups in some scenarios.     
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NonMissingAssemblySymbol.LookupTopLevelMetadataType(System.String,System.Int32)">
            <summary>
            Lookup a top level type referenced from metadata, names should be
            compared case-sensitively.
            </summary>
            <param name="emittedName">
            Full type name with generic name mangling.
            </param>
            <param name="arity"></param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NonMissingAssemblySymbol.IsMissing">
            <summary>
            Does this symbol represent a missing assembly.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NonMissingAssemblySymbol.GlobalNamespace">
            <summary>
            Gets the merged root namespace that contains all namespaces and types defined in the modules
            of this assembly. If there is just one module in this assembly, this property just returns the 
            GlobalNamespace of that module.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.NonMissingModuleSymbol">
            <summary>
            A <see cref="T:Roslyn.Compilers.CSharp.NonMissingModuleSymbol"/> is a special kind of <see cref="T:Roslyn.Compilers.CSharp.ModuleSymbol"/> that represents
            a module that is not missing, i.e. the "real" thing.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.NonMissingModuleSymbol.referencedAssemblySymbols">
            <summary>
            An array of AssemblySymbol objects corresponding to assemblies referenced by this module.
            The array and its content is provided by AssemblyManager and must not be modified.
            Items at the same position from this array and from GetReferencedAssemblySymbols should 
            correspond to each other. If reference is not resolved by compiler, corresponding item in 
            this array is MissingAssemblySymbol.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.NonMissingModuleSymbol.referencedAssemblies">
            <summary>
            An array of assembly identities for assemblies referenced by this module.
            The array and its content is provided by AssemblyManager and must not be modified.
            Items at the same position from this array and from ModuleSymbol.referencedAssemblySymbols
            should correspond to each other. This array is returned by GetReferencedAssemblies() method.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NonMissingModuleSymbol.GetReferencedAssemblies">
            <summary>
            Returns an array of assembly identities for assemblies referenced by this module.
            Items at the same position from GetReferencedAssemblies and from GetReferencedAssemblySymbols 
            should correspond to each other.
            
            The array and its content is provided by AssemblyManager and must not be modified.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NonMissingModuleSymbol.GetReferencedAssemblySymbols">
            <summary>
            Returns an array of AssemblySymbol objects corresponding to assemblies referenced 
            by this module. Items at the same position from GetReferencedAssemblies and 
            from GetReferencedAssemblySymbols should correspond to each other. If reference is 
            not resolved by compiler, GetReferencedAssemblySymbols returns MissingAssemblySymbol in the
            correspnding item.
            
            The array and its content is provided by AssemblyManager and must not be modified.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NonMissingModuleSymbol.SetReferences(Roslyn.Compilers.ReadOnlyArray{System.Reflection.AssemblyName},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.AssemblySymbol})">
            <summary>
            A helper method for AssemblyManager to set assembly identities for assemblies 
            referenced by this module and corresponding AssemblySymbols.
            </summary>
            <param name="names"></param>
            <param name="symbols"></param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NonMissingModuleSymbol.LookupTopLevelMetadataType(System.String,System.Int32)">
            <summary>
            Lookup a top level type referenced from metadata, names should be
            compared case-sensitively.
            </summary>
            <param name="actualName">
            Full type name with generic name mangling removed.
            </param>
            <param name="arity">
            Type's arity.
            </param>
            <returns>
            Symbol for the type, or MissingMetadataSymbol if the type isn't found.
            </returns>
            <remarks></remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NonMissingModuleSymbol.IsMissing">
            <summary>
            Does this symbol represent a missing module.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SourceAttributeData">
            <summary>
            Represents a Source custom attribute specification
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SourceLocalSymbol">
            <summary>
            Represents a local variable in a method body.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.SourceLocalSymbol.constantTuple">
            <summary>
            Store the constant value and the corresponding diagnostics together
            to avoid having the former set by one thread and the latter set by
            another.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceLocalSymbol.MakeConstantTuple(Roslyn.Compilers.CSharp.LocalSymbol,Roslyn.Compilers.CSharp.BoundExpression)">
            <summary>
            Determine the constant value of this local and the corresponding diagnostics.
            Set both to constantTuple in a single operation for thread safety.
            </summary>
            <param name="inProgress">Null for the initial call, non-null if we are in the process of evaluating a constant.</param>
            <param name="boundInitValue">If we already have the bound node for the initial value, pass it in to avoid recomputing it.</param>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SourceLocalSymbol.Name">
            <summary>
            Gets the name of the local variable.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SourceLocalSymbol.Locations">
            <summary>
            Gets the locations where the local symbol was originally defined in source.
            There should not be local symbols from metadata, and there should be only one local variable declared.
            TODO: check if there are multiple same name local variables - error symbol or local symbol?
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceNamespaceSymbol.RegisterDeclaredCorTypes">
            <summary>
            Register COR types declared in this namespace, if any, in the COR types cache.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SynthesizedSealedPropertyAccessor">
            <summary>
            If a sealed override property defines fewer accessors than the
            original virtual property, it is necessary to synthesize a sealed
            accessor so that the accessor will not be overridable from metadata.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceNamedTypeSymbol.IsRestrictedBaseType(Roslyn.Compilers.SpecialType)">
            <summary>
            Returns true if the type cannot be used as an explicit base class.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceNamedTypeSymbol.GetSynthesizedExplicitImplementations(System.Threading.CancellationToken)">
            <summary>
            In some circumstances (e.g. implicit implementation of an interface method by a non-virtual method in a 
            base type from another assembly) it is necessary for the compiler to generate explicit implementations for
            some interface methods.  They don't go in the symbol table, but if we are emitting, then we should
            generate code for them.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceNamedTypeSymbol.AddHidingAbstractDiagnostic``1(``0,Roslyn.Compilers.CSharp.Location,Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.DiagnosticBag,System.Boolean@)">
            <summary>
            If necessary, report a diagnostic for a hidden abstract member.
            </summary>
            <returns>True if a diagnostic was reported.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceNamedTypeSymbol.CheckInterfaceUnification(Roslyn.Compilers.DiagnosticBag,System.Threading.CancellationToken)">
            <summary>
            It is invalid for a type to directly (vs through a base class) implement two interfaces that
            unify (i.e. are the same for some substitution of type parameters).
            </summary>
            <remarks>
            CONSIDER: check this while building up InterfacesAndTheirBaseInterfaces (only in the SourceNamedTypeSymbol case).
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceNamedTypeSymbol.ImplementInterfaceMember(Roslyn.Compilers.CSharp.TypeSymbol.SymbolAndDiagnostics,Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.CSharp.SynthesizedExplicitImplementationMethod})">
            <summary>
            Though there is a method that C# considers to be an implementation of the interface method, that
            method may not be considered an implementation by the CLR.  In particular, implicit implementation
            methods that are non-virtual or that have different (usually fewer) custom modifiers than the
            interface method, will not be considered CLR overrides.  To address this problem, we either make
            them virtual (in metadata, not in C#), or we introduce an explicit interface implementation that
            delegates to the implicit implementation.
            </summary>
            <param name="implementingMemberAndDiagnostics">Returned from FindImplementationForInterfaceMemberWithDiagnostics.</param>
            <param name="interfaceMember">The interface method or property that is being implemented.</param>
            <param name="synthesizedImplementations">A list to which we should add any stubs that we generate.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceNamedTypeSymbol.IsPossibleImplementationUnderRuntimeRules(Roslyn.Compilers.CSharp.MethodSymbol,Roslyn.Compilers.CSharp.NamedTypeSymbol)">
            <summary>
            The CLR will only look for an implementation of an interface method in a type that
              1) declares that it implements that interface; or
              2) is a base class of a type that declares that it implements the interface but not
                   a subtype of a class that declares that it implements the interface.
                   
            For example,
            
              interface I
              class A
              class B : A, I
              class C : B
              class D : C, I
            
            Suppose the runtime is looking for D's implementation of a member of I.  It will look in 
            D because of (1), will not look in C, will look in B because of (1), and will look in A
            because of (2).
            
            The key point is that it does not look in C, which C# *does*.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceNamedTypeSymbol.IsOverrideOfPossibleImplementationUnderRuntimeRules(Roslyn.Compilers.CSharp.MethodSymbol,Roslyn.Compilers.CSharp.NamedTypeSymbol)">
            <summary>
            If C# picks a different implementation than the CLR (see IsPossibleImplementationUnderClrRules), then we might
            still be okay, but dynamic dispath might result in C#'s choice getting called anyway.
            </summary>
            <remarks>
            This is based on SymbolPreparer::IsCLRMethodImplSame in the native compiler.
            
            ACASEY: What the native compiler actually does (I think) is compute the C# answer, compute the CLR answer,
            and then confirm that they override the same method.  What I've done here is check for the situations
            where the answers could disagree.  I believe the results will be equivalent.  If in doubt, a more conservative
            check would be implementingMethod.ContainingType.InterfacesAndTheirBaseInterfaces.Contains(@interface).
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceNamedTypeSymbol.FixPartialMember(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.Symbol},Roslyn.Compilers.CSharp.SourceMemberMethodSymbol,Roslyn.Compilers.CSharp.SourceMemberMethodSymbol,Roslyn.Compilers.CSharp.SourceMemberMethodSymbol@)">
            <summary>
            Fix up a partial method by combining its latent and implementaing declarations, updating the array of symbols (by name),
            and returning the combined symbol.
            </summary>
            <param name="symbols">The symbols array containing both the latent and implementing declaration</param>
            <param name="part1">One of the two declarations</param>
            <param name="part2">The other declaration</param>
            <param name="combined">The symbol that should be used to represent the combination of the two</param>
            <returns>An updated symbols array containing only one method symbol representing the two parts</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceNamedTypeSymbol.CheckForMemberConflictWithPropertyAccessor(Roslyn.Compilers.CSharp.PropertySymbol,System.Boolean,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Report an error if a member (other than a method) exists with the same name
            as the property accessor, or if a method exists with the same name and signature.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceNamedTypeSymbol.GetAccessorOrPropertyLocation(Roslyn.Compilers.CSharp.PropertySymbol,System.Boolean)">
            <summary>
            Return the location of the accessor, or if no accessor, the location of the property.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceNamedTypeSymbol.ParametersMatchPropertyAccessor(Roslyn.Compilers.CSharp.PropertySymbol,System.Boolean,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.ParameterSymbol})">
            <summary>
            Return true if the method parameters match the parameters of the
            property accessor, including the value parameter for the setter.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SourceNamedTypeSymbol.BaseType">
            <summary>
            Gets the BaseType of this type. If the base type could not be determined, then 
            an instance of ErrorType is returned. If this kind of type does not have a base type
            (for example, interfaces), null is returned. Also the special class System.Object
            always has a BaseType of null.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SourceNamedTypeSymbol.Interfaces">
            <summary>
            Gets the set of interfaces that this type directly implements. This set does not include
            interfaces that are base interfaces of directly implemented interfaces.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SourceNamedTypeSymbol.EnumUnderlyingType">
            <summary>
            For enum types, gets the underlying type. Returns null on all other
            kinds of types.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SourceNamedTypeSymbol.EnumValueField">
            <summary>
            For enum types, returns the synthesized instance field used
            for generating metadata. Returns null for non-enum types.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SynthesizedBackingFieldSymbol">
            <summary>
            Represents a compiler generated backing field for an automatically implemented property.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.AttributeTargetSpecifierSyntax">
            <summary>Class representing what language construct an attribute targets.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SyntaxNode">
            <summary>
            Represents a non-terminal node in the syntax tree.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.GetLeadingTrivia">
            <summary>
            The list of trivia that appears before this node in the source code.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.GetTrailingTrivia">
            <summary>
            The list of trivia that appears after this node in the source code.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.GetCachedSlot(System.Int32)">
            <summary>
            Gets a node at given node index without forcing its creation.
            If node was not created it would return null.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.GetNodeSlot(System.Int32)">
            <summary>
            Gets node at given node index. 
            This WILL force node creation if node has not yet been created.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.GetSlot(System.Int32)">
            <summary>
            Same as GetNodeSlot, but can also return a token.
            This is used in uncommon cases where we do not know if slot is a node or token.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.GetFullText">
            <summary>
            Returns the complete text for the node, including leading and trailing trivia.
            </summary>
            <returns>The complete text for the node, including leading and trailing trivia.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.GetText">
            <summary>
            Returns the text representation of the node, not including leading and trailing trivia.
            </summary>
            <returns>The test representation of the node, not including leading and trailing trivia.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.WriteTo(System.IO.TextWriter)">
            <summary>
            Writes the full text of this node to the specified TextWriter.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.GetChildPosition(System.Int32)">
            <summary>
            This function calculates the offset of a child at given position.
            It is very common that some children to the left of the given index
            already know their positions so we first check if that is the case.
            In a worst case the cost is O(n), but it is not generally an issue 
            because number of children in regular nodes is fixed and small.
            In a case where the number of children could be large (lists) 
            this function is overridden with more efficient implementations.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.EquivalentTo(Roslyn.Compilers.CSharp.SyntaxNode)">
            <summary>
            Determines whether this node is structurally equivalent to another.
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.GetFirstDirective(System.Func{Roslyn.Compilers.CSharp.DirectiveSyntax,System.Boolean})">
            <summary>
            Gets the first directive of the tree rooted by this node.
            </summary>
            <param name="predicate"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.GetLastDirective(System.Func{Roslyn.Compilers.CSharp.DirectiveSyntax,System.Boolean})">
            <summary>
            Gets the last directive of the tree rooted by this node.
            </summary>
            <param name="predicate"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.GetAnnotatedTrivia(Roslyn.Compilers.SyntaxAnnotation)">
            <summary>
            Finds all trivia with this annotation attached, that are on or under node.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.ChildNodes">
            <summary>
            Gets a list of the child nodes in document order. This list does not contain tokens.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.ChildNodesAndTokens">
            <summary>
            Gets the list of child nodes and tokens of this node in document order, where each element
            is a SyntaxNodeOrToken instance.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.Ancestors(System.Boolean)">
            <summary>
            Gets a list of ancestor nodes that have type TNode and satisfies the predicate.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.AncestorsAndSelf(System.Boolean)">
            <summary>
            Gets a list of ancestor nodes (including this node) that have type TNode and satisfies the predicate.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.DescendentNodes(System.Func{Roslyn.Compilers.CSharp.SyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Gets a list of descendent nodes in prefix document order.
            </summary>
            <param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
            <param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.DescendentNodes(Roslyn.Compilers.TextSpan,System.Func{Roslyn.Compilers.CSharp.SyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Gets a list of descendent nodes in prefix document order.
            </summary>
            <param name="span">The span the node's full span must intersect.</param>
            <param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
            <param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.DescendentNodesAndSelf(System.Func{Roslyn.Compilers.CSharp.SyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Gets a list of descendent nodes (including this node) in prefix document order.
            </summary>
            <param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
            <param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.DescendentNodesAndSelf(Roslyn.Compilers.TextSpan,System.Func{Roslyn.Compilers.CSharp.SyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Gets a list of descendent nodes (including this node) in prefix document order.
            </summary>
            <param name="span">The span the node's full span must intersect.</param>
            <param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
            <param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.DescendentNodesAndTokens(System.Func{Roslyn.Compilers.CSharp.SyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Gets a list of descendent nodes and tokens in prefix document order.
            </summary>
            <param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
            <param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.DescendentNodesAndTokens(Roslyn.Compilers.TextSpan,System.Func{Roslyn.Compilers.CSharp.SyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Gets a list of the descendent nodes and tokens in prefix document order.
            </summary>
            <param name="span">The span the node's full span must intersect.</param>
            <param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
            <param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.DescendentNodesAndTokensAndSelf(System.Func{Roslyn.Compilers.CSharp.SyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Gets a list of descendent nodes and tokens (including this node) in prefix document order.
            </summary>
            <param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
            <param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.DescendentNodesAndTokensAndSelf(Roslyn.Compilers.TextSpan,System.Func{Roslyn.Compilers.CSharp.SyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Gets a list of the descendent nodes and tokens (including this node) in prefix document order.
            </summary>
            <param name="span">The span the node's full span must intersect.</param>
            <param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
            <param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.GetFirstToken(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Gets the first token of the tree rooted by this node.
            </summary>
            <param name="includeSkipped">True if skipped tokens should be included, false by default.</param>
            <param name="includeDirectives">True if directives should be included, false by default.</param>
            <param name="includeDocumentationComments">True if documentation comments should be included, false by default.</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.GetFirstToken(System.Func{Roslyn.Compilers.CSharp.SyntaxToken,System.Boolean},System.Func{Roslyn.Compilers.CSharp.SyntaxTrivia,System.Boolean})">
            <summary>
            Gets the first token of the tree rooted by this node.
            </summary>
            <param name="predicate">Only tokens for which this predicate returns true are included.  Pass null to include
            all tokens.</param>
            <param name="stepInto">Steps into trivia if this is not null.  Only trivia for which this delegate returns
            true are included.</param> 
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.GetLastToken(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Gets the last non-zero-width token of the tree rooted by this node.
            </summary>
            <param name="includeSkipped">True if skipped tokens should be included, false by default.</param>
            <param name="includeDirectives">True if directives should be included, false by default.</param>
            <param name="includeDocumentationComments">True if documentation comments should be included, false by default.</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.GetLastToken(System.Func{Roslyn.Compilers.CSharp.SyntaxToken,System.Boolean},System.Func{Roslyn.Compilers.CSharp.SyntaxTrivia,System.Boolean})">
            <summary>
            Gets the last token of the tree rooted by this node.
            </summary>
            <param name="predicate"></param>
            <param name="stepInto"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.DescendentTokens(System.Func{Roslyn.Compilers.CSharp.SyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Gets a list of descendent tokens under this node.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.DescendentTokens(Roslyn.Compilers.TextSpan,System.Func{Roslyn.Compilers.CSharp.SyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Gets a list of descendent tokens under this node with a full span that intersects the specified span.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.FindToken(System.Int32,System.Func{Roslyn.Compilers.CSharp.SyntaxTrivia,System.Boolean})">
             <summary>
            Finds a token according to the following rules:
            1)	If position matches the End of the node/s FullSpan and the node is CompilationUnit, then EoF is returned. 
             
            2)	If node.FullSpan.Contains(position) the token that contains given position is returned.
                 If stepInto is not Nothing, then structured trivia that satisfies the condition will also be visited during the search.
             
            3)	Otherwise an IndexOutOfRange is thrown
             </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.FindToken(System.Int32,System.Boolean)">
             <summary>
            Finds a token according to the following rules:
            1)	If position matches the End of the node/s FullSpan and the node is CompilationUnit, then EoF is returned. 
             
            2)	If node.FullSpan.Contains(position) then the token that contains given position is returned.
             
            3)	Otherwise an IndexOutOfRange is thrown
             </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.FindTrivia(System.Int32,System.Func{Roslyn.Compilers.CSharp.SyntaxTrivia,System.Boolean})">
            <summary>
            Finds a descendent trivia of this node at the specified position, where the position is within the span of the node.
            </summary>
            <param name="position">The character position of the trivia relative to the beginning of the file.</param>
            <param name="stepInto">Specifies a function that determines per trivia node, whether to descend into structured trivia of that node.</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.FindTrivia(System.Int32,System.Boolean)">
            <summary>
            Finds a descendent trivia of this node whose span includes the supplied position.
            </summary>
            <param name="position">The character position of the trivia relative to the beginning of the file.</param>
            <param name="findInsideTrivia">Whether to search inside structured trivia.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.DescendentTrivia(System.Func{Roslyn.Compilers.CSharp.SyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            A list of all trivia for all descendent tokens.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.DescendentTrivia(Roslyn.Compilers.TextSpan,System.Func{Roslyn.Compilers.CSharp.SyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            A list of all trivia for all descendent tokens.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.ChildNodesAndTokensCore">
            <summary>
            The list of child nodes and tokens of this node.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.EquivalentToCore(Roslyn.Compilers.Common.CommonSyntaxNode)">
            <summary>
            Determine if this node is structurally equivalent to another.
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxNode.Parent">
            <summary>
            The node that contains this node in its Children collection.
            </summary>        
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxNode.Kind">
            <summary>
            Gets the <see cref="T:Roslyn.Compilers.CSharp.SyntaxKind"/>  of the non-terminal.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxNode.Position">
            <summary>
            The character position of this node relative to the beginning of the file, not including leading and trailing trivia.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxNode.HasChildren">
            <summary>
            Determines whether this node has any child nodes or tokens. 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxNode.HasDirectives">
            <summary>
            Determines whether this node has any descendent preprocessor directives. 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxNode.HasDiagnostics">
            <summary>
            Determines whether this node or any of its descendent nodes, tokens or trivia have any diagnostics on them.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxNode.HasAnnotations">
            <summary>
            Determines whether this node or any of its descendent nodes, tokens or trivia have annotations on them
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxNode.HasLeadingTrivia">
            <summary>
            Determines whether this node has any leading trivia.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxNode.HasTrailingTrivia">
            <summary>
            Determines whether this node has any trailing trivia.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxNode.IsStructuredTrivia">
            <summary>
            Determines whether this node represents a structured trivia.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxNode.HasStructuredTrivia">
            <summary>
            Determines whether a descendent trivia of this node is structured.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxNode.IsMissing">
            <summary>
            Determines whether the node represents a language construct that was actually parsed from the source code. Missing nodes are
            generated by the parser in error scenarios to represent constructs that should have been present
            in the source code in order to compile successfully but were actually missing.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxNode.FullSpan">
            <summary>
            The absolute span of this node in characters, including its leading and trailing trivia.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxNode.Span">
            <summary>
            The absolute span of this node in characters, not including its leading and trailing trivia.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxNode.Width">
            <summary>
            The width of the node in characters, not including leading and trailing trivia.
            </summary>
            <remarks>
            The Width property returns the same value as Span.Length, but is somewhat more efficient.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxNode.FullWidth">
            <summary>
            The complete width of the node in characters, including leading and trailing trivia.
            </summary>
            <remarks>The FullWidth property returns the same value as FullSpan.Length, but is somewhat more
            efficient.</remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxNode.KindCore">
            <summary>
            An integer representing the language specific kind of node.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxNode.ParentCore">
            <summary>
            The node that holds this node in its Children collection.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AttributeTargetSpecifierSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AttributeTargetSpecifierSyntax.ColonToken">
            <summary>Gets the colon token.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxExtensions.IsPartOfStructuredTrivia(Roslyn.Compilers.CSharp.SyntaxNode)">
            <summary>
            Determines if the node is a descendant of a structured trivia.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxExtensions.IsPartOfStructuredTrivia(Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>
            Determines if the token is a descendant of a structured trivia.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxExtensions.IsPartOfStructuredTrivia(Roslyn.Compilers.CSharp.SyntaxTrivia)">
            <summary>
            Determines if the trivia is a descendant of a structured trivia.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxExtensions.ReplaceNode``2(``0,``1,``1)">
            <summary>
            Creates a new tree of nodes with the specified old node replaced with a new node.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <typeparam name="TNode">The type of the replaced node.</typeparam>
            <param name="root">The root node of the tree of nodes.</param>
            <param name="oldNode">The node to be replaced; a descendant of the root node.</param>
            <param name="newNode">The new node to use in the new tree in place of the old node.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxExtensions.ReplaceNodes``2(``0,System.Collections.Generic.IEnumerable{``1},System.Func{``1,``1,Roslyn.Compilers.CSharp.SyntaxNode})">
            <summary>
            Creates a new tree of nodes with the specified old node replaced with a new node.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <typeparam name="TNode">The type of the replaced node.</typeparam>
            <param name="root">The root node of the tree of nodes.</param>
            <param name="oldNodes">The nodes to be replaced; descendants of the root node.</param>
            <param name="computeReplacementNode">A function that computes a replacement node for the
            argument nodes. The first argument is the original node. The second argument is the same
            node rewritten with replaced descendents.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxExtensions.ReplaceToken``1(``0,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>
            Creates a new tree of nodes with the specified old token replaced with a new token.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <param name="root">The root node of the tree of nodes.</param>
            <param name="oldToken">The token to be replaced.</param>
            <param name="newToken">The new token to use in the new tree in place of the old
            token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxExtensions.ReplaceTokens``1(``0,System.Collections.Generic.IEnumerable{Roslyn.Compilers.CSharp.SyntaxToken},System.Func{Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken})">
            <summary>
            Creates a new tree of nodes with the specified old node replaced with a new node.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <param name="root">The root node of the tree of nodes.</param>
            <param name="oldTokens">The token to be replaced; descendants of the root node.</param>
            <param name="computeReplacementToken">A function that computes a replacement token for
            the argument tokens. The first argument is the original token. The second argument is
            the same token rewritten with replaced trivia.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxExtensions.ReplaceTrivia``1(``0,Roslyn.Compilers.CSharp.SyntaxTrivia,Roslyn.Compilers.CSharp.SyntaxTriviaList)">
            <summary>
            Creates a new tree of nodes with the specified old trivia replaced with a new trivia
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <param name="root">The root node of the tree of nodes.</param>
            <param name="oldTrivia">The trivia to be replaced.</param>
            <param name="newTrivia">The new trivia to use in the new tree in place of the old
            trivia.</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxExtensions.ReplaceTrivia(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxTrivia,Roslyn.Compilers.CSharp.SyntaxTriviaList)">
            <summary>
            Creates a new token with the specified old trivia replaced with a new trivia. The old trivia may appear in
            the token's leading or trailing trivia.
            </summary>
            <param name="token">The original token.</param>
            <param name="oldTrivia">The trivia to be replaced.</param>
            <param name="newTrivia">The new trivia to use in the new tree in place of the old
            trivia.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxExtensions.ReplaceTrivia``1(``0,System.Collections.Generic.IEnumerable{Roslyn.Compilers.CSharp.SyntaxTrivia},System.Func{Roslyn.Compilers.CSharp.SyntaxTrivia,Roslyn.Compilers.CSharp.SyntaxTrivia,Roslyn.Compilers.CSharp.SyntaxTriviaList})">
            <summary>
            Creates a new tree of nodes with the specified old trivia replaced with computed new trivia.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <param name="root">The root node of the tree of nodes.</param>
            <param name="oldTrivia">The trivia to be replaced; descendants of the root node.</param>
            <param name="computeReplacementTrivia">A function that computes a replacement trivia for
            the argument trivia. The first argument is the original trivia. The second argument is
            the same trivia rewritten with replaced structure.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxExtensions.ReplaceTrivia(Roslyn.Compilers.CSharp.SyntaxToken,System.Collections.Generic.IEnumerable{Roslyn.Compilers.CSharp.SyntaxTrivia},System.Func{Roslyn.Compilers.CSharp.SyntaxTrivia,Roslyn.Compilers.CSharp.SyntaxTrivia,Roslyn.Compilers.CSharp.SyntaxTriviaList})">
            <summary>
            Creates a new token with the specified old trivia replaced with computed new trivia.
            </summary>
            <param name="token">The original token.</param>
            <param name="oldTrivia">The trivia to be replaced; descendants of the root token.</param>
            <param name="computeReplacementTrivia">A function that computes a replacement trivia for
            the argument trivia. The first argument is the original trivia. The second argument is
            the same trivia rewritten with replaced structure.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxExtensions.Format``1(``0,System.String,System.Boolean)">
            <summary>
            Creates a new syntax node with all whitespace and end of line trivia replaced with
            regularly formatted trivia.
            </summary>
            <typeparam name="TNode">The type of the node.</typeparam>
            <param name="node">The node to format.</param>
            <param name="indentation">An optional sequence of whitespace characters that defines a
            single level of indentation.</param>
            <param name="elasticTrivia">If true the replaced trivia is elastic trivia.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxExtensions.Format(Roslyn.Compilers.CSharp.SyntaxToken,System.String,System.Boolean)">
            <summary>
            Creates a new token with all whitespace and end of line trivia replaced with regularly
            formatted trivia.
            </summary>
            <param name="token">The token to format.</param>
            <param name="indentation">An optional sequence of whitespace characters that defines a
            single level of indentation.</param>
            <param name="elasticTrivia">If true the replaced trivia is elastic trivia.</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxExtensions.Format(Roslyn.Compilers.CSharp.SyntaxTriviaList,System.String,System.Boolean)">
            <summary>
            Creates a new list of trivia with all whitespace and end of line trivia replaced with
            regularly formatted trivia.
            </summary>
            <param name="trivia">The list of trivia.</param>
            <param name="indentation">An optional sequence of whitespace characters that defines a
            single level of indentation.</param>
            <param name="elasticTrivia"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxExtensions.IsControlledStatement(Roslyn.Compilers.CSharp.SyntaxNode)">
            <summary>
            Is this statement the controlled statement of its enclosing statement?
            </summary>
            <param name="statement"></param>
            <returns></returns>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.LanguageVersion">
            <summary>
            Specifies the language version.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.LanguageVersion.CSharp1">
            <summary>
            C# language version 1.0.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.LanguageVersion.CSharp2">
            <summary>
            C# language version 2.0.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.LanguageVersion.CSharp3">
            <summary>
            C# language version 3.0.
            </summary>
            <remarks> Features: LINQ.
            </remarks>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.LanguageVersion.CSharp4">
            <summary>
            C# language version 4.0.
            </summary>
            <remarks> Features: dynamic.
            </remarks>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.LanguageVersion.CSharp5">
            <summary>
            C# language version 5.0.
            </summary>
            <remarks> Features: async.
            </remarks>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.LanguageVersion.CSharp6">
            <summary> C# language version 6.0.
            </summary>
             <remarks>
             Features: using of a static class.
             </remarks>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SourceLocationWithAssociatedNode">
            <summary>
            A program location in source code for which there is an associated SyntaxNode.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SourceLocation">
            <summary>
            A program location in source code.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Location">
            <summary>
            Represents a location in source code or metadata. Used for the location of diagnostics and symbols in metadata
            and source.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Location.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serializes the location.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Location.GetLineSpan(System.Boolean)">
            <summary>
            Gets the location in terms of file name/line/column.  However, the file is actually whatever was passed in
            when asked to parse; there may not really be a file.
            </summary>
            <param name="usePreprocessorDirectives">
            If true, the filename/line/column
            reported takes into account #line directives. If false, #line directives
            are ignored.
            </param>
            <returns>
            <see cref="T:Roslyn.Compilers.FileLinePositionSpan"/> that contains file, line and column information. 
            Returns an invalid span (see <see cref="P:Roslyn.Compilers.FileLinePositionSpan.IsValid"/>) if the information is not available.
            </returns>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Location.Kind">
            <summary>
            The location kind such as metadata or source.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Location.InSource">
            <summary>
            Indicates if the location refers to a particular place in source code.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Location.InMetadata">
            <summary>
            Indicates if the location refers to metadata.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Location.SourceSpan">
            <summary>
            The abstract location in terms of a start and length, but the referent could be a parsed string, text from a
            tools editor buffer, or whatever.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Location.SourceTree">
            <summary>
            The syntax tree in which this location occurs.  This is null if the tree is not available.
            </summary>
            <remarks>
            Might return null even if <see cref="P:Roslyn.Compilers.CSharp.Location.InSource"/> returns true. The tree might not be available anymore, 
            for example, if the location is serialized and deserialized.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Location.MetadataModule">
            <summary>
            Returns the metadata module the error is associated with or null if the module is not available.
            </summary>
            <remarks>
            Might return null even if <see cref="P:Roslyn.Compilers.CSharp.Location.InMetadata"/> returns true. The module symbol might not be available anymore, 
            for example, if the location is serialized and deserialized.
            </remarks>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ParseOptions">
            <summary>
            This class stores several source parsing related options and offers access to their values.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.ParseOptions.Default">
            <summary>
            The default parse options.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ParseOptions.#ctor(Roslyn.Compilers.CSharp.CompatibilityMode,Roslyn.Compilers.CSharp.LanguageVersion,System.Collections.Generic.IEnumerable{System.String},System.Boolean,Roslyn.Compilers.SourceCodeKind)">
            <summary>
            Initializes a new instance of the <see cref="T:Roslyn.Compilers.CSharp.ParseOptions"/> class.
            </summary>
            <param name="compatibility">The compatibility mode.</param>
            <param name="languageVersion">The language version.</param>
            <param name="preprocessorSymbols">The defined preprocessor symbols.</param>
            <param name="suppressDocumentationCommentParse">if set to <c>true</c> documentation comment parsing will be
            skipped.</param>
            <param name="kind">The source kind.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ParseOptions.Copy(System.Nullable{Roslyn.Compilers.CSharp.CompatibilityMode},System.Nullable{Roslyn.Compilers.CSharp.LanguageVersion},System.Collections.Generic.IEnumerable{System.String},System.Nullable{System.Boolean},System.Nullable{Roslyn.Compilers.SourceCodeKind})">
            <summary>
            Creates a copy of this instance of <see cref="T:Roslyn.Compilers.CSharp.ParseOptions"/>. Options can be overridden by passing non null
            options to this method.
            </summary>
            <param name="compatibility">The compatibility mode.</param>
            <param name="languageVersion">The language version.</param>
            <param name="preprocessorSymbols">The defined preprocessor symbols.</param>
            <param name="suppressDocumentationCommentParse">Whether to suppress parsing documentation comments or
            not.</param>
            <param name="kind">The source code kind.</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ParseOptions.GetOptionNames">
            <summary>
            Gets the names of all the options represented by this collection of options.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ParseOptions.HasOption(System.String)">
            <summary>
            Determines if this collection of options represents the named option.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ParseOptions.GetOption(System.String)">
            <summary>
            Gets the value of a particular named option.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ParseOptions.SetOption(System.String,System.String)">
            <summary>
            Creates a copy of this collection of options, with a given option set to a given value.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParseOptions.Compatibility">
            <summary>
            Gets the compatibility mode.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParseOptions.LanguageVersion">
            <summary>
            Gets the language version.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParseOptions.PreprocessorSymbols">
            <summary>
            Gets the preprocessor symbols.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParseOptions.SuppressDocumentationCommentParse">
            <summary>
            Gets a value indicating whether the documentation comment parsing is skipped.
            </summary>
            <value>
            	<c>true</c> if documentation comment parsing is skipped; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParseOptions.Kind">
            <summary>
            Gets the kind of the source code being parsed.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParseOptions.Roslyn#Compilers#Common#IParseOptions#Kind">
            <summary>
            Gets the kind of the source code being parsed.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.InternalSyntax.Blender.newPosition">
            <summary>
            newPosition represents the position we are in the final IText.  As we consume and reuse
            nodes from the old tree we will update our position in the new text accordingly.
            Likewise, when we must lex tokens out of the new tree we will update as well.
            
            NOTE(cyrusn): We do not need an oldPosition because it is redundant given the
            oldTreeCursor.  The oldPosition is implicitly defined by the position of the cursor.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.InternalSyntax.Blender.ExtendToAffectedRange(Roslyn.Compilers.CSharp.SyntaxNode,Roslyn.Compilers.TextChangeRange)">
            <summary>
            Affected range of a change is the range within which nodes can be affected by a change
            and cannot be reused. Because of lookahead effective range of a change is larger than
            the change itself.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.Blender.Cursor">
            <summary>
            THe cursor represents a location in the tree that we can move around to indicate where
            we are in the original tree as we're incrementally parsing.  When it is at a node or
            token, it can either move forward to that entity's next sibling.  It can also move down
            to a node's first child or first token.
            
            Once the cursor hits the end of file, it's done.  Note: the cursor will skip any other
            zero length nodes in the tree.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.LexerCache.IdentityDictionary`1">
            <summary>
            This is basically a hash-set of strings that is searchable by  
            strings, string sub ranges, character array ranges or string-builder.  
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.LexerCache.TextMap`1">
            <summary>
            This is basically a hash-set of strings that is searchable by  
            strings, string sub ranges, character array ranges or string-builder.  
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.InternalSyntax.SyntaxParser.AddSkippedSyntax(Roslyn.Compilers.CSharp.InternalSyntax.SyntaxToken,Roslyn.Compilers.CSharp.InternalSyntax.SyntaxNode,System.Boolean)">
            <summary>
            Converts skippedSyntax node into tokens and adds these as trivia on the target token.
            Also adds the first error (in depth-first preorder) found in the skipped syntax tree to the target token.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.InternalSyntax.SyntaxParser.FindOffset(Roslyn.Compilers.CSharp.InternalSyntax.SyntaxNode,Roslyn.Compilers.CSharp.InternalSyntax.SyntaxNode,System.Int32@)">
            <summary>
            This function searches for the given location node within the subtree rooted at root node. 
            If it finds it, the function computes the offset span of that child node within the root and returns true, 
            otherwise it returns false.
            </summary>
            <param name="root">Root node</param>
            <param name="location">Node to search in the subtree rooted at root node</param>
            <param name="offset">Offset of the location node within the subtree rooted at child</param>
            <returns></returns>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.SyntaxParser.IsInteractive">
            <summary>
            Interactive code - global statements, member declarations and expressions allowed.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.SyntaxParser.IsScript">
            <summary>
            Script - global statements and member declarations allowed, but not expressions.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MethodBodyCompiler.CompileSynthesizedExplicitImplementations(Roslyn.Compilers.CSharp.SourceNamedTypeSymbol)">
            <summary>
            In some circumstances (e.g. implicit implementation of an interface method by a non-virtual method in a 
            base type from another assembly) it is necessary for the compiler to generate explicit implementations for
            some interface methods.  They don't go in the symbol table, but if we are emitting, then we should
            generate code for them.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MethodBodyCompiler.HasThisConstructorInitializer(Roslyn.Compilers.CSharp.MethodSymbol)">
            <summary>
            Returns true if the method is a constructor and has a this() constructor initializer.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MethodBodyCompiler.ConstructSynthesizedExplicitImplementationBody(Roslyn.Compilers.CSharp.SynthesizedExplicitImplementationMethod)">
            <summary>
            Given a SynthesizedExplicitImplementationMethod (effectively a tuple (interface method, implementing method, implementing type)),
            construct a BoundBlock body.  Consider the tuple (Interface.Foo, Base.Foo, Derived).  The generated method will look like:
            
            R Interface.Foo&lt;T1, T2, ...&gt;(A1 a1, A2 a2, ...)
            {
                //don't return the output if the return type is void
                return this.Foo&lt;T1, T2, ...&gt;(a1, a2, ...);
            }
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MethodBodyCompiler.ConstructSynthesizedSealedAccessorBody(Roslyn.Compilers.CSharp.SynthesizedSealedPropertyAccessor)">
            <summary>
            Given a SynthesizedSealedPropertyAccessor (an accessor with a reference to the accessor it overrides),
            construct a BoundBlock body.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MethodBodyCompiler.ConstructSingleInvocationMethodBody(Roslyn.Compilers.CSharp.MethodSymbol,Roslyn.Compilers.CSharp.MethodSymbol,System.Boolean)">
            <summary>
            Construct a body for a method containing a call to a single other method with the same signature (modulo name).
            </summary>
            <param name="implementedMethod">Method for which to construct body.</param>
            <param name="methodToInvoke">Method to invoke in constructed body.</param>
            <param name="useBaseReference">True for "base.", false for "this.".</param>
            <returns>Body for implementedMethod.</returns>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Accessibility">
            <summary>
            Represents the accessibility of a symbol. Note: This enum is ordered by effective
            accessibility.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Accessibility.NotApplicable">
            <summary>
            Indicates that accessibility is not applicable to this kind of symbol.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Accessibility.ProtectedAndInternal">
            <summary>
            Not supported in C#, but should be supported for symbols imported from reference
            assemblies in other languages.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.VarianceSafety">
            <summary>
            This class groups together all of the functionality needed to check for error CS1961, ERR_UnexpectedVariance.
            Its functionality is accessible through the NamedTypeSymbol extension method CheckInterfaceVarianceSafety and
            the MethodSymbol extension method CheckMethodVarianceSafety (for checking delegate Invoke).
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.VarianceSafety.CheckInterfaceVarianceSafety(Roslyn.Compilers.CSharp.NamedTypeSymbol,Roslyn.Compilers.DiagnosticBag,System.Threading.CancellationToken)">
            <summary>
            Accumulate diagnostics related to the variance safety of an interface.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.VarianceSafety.CheckMethodVarianceSafety(Roslyn.Compilers.CSharp.MethodSymbol,Roslyn.Compilers.DiagnosticBag,System.Threading.CancellationToken)">
            <summary>
            Accumulate diagnostics related to the variance safety of an interface method.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.VarianceSafety.CheckPropertyVarianceSafety(Roslyn.Compilers.CSharp.PropertySymbol,Roslyn.Compilers.DiagnosticBag,System.Threading.CancellationToken)">
            <summary>
            Accumulate diagnostics related to the variance safety of an interface property.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.VarianceSafety.CheckParametersVarianceSafety(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.ParameterSymbol},Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.DiagnosticBag,System.Threading.CancellationToken)">
            <summary>
            Accumulate diagnostics related to the variance safety of an interface method/property parameter.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.VarianceSafety.IsVarianceUnsafe(Roslyn.Compilers.CSharp.TypeSymbol,System.Boolean,System.Boolean,Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.DiagnosticBag,System.Threading.CancellationToken)">
            <summary>
            Returns true if the type is output-unsafe or input-unsafe, as defined in the C# spec.
            Roughly, a type is output-unsafe if it could not be the return type of a method and
            input-unsafe if it could not be a parameter type of a method.
            </summary>
            <remarks>
            This method is intended to match spec section 13.1.3.1 as closely as possible 
            (except that the output-unsafe and input-unsafe checks are merged).
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.VarianceSafety.IsVarianceUnsafe(Roslyn.Compilers.CSharp.NamedTypeSymbol,System.Boolean,System.Boolean,Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.DiagnosticBag,System.Threading.CancellationToken)">
            <summary>
            3) T is an interface or delegate type <![CDATA[S<A_1, ..., A_k>]]> constructed
            from a generic type <![CDATA[S<X_1, ..., X_k>]]> where for at least one A_i one
            of the following holds:
                a) X_i is covariant or invariant and A_i is output-unsafe [input-unsafe]
                b) X_i is contravariant or invariant and A_i is input-unsafe [output-unsafe] (note: spec has "input-safe", but it's a typo)
            </summary>
            <remarks>
            Slight rewrite to make it more idiomatic for C#:
                a) X_i is covariant and A_i is input-unsafe
                b) X_i is contravariant and A_i is output-unsafe
                c) X_i is invariant and A_i is input-unsafe or output-unsafe
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.VarianceSafety.AddVarianceError(Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.CSharp.TypeParameterSymbol,Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.CSharp.MessageID)">
            <summary>
            Add an ERR_UnexpectedVariance diagnostic to the diagnostic bag.
            </summary>
            <param name="diagnostics">Diagnostic bag.</param>
            <param name="unsafeTypeParameter">Type parameter that is not variance safe.</param>
            <param name="context">Context in which type is not variance safe (e.g. method).</param>
            <param name="expectedVariance">Desired variance of type.</param>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.AbstractTypeMap">
            <summary>
            Abstract base class for mutable and immutable type maps.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AbstractTypeMap.SubstituteMemberType(Roslyn.Compilers.CSharp.NamedTypeSymbol)">
            <summary>
            Substitute for a type declaration.  May use alpha renaming if the container is substituted.
            </summary>
            <param name="previous"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AbstractTypeMap.SubstituteNamedType(Roslyn.Compilers.CSharp.NamedTypeSymbol)">
            <summary>
            SubstType, but for NamedTypeSymbols only.  This is used for concrete types, so no alpha substitution appears in the result.
            </summary>
            <param name="previous"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AbstractTypeMap.SubstituteType(Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            Perform the substitution on the given type.  Each occurrence of the type parameter is
            replaced with its corresponding type argument from the map.
            </summary>
            <param name="previous">The type to be rewritten.</param>
            <returns>The type with type parameters replaced with the type arguments.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AbstractTypeMap.SubstituteTypes(System.Collections.Generic.IList{Roslyn.Compilers.CSharp.TypeSymbol})">
            <summary>
            Perform the substitution on every member of the list, returning a new list.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AbstractTypeMap.SubstituteNamedTypes(System.Collections.Generic.IEnumerable{Roslyn.Compilers.CSharp.NamedTypeSymbol})">
            <summary>
            Like SubstTypes, but for NamedTypeSymbols.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AbstractTypeMap.SubstituteNamedTypes(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.NamedTypeSymbol})">
            <summary>
            Like SubstTypes, but for NamedTypeSymbols.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.MutableTypeMap">
            <summary>
            Utility class for substituting actual type arguments for formal generic type parameters.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.OverriddenOrHiddenMembersResult`1">
            <summary>
            Groups the information computed by MakeOverriddenOrHiddenMembers.
            </summary>
            <typeparam name="T">Expected to be a member symbol type (e.g. method, property).</typeparam>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.LabelSymbol">
            <summary>
            Represents a label in method body
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LabelSymbol.Name">
            <summary>
            Gets the name of this label
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LabelSymbol.IsExtern">
            <summary>
            Returns false because label can't be defined externally.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LabelSymbol.IsSealed">
            <summary>
            Returns false because label can't be sealed.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LabelSymbol.IsAbstract">
            <summary>
            Returns false because label can't be abstract.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LabelSymbol.IsOverride">
            <summary>
            Returns false because label can't be overridden.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LabelSymbol.IsVirtual">
            <summary>
            Returns false because label can't be virtual.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LabelSymbol.IsStatic">
            <summary>
            Returns false because label can't be static.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LabelSymbol.DeclaredAccessibility">
            <summary>
            Returns 'NotApplicable' because label can't be used outside the member body.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LabelSymbol.Locations">
            <summary>
            Gets the locations where the symbol was originally defined, either in source or
            metadata. Some symbols (for example, partial classes) may be defined in more than one
            location.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LabelSymbol.ContainingMethod">
            <summary>
            Gets the immediately containing symbol of the <see cref="T:Roslyn.Compilers.CSharp.LabelSymbol"/>.
            It should be the <see cref="T:Roslyn.Compilers.CSharp.MethodSymbol"/> containing the label in its body.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LabelSymbol.ContainingSymbol">
            <summary>
            Gets the immediately containing symbol of the <see cref="T:Roslyn.Compilers.CSharp.LabelSymbol"/>.
            It should be the <see cref="T:Roslyn.Compilers.CSharp.MethodSymbol"/> containing the label in its body.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LabelSymbol.Kind">
            <summary>
            Returns value 'Label' of the <see cref="T:Roslyn.Compilers.CSharp.SymbolKind"/>
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Metadata.PE.MethodRefMetadataDecoder">
            <summary>
            This subclass of MetadataDecoder is specifically for finding
            method symbols corresponding to method MemberRefs.  The parent 
            implementation is unsuitable because it requires a PEMethodSymbol
            for context when decoding method type parameters and no such
            context is available because it is precisely what we are trying
            to find.  Since we know in advance that there will be no context
            and that signatures decoded with this class will only be used
            for comparison (when searching through the methods of a known
            TypeSymbol), we can return indexed type parameters instead.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Metadata.PE.MetadataDecoder">
            <summary>
            Helper class to resolve metadata tokens and signatures.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Metadata.PE.MetadataDecoder.moduleSymbol">
            <summary>
            ModuleSymbol for the module - source of metadata.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Metadata.PE.MetadataDecoder.typeContextOpt">
            <summary>
            Type context for resolving generic type arguments.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Metadata.PE.MetadataDecoder.methodContextOpt">
            <summary>
            Method context for resolving generic method type arguments.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Metadata.PE.MetadataDecoder.LookupTopLevelTypeDefSymbol(System.Int32,System.String,System.UInt16)">
            <summary>
            Lookup a type defined in referenced assembly.
            </summary>
            <param name="referencedAssemblyIndex"></param>
            <param name="emittedName"></param>
            <param name="arity"></param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Metadata.PE.MetadataDecoder.LookupTopLevelTypeDefSymbol(System.String,System.UInt16)">
            <summary>
            Lookup a type defined in this module.
            This method will be called only if the type we are
            looking for hasn't been loaded yet. Otherwise, MetadataDecoder
            would have found the type in TypeDefRowIdToTypeMap based on its 
            TypeDef row id. 
            </summary>
            <param name="emittedName"></param>
            <param name="arity"></param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Metadata.PE.MetadataDecoder.SubstituteTypeParameters(Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.CSharp.TypeSymbol[],System.Boolean[])">
            <summary>
            Produce constructed type symbol.
            </summary>
            <param name="genericTypeDef">
            Symbol for generic type.
            </param>
            <param name="arguments">
            Generic type arguments, including those for nesting types.
            </param>
            <param name="refersToNoPiaLocalType">
            Flags for arguments. Each item indicates whether corresponding argument refers to NoPia local types.
            </param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Metadata.PE.MetadataDecoder.SubstituteNoPiaLocalType(System.String,System.Boolean,Roslyn.Compilers.CSharp.TypeSymbol,System.String,System.String,System.String,Roslyn.Compilers.CSharp.AssemblySymbol,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.AssemblySymbol})">
            <summary>
            Find canonical type for NoPia embedded type.
            </summary>
            <param name="name"></param>
            <param name="isInterface"></param>
            <param name="baseType"></param>
            <param name="interfaceGuid"></param>
            <param name="scope"></param>
            <param name="identifier"></param>
            <param name="referringAssembly"></param>
            <param name="lookupIn"></param>
            <returns>
            Symbol for the canonical type or an ErrorTypeSymbol. Never returns null.
            </returns>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Metadata.PE.MetadataDecoder.IsOrClosedOverATypeFromAssembliesVisitor">
            <summary>
            Perform a check whether the type or at least one of its generic arguments 
            is defined in the specified assemblies. The check is performed recursively. 
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Metadata.PE.MethodRefMetadataDecoder.containingType">
            <summary>
            Type context for resolving generic type arguments.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Metadata.PE.MethodRefMetadataDecoder.GetGenericMethodTypeParamSymbol(System.Int32)">
            <summary>
            We know that we'll never have a method context because that's what we're
            trying to find.  Instead, just return an indexed type parameter that will
            make comparison easier.
            </summary>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Metadata.PE.MethodRefMetadataDecoder.GetGenericTypeParamSymbol(System.Int32)">
            <summary>
            This override changes two things:
                1) Return type arguments instead of type parameters.
                2) Handle non-PE types.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Metadata.PE.MethodRefMetadataDecoder.FindMethodBySignature(Roslyn.Compilers.CSharp.TypeSymbol,System.UInt32)">
            <summary>
            Search through the members of a given type symbol to find the method that matches a particular
            signature.
            </summary>
            <param name="targetTypeSymbol">Type containing the desired method symbol.</param>
            <param name="targetMemberRefToken">A MemberRef token that can be used to obtain the name and signature of the method</param>
            <returns>The matching method symbol, or null if the inputs do not correspond to a valid method.</returns>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.MethodKind">
            <summary>
            Represents the kind of a method.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MethodKind.Ordinary">
            <summary>
            A normal method.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MethodKind.Constructor">
            <summary>
            An instance constructor. The return type is always void.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MethodKind.StaticConstructor">
            <summary>
            A static constructor. The return type is always void.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MethodKind.Destructor">
            <summary>
            A destructor.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MethodKind.DelegateInvoke">
            <summary>
            The invoke method of a delegate.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MethodKind.Operator">
            <summary>
            A user-defined operator.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MethodKind.Conversion">
            <summary>
            A user-defined conversion.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MethodKind.PropertyGet">
            <summary>
            The implicitly-defined get method associated with a property.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MethodKind.PropertySet">
            <summary>
            The implicitly-defined set method associated with a property.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MethodKind.EventAdd">
            <summary>
            The implicitly-defined add method associated with an event.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MethodKind.EventRemove">
            <summary>
            The implicitly-defined remove method associated with an event.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MethodKind.ExplicitInterfaceImplementation">
            <summary>
            An explicit interface implementation method. The ImplementedMethods
            property can be used to determine which method is being implemented.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MethodKind.AnonymousFunction">
            <summary>
            An anonymous method or lambda expression
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SignatureOnlyParameterSymbol">
            <summary>
            Intended to be used to create ParameterSymbols for a SignatureOnlyMethodSymbol.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.PropertySymbolExtensions.GetBaseProperty(Roslyn.Compilers.CSharp.PropertySymbol)">
            <summary>
            If the property is overrides another, returns the base virtual property.
            Otherwise return the original property.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.PropertySymbolExtensions.GetOwnOrInheritedGetMethod(Roslyn.Compilers.CSharp.PropertySymbol)">
            <summary>
            If the property has a GetMethod, return that.  Otherwise check the overridden
            property, if any.  Repeat for each overridden property.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.PropertySymbolExtensions.GetOwnOrInheritedSetMethod(Roslyn.Compilers.CSharp.PropertySymbol)">
            <summary>
            If the property has a SetMethod, return that.  Otherwise check the overridden
            property, if any.  Repeat for each overridden property.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.PropertySymbol">
            <summary>
            Represents a property or indexer.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.PropertySymbol.MakeOverriddenOrHiddenMembers">
            <summary>
            Walk up the type hierarchy from ContainingType and list members that this
            property either overrides (accessible properties with the same name, if this
            property is declared "override") or hides (accessible non-property members 
            with the same name, plus properties that would be in the overrides list if
            this property is not declared "override").
            
            Properties in the overridden list may not be virtual or may have different
            accessibities, types, accessors, etc.  They are really candidates to be
            overridden.
            
            Members in the hidden list are definitely hidden.
            </summary>
            <remarks>
            In metadata, properties participate in overriding only through their accessors.
            That is, property accessors may implicitly or explicitly override other methods
            and a property can be considered to override another property if its accessors
            override those of the other property.
            This implementation (like Dev10) will not follow that approach.  Instead, it is
            based on spec section 10.7.5, which treats properties as entities in their own
            right.  If all property accessors have conventional names in metadata and nothing
            "unusual" is done with explicit overriding, this approach should produce the same
            results as an implementation based on accessor overriding.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.PropertySymbol.FindOverriddenOrHiddenMembersInType(System.Boolean,Roslyn.Compilers.CSharp.NamedTypeSymbol,Roslyn.Compilers.CSharp.NamedTypeSymbol,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.CSharp.PropertySymbol},Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.CSharp.Symbol})">
            <summary>
            Look for overridden or hidden members in a specific type.
            </summary>
            <param name="thisIsOverride">True if this property was declared "override".</param>
            <param name="thisContainingType">The type that contains this method (this.ContainingType).</param>
            <param name="currType">The type to search.</param>
            <param name="overriddenBuilder">Overridden members (properties with the same name) will be added to this builder.</param>
            <param name="hiddenBuilder">Hidden members (same name, different kind) will be added to this builder.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.PropertySymbol.Accept``2(Roslyn.Compilers.CSharp.SymbolVisitor{``0,``1},``0)">
            <summary>
            Implements visitor pattern.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.PropertySymbol.Equals(Roslyn.Compilers.CSharp.PropertySymbol)">
            <summary>
            Compares this symbol to another PropertySymbol.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.PropertySymbol.Type">
            <summary>
            The type of the property. 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.PropertySymbol.TypeCustomModifiers">
            <summary>
            The list of custom modifiers, if any, associated with the type of the property. 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.PropertySymbol.Parameters">
            <summary>
            The parameters of this property. If this property has no parameters, returns
            an empty list. Parameters are only present on indexers, or on some properties
            imported from a COM interface.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.PropertySymbol.IsIndexer">
            <summary>
            Returns whether the property is really an indexer.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.PropertySymbol.IsReadOnly">
            <summary>
            True if this is a read-only property; that is, a property with no set accessor.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.PropertySymbol.IsWriteOnly">
            <summary>
            True if this is a write-only property; that is, a property with no get accessor.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.PropertySymbol.GetMethod">
            <summary>
            The 'get' accessor of the property, or null if the property is write-only.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.PropertySymbol.SetMethod">
            <summary>
            The 'set' accessor of the property, or null if the property is read-only.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.PropertySymbol.OverriddenProperty">
            <summary>
            Returns the overridden property, or null.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.PropertySymbol.ExplicitInterfaceImplementations">
            <summary>
            Returns interface properties explicitly implemented by this property.
            </summary>
            <remarks>
            Properties imported from metadata can explicitly implement more than one property.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.PropertySymbol.Kind">
            <summary>
            Gets the kind of this symbol.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Retargeting.RetargetingPropertySymbol.retargetingModule">
            <summary>
            Owning RetargetingModuleSymbol.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Retargeting.RetargetingPropertySymbol.underlyingProperty">
            <summary>
            The underlying PropertySymbol, cannot be another RetargetingPropertySymbol.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.MethodSignatureComparer">
            <summary>
            C#4 10.6: The name, the type parameter list and the formal parameter list of a method define
            the signature (§3.6) of the method. Specifically, the signature of a method consists of its
            name, the number of type parameters and the number, modifiers, and types of its formal
            parameters. For these purposes, any type parameter of the method that occurs in the type of
            a formal parameter is identified not by its name, but by its ordinal position in the type
            argument list of the method. The return type is not part of a method’s signature, nor are
            the names of the type parameters or the formal parameters.
            
            C#4 3.6: For the purposes of signatures, the types object and dynamic are considered the
            same. 
            
            C#4 3.6: We implement the rules for ref/out by mapping both to ref.  The caller (i.e.
            checking for proper overrides or partial methods, etc) should check that ref/out are
            consistent.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MethodSignatureComparer.ExplicitMethodImplementationComparer">
            <summary>
            This instance is used when trying to determine if one method explicitly implements another,
            according the C# definition.
            The method signatures are compared without regard to name (including the interface part, if any)
            and the return types must match.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MethodSignatureComparer.CSharpImplicitMethodImplementationComparer">
            <summary>
            This instance is used when trying to determine if one method implicitly implements another,
            according to the C# definition.
            The method signatures, type constraints, and return types must match.  Custom modifiers are ignored.
            </summary>
            <remarks>
            One would expect this comparer to have requireSourceMethod = true, but it doesn't because (for source types)
            we allow inexact matching of custom modifiers when computing implicit method implementations.  Consider the
            following scenario: interface I has a method M with custom modifiers C1, source type ST includes I in its
            interface list but has no method M, and metadata type MT has a method M with custom modifiers C2.
            In this scenario, we want to compare I.M to MT.M without regard to custom modifiers, because if C1 != C2,
            we can just synthesize an explicit implementation of I.M in ST that calls MT.M.
            </remarks>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MethodSignatureComparer.CSharpCloseImplicitMethodImplementationComparer">
            <summary>
            This instance is used as a fallback when it is determined that one method does not implicitly implement
            another.  It applies a looser check to determine whether the proposed implementation should be reported
            as "close".
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MethodSignatureComparer.DuplicateSourceMethodComparer">
            <summary>
            This instance is used to determine if two C# methods declared in source have the same signature.
            Names, arities, and parameter types are considered.
            Return types, type parameter contraints, custom modifiers, and parameter ref kinds, etc are ignored.
            </summary>
            <remarks>
            This does the same comparison that MethodSignature used to do.
            </remarks>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MethodSignatureComparer.CSharpMethodOverrideComparer">
            <summary>
            This instance is used to check whether one method overrides another, according to the C# definition.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MethodSignatureComparer.CSharpAccessorOverrideComparer">
            <summary>
            This instance is used to check whether one property or event overrides another, according to the C# definition.
            NOTE: C# ignores accessor method names.
            CAVEAT: considers return types so that getters and setters will be treated the same.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MethodSignatureComparer.CSharpCustomModifierMethodOverrideComparer">
            <summary>
            Same as CSharpMethodOverrideComparer except that it pays attention to custom modifiers.  
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MethodSignatureComparer.RuntimeMethodSignatureComparer">
            <summary>
            This instance is intended to reflect the definition of signature equality used by the runtime (ECMA 335 Section 8.6.1.6).
            It considers return type, name, parameters, calling convention, and custom modifiers, but ignores
            the difference between RefKind.Out and RefKind.Ref.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MethodSignatureComparer.RuntimeImplicitMethodImplementationComparer">
            <summary>
            This instance is the same as RuntimeMethodSignatureComparer, except that it also considers
            type constraints (as required by the C# definition of implicit method implementation).
            CONSIDER: just use RuntimeMethodSignatureComparer?
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MethodSignatureComparer.CSharpSignatureAndConstraintsAndReturnTypeComparer">
            <summary>
            This instance is used to search for methods that have the same signature, return type, and constraints
            according to the C# definition.  Custom modifiers are ignored.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MethodSignatureComparer.RetargetedExplicitMethodImplementationComparer">
            <summary>
            This instance is used to search for methods that have identical signatures in every regard.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SignatureOnlyMethodSymbol">
            <summary>
            A representation of a method symbol that is intended only to be used for comparison purposes
            (esp in MethodSignatureComparer).
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SourceLabelSymbol.Name">
            <summary>
            Gets the name of the local variable.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SynthesizedEnumConstantSymbol">
            <summary>
            A compiler generated field for an enum constant.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SynthesizedExplicitImplementationMethod">
            <summary>
            When C# interface implementation differs from CLR interface implementation,
            we insert a synthesized explicit interface implementation that delegates
            to the method that C# considers an implicit implementation.
            There are two key scenarios for this:
            1) A single source method is implicitly implementing one or more interface
               methods from metadata and the interface methods have different custom
               modifiers.  In this case, we explicitly implement the interface methods
               and have (all) implementations delegate to the source method.
            2) A non-virtual, non-source method in a base type is implicitly implementing
               an interface method.  Since we can't change the "virtualness" of the 
               non-source method, we introduce an explicit implementation that delegates
               to it instead.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.SourceMemberMethodSymbol.partialImplementation">
            <summary>
            If this is a partial method, its implementation (if any).  This should be set, if at all, before this
            symbol appears among the members of its owner.  The "partial implementation" is not listed among the
            "members" of the enclosing type as a separate member.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceMemberMethodSymbol.FindExplicitImplementationCollisions(Roslyn.Compilers.CSharp.MethodSymbol,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Given a method, look for other members contained in the same type with signatures that will
            not be distinguishable by the runtime.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SourcePropertyAccessorSymbol.LocalAccessibility">
            <summary>
            Return Accessibility declared locally on the accessor, or
            NotApplicable if no accessibility was declared explicitly.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SymbolKind">
            <summary>
            Represents the different kinds of symbol.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.TempLocalSymbol">
            <summary>
            TempLocalSymbol is special kind of LocalSymbol that can have ref kind.
            
            The semantics of LHS ByRef local is roughly the same as of a ByRef argument
               EmitAssignment will do EmitAddress for RHS and then assign.
                                                
            The semantics of RHS ByRef local is roughly the same as of a ByRef parameter
               EmitExpression   will load the value which local is refering to.
               EmitAddress      will load the actual local.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.LookupOptions">
            <summary>
            Options that can be used to modify the symbol lookup mechanism. 
            </summary>
            <remarks>
            Multiple options can be combined together.  LookupOptions.AreValid checks for valid combinations.
            </remarks>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.LookupOptions.Default">
            <summary>
            Consider all symbols, using normal accessibility rules.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.LookupOptions.NamespaceAliasesOnly">
            <summary>
            Consider only namespace aliases and extern aliases.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.LookupOptions.NamespacesOrTypesOnly">
            <summary>
            Consider only namespaces and types.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.LookupOptions.MustBeInvocableMember">
            <summary>
            Only  consider symbols that are invocable members.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.LookupOptions.MustBeInstance">
            <summary>
            Consider only symbols that are instance members.
            Valid with IncludeExtensionMethods since extension
            methods are invoked on an instance.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.LookupOptions.MustNotBeInstance">
            <summary>
            Do not consider symbols that are instance members.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.LookupOptions.MustNotBeNamespace">
            <summary>
            Do not consider symbols that are namespaces.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.LookupOptions.IgnoreAccessibility">
            <summary>
            Ignore accessibility checking when determining if a symbol is a match.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.LookupOptions.AllMethodsOnArityZero">
            <summary>
            Consider methods of any arity when arity zero is specified. Because type parameters can be inferred, it is
            often desired to consider generic methods when no type arguments were present.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.LookupOptions.LabelsOnly">
            <summary>
            Look only for label symbols.  This must be exclusive of all other options.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.LookupOptions.UseBaseReferenceAccessibility">
            <summary>
            Usually, when determining if a member is accessible, both the type of the receiver
            and the type containing the access are used.  If this flag is specified, then only
            the containing type will be used (i.e. as if you've written base.XX).
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.LookupOptions.IncludeExtensionMethods">
            <summary>
            Include extension methods.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LookupOptionExtensions.AreValid(Roslyn.Compilers.CSharp.LookupOptions)">
            <summary>
            Are these options valid in their current combination?
            </summary>
            <remarks>
            Some checks made here:
            
            - Default is valid.
            - If LabelsOnly is set, it must be the only option.
            - If one of MustBeInstance or MustNotBeInstance are set, the other one must not be set.
            - If any of MustNotBeInstance, MustBeInstance, or MustNotBeNonInvocableMember are set,
              the options are considered valid.
            - Otherwise, only one of NamespaceAliasesOnly, NamespacesOrTypesOnly, or AllMethodsOnArityZero must be set.
            </remarks>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.AccessCheck">
            <summary>
            Contains the code for determining C# accessibility rules.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AccessCheck.IsSymbolAccessible(Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.CSharp.AssemblySymbol)">
            <summary>
            Checks if 'symbol' is accessible from within assembly 'within'.  
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AccessCheck.IsSymbolAccessible(Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.CSharp.NamedTypeSymbol,Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            Checks if 'symbol' is accessible from within type 'within', with
            an optional qualifier of type "throughTypeOpt".
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AccessCheck.IsSymbolAccessible(Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.CSharp.NamedTypeSymbol,Roslyn.Compilers.CSharp.TypeSymbol,System.Boolean@,Roslyn.Compilers.ConsList{Roslyn.Compilers.CSharp.Symbol})">
            <summary>
            Checks if 'symbol' is accessible from within type 'within', with
            an qualifier of type "throughTypeOpt". Sets "failedThroughTypeCheck" to true
            if it failed the "through type" check.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AccessCheck.IsSymbolAccessibleCore(Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.CSharp.TypeSymbol,System.Boolean@,Roslyn.Compilers.CSharp.Compilation,Roslyn.Compilers.ConsList{Roslyn.Compilers.CSharp.Symbol})">
            <summary>
            Checks if 'symbol' is accessible from within 'within', which must be a NamedTypeSymbol or 
            an AssemblySymbol. 
            
            Note that NamedTypeSymbol, if available, is the type that is associated with the binder 
            that found the 'symbol', not the inner-most type that contains the access to the 'symbol'.
            
            If 'symbol' is accessed off of an expression then 'throughTypeOpt' is the type of that expression. 
            This is needed to properly do protected access checks. Sets "failedThroughTypeCheck" to true 
            if this protected check failed.
            
            NOTE(cyrusn): I expect this function to be called a lot.  As such, i do not do any memory
            allocations in the function itself (including not making any iterators).  This does mean
            that certain helper functions that we'd like to call are inlined in this method to
            prevent the overhead of returning collections or enumerators.  
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SyntaxVisitor`1">
            <summary>
            Represents a <see cref="T:Roslyn.Compilers.CSharp.SyntaxNode"/> visitor that visits only the single SyntaxNode
            passed into its <see cref="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.Visit(Roslyn.Compilers.CSharp.SyntaxNode)"/> method and produces 
            a value of the type specified by the <typeparamref name="TResult"/> parameter.
            </summary>
            <typeparam name="TResult">
            The type of the return value this visitor's Visit method.
            </typeparam>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitIdentifierName(Roslyn.Compilers.CSharp.IdentifierNameSyntax)">
            <summary>Called when the visitor visits a IdentifierNameSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitQualifiedName(Roslyn.Compilers.CSharp.QualifiedNameSyntax)">
            <summary>Called when the visitor visits a QualifiedNameSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitGenericName(Roslyn.Compilers.CSharp.GenericNameSyntax)">
            <summary>Called when the visitor visits a GenericNameSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitTypeArgumentList(Roslyn.Compilers.CSharp.TypeArgumentListSyntax)">
            <summary>Called when the visitor visits a TypeArgumentListSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitAliasQualifiedName(Roslyn.Compilers.CSharp.AliasQualifiedNameSyntax)">
            <summary>Called when the visitor visits a AliasQualifiedNameSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitPredefinedType(Roslyn.Compilers.CSharp.PredefinedTypeSyntax)">
            <summary>Called when the visitor visits a PredefinedTypeSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitArrayType(Roslyn.Compilers.CSharp.ArrayTypeSyntax)">
            <summary>Called when the visitor visits a ArrayTypeSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitArrayRankSpecifier(Roslyn.Compilers.CSharp.ArrayRankSpecifierSyntax)">
            <summary>Called when the visitor visits a ArrayRankSpecifierSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitPointerType(Roslyn.Compilers.CSharp.PointerTypeSyntax)">
            <summary>Called when the visitor visits a PointerTypeSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitNullableType(Roslyn.Compilers.CSharp.NullableTypeSyntax)">
            <summary>Called when the visitor visits a NullableTypeSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitParenthesizedExpression(Roslyn.Compilers.CSharp.ParenthesizedExpressionSyntax)">
            <summary>Called when the visitor visits a ParenthesizedExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitPrefixUnaryExpression(Roslyn.Compilers.CSharp.PrefixUnaryExpressionSyntax)">
            <summary>Called when the visitor visits a PrefixUnaryExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitPostfixUnaryExpression(Roslyn.Compilers.CSharp.PostfixUnaryExpressionSyntax)">
            <summary>Called when the visitor visits a PostfixUnaryExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitMemberAccessExpression(Roslyn.Compilers.CSharp.MemberAccessExpressionSyntax)">
            <summary>Called when the visitor visits a MemberAccessExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitBinaryExpression(Roslyn.Compilers.CSharp.BinaryExpressionSyntax)">
            <summary>Called when the visitor visits a BinaryExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitConditionalExpression(Roslyn.Compilers.CSharp.ConditionalExpressionSyntax)">
            <summary>Called when the visitor visits a ConditionalExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitThisExpression(Roslyn.Compilers.CSharp.ThisExpressionSyntax)">
            <summary>Called when the visitor visits a ThisExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitBaseExpression(Roslyn.Compilers.CSharp.BaseExpressionSyntax)">
            <summary>Called when the visitor visits a BaseExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitLiteralExpression(Roslyn.Compilers.CSharp.LiteralExpressionSyntax)">
            <summary>Called when the visitor visits a LiteralExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitMakeRefExpression(Roslyn.Compilers.CSharp.MakeRefExpressionSyntax)">
            <summary>Called when the visitor visits a MakeRefExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitRefTypeExpression(Roslyn.Compilers.CSharp.RefTypeExpressionSyntax)">
            <summary>Called when the visitor visits a RefTypeExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitRefValueExpression(Roslyn.Compilers.CSharp.RefValueExpressionSyntax)">
            <summary>Called when the visitor visits a RefValueExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitCheckedExpression(Roslyn.Compilers.CSharp.CheckedExpressionSyntax)">
            <summary>Called when the visitor visits a CheckedExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitDefaultExpression(Roslyn.Compilers.CSharp.DefaultExpressionSyntax)">
            <summary>Called when the visitor visits a DefaultExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitTypeOfExpression(Roslyn.Compilers.CSharp.TypeOfExpressionSyntax)">
            <summary>Called when the visitor visits a TypeOfExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitSizeOfExpression(Roslyn.Compilers.CSharp.SizeOfExpressionSyntax)">
            <summary>Called when the visitor visits a SizeOfExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitInvocationExpression(Roslyn.Compilers.CSharp.InvocationExpressionSyntax)">
            <summary>Called when the visitor visits a InvocationExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitElementAccessExpression(Roslyn.Compilers.CSharp.ElementAccessExpressionSyntax)">
            <summary>Called when the visitor visits a ElementAccessExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitArgumentList(Roslyn.Compilers.CSharp.ArgumentListSyntax)">
            <summary>Called when the visitor visits a ArgumentListSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitBracketedArgumentList(Roslyn.Compilers.CSharp.BracketedArgumentListSyntax)">
            <summary>Called when the visitor visits a BracketedArgumentListSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitArgument(Roslyn.Compilers.CSharp.ArgumentSyntax)">
            <summary>Called when the visitor visits a ArgumentSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitNameColon(Roslyn.Compilers.CSharp.NameColonSyntax)">
            <summary>Called when the visitor visits a NameColonSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitCastExpression(Roslyn.Compilers.CSharp.CastExpressionSyntax)">
            <summary>Called when the visitor visits a CastExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitAnonymousMethodExpression(Roslyn.Compilers.CSharp.AnonymousMethodExpressionSyntax)">
            <summary>Called when the visitor visits a AnonymousMethodExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitSimpleLambdaExpression(Roslyn.Compilers.CSharp.SimpleLambdaExpressionSyntax)">
            <summary>Called when the visitor visits a SimpleLambdaExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitParenthesizedLambdaExpression(Roslyn.Compilers.CSharp.ParenthesizedLambdaExpressionSyntax)">
            <summary>Called when the visitor visits a ParenthesizedLambdaExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitInitializerExpression(Roslyn.Compilers.CSharp.InitializerExpressionSyntax)">
            <summary>Called when the visitor visits a InitializerExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitObjectCreationExpression(Roslyn.Compilers.CSharp.ObjectCreationExpressionSyntax)">
            <summary>Called when the visitor visits a ObjectCreationExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitAnonymousObjectCreationExpression(Roslyn.Compilers.CSharp.AnonymousObjectCreationExpressionSyntax)">
            <summary>Called when the visitor visits a AnonymousObjectCreationExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitArrayCreationExpression(Roslyn.Compilers.CSharp.ArrayCreationExpressionSyntax)">
            <summary>Called when the visitor visits a ArrayCreationExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitImplicitArrayCreationExpression(Roslyn.Compilers.CSharp.ImplicitArrayCreationExpressionSyntax)">
            <summary>Called when the visitor visits a ImplicitArrayCreationExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitStackAllocArrayCreationExpression(Roslyn.Compilers.CSharp.StackAllocArrayCreationExpressionSyntax)">
            <summary>Called when the visitor visits a StackAllocArrayCreationExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitQueryExpression(Roslyn.Compilers.CSharp.QueryExpressionSyntax)">
            <summary>Called when the visitor visits a QueryExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitFromClause(Roslyn.Compilers.CSharp.FromClauseSyntax)">
            <summary>Called when the visitor visits a FromClauseSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitLetClause(Roslyn.Compilers.CSharp.LetClauseSyntax)">
            <summary>Called when the visitor visits a LetClauseSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitJoinClause(Roslyn.Compilers.CSharp.JoinClauseSyntax)">
            <summary>Called when the visitor visits a JoinClauseSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitJoinIntoClause(Roslyn.Compilers.CSharp.JoinIntoClauseSyntax)">
            <summary>Called when the visitor visits a JoinIntoClauseSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitWhereClause(Roslyn.Compilers.CSharp.WhereClauseSyntax)">
            <summary>Called when the visitor visits a WhereClauseSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitOrderByClause(Roslyn.Compilers.CSharp.OrderByClauseSyntax)">
            <summary>Called when the visitor visits a OrderByClauseSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitOrdering(Roslyn.Compilers.CSharp.OrderingSyntax)">
            <summary>Called when the visitor visits a OrderingSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitSelectClause(Roslyn.Compilers.CSharp.SelectClauseSyntax)">
            <summary>Called when the visitor visits a SelectClauseSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitGroupClause(Roslyn.Compilers.CSharp.GroupClauseSyntax)">
            <summary>Called when the visitor visits a GroupClauseSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitQueryContinuation(Roslyn.Compilers.CSharp.QueryContinuationSyntax)">
            <summary>Called when the visitor visits a QueryContinuationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitGlobalStatement(Roslyn.Compilers.CSharp.GlobalStatementSyntax)">
            <summary>Called when the visitor visits a GlobalStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitBlock(Roslyn.Compilers.CSharp.BlockSyntax)">
            <summary>Called when the visitor visits a BlockSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitLocalDeclarationStatement(Roslyn.Compilers.CSharp.LocalDeclarationStatementSyntax)">
            <summary>Called when the visitor visits a LocalDeclarationStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitVariableDeclaration(Roslyn.Compilers.CSharp.VariableDeclarationSyntax)">
            <summary>Called when the visitor visits a VariableDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitVariableDeclarator(Roslyn.Compilers.CSharp.VariableDeclaratorSyntax)">
            <summary>Called when the visitor visits a VariableDeclaratorSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitEqualsValueClause(Roslyn.Compilers.CSharp.EqualsValueClauseSyntax)">
            <summary>Called when the visitor visits a EqualsValueClauseSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitExpressionStatement(Roslyn.Compilers.CSharp.ExpressionStatementSyntax)">
            <summary>Called when the visitor visits a ExpressionStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitEmptyStatement(Roslyn.Compilers.CSharp.EmptyStatementSyntax)">
            <summary>Called when the visitor visits a EmptyStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitLabeledStatement(Roslyn.Compilers.CSharp.LabeledStatementSyntax)">
            <summary>Called when the visitor visits a LabeledStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitGotoStatement(Roslyn.Compilers.CSharp.GotoStatementSyntax)">
            <summary>Called when the visitor visits a GotoStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitBreakStatement(Roslyn.Compilers.CSharp.BreakStatementSyntax)">
            <summary>Called when the visitor visits a BreakStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitContinueStatement(Roslyn.Compilers.CSharp.ContinueStatementSyntax)">
            <summary>Called when the visitor visits a ContinueStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitReturnStatement(Roslyn.Compilers.CSharp.ReturnStatementSyntax)">
            <summary>Called when the visitor visits a ReturnStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitThrowStatement(Roslyn.Compilers.CSharp.ThrowStatementSyntax)">
            <summary>Called when the visitor visits a ThrowStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitYieldStatement(Roslyn.Compilers.CSharp.YieldStatementSyntax)">
            <summary>Called when the visitor visits a YieldStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitWhileStatement(Roslyn.Compilers.CSharp.WhileStatementSyntax)">
            <summary>Called when the visitor visits a WhileStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitDoStatement(Roslyn.Compilers.CSharp.DoStatementSyntax)">
            <summary>Called when the visitor visits a DoStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitForStatement(Roslyn.Compilers.CSharp.ForStatementSyntax)">
            <summary>Called when the visitor visits a ForStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitForEachStatement(Roslyn.Compilers.CSharp.ForEachStatementSyntax)">
            <summary>Called when the visitor visits a ForEachStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitUsingStatement(Roslyn.Compilers.CSharp.UsingStatementSyntax)">
            <summary>Called when the visitor visits a UsingStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitFixedStatement(Roslyn.Compilers.CSharp.FixedStatementSyntax)">
            <summary>Called when the visitor visits a FixedStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitCheckedStatement(Roslyn.Compilers.CSharp.CheckedStatementSyntax)">
            <summary>Called when the visitor visits a CheckedStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitUnsafeStatement(Roslyn.Compilers.CSharp.UnsafeStatementSyntax)">
            <summary>Called when the visitor visits a UnsafeStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitLockStatement(Roslyn.Compilers.CSharp.LockStatementSyntax)">
            <summary>Called when the visitor visits a LockStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitIfStatement(Roslyn.Compilers.CSharp.IfStatementSyntax)">
            <summary>Called when the visitor visits a IfStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitElseClause(Roslyn.Compilers.CSharp.ElseClauseSyntax)">
            <summary>Called when the visitor visits a ElseClauseSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitSwitchStatement(Roslyn.Compilers.CSharp.SwitchStatementSyntax)">
            <summary>Called when the visitor visits a SwitchStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitSwitchSection(Roslyn.Compilers.CSharp.SwitchSectionSyntax)">
            <summary>Called when the visitor visits a SwitchSectionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitSwitchLabel(Roslyn.Compilers.CSharp.SwitchLabelSyntax)">
            <summary>Called when the visitor visits a SwitchLabelSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitTryStatement(Roslyn.Compilers.CSharp.TryStatementSyntax)">
            <summary>Called when the visitor visits a TryStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitCatchClause(Roslyn.Compilers.CSharp.CatchClauseSyntax)">
            <summary>Called when the visitor visits a CatchClauseSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitCatchDeclaration(Roslyn.Compilers.CSharp.CatchDeclarationSyntax)">
            <summary>Called when the visitor visits a CatchDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitFinallyClause(Roslyn.Compilers.CSharp.FinallyClauseSyntax)">
            <summary>Called when the visitor visits a FinallyClauseSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitCompilationUnit(Roslyn.Compilers.CSharp.CompilationUnitSyntax)">
            <summary>Called when the visitor visits a CompilationUnitSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitExternAliasDirective(Roslyn.Compilers.CSharp.ExternAliasDirectiveSyntax)">
            <summary>Called when the visitor visits a ExternAliasDirectiveSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitUsingDirective(Roslyn.Compilers.CSharp.UsingDirectiveSyntax)">
            <summary>Called when the visitor visits a UsingDirectiveSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitNamespaceDeclaration(Roslyn.Compilers.CSharp.NamespaceDeclarationSyntax)">
            <summary>Called when the visitor visits a NamespaceDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitAttributeDeclaration(Roslyn.Compilers.CSharp.AttributeDeclarationSyntax)">
            <summary>Called when the visitor visits a AttributeDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitAttributeTargetSpecifier(Roslyn.Compilers.CSharp.AttributeTargetSpecifierSyntax)">
            <summary>Called when the visitor visits a AttributeTargetSpecifierSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitAttribute(Roslyn.Compilers.CSharp.AttributeSyntax)">
            <summary>Called when the visitor visits a AttributeSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitAttributeArgumentList(Roslyn.Compilers.CSharp.AttributeArgumentListSyntax)">
            <summary>Called when the visitor visits a AttributeArgumentListSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitAttributeArgument(Roslyn.Compilers.CSharp.AttributeArgumentSyntax)">
            <summary>Called when the visitor visits a AttributeArgumentSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitNameEquals(Roslyn.Compilers.CSharp.NameEqualsSyntax)">
            <summary>Called when the visitor visits a NameEqualsSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitTypeParameterList(Roslyn.Compilers.CSharp.TypeParameterListSyntax)">
            <summary>Called when the visitor visits a TypeParameterListSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitTypeParameter(Roslyn.Compilers.CSharp.TypeParameterSyntax)">
            <summary>Called when the visitor visits a TypeParameterSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitClassDeclaration(Roslyn.Compilers.CSharp.ClassDeclarationSyntax)">
            <summary>Called when the visitor visits a ClassDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitStructDeclaration(Roslyn.Compilers.CSharp.StructDeclarationSyntax)">
            <summary>Called when the visitor visits a StructDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitInterfaceDeclaration(Roslyn.Compilers.CSharp.InterfaceDeclarationSyntax)">
            <summary>Called when the visitor visits a InterfaceDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitEnumDeclaration(Roslyn.Compilers.CSharp.EnumDeclarationSyntax)">
            <summary>Called when the visitor visits a EnumDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitDelegateDeclaration(Roslyn.Compilers.CSharp.DelegateDeclarationSyntax)">
            <summary>Called when the visitor visits a DelegateDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitEnumMemberDeclaration(Roslyn.Compilers.CSharp.EnumMemberDeclarationSyntax)">
            <summary>Called when the visitor visits a EnumMemberDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitBaseList(Roslyn.Compilers.CSharp.BaseListSyntax)">
            <summary>Called when the visitor visits a BaseListSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitTypeParameterConstraintClause(Roslyn.Compilers.CSharp.TypeParameterConstraintClauseSyntax)">
            <summary>Called when the visitor visits a TypeParameterConstraintClauseSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitConstructorConstraint(Roslyn.Compilers.CSharp.ConstructorConstraintSyntax)">
            <summary>Called when the visitor visits a ConstructorConstraintSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitClassOrStructConstraint(Roslyn.Compilers.CSharp.ClassOrStructConstraintSyntax)">
            <summary>Called when the visitor visits a ClassOrStructConstraintSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitTypeConstraint(Roslyn.Compilers.CSharp.TypeConstraintSyntax)">
            <summary>Called when the visitor visits a TypeConstraintSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitFieldDeclaration(Roslyn.Compilers.CSharp.FieldDeclarationSyntax)">
            <summary>Called when the visitor visits a FieldDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitEventFieldDeclaration(Roslyn.Compilers.CSharp.EventFieldDeclarationSyntax)">
            <summary>Called when the visitor visits a EventFieldDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitExplicitInterfaceSpecifier(Roslyn.Compilers.CSharp.ExplicitInterfaceSpecifierSyntax)">
            <summary>Called when the visitor visits a ExplicitInterfaceSpecifierSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitMethodDeclaration(Roslyn.Compilers.CSharp.MethodDeclarationSyntax)">
            <summary>Called when the visitor visits a MethodDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitOperatorDeclaration(Roslyn.Compilers.CSharp.OperatorDeclarationSyntax)">
            <summary>Called when the visitor visits a OperatorDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitConversionOperatorDeclaration(Roslyn.Compilers.CSharp.ConversionOperatorDeclarationSyntax)">
            <summary>Called when the visitor visits a ConversionOperatorDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitConstructorDeclaration(Roslyn.Compilers.CSharp.ConstructorDeclarationSyntax)">
            <summary>Called when the visitor visits a ConstructorDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitConstructorInitializer(Roslyn.Compilers.CSharp.ConstructorInitializerSyntax)">
            <summary>Called when the visitor visits a ConstructorInitializerSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitDestructorDeclaration(Roslyn.Compilers.CSharp.DestructorDeclarationSyntax)">
            <summary>Called when the visitor visits a DestructorDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitPropertyDeclaration(Roslyn.Compilers.CSharp.PropertyDeclarationSyntax)">
            <summary>Called when the visitor visits a PropertyDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitEventDeclaration(Roslyn.Compilers.CSharp.EventDeclarationSyntax)">
            <summary>Called when the visitor visits a EventDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitIndexerDeclaration(Roslyn.Compilers.CSharp.IndexerDeclarationSyntax)">
            <summary>Called when the visitor visits a IndexerDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitAccessorList(Roslyn.Compilers.CSharp.AccessorListSyntax)">
            <summary>Called when the visitor visits a AccessorListSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitAccessorDeclaration(Roslyn.Compilers.CSharp.AccessorDeclarationSyntax)">
            <summary>Called when the visitor visits a AccessorDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitParameterList(Roslyn.Compilers.CSharp.ParameterListSyntax)">
            <summary>Called when the visitor visits a ParameterListSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitBracketedParameterList(Roslyn.Compilers.CSharp.BracketedParameterListSyntax)">
            <summary>Called when the visitor visits a BracketedParameterListSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitParameter(Roslyn.Compilers.CSharp.ParameterSyntax)">
            <summary>Called when the visitor visits a ParameterSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitIncompleteMember(Roslyn.Compilers.CSharp.IncompleteMemberSyntax)">
            <summary>Called when the visitor visits a IncompleteMemberSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitSkippedTokens(Roslyn.Compilers.CSharp.SkippedTokensSyntax)">
            <summary>Called when the visitor visits a SkippedTokensSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitDocumentationComment(Roslyn.Compilers.CSharp.DocumentationCommentSyntax)">
            <summary>Called when the visitor visits a DocumentationCommentSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitXmlElement(Roslyn.Compilers.CSharp.XmlElementSyntax)">
            <summary>Called when the visitor visits a XmlElementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitXmlElementStartTag(Roslyn.Compilers.CSharp.XmlElementStartTagSyntax)">
            <summary>Called when the visitor visits a XmlElementStartTagSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitXmlElementEndTag(Roslyn.Compilers.CSharp.XmlElementEndTagSyntax)">
            <summary>Called when the visitor visits a XmlElementEndTagSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitXmlEmptyElement(Roslyn.Compilers.CSharp.XmlEmptyElementSyntax)">
            <summary>Called when the visitor visits a XmlEmptyElementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitXmlName(Roslyn.Compilers.CSharp.XmlNameSyntax)">
            <summary>Called when the visitor visits a XmlNameSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitXmlPrefix(Roslyn.Compilers.CSharp.XmlPrefixSyntax)">
            <summary>Called when the visitor visits a XmlPrefixSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitXmlAttribute(Roslyn.Compilers.CSharp.XmlAttributeSyntax)">
            <summary>Called when the visitor visits a XmlAttributeSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitXmlText(Roslyn.Compilers.CSharp.XmlTextSyntax)">
            <summary>Called when the visitor visits a XmlTextSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitXmlCDataSection(Roslyn.Compilers.CSharp.XmlCDataSectionSyntax)">
            <summary>Called when the visitor visits a XmlCDataSectionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitXmlProcessingInstruction(Roslyn.Compilers.CSharp.XmlProcessingInstructionSyntax)">
            <summary>Called when the visitor visits a XmlProcessingInstructionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitXmlComment(Roslyn.Compilers.CSharp.XmlCommentSyntax)">
            <summary>Called when the visitor visits a XmlCommentSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitIfDirective(Roslyn.Compilers.CSharp.IfDirectiveSyntax)">
            <summary>Called when the visitor visits a IfDirectiveSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitElifDirective(Roslyn.Compilers.CSharp.ElifDirectiveSyntax)">
            <summary>Called when the visitor visits a ElifDirectiveSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitElseDirective(Roslyn.Compilers.CSharp.ElseDirectiveSyntax)">
            <summary>Called when the visitor visits a ElseDirectiveSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitEndIfDirective(Roslyn.Compilers.CSharp.EndIfDirectiveSyntax)">
            <summary>Called when the visitor visits a EndIfDirectiveSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitRegionDirective(Roslyn.Compilers.CSharp.RegionDirectiveSyntax)">
            <summary>Called when the visitor visits a RegionDirectiveSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitEndRegionDirective(Roslyn.Compilers.CSharp.EndRegionDirectiveSyntax)">
            <summary>Called when the visitor visits a EndRegionDirectiveSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitErrorDirective(Roslyn.Compilers.CSharp.ErrorDirectiveSyntax)">
            <summary>Called when the visitor visits a ErrorDirectiveSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitWarningDirective(Roslyn.Compilers.CSharp.WarningDirectiveSyntax)">
            <summary>Called when the visitor visits a WarningDirectiveSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitBadDirective(Roslyn.Compilers.CSharp.BadDirectiveSyntax)">
            <summary>Called when the visitor visits a BadDirectiveSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitDefineDirective(Roslyn.Compilers.CSharp.DefineDirectiveSyntax)">
            <summary>Called when the visitor visits a DefineDirectiveSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitUndefDirective(Roslyn.Compilers.CSharp.UndefDirectiveSyntax)">
            <summary>Called when the visitor visits a UndefDirectiveSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitLineDirective(Roslyn.Compilers.CSharp.LineDirectiveSyntax)">
            <summary>Called when the visitor visits a LineDirectiveSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitPragmaWarningDirective(Roslyn.Compilers.CSharp.PragmaWarningDirectiveSyntax)">
            <summary>Called when the visitor visits a PragmaWarningDirectiveSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitPragmaChecksumDirective(Roslyn.Compilers.CSharp.PragmaChecksumDirectiveSyntax)">
            <summary>Called when the visitor visits a PragmaChecksumDirectiveSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitReferenceDirective(Roslyn.Compilers.CSharp.ReferenceDirectiveSyntax)">
            <summary>Called when the visitor visits a ReferenceDirectiveSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.BinderFactory.GetImportsBinder(Roslyn.Compilers.CSharp.SyntaxNode)">
            <summary>
            Returns binder that binds usings and aliases 
            </summary>
            <param name="unit">
            Specify <see cref="T:Roslyn.Compilers.CSharp.NamespaceDeclarationSyntax"/> imports in the corresponding namespace, or
            <see cref="T:Roslyn.Compilers.CSharp.CompilationUnitSyntax"/> for top-level imports.
            </param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.BinderFactory.IsInUsing(Roslyn.Compilers.CSharp.SyntaxNode)">
            <summary>
            Returns true if containingNode has a child that contains the specified position
            and has kind UsingDirective.
            </summary>
            <remarks>
            Usings can't see other usings, so this is extra info when looking at a namespace
            or compilation unit scope.
            </remarks>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.BuckStopsHereBinder">
            <summary>
            A binder that knows no symbols and will not delegate further.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InContainerBinder">
            <summary>
            A binder that places the members of a symbol in scope.  If there is a container declaration
            with using directives, those are merged when looking up names.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.InContainerBinder.#ctor(Roslyn.Compilers.CSharp.NamespaceOrTypeSymbol,Roslyn.Compilers.CSharp.Binder,Roslyn.Compilers.CSharp.SyntaxNode,System.Boolean,System.Boolean)">
            <summary>
            Creates a binder for a container with imports (usings and extern aliases) that can be
            retrieved from <paramref name="declarationSyntax"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.InContainerBinder.#ctor(Roslyn.Compilers.CSharp.NamespaceOrTypeSymbol,Roslyn.Compilers.CSharp.Binder,Roslyn.Compilers.CSharp.Imports)">
            <summary>
            Creates a binder with given imports.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.WithClassTypeParametersBinder">
            <summary>
            A binder that places class/interface/struct/delegate type parameters in scope
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.WithMethodTypeParametersBinder">
            <summary>
            A binder that places method type parameters in scope.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.EmitResult">
            <summary>
            The result of the Compilation Emit operation.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.EmitResult.Diagnostics">
            <summary>
            A list of all the diagnostics associated with compilations. This include parse errors, declaration errors,
            compilation errors, and emitting errors.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.EmitResult.Success">
            <summary>
            True if the compilation successfully produced an executable.
            If false then the diagnostics should include at least one error diagnostic
            indicating the cause of the failure.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ReflectionEmitResult">
            <summary>
            The result of emitting a compilation to a dynamic module.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ReflectionEmitResult.EntryPoint">
            <summary>
            Gets method information about the entrypoint of the emitted assembly.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ReflectionEmitResult.IsUncollectible">
            <summary>
            Indicates whether the emitted assembly can be garbage collected.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ExecutableCodeBinder">
            <summary>
            This binder owns and lazily creates the map of SyntaxNodes to Binders associated with
            the syntax with which it is created. This binder is not created in reaction to any
            specific syntax node type. It is inserted into the binder chain
            between the binder which it is constructed with and those that it constructs via
            the LocalBinderFactory. 
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SpeculativeSemanticModel.GetDeclarationDiagnostics(System.Threading.CancellationToken)">
            <summary>
            Get all the syntax and declaration errors within the syntax tree associated with this object. Does not get
            errors involving compiling method bodies or initializers.
            </summary>
            <param name="cancellationToken">A cancellation token that can be used to cancel the process of obtaining the
            diagnostics.</param>
            <remarks>The declaration errors for a syntax tree are cached. The first time this method is called, a ll
            declarations are analyzed for diagnostics. Calling this a second time will return the cached diagnostics.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SpeculativeSemanticModel.GetDiagnostics(System.Threading.CancellationToken)">
            <summary>
            Get all the errors within the syntax tree associated with this object. Includes errors involving compiling
            method bodies or initializers, in addition to the errors returned by GetDeclarationDiagnostics.
            </summary>
            <param name="cancellationToken">A cancellation token that can be used to cancel the process of obtaining the
            diagnostics.</param>
            <remarks>
            Because this method must semantically all method bodies and initializers to check for diagnostics, it may
            take a significant amount of time. Unlike GetDeclarationDiagnostics, diagnostics for method bodies and
            initializers are not cached, the any semantic information used to obtain the diagnostics is discarded.
            </remarks>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Declaration">
            <summary>
            A Declaration summarizes the declaration structure of a source file. Each entity declaration
            in the program that is a container (specifically namespaces, classes, interfaces, structs,
            and delegate declarations) is represented by a node in this tree.  At the top level, the
            compilation unit is treated as a declaration of the unnamed namespace.
            
            Special treatment is required for namespace declarations, because a single namespace
            declaration can declare more than one namespace.  For example, in the declaration
            
                namespace A.B.C {}
                
            we see that namespaces A and B and C are declared.  This declaration is represented as three
            declarations. All three of these ContainerDeclaration objects contain a reference to the
            syntax tree for the declaration.
            
            A "single" declaration represents a specific namespace or type declaration at a point in
            source code. A "root" declaration is a special single declaration which summarizes the
            contents of an entire file's types and namespaces.  Each source file is represented as a tree
            of single declarations.
            
            A "merged" declaration merges together one or more declarations for the same symbol.  For
            example, the root namespace has multiple single declarations (one in each source file) but
            there is a single merged declaration for them all.  Similarly partial classes may have
            multiple declarations, grouped together under the umbrella of a merged declaration.  In the
            common trivial case, a merged declaration for a single declaration contains only that single
            declaration.  The whole program, consisting of the set of all declarations in all of the
            source files, is represented by a tree of merged declarations.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CodeGen.CodeGenerator.EmitAddress(Roslyn.Compilers.CSharp.BoundExpression,System.Boolean)">
            <summary>
            Emits address as in &amp; 
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CodeGen.CodeGenerator.EmitAddressOfTempClone(Roslyn.Compilers.CSharp.BoundExpression)">
            <summary>
            Emits address of a temp.
            Used in cases where taking address directly is not possible 
            (typically because expression does not have a home)
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CodeGen.CodeGenerator.HasHome(Roslyn.Compilers.CSharp.BoundExpression)">
            <summary>
            Checks if expression directly or indirectly represents a value with its own home. In
            such cases it is possible to get a reference without loading into a temporary.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CodeGen.CodeGenerator.HasHome(Roslyn.Compilers.CSharp.BoundFieldAccess)">
            <summary>
            Special HasHome for fields. Fields have homes when they are writeable.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CodeGen.CodeGenerator.EmitReceiverRef(Roslyn.Compilers.CSharp.BoundExpression)">
            <summary>
            Emits receiver in a form that allows member accesses ( O or &amp; ). For verifiably
            reference types it is the actual reference. For generic types it is a address of the
            receiver with readonly intent. For the value types it is an address of the receiver.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CodeGen.CodeGenerator.EmitVectorInitializers(Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.BoundExpression})">
            <summary>
            Emits appropriate initialization sequence for the array on the stack.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CodeGen.CodeGenerator.EmitNonconstElementInitializers(Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.BoundExpression})">
            <summary>
            Emits only nonconstant initializers.
            This is used after whole array was blitted with constants, but some elements are nonconstants.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CodeGen.CodeGenerator.AsConstOrDefault(Roslyn.Compilers.CSharp.BoundExpression,System.Boolean@)">
            <summary>
            Returns a constant value that corresponds to a single initializer.
            If expression is not a constant, a default value is returned.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CodeGen.CodeGenerator.ShouldEmitBlockInitializer(Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.BoundExpression})">
            <summary>
            Decides if we can/should emit initializer via a metadata block.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CodeGen.CodeGenerator.CanUseCallOnRefTypeReceiver(Roslyn.Compilers.CSharp.BoundExpression)">
            <summary>
            Used to decide if we need to emit call or callvirt.
            It basically checks if the receiver expression cannot be null, but it is not 100% precise. 
            There are cases where it really can be null, but we do not care.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CodeGen.CodeGenerator.TreatLongsAsNative(Microsoft.Cci.PrimitiveTypeCode)">
            <summary>
            When array operation get long or ulong arguments the args should be 
            cast to native int.
            Note that the cast is always checked.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CodeGen.CodeGenerator.EmitVectorElementStore(Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            Emit an element store instruction for a single dimensional array.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CodeGen.CodeGenerator.EmitConditionalOperator(Roslyn.Compilers.CSharp.BoundConditionalOperator,System.Boolean)">
            <summary>
            Emit code for a conditional (aka ternary) operator.
            </summary>
            <remarks>
            (b ? x : y) becomes
                push b
                if pop then goto TRUE
                push y
                goto DONE
              TRUE:
                push x
              DONE:
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CodeGen.CodeGenerator.CodeForJump(Roslyn.Compilers.CSharp.BinaryOperatorKind,System.Boolean,Roslyn.Compilers.CodeGen.ILOpCode@)">
            <summary>
            Produces opcode for a jump that corresponds to given opearation and sense.
            Also produces a reverse opcode - opcode for the same condition with inverted sense.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CodeGen.CodeGenerator.GetLocal(Roslyn.Compilers.CSharp.BoundLocal)">
            <summary>
            Gets already declared and initialized local.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CodeGen.CodeGenerator.FreeLocal(Roslyn.Compilers.CSharp.LocalSymbol)">
            <summary>
            Releases a local.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CodeGen.CodeGenerator.AllocateTemp(Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            Allocates a temp without identity.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CodeGen.CodeGenerator.FreeTemp(Roslyn.Compilers.CodeGen.LocalDefinition)">
            <summary>
            Frees a temp without identity.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.CodeGen.CodeGenerator.indirectReturnState">
            <summary>
            In some cases returns are handled as gotos to return epilogue.
            This is used to track the state of the epilogue.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ImplicitTypeDeclaration">
            <summary>
            Represents a type declaration that wraps member declarations and statements used in a
            namespace declaration or top-level code. Such code could either occur in global script or it
            could be a misplaced global code that needs to be removed. 
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ImplicitTypeDeclaration.#ctor(Roslyn.Compilers.CSharp.SyntaxReference,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.SingleTypeDeclaration},System.Collections.Generic.ISet{System.String},System.String)">
            <summary>
            Script class declaration constructor.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ImplicitTypeDeclaration.#ctor(Roslyn.Compilers.CSharp.SyntaxReference,System.Collections.Generic.ISet{System.String})">
            <summary>
            Misplaced global code container constructor.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ImplicitTypeDeclaration.IsMisplacedCodeContainer">
            <summary>
            True if this implicit type represents misplaced global code, such as method declarations in namespaces, etc.
            </summary>
        </member>
        <member name="T:Roslyn.Scripting.CSharp.ScriptEngine">
            <summary>
            Represents a runtime execution context for C# scripts.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SymbolDisplay">
            <summary>
            A static class which is used to display symbol content based on specific <see cref="T:Roslyn.Compilers.SymbolDisplayFormat"/> 
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolDisplay.ToDisplayString(Roslyn.Compilers.Common.ISymbol,Roslyn.Compilers.SymbolDisplayFormat,System.IFormatProvider)">
            <summary>
            Convert a symbol to a string that can be displayed to the user.
            </summary>
            <param name="symbol">Symbol to be displayed.</param>
            <param name="format">Formatting rules - null implies
            SymbolDisplayFormat.ErrorMessageFormat.</param>
            <param name="formatProvider">For formatting values within the symbol - null is passed to
            IFormattable.ToString, which treats it as CultureInfo.CurrentCulture.</param>
            <returns>A formatted string that can be displayed to the user.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolDisplay.ToMinimalDisplayString(Roslyn.Compilers.Common.ISymbol,Roslyn.Compilers.CSharp.Location,Roslyn.Compilers.CSharp.SemanticModel,Roslyn.Compilers.SymbolDisplayFormat,System.IFormatProvider)">
            <summary>
            Convert a symbol to a string that can be displayed to the user. May be tailored to a
            specific location in the source code.
            </summary>
            <param name="symbol">Symbol to be displayed.</param>
            <param name="location">A location in the source code (context).</param>
            <param name="semanticModel">Binding information (for determining names appropriate to
            the context).</param>
            <param name="format">Formatting rules - null implies
            SymbolDisplayFormat.MinimallyQualifiedFormat.</param>
            <param name="formatProvider">For formatting values within the symbol - null is passed to
            IFormattable.ToString, which treats it as CultureInfo.CurrentCulture.</param>
            <returns>A formatted string that can be displayed to the user.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolDisplay.ToDisplayParts(Roslyn.Compilers.Common.ISymbol,Roslyn.Compilers.SymbolDisplayFormat)">
            <summary>
            Convert a symbol to an array of string parts, each of which has a kind. Useful for
            colorizing the display string.
            </summary>
            <param name="symbol">Symbol to be displayed.</param>
            <param name="format">Formatting rules - null implies
            SymbolDisplayFormat.ErrorMessageFormat.</param>
            <returns>A read-only array of string parts.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolDisplay.ToMinimalDisplayParts(Roslyn.Compilers.Common.ISymbol,Roslyn.Compilers.CSharp.Location,Roslyn.Compilers.CSharp.SemanticModel,Roslyn.Compilers.SymbolDisplayFormat)">
            <summary>
            Convert a symbol to an array of string parts, each of which has a kind. May be tailored
            to a specific location in the source code. Useful for colorizing the display string.
            </summary>
            <param name="symbol">Symbol to be displayed.</param>
            <param name="location">A location in the source code (context).</param>
            <param name="semanticModel">Binding information (for determining names appropriate to
            the context).</param>
            <param name="format">Formatting rules - null implies
            SymbolDisplayFormat.MinimallyQualifiedFormat.</param>
            <returns>A read-only array of string parts.</returns>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.FieldInitializer">
            <summary>
            Represents a field initializer or a global statement in script code.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.FieldInitializer.Field">
            <summary>
            The field being initialized or null if this is a global statement.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.FieldInitializer.Syntax">
            <summary>
            A reference to <see cref="T:Roslyn.Compilers.CSharp.EqualsValueClauseSyntax"/> or <see cref="T:Roslyn.Compilers.CSharp.GlobalStatementSyntax"/>.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.TypeParameterBuilder">
            <summary>
            A context for binding type parameter symbols.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SynthesizedFieldSymbol">
            <summary>
            Represents a compiler generated field of given type and name.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SynthesizedParameterSymbol">
            <summary>
            Represents a simple compiler generated parameter of a given type.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SynthesizedParameterSymbol.DeriveParameters(Roslyn.Compilers.CSharp.MethodSymbol,Roslyn.Compilers.CSharp.MethodSymbol)">
            <summary>
            For each parameter of a source method, construct a corresponding synthesized parameter
            for a destination method.
            </summary>
            <param name="sourceMethod">Has parameters.</param>
            <param name="destinationMethod">Needs parameters.</param>
            <returns>Synthesized parameters to add to destination method.</returns>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.TypeKind">
            <summary>
            Represents the different kinds of types.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.AliasSymbol">
            <summary>
            Symbol representing a using alias appearing in a compilation unit or within a namespace
            declaration. Generally speaking, these symbols do not appear in the set of symbols reachable
            from the unnamed namespace declaration.  In other words, when a using alias is used in a
            program, it acts as a transparent alias, and the symbol to which it is an alias is used in
            the symbol table.  For example, in the source code
            <pre>
            namespace NS
            {
                using o = System.Object;
                partial class C : o {}
                partial class C : object {}
                partial class C : System.Object {}
            }
            </pre>
            all three declarations for class C are equivalent and result in the same symbol table object
            for C. However, these using alias symbols do appear in the results of certain SemanticModel
            APIs. Specifically, for the base clause of the first of C's class declarations, the
            following APIs may produce a result that contains an AliasSymbol:
            <pre>
                SemanticInfo SemanticModel.GetSemanticInfo(ExpressionSyntax expression);
                SemanticInfo SemanticModel.BindExpression(SyntaxNode location, ExpressionSyntax expression);
                SemanticInfo SemanticModel.BindType(SyntaxNode location, ExpressionSyntax type);
                SemanticInfo SemanticModel.BindNamespaceOrType(SyntaxNode location, ExpressionSyntax type);
            </pre>
            Also, the following are affected if container==null (and, for the latter, when arity==null
            or arity==0):
            <pre>
                IList&lt;string&gt; SemanticModel.LookupNames(SyntaxNode location, NamespaceOrTypeSymbol container = null, LookupOptions options = LookupOptions.Default, List&lt;string> result = null);
                IList&lt;Symbol&gt; SemanticModel.LookupSymbols(SyntaxNode location, NamespaceOrTypeSymbol container = null, string name = null, int? arity = null, LookupOptions options = LookupOptions.Default, List&lt;Symbol> results = null);
            </pre>
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AliasSymbol.Target">
            <summary>
            Gets the <see cref="T:Roslyn.Compilers.CSharp.NamespaceOrTypeSymbol"/> for the
            namespace or type referenced by the alias.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AliasSymbol.ContainingSymbol">
            <summary>
            Using aliases in C# are always contained within a namespace declaration, or at the top
            level within a compilation unit, within the implicit unnamed namespace declaration.  We
            return that as the "containing" symbol, even though the alias isn't a member of the
            namespace as such.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Compilation">
            <summary>
            The compilation object is an immutable representation of a single invocation of the compiler. Although
            immutable, a compilation is also on-demand, and will realize and cache data as necessary. A compilation can
            produce a new compilation from existing compilation with the application of small deltas. In many cases, it is
            more efficient than creating a new compilation from scratch, as the new compilation can reuse information from
            the old compilation.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Compilation.lazyWellKnownTypes">
            <summary>
            An array of cached well known types available for use in this Compilation.
            Lazily filled by GetWellKnownType method.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Compilation.lazyWellKnownTypeMembers">
            <summary>
            Lazy cache of well known members.
            Not yet known value is represented by ErrorTypeSymbol.UnknownResultType
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.GetWellKnownTypeMember(Roslyn.Compilers.WellKnownMember)">
            <summary>
            Lookup member declaration in well known type used by this Compilation.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Compilation.OtherAssemblySymbols">
            <summary>
            The list of RetargetingAssemblySymbol objects created for this Compilation. 
            RetargetingAssemblySymbols are created when some other compilation references this one, 
            but the other references provided are incompatible with it. For example, compilation C1 
            references v1 of Lib.dll and compilation C2 references C1 and v2 of Lib.dll. In this
            case, in context of C2, all types from v1 of Lib.dll leaking through C1 (through method 
            signatures, etc.) must be retargeted to the types from v2 of Lib.dll. This is what 
            RetargetingAssemblySymbol is responsible for. In the example above, modules in C2 do not 
            reference C1.m_AssemblySymbol, but reference a special RetargetingAssemblySymbol created
            for C1 by AssemblyManager.
             
            WeakReference is used to allow RetargetingAssemblySymbols to be collected when they become unused.
            
            The cache must be locked for the duration of read/write operations, 
            see AssemblyManager.CacheLockObject property.
            
            Internal accesibility is for test purpose only.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Compilation.MissingCorLibrary">
            <summary>
            AssemblySymbol to represent missing, for whatever reason, CorLibrary.
            The symbol is created by AssemblyManager on as needed basis and is shared by all compilations
            with missing CorLibraries.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Compilation.lazyAssemblySymbol">
            <summary>
            The <see cref="T:Roslyn.Compilers.CSharp.SourceAssemblySymbol"/> for this compilation. Do not access directly, use Assembly property
            instead. This field is lazily initialized by AssemblyManager, AssemblyManager.CacheLockObject must be locked
            while AssemblyManager "calculates" the value and assigns it, several threads must not perform duplicate
            "calculation" simultaneously.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Compilation.references">
            <summary>
            The list of metadata references provided to Create method.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Compilation.outputName">
            <summary>
            The name passed to the constructor of the Compilation. Assumed to contain file name and
            extension.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Compilation.lazyReferencedAssembliesMap">
            <summary>
            A map from a metadata reference to an AssemblySymbol used for it. Do not access
            directly, use ReferencedAssembliesMap property instead. This field is lazily initialized
            by AssemblyManager when it creates SourceAssemblySymbol, AssemblyManager.CacheLockObject
            must be locked while AssemblyManager "calculates" the value and assigns it, several
            threads must not perform duplicate "calculation" simultaneously.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Compilation.lazyReferencedModulesMap">
            <summary>
            A map from a net-module metadata reference to a ModuleSymbol used for it. The
            ModuleSymbol is one of the modules contained in m_AssemblySymbol.Modules list. Do not
            access directly, use ReferencedModulesMap property instead. This field is lazily
            initialized by AssemblyManager when it creates SourceAssemblySymbol,
            AssemblyManager.CacheLockObject must be locked while AssemblyManager "calculates" the
            value and assigns it, several threads must not perform duplicate "calculation"
            simultaneously.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Compilation.lazyAssemblyManagerDiagnostics">
            <summary>
            reference through AssemblyManagerDiagnostics
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.Create(System.String,Roslyn.Compilers.CSharp.CompilationOptions,System.Collections.Generic.IEnumerable{Roslyn.Compilers.CSharp.SyntaxTree},System.Collections.Generic.IEnumerable{Roslyn.Compilers.MetadataReference},Roslyn.Compilers.MetadataReferenceResolver,Roslyn.Compilers.IMetadataFileProvider)">
            <summary>
            Creates a new compilation from scratch. Methods such as AddSyntaxTrees or AddReferences
            on the returned object will allow to continue building up the Compilation incrementally.
            </summary>
            <param name="outputName">The name of the compilation, filename and extension. No illegal path characters.</param>
            <param name="options">The compiler options to use.</param>
            <param name="syntaxTrees">The syntax trees with the source code for the new compilation.</param>
            <param name="references">The references for the new compilation.</param>
            <param name="referenceResolver">Resolves names and paths of metadata references.</param>
            <param name="metadataFileProvider">Translates a resolved assembly reference path to a path to the file that can be opened by the compiler.</param>
            <returns>A new compilation.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.CreateSubmission(System.String,Roslyn.Compilers.CSharp.CompilationOptions,Roslyn.Compilers.CSharp.SyntaxTree,Roslyn.Compilers.Common.ICompilation,System.Collections.Generic.IEnumerable{Roslyn.Compilers.MetadataReference},Roslyn.Compilers.MetadataReferenceResolver,Roslyn.Compilers.IMetadataFileProvider,System.Type,System.Type)">
            <summary>
            Creates a new compilation that can be used in scripting.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.GetImports(Roslyn.Compilers.CSharp.SingleNamespaceDeclaration)">
            <summary>
            Returns imported symbols for the given declaration.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.AddReferences(Roslyn.Compilers.MetadataReference[])">
            <summary>
            Creates a new compilation with additional metadata references.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.AddReferences(System.Collections.Generic.IEnumerable{Roslyn.Compilers.MetadataReference})">
            <summary>
            Creates a new compilation with additional metadata references.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.RemoveReferences(Roslyn.Compilers.MetadataReference[])">
            <summary>
            Creates a new compilation without the specified metadata references.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.RemoveReferences(System.Collections.Generic.IEnumerable{Roslyn.Compilers.MetadataReference})">
            <summary>
            Creates a new compilation without the specified metadata references.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.RemoveAllReferences">
            <summary>
            Creates a new compilation without any metadata references
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.ReplaceReference(Roslyn.Compilers.MetadataReference,Roslyn.Compilers.MetadataReference)">
            <summary>
            Creates a new compilation with an old metadata reference replaced with a new metadata reference.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.AddSyntaxTrees(Roslyn.Compilers.CSharp.SyntaxTree[])">
            <summary>
            Creates a new compilation with additional syntax trees.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.AddSyntaxTrees(System.Collections.Generic.IEnumerable{Roslyn.Compilers.CSharp.SyntaxTree})">
            <summary>
            Creates a new compilation with additional syntax trees.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.ContainsSyntaxTree(Roslyn.Compilers.CSharp.SyntaxTree)">
            <summary>
            Returns true if this compilation contains the specified tree.  False otherwise.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.RemoveSyntaxTrees(Roslyn.Compilers.CSharp.SyntaxTree[])">
            <summary>
            Creates a new compilation without the specified syntax trees. Preserves metadata info for use with trees
            added later. 
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.RemoveSyntaxTrees(System.Collections.Generic.IEnumerable{Roslyn.Compilers.CSharp.SyntaxTree})">
            <summary>
            Creates a new compilation without the specified syntax trees. Preserves metadata info for use with trees
            added later. 
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.RemoveAllSyntaxTrees">
            <summary>
            Creates a new compilation without the specified syntax trees. Preserves metadata info
            for use with trees added later. 
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.ReplaceSyntaxTree(Roslyn.Compilers.CSharp.SyntaxTree,Roslyn.Compilers.CSharp.SyntaxTree)">
            <summary>
            Creates a new compilation without the specified syntax trees. Preserves metadata info
            for use with trees added later. 
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.UpdateOptions(Roslyn.Compilers.CSharp.CompilationOptions)">
            <summary>
            Creates a new compilation with the specified compilation options.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.UpdatePreviousSubmission(Roslyn.Compilers.Common.ICompilation)">
            <summary>
            Returns a new compilation with the given compilation set as the previous submission.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.GetDirectiveReferences">
            <summary>
            Retrieves metadata references for all #r directives in the compilation.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.GetReferencedAssemblySymbol(Roslyn.Compilers.MetadataReference)">
            <summary>
            Gets the <see cref="T:Roslyn.Compilers.CSharp.AssemblySymbol"/> for a metadata reference used to create this compilation.
            </summary>
            <returns><see cref="T:Roslyn.Compilers.CSharp.AssemblySymbol"/> corresponding to the given reference or null if there is none.</returns>
            <remarks>
            Note that this method uses <see cref="T:Roslyn.Compilers.MetadataReference"/> equality for comparing
            references and doesn't resolve the reference. So, for example, if the compilation
            assembly references only include <see cref="T:Roslyn.Compilers.AssemblyFileReference"/>("c:\foo\bar.dll") 
            this method returns null for <paramref name="reference"/> == <see cref="T:Roslyn.Compilers.AssemblyFileReference"/>("c:\foo\..\foo\bar.dll"), even though the paths represent
            the same file.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.GetReferencedModuleSymbol(Roslyn.Compilers.ModuleFileReference)">
            <summary>
            Gets the <see cref="T:Roslyn.Compilers.CSharp.ModuleSymbol"/> that represents an added metadata module.
            </summary>
            <returns><see cref="T:Roslyn.Compilers.CSharp.ModuleSymbol"/> corresponding to the given reference or null if there is none.</returns>
            <remarks>
            Note that this method uses <see cref="T:Roslyn.Compilers.ModuleFileReference"/> equality for comparing
            references and doesn't resolve the reference. So, for example, if the compilation module
            references only include <see cref="T:Roslyn.Compilers.ModuleFileReference"/>("c:\foo\bar.dll") this method
            returns null for <paramref name="reference"/> == <see cref="T:Roslyn.Compilers.ModuleFileReference"/>("c:\foo\..\foo\bar.dll"), even though the paths represent
            the same file.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.GetCompilationNamespace(Roslyn.Compilers.Common.INamespaceSymbol)">
            <summary>
            Given for the specified module or assembly namespace, gets the corresponding compilation namespace (merged
            namespace representation for all namespace declarations and references with contributions for the
            namespaceSymbol).
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.GetDeclarationDiagnostics(System.Threading.CancellationToken)">
            <summary>
            Gets the diagnostics produced during symbol declaration headers.  There are no diagnostics for accessor or
            method bodies, for example.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.GetDiagnostics(System.Threading.CancellationToken)">
            <summary>
            Gets the all the diagnostics for the compilation, including syntax, declaration, and binding. Does not
            include any diagnostics that might be produced during emit.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.CreateDefaultWin32Resources(System.Boolean,System.Boolean,System.IO.Stream,System.IO.Stream)">
            <summary>
            Create a stream filled with default win32 resources.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.Emit(System.IO.Stream,System.String,System.IO.Stream,System.IO.Stream,System.Threading.CancellationToken,System.Func{System.String,System.IO.Stream},System.IO.Stream,System.Collections.Generic.IEnumerable{Roslyn.Compilers.ResourceDescription})">
            <summary>
            Emit the IL for the compilation into the specified stream.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.Emit(System.IO.Stream,System.String,System.IO.Stream,System.IO.Stream,System.Threading.CancellationToken,System.Func{System.String,System.IO.Stream},System.IO.Stream,System.Collections.Generic.IEnumerable{Roslyn.Compilers.ResourceDescription},Roslyn.Compilers.CodeGen.CompilationTestData)">
            <summary>
            This overload is only intended to be directly called by tests that want to pass an ilBuilderMap.
            The map is used for storing a list of methods and their associated IL.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.EmitMetadataOnly(System.IO.Stream,System.IO.Stream,System.Threading.CancellationToken,System.Func{System.String,System.IO.Stream})">
            <summary>
            Emits the IL for the symbol declarations into the specified stream.  Useful for emitting information for
            cross-language modeling of code.  This emits what it can even if there are errors.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.Emit(System.Reflection.Emit.ModuleBuilder,Roslyn.Compilers.IAssemblyLoader,System.Func{Roslyn.Compilers.CSharp.AssemblySymbol,System.Reflection.AssemblyName},System.Threading.CancellationToken)">
            <summary>
            Emits the compilation into given <see cref="T:System.Reflection.Emit.ModuleBuilder"/> using Reflection.Emit APIs.
            </summary>
            <param name="moduleBuilder">
            The module builder to add the types into. Can be reused for multiple compilation units.
            </param>
            <param name="assemblyLoader">
            Loads an assembly given an <see cref="T:System.Reflection.AssemblyName"/>. 
            This callback is used for loading assemblies referenced by the compilation.
            <see cref="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)"/> is used if not specified.
            </param>
            <param name="assemblySymbolMapper">
            Applied when converting assembly symbols to assembly references.
            <see cref="T:Roslyn.Compilers.CSharp.AssemblySymbol"/> is mapped to its <see cref="P:Roslyn.Compilers.CSharp.AssemblySymbol.AssemblyName"/> by default.
            </param>
            <param name="cancellationToken">Can be used to cancel the emit process.</param>
            <returns>
            An instance of <see cref="T:Roslyn.Compilers.CSharp.ReflectionEmitResult"/> that indicates whether or not the call succeeded and includes the list of errors
            and the entry point if there is any.
            </returns>
            <remarks>
            Reflection.Emit doesn't support all metadata constructs. If an unsupported construct is
            encountered a metadata writer that procudes uncollectible code is used instead. This is
            indicated by 
            <see cref="P:Roslyn.Compilers.CSharp.ReflectionEmitResult.IsUncollectible"/> flag on the result. 
            
            Reusing <see cref="T:System.Reflection.Emit.ModuleBuilder"/> may be beneficial in certain
            scenarios. For example, when emitting a sequence of code snippets one at a time (like in
            REPL). All the snippets can be compiled into a single module as long as the types being
            emitted have unique names. Reusing a single module/assembly reduces memory overhead. On
            the other hand, collectible assemblies are units of collection. Defining too many
            unrelated types in a single assemly might prevent the unused types to be collected. 
            </remarks>
            <exception cref="T:System.InvalidOperationException">Referenced assembly can't be resolved.</exception>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.GetSemanticModel(Roslyn.Compilers.CSharp.SyntaxTree)">
            <summary>
            Gets a new SyntaxTreeSemanticModel for the specified syntax tree.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.GetSpecialType(Roslyn.Compilers.SpecialType)">
            <summary>
            Get the symbol for the predefined type from the COR Library referenced by this compilation.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.GetSpecialTypeMember(Roslyn.Compilers.SpecialMember)">
            <summary>
            Get the symbol for the predefined type member from the COR Library referenced by this compilation.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.BindScriptClass">
            <summary>
            Resolves a symbol that represents script container (Script class). Uses the
            full name of the container class stored in <see cref="P:Roslyn.Compilers.CSharp.CompilationOptions.ScriptClassName"/> to find the symbol.
            </summary>
            <returns>The Script class symbol or null if it is not defined.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.GetTypeByMetadataName(System.String)">
            <summary>
            Gets the type within the compilation's assembly and all referenced assemblies
            using its canonical CLR metadata name.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.CreateArrayTypeSymbol(Roslyn.Compilers.CSharp.TypeSymbol,System.Int32)">
            <summary>
            Returns a new ArrayTypeSymbol representing an array type tied to the base types of the COR Library in this
            Compilation.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.CreatePointerTypeSymbol(Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            Returns a new PointerTypeSymbol representing a pointer type tied to a type in this Compilation.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.Clone">
            <summary>
            Create a duplicate of this compilation with different symbol instances.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.GetSubmissionResultType(System.Boolean@)">
            <summary>
            Returns the type of the submission return value. 
            </summary>
            <returns>
            The type of the last expression of the submission. 
            Null if the type of the last expression is unknown (null).
            Void type if the type of the last expression statement is void or 
            the submission ends with a declaration or statement that is not an expression statement.
            </returns>
            <param name="hasValue">True if the submission has value, i.e. if it ends with a statement that is an expression statement.</param>
            <exception cref="T:System.InvalidOperationException">The compilation doesn't represent a submission (<see cref="P:Roslyn.Compilers.CSharp.Compilation.IsSubmission"/> return false).</exception>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Compilation.ThisSymbolCache">
            <summary>
            Until binding deals with "this" as a parameter symbol, we fake it using a map.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Compilation.ScriptClass">
            <summary>
            A symbol representing the implicit Script class. This is null if the class is not
            defined in the compilation.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Compilation.ReferenceResolver">
            <summary>
            The metadata references (names and relative paths) resolver.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Compilation.MetadataFileProvider">
            <summary>
            Translates a resolved assembly reference path to a path to the file that can be opened by the compiler.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Compilation.IsSubmission">
            <summary>
            True if this compilation represents an interactive submission.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Compilation.SubmissionReturnType">
            <summary>
            The type object that represents the type of submission result the host requested.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Compilation.SyntaxTrees">
            <summary>
            The syntax trees (parsed from source code) that this compilation was created with.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Compilation.References">
            <summary>
            The references that this compilation was created with.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Compilation.Options">
            <summary>
            The options the compilation was created with. 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Compilation.Assembly">
            <summary>
            The AssemblySymbol that represents the assembly being created.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Compilation.SourceModule">
            <summary>
            Get a ModuleSymbol that refers to the module being created by compiling all of the code.
            By getting the GlobalNamespace property of that module, all of the namespaces and types
            defined in source code can be obtained.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Compilation.SemanticDiagnostics">
            <summary>
            The bag in which semantic analysis should deposit its diagnostics.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Compilation.GlobalNamespace">
            <summary>
            Gets the root namespace that contains all namespaces and types defined in source code or in 
            referenced metadata, merged into a single namespace hierarchy.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Compilation.DynamicType">
            <summary>
            The TypeSymbol for the type 'dynamic' in this Compilation.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Compilation.ObjectType">
            <summary>
            The NamedTypeSymbol for the .NET System.Object type, which could have a TypeKind of Error if there was no
            COR Library in this Compilation.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Compilation.AssemblyManager">
            <summary>
            AssemblyManager encapsulates functionality to create an underlying SourceAssemblySymbol 
            (with underlying ModuleSymbols) for Compilation and AssemblySymbols for referenced
            assemblies (with underlying ModuleSymbols) all properly linked together based on
            reference resolution between them.
            
            AssemblyManager is also responsible for reuse of metadata readers for imported modules
            and assemblies as well as existing AssemblySymbols for referenced assemblies. In order
            to do that, it maintains global cache for metadata readers and AssemblySymbols
            associated with them. The cache uses WeakReferences to refer to the metadata readers and
            AssemblySymbols to allow memory and resources being reclaimed once they are no longer
            used. The tricky part about reusing existing AssemblySymbols is to find a set of
            AssemblySymbols that are created for the referenced assemblies, which (the
            AssemblySymbols from the set) are linked in a way, consistent with the reference
            resolution between the referenced assemblies.
            
            When existing Compilation is used as a metadata reference, there are scenarios when its
            underlying SourceAssemblySymbol cannot be used to provide symbols in context of the new
            Compilation. Consider classic multi-targeting scenario: compilation C1 references v1 of
            Lib.dll and compilation C2 references C1 and v2 of Lib.dll. In this case,
            SourceAssemblySymbol for C1 is linked to AssemblySymbol for v1 of Lib.dll. However,
            given the set of references for C2, the same reference for C1 should be resolved against
            v2 of Lib.dll. In other words, in context of C2, all types from v1 of Lib.dll leaking
            through C1 (through method signatures, etc.) must be retargeted to the types from v2 of
            Lib.dll. In this case, AssemblyManager creates a special RetargetingAssemblySymbol for
            C1, which is responsible for the type retargeting. The RetargetingAssemblySymbols could
            also be reused for different Compilations, AssemblyManager maintains a cache of
            RetargetingAssemblySymbols (WeakReferences) for each Compilation.
            
            The only public entry point of this class is CreateSourceAssembly() method.
            
            TODO: Comment on CorLibrary.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Compilation.AssemblyManager.CompilationsToCompact">
            <summary>
            List of compilations that should be compacted.
            
            The cache must be locked for the duration of read/write operations, 
            see AssemblyManager.CacheLockObject property.
            
            Internal accesibility is for test purpose only.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.AssemblyManager.CompactCacheOfRetargetingAssemblies">
            <summary>
            Called by compactTimer.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.AssemblyManager.LockAndCleanCaches">
            <summary>
            Lock and clean global Metadata caches, meant to be used for test purpose only.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.AssemblyManager.ResolveAssemblyNameReference(Roslyn.Compilers.MetadataReference,Roslyn.Compilers.CSharp.Location,Roslyn.Compilers.CSharp.Compilation,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            If the given <paramref name="metadataReference"/> is an <see cref="T:Roslyn.Compilers.AssemblyNameReference"/> 
            uses the <paramref name="compilation"/>'s reference resolver to translate it to a reference 
            of another kind that we load. Otherwise returns the <paramref name="metadataReference"/> itself.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.AssemblyManager.ResolvePath(System.String,Roslyn.Compilers.CSharp.Location,Roslyn.Compilers.CSharp.Compilation,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Uses the <paramref name="compilation"/>'s reference resolver to normalize given <paramref name="path"/>.
            If the path returned by the resolver is relative converts it into an absolute path using the current working directory.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.AssemblyManager.IsSourceAssemblySymbolCreated(Roslyn.Compilers.CSharp.Compilation)">
            <summary>
            For testing purposes only.
            </summary>
            <param name="compilation"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.AssemblyManager.IsReferencedAssembliesMapCreated(Roslyn.Compilers.CSharp.Compilation)">
            <summary>
            For testing purposes only.
            </summary>
            <param name="compilation"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.AssemblyManager.IsReferencedModulesMapCreated(Roslyn.Compilers.CSharp.Compilation)">
            <summary>
            For testing purposes only.
            </summary>
            <param name="compilation"></param>
            <returns></returns>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Compilation.AssemblyManager.CompactTimerIsOn">
            <summary>
            For test purposes.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Compilation.AssemblyManager.CacheLockObject">
            <summary>
            The object that must be locked for the duration of read/write operations on AssemblyManager's caches.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AccessorDeclarationSyntax.Attributes">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AccessorDeclarationSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AccessorDeclarationSyntax.Keyword">
            <summary>Gets the keyword token, or identifier if an erroneous accessor declaration.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AccessorDeclarationSyntax.BodyOpt">
            <summary>Gets the optional body block which may be empty, but it is null if there are no braces.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AccessorDeclarationSyntax.SemicolonTokenOpt">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.AliasQualifiedNameSyntax">
            <summary>Class which represents the syntax node for alias qualified name.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.NameSyntax">
            <summary>Provides the base class from which the classes that represent name syntax nodes are derived. This is an abstract class.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.TypeSyntax">
            <summary>Provides the base class from which the classes that represent type syntax nodes are derived. This is an abstract class.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ExpressionSyntax">
            <summary>Provides the base class from which the classes that represent expression syntax nodes are derived. This is an abstract class.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeSyntax.PlainName">
            <summary>
            Unqualified non-generic name (identifier).
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AliasQualifiedNameSyntax.Alias">
            <summary>IdentifierNameSyntax node representing the name of the alias</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AliasQualifiedNameSyntax.ColonColonToken">
            <summary>SyntaxToken representing colon colon.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AliasQualifiedNameSyntax.Name">
            <summary>SimpleNameSyntax node representing the name that is being alias qualified.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ArrayTypeSyntax">
            <summary>Class which represents the syntax node for the array type.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ArrayTypeSyntax.ElementType">
            <summary>TypeSyntax node representing the type of the element of the array.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ArrayTypeSyntax.RankSpecifiers">
            <summary>SyntaxList of ArrayRankSpecifierSyntax nodes representing the list of rank specifiers for the array.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CompilationUnitSyntax.GetReferenceDirectives">
            <summary>
            Returns #r directives specified in the compilation.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.CompilationUnitSyntax.Attributes">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.DiagnosticList">
            <summary>
            A list of <see cref="T:Roslyn.Compilers.CSharp.Diagnostic"/> objects.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.DiagnosticList.GetEnumerator">
            <summary>
            Returns an enumerator over this list of diagnostics.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.DiagnosticList.Count">
            <summary>
            Returns the count of diagnostic instances in this list.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.DiagnosticList.Item(System.Int32)">
            <summary>
            Returns the diagnostic instance at the specified index in this list.
            </summary>
            <param name="index">The index of the diagnostic.</param>
            <returns>The specified diagnostic.</returns>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.DiagnosticList.Enumerator">
            <summary>
            An enumerator for diagnostic lists.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.DiagnosticList.Enumerator.MoveNext">
            <summary>
            Moves the enumerator to the next diagnostic instance in the diagnostic list.
            </summary>
            <returns>Returns true if enumerator moved to the next diagnostic, false if the
            enumerator was at the end of the diagnostic list.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.DiagnosticList.Enumerator.UpdateDiagnosticInfoForMissingTokens(Roslyn.Compilers.CSharp.InternalSyntax.SyntaxDiagnosticInfo,Roslyn.Compilers.CSharp.DiagnosticList.Enumerator.NodeIteration[],System.Int32)">
            <summary>
            Update DiagnosticInfo for missing tokens
            </summary>
            <param name="sdi">DiagnosticInfo to be updated</param>
            <param name="stack">NodeIteration stack</param>
            <param name="count">Size of stack</param>
            <returns>Updated DiagnosticInfo</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.DiagnosticList.Enumerator.UpdateDiagnosticInfoForMissingTokensAtEndOfLine(Roslyn.Compilers.CSharp.InternalSyntax.SyntaxDiagnosticInfo@,Roslyn.Compilers.CSharp.DiagnosticList.Enumerator.NodeIteration[],System.Int32)">
            <summary>
            Update DiagnosticInfo for missing tokens at the end of source line
            </summary>
            <param name="sdi">Diagnostic Info to be updated</param>
            <param name="stack">NodeIteration stack</param>
            <param name="count">Size of stack</param>
            <returns>Flag indicating whether DiagnosticInfo was updated</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.DiagnosticList.Enumerator.UpdateDiagnosticInfoForMissingTokens(Roslyn.Compilers.CSharp.InternalSyntax.SyntaxDiagnosticInfo@,Roslyn.Compilers.CSharp.DiagnosticList.Enumerator.NodeIteration[],System.Int32)">
            <summary>
            Update DiagnosticInfo for missing tokens
            </summary>
            <param name="sdi">DiagnosticInfo to be updated</param>
            <param name="stack">NodeIteration stack</param>
            <param name="count">Size of stack</param>
            <returns>Flag indicating whether DiagnosticInfo was updated</returns>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.DiagnosticList.Enumerator.Current">
            <summary>
            The current diagnostic that the enumerator is pointing at.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.StatementSyntax">
            <summary>Represents the base class for all statements syntax classes.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ExpressionStatementSyntax.AllowsAnyExpression">
            <summary>
            Returns true if the <see cref="P:Roslyn.Compilers.CSharp.ExpressionStatementSyntax.Expression"/> property is allowed by the rules of the
            language to be an arbitrary expression, not just a statement expression.
            </summary>
            <remarks>
            True if, for example, this expression statement represents the last expression statement
            of the interactive top-level code.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.InternalSyntax.SyntaxNode.EnumerateNodes">
            <summary>
            Enumerates all nodes of the tree rooted by this node (including this node).
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.NullableTypeSyntax">
            <summary>Class which represents the syntax node for a nullable type.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NullableTypeSyntax.ElementType">
            <summary>TypeSyntax node representing the type of the element.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NullableTypeSyntax.QuestionToken">
            <summary>SyntaxToken representing the question mark.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.PointerTypeSyntax">
            <summary>Class which represents the syntax node for pointer type.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.PointerTypeSyntax.ElementType">
            <summary>TypeSyntax node that represents the element type of the pointer.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.PointerTypeSyntax.AsteriskToken">
            <summary>SyntaxToken representing the asterisk.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.IdentifierNameSyntax">
            <summary>Class which represents the syntax node for identifier name.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SimpleNameSyntax">
            <summary>Provides the base class from which the classes that represent simple name syntax nodes are derived. This is an abstract class.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SimpleNameSyntax.Identifier">
            <summary>SyntaxToken representing the identifier of the simple name.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.IdentifierNameSyntax.Identifier">
            <summary>SyntaxToken representing the keyword for the kind of the identifier name.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.PredefinedTypeSyntax">
            <summary>Class which represents the syntax node for predefined types.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.PredefinedTypeSyntax.Keyword">
            <summary>SyntaxToken which represents the keyword corresponding to the predefined type.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.QualifiedNameSyntax">
            <summary>Class which represents the syntax node for qualified name.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.QualifiedNameSyntax.Left">
            <summary>NameSyntax node representing the name on the left side of the dot token of the qualified name.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.QualifiedNameSyntax.DotToken">
            <summary>SyntaxToken representing the dot.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.QualifiedNameSyntax.Right">
            <summary>SimpleNameSyntax node representing the name on the right side of the dot token of the qualified name.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.FlowAnalysisPass.Rewrite(Roslyn.Compilers.CSharp.MethodSymbol,Roslyn.Compilers.CSharp.BoundBlock,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            The flow analysis pass.  This pass reports required diagnostics for unreachable
            statements and uninitialized variables (through the call to FlowAnalysisWalker.Analyze),
            and inserts a final return statement if the end of a void-returning method is reachable.
            </summary>
            <param name="method">the method to be analyzed</param>
            <param name="block">the method's body</param>
            <param name="diagnostics">the receiver of the reported diagnostics</param>
            <returns>the rewritten block for the method (with a return statement possibly inserted)</returns>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SyntaxTreeSemanticModel">
            <summary>
            Allows asking semantic questions about any node in a SyntaxTree within a Compilation.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTreeSemanticModel.GetDeclarationDiagnostics(System.Threading.CancellationToken)">
            <summary>
            Get all the syntax and declaration errors within the syntax tree associated with this object. Does not get
            errors involving compiling method bodies or initializers.
            </summary>
            <param name="cancellationToken">A cancellation token that can be used to cancel the process of obtaining the
            diagnostics.</param>
            <remarks>The declaration errors for a syntax tree are cached. The first time this method is called, a ll
            declarations are analyzed for diagnostics. Calling this a second time will return the cached diagnostics.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTreeSemanticModel.GetDiagnostics(System.Threading.CancellationToken)">
            <summary>
            Get all the errors within the syntax tree associated with this object. Includes errors involving compiling
            method bodies or initializers, in addition to the errors returned by GetDeclarationDiagnostics.
            </summary>
            <param name="cancellationToken">A cancellation token that can be used to cancel the process of obtaining the
            diagnostics.</param>
            <remarks>
            Because this method must semantically all method bodies and initializers to check for diagnostics, it may
            take a significant amount of time. Unlike GetDeclarationDiagnostics, diagnostics for method bodies and
            initializers are not cached, the any semantic information used to obtain the diagnostics is discarded.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTreeSemanticModel.GetEnclosingBinder(System.Int32)">
            <summary>
            Gets the enclosing binder associated with the node
            </summary>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTreeSemanticModel.OldGetSemanticInfo(Roslyn.Compilers.CSharp.ExpressionSyntax,System.Threading.CancellationToken)">
            <summary>
            Gets semantic information, such as type, symbols, and diagnostics, about a syntax node.
            </summary>
            <param name="expression">The syntax node to get semantic information for.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTreeSemanticModel.OldGetSemanticInfo(Roslyn.Compilers.CSharp.ConstructorInitializerSyntax,System.Threading.CancellationToken)">
            <summary>
            Gets semantic information, such as type, symbols, and diagnostics, about a syntax node.
            </summary>
            <param name="constructorInitializer">The syntax node to get semantic information for.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTreeSemanticModel.ClassifyConversion(Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            Determines what type of conversion, if any, would be used if a given expression was converted to a given
            type.
            </summary>
            <param name="expression">An expression which much occur within the syntax tree associated with this
            object.</param>
            <param name="destination">The type to attempt conversion to.</param>
            <returns>Returns a Conversion object that summarizes whether the conversion was possible, and if so, what
            kind of conversion it was. If no conversion was possible, a Conversion object with a false "Exists "
            property is returned.</returns>
            <remarks>To determine the conversion between two types (instead of an expression and a type), use
            Compilation.ClassifyConversion.</remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTreeSemanticModel.OldGetSemanticInfoInParent(Roslyn.Compilers.CSharp.ExpressionSyntax,System.Threading.CancellationToken)">
            <summary>
            Gets the semantic information for a syntax node as seen from the perspective of the node's parent. 
            </summary>
            <param name="expression"></param>
            <param name="cancellationToken"></param>
            <remarks>
            This method allows observing the result of implicit conversions that do not have syntax node's directly
            associated with them. For example, consider the following code:
            <code>
            void f(long x); 
            int i = 17; 
            f(i);  
            </code>
            A call to GetSemanticInfo on the syntax node for "i" in "f(i)" would have a Type of "int". A call to
            GetSemanticInfoInParent on the same syntax node would have a Type of "long", since there is an implicit
            conversion from int to long as part of the function call to f.
            </remarks>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTreeSemanticModel.GetSpeculativeSemanticModel(System.Int32,Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>
            Get a SemanticModel object that is associated with an expression that did not appear in
            this source code. This can be used to get detailed semantic information about sub-parts
            of an expression that did not appear in source code. 
            </summary>
            <param name="position">The character position for determining the enclosing declaration scope and
            accessibility.</param>
            <param name="expression">The expression to analyze. This expression does not need to be present in the
            syntax tree associated with this object.</param>
            <returns>A SemanticModel object that can be used to inquire about the semantic information associated with
            syntax nodes within "expression".</returns>
            <remarks>
            If semantic information about just the root node of "expression", the BindExpression method can be used
            instead.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTreeSemanticModel.GetSpeculativeSemanticModel(System.Int32,Roslyn.Compilers.CSharp.StatementSyntax)">
            <summary>
            Get a SemanticModel object that is associated with an expression that did not appear in
            this source code. This can be used to get detailed semantic information about sub-parts
            of an expression that did not appear in source code. 
            </summary>
            <param name="position">The character position for determining the enclosing declaration scope and
            accessibility.</param>
            <param name="statement">The statement to analyze. This statement does not need to be present in the syntax
            tree associated with this object.</param>
            <returns>A SemanticModel object that can be used to inquire about the semantic information associated with
            syntax nodes within "statement".</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbol(Roslyn.Compilers.CSharp.NamespaceDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a namespace declaration syntax node, get the corresponding namespace symbol for the declaration
            assembly.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a namespace.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The namespace symbol that was declared by the namespace declaration.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbol(Roslyn.Compilers.CSharp.BaseTypeDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a type declaration, get the corresponding type symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a type.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The type symbol that was declared.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbol(Roslyn.Compilers.CSharp.DelegateDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a delegate declaration, get the corresponding type symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a delegate.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The type symbol that was declared.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbol(Roslyn.Compilers.CSharp.MemberDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given an member declaration syntax, get the corresponding symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a member.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbol(Roslyn.Compilers.CSharp.AccessorDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given an syntax node that declares a property or member accessor, get the corresponding symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares an accessor.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbol(Roslyn.Compilers.CSharp.VariableDeclaratorSyntax,System.Threading.CancellationToken)">
            <summary>
            Given an variable declarator syntax, get the corresponding symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a variable.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbol(Roslyn.Compilers.CSharp.UsingDirectiveSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a using declaration get the corresponding symbol for the using alias that was introduced.  
            </summary>
            <param name="declarationSyntax"></param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The alias symbol that was declared, or null if no alias symbol was declared or a duplicate alias
            symbol was declared.</returns>
            <remarks>
            If the using directive is an error because it attempts to introduce an alias for which an existing alias was
            previously declared in the same scope, the result is null.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbol(Roslyn.Compilers.CSharp.ParameterSyntax,System.Threading.CancellationToken)">
            <summary>
            Given an parameter declaration syntax node, get the corresponding symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a parameter.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The parameter that was declared.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbol(Roslyn.Compilers.CSharp.TypeParameterSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a type parameter declaration (field or method), get the corresponding symbol
            </summary>
            <param name="typeParameter"></param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTreeSemanticModel.AnalyzeRegionControlFlow(Roslyn.Compilers.TextSpan)">
            <summary>
            Analyze control-flow within a part of a method body. 
            </summary>
            <param name="span">The span of code within the associated SyntaxTree to analyze. The span must be fully
            inside a method body.</param>
            <returns>An object that can be used to obtain the result of the control flow analysis.</returns>
            <exception cref="T:System.ArgumentException">The span is not with a method body.</exception>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTreeSemanticModel.AnalyzeRegionDataFlow(Roslyn.Compilers.TextSpan)">
            <summary>
            Analyze data-flow within a part of a method body. 
            </summary>
            <param name="span">The span of code within the associated SyntaxTree to analyze. The span must be fully
            inside a method body.</param>
            <returns>An object that can be used to obtain the result of the data flow analysis.</returns>
            <exception cref="T:System.ArgumentException">The span is not with a method body.</exception>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxTreeSemanticModel.Compilation">
            <summary>
            The compilation this object was obtained from.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxTreeSemanticModel.Root">
            <summary>
            The root node of the syntax tree that this object is associated with.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxTreeSemanticModel.SyntaxTree">
            <summary>
            The SyntaxTree that this object is associated with.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.RegionControlFlowAnalysis">
            <summary>
            This class implements the region control flow analysis operations. Region control flow
            analysis provides information about statements which enter and leave a region. The analysis
            is done lazily. When created, it performs no analysis, but simply caches the arguments.
            Then, the first time one of the analysis results is used it computes that one result and
            caches it. Each result is computed using a custom algorithm.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.RegionControlFlowAnalysis.JumpsIntoRegion">
            <summary>
            A collection of statements outside the region that jump into the region.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.RegionControlFlowAnalysis.JumpsOutOfRegion">
            <summary>
            A collection of statements inside the region that jump to locations outside the region.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.RegionControlFlowAnalysis.RegionEndPointIsReachable">
            <summary>
            Returns true if and only if the endpoint of the last statement in the region is reachable or the region contains no
            statements.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.RegionControlFlowAnalysis.ReturnStatements">
            <summary>
            A collection of return statements found within the region that return to the enclosing method or lambda.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.OldSemanticInfo">
            <summary>
            Summarizes the semantic information about a syntax node. Includes the symbol(s),
            the type, and any errors resulting from binding.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.OldSemanticInfo.None">
            <summary>
            A pre-created instance of SemanticInfo that has a "null" type, no symbols, and no diagnostics.  
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.OldSemanticInfo.Type">
            <summary>
            The type of the expression represented by the syntax node. For expressions that do not
            have a type, null is returned. If the type could not be determined due to an error, then
            an object derived from ErrorTypeSymbol is returned.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.OldSemanticInfo.Symbols">
            <summary>
            The set of symbols of that are referred to by the syntax node. For example, for a syntax node that is the
            name of a field, the symbol that represents that field would be returned. Some expressions, such as built-in
            operators, do not refer to symbols; in this case, an empty collection is returned. 
            </summary>
            <remarks>
            In some cases, multiple symbols are returned. For example, when examining a name that refers to a method
            group, all the methods in the group are returned. When examining an invocation syntax node, however, only
            the method that overload resolution chose will be returned. 
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.OldSemanticInfo.Diagnostics">
            <summary>
            Any semantic diagnostics that were directly related to the syntax node. 
            </summary>
            <remarks>
            Does not return syntax errors, or errors relating to sub-expressions.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.OldSemanticInfo.AllErrorDiagnostics">
            <summary>
            All error diagnostics that are inside the given node. Includes syntax errors, and errors on sub-expressions
            of the node.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.OldSemanticInfo.AllWarningDiagnostics">
            <summary>
            All warning diagnostics that are inside the given node. Includes syntax warning, and warnings on sub-expressions
            of the node.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.DeclarationTable">
            <summary>
            A declaration table is a device which keeps track of type and namespace declarations from
            parse trees. It is optimized for the case where there is one set of declarations that stays
            constant, and a specific root namespace declaration corresponding to the currently edited
            file which is being added and removed repeatedly. It maintains a cache of information for
            "merging" the root declarations into one big summary declaration; this cache is efficiently
            re-used provided that the pattern of adds and removes is as we expect.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.DeclarationTreeBuilder.CreateScriptRootDeclaration(Roslyn.Compilers.CSharp.CompilationUnitSyntax)">
            <summary>
            Creates a root declaration that contains a Script class declaration (possibly in a namespace) and namespace declarations.
            Top-level declarations in script code are nested in Script class.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ArrayTypeSymbol">
            <summary>
            An ArrayTypeSymbol represents an array type, such as int[] or object[,].
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ArrayTypeSymbol.#ctor(Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.CustomModifier},System.Int32,Roslyn.Compilers.CSharp.Compilation)">
            <summary>
            Create a new ArrayTypeSymbol.
            </summary>
            <param name="elementType">The element type of this array type.</param>
            <param name="customModifiers">Custom modifiers for the element type of this array type.</param>
            <param name="rank">The rank of this array type.</param>
            <param name="compilation">The compilation in which the type is constructed.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ArrayTypeSymbol.#ctor(Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.CustomModifier},System.Int32,Roslyn.Compilers.CSharp.AssemblySymbol)">
            <summary>
            Create a new ArrayTypeSymbol.
            </summary>
            <param name="elementType">The element type of this array type.</param>
            <param name="customModifiers">Custom modifiers for the element type of this array type.</param>
            <param name="rank">The rank of this array type.</param>
            <param name="declaringAssembly">The assembly "declaring"/using the array type.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ArrayTypeSymbol.#ctor(Roslyn.Compilers.CSharp.TypeSymbol,System.Collections.Generic.List{Roslyn.Compilers.MetadataReader.MetadataDecoder{Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.CSharp.MethodSymbol,Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.CSharp.TypedConstant}.ModifierInfo},Roslyn.Compilers.CSharp.AssemblySymbol)">
            <summary>
            Create a new ArrayTypeSymbol of rank 1.
            </summary>
            <param name="elementType">The element type of this array type.</param>
            <param name="customModifiers">Custom modifiers for the element type of this array type.</param>
            <param name="declaringAssembly">The assembly "declaring"/using the array type.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ArrayTypeSymbol.#ctor(Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.CustomModifier},System.Int32,Roslyn.Compilers.CSharp.NamedTypeSymbol,Roslyn.Compilers.CSharp.NamedTypeSymbol)">
            <summary>
            Create a new ArrayTypeSymbol.
            </summary>
            <param name="elementType">The element type of this array type.</param>
            <param name="customModifiers">Custom modifiers for the element type of this array type.</param>
            <param name="rank">The rank of this array type.</param>
            <param name="array">The core library type "System.Array".</param>
            <param name="ilist">The core library type "IList".</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ArrayTypeSymbol.#ctor(Roslyn.Compilers.CSharp.TypeSymbol,System.Int32,Roslyn.Compilers.CSharp.NamedTypeSymbol,Roslyn.Compilers.CSharp.NamedTypeSymbol)">
            <summary>
            Create a new ArrayTypeSymbol.
            </summary>
            <param name="elementType">The element type of this array type.</param>
            <param name="rank">The rank of this array type.</param>
            <param name="array">The core library type "System.Array".</param>
            <param name="ilist">The core library type "IList".</param>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ArrayTypeSymbol.CustomModifiers">
            <summary>
            Gets the list of custom modifiers associated with the array.
            Returns an empty list if there are no custom modifiers.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ArrayTypeSymbol.Rank">
            <summary>
            Gets the number of dimensions of the array. A regular single-dimensional array
            has rank 1, a two-dimensional array has rank 2, etc.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ArrayTypeSymbol.ElementType">
            <summary>
            Gets the type of the elements stored in the array.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Emit.Module.assemblySymbolMapper">
            <summary>
            Used to translate assembly symbols to assembly references in scenarios when the physical assemblies 
            being emitted don't correspond to the assembly symbols 1:1. This happens, for example, in interactive sessions where
            multiple code submissions might be compiled into a single dynamic assembly or into multiple assemblies 
            depending on properties of the code being emitted. If null we map assembly symbol exactly to its assembly name.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Emit.Module.GetCompilerGeneratedTypes(Roslyn.Compilers.CSharp.NamedTypeSymbol)">
            <summary>
            Returns null if there are no compiler generated types.
            </summary>
            <param name="container"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Emit.Module.GetCompilerGeneratedMethods(Roslyn.Compilers.CSharp.NamedTypeSymbol)">
            <summary>
            Returns null if there are no compiler generated methods.
            </summary>
            <param name="container"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Emit.Module.GetCompilerGeneratedFields(Roslyn.Compilers.CSharp.NamedTypeSymbol)">
            <summary>
            Returns null if there are no compiler generated fields.
            </summary>
            <param name="container"></param>
            <returns></returns>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Emit.Module.CompilerGeneratedDefinitions">
            <summary>
            Captures the set of compiler generated definitions that should be added to a type
            during emit process.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.CustomModifier">
            <summary>
            Represents a custom modifier (modopt/modreq).
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.CustomModifier.IsOptional">
            <summary>
            If true, a language may use the modified storage location without 
            being aware of the meaning of the modification, modopt vs. modreq. 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.CustomModifier.Modifier">
            <summary>
            A type used as a tag that indicates which type of modification applies.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Emit.GenericMethodInstanceReference">
            <summary>
            Represents a reference to a generic method instantiation, closed over type parameters,
            e.g. MyNamespace.Class.Method{T}()
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Emit.GenericNestedTypeInstanceReference">
            <summary>
            Represents a reference to a generic type instantiation that is nested in a non-generic type.
            e.g. A.B{int}
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Emit.GenericTypeInstanceReference">
            <summary>
            Represents a reference to a generic type instantiation.
            Subclasses represent nested and namespace types.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Emit.GenericNamespaceTypeInstanceReference">
            <summary>
            Represents a reference to a generic type instantiation that is not nested.
            e.g. MyNamespace.A{int}
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.PointerTypeSymbol">
            <summary>
            Represents a pointer type such as "int *". Pointer types
            are used only in unsafe code.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.PointerTypeSymbol.#ctor(Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            Create a new PointerTypeSymbol.
            </summary>
            <param name="pointedAtType">The type being pointed at.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.PointerTypeSymbol.#ctor(Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.CustomModifier})">
            <summary>
            Create a new PointerTypeSymbol.
            </summary>
            <param name="pointedAtType">The type being pointed at.</param>
            <param name="customModifiers">Custom modifiers for the element type of this array type.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.PointerTypeSymbol.#ctor(Roslyn.Compilers.CSharp.TypeSymbol,System.Collections.Generic.List{Roslyn.Compilers.MetadataReader.MetadataDecoder{Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.CSharp.MethodSymbol,Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.CSharp.TypedConstant}.ModifierInfo})">
            <summary>
            Create a new PointerTypeSymbol.
            </summary>
            <param name="pointedAtType">The type being pointed at.</param>
            <param name="customModifiers">Custom modifiers for the element type of this array type.</param>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.PointerTypeSymbol.CustomModifiers">
            <summary>
            The list of custom modifiers, if any, associated with the pointer type.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.PointerTypeSymbol.PointedAtType">
            <summary>
            Gets the type of the storage location that an instance of the pointer type points to.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Emit.SpecializedFieldReference">
            <summary>
            Represents a reference to a field of a generic type instantiation.
            e.g.
            A{int}.Field
            A{int}.B{string}.C.Field
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Emit.SpecializedGenericNestedTypeInstanceReference">
            <summary>
            Represents a reference to an instantiation of a generic type nested in an instantiation of another generic type.
            e.g. 
            A{int}.B{string}
            A.B{int}.C.D{string}
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Emit.SpecializedNestedTypeReference">
            <summary>
            Represents a reference to a type nested in an instantiation of a generic type.
            e.g. 
            A{int}.B
            A.B{int}.C.D
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.TypeParameterSymbol">
            <summary>
            Represents a type parameter in a generic type or generic method.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeParameterSymbol.Ordinal">
            <summary>
            The ordinal position of the type parameter in the parameter list which declares
            it. The first type parameter has ordinal zero.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeParameterSymbol.ConstraintTypes">
            <summary>
            The types that were directly specified as constraints on the type parameter.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeParameterSymbol.HasConstructorConstraint">
            <summary>
            True if the parameterless constructor constraint was specified for the type parameter.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeParameterSymbol.IsMethodTypeParameter">
            <summary>
            True if the type parameter was declared by a generic method.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeParameterSymbol.DeclaringMethod">
            <summary>
            The method that declared this type parameter, or null.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeParameterSymbol.DeclaringType">
            <summary>
            The type that declared this type parameter, or null.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Diagnostic">
            <summary>
            A diagnostic, along with the location where it occurred.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Diagnostic.Location">
            <summary>
            The primary location of the diagnostic.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Diagnostic.Info">
            <summary>
            Get the information about the diagnostic: the code, severity, message, etc.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Diagnostic.AdditionalLocations">
            <summary>
            Get additional locations related to the diagnostic. Typically these are the locations of
            symbols that are mentioned in the message.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.DiagnosticBagExtensions.SealDiagnostics(Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Get all the diagnostics in the diagnostic bag, as an enumerable of Diagnostic. DiagnosticBag
            implements IEnumerable&lt;IDiagnostic&gt; instead of IEnumerable&lt;Diagnostic&gt;.
            </summary>
            <param name="diagBag"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.DiagnosticBagExtensions.GetDiagnostics(Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Get all the diagnostics in the diagnostic bag, as an enumerable of Diagnostic. DiagnosticBag
            implements IEnumerable&lt;IDiagnostic&gt; instead of IEnumerable&lt;Diagnostic&gt;.
            </summary>
            <param name="diagBag"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.DiagnosticBagExtensions.Add(Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.CSharp.ErrorCode,Roslyn.Compilers.CSharp.Location,System.Object[])">
            <summary>
            Add a diagnostic to the bag.
            </summary>
            <param name="diagnostics"></param>
            <param name="code"></param>
            <param name="location"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ErrorFacts.GetMessage(Roslyn.Compilers.CSharp.MessageID,System.Globalization.CultureInfo)">
            <remarks>Don't call this during a parse--it loads resources</remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ErrorFacts.GetMessage(Roslyn.Compilers.CSharp.ErrorCode,System.Globalization.CultureInfo)">
            <remarks>Don't call this during a parse--it loads resources</remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ErrorFacts.GetMessage(Roslyn.Compilers.CSharp.XmlParseErrorCode,System.Globalization.CultureInfo)">
            <remarks>Don't call this during a parse--it loads resources</remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Hosting.CommandLineArguments.ScriptArguments">
            <summary>
            Arguments following script argument separator "--" or null if <see cref="P:Roslyn.Compilers.CSharp.Hosting.CommandLineArguments.IsInteractive"/> is false.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.MetadataLocation">
            <summary>
            A program location in metadata.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.NodeLocation">
            <summary>
            A Location describing a SyntaxNode that isn't part of any tree.  These can be used as the
            location of an error resulting from the speculative binding APIs such as Bindings.BindType.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.NoLocation">
            <summary>
            A class that represents no location at all. Useful for errors in command line options, for example.
            </summary>
            <remarks></remarks>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.TokenLocation">
            <summary>
            A Location describing a SyntaxToken that isn't part of any tree.  This can be used as the
            location of an error message in speculative binding APIs such as Bindings.BindType.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.CharacterInfo">
            <summary>
            Defines a set of methods to determine how Unicode characters are treated by the C# compiler.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CharacterInfo.IsHexDigit(System.Char)">
            <summary>
            Returns true if the Unicode character is a hexadecimal digit.
            </summary>
            <param name="c">The Unicode character.</param>
            <returns>true if the character is a hexadecimal digit 0-9, A-F, a-f.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CharacterInfo.IsDecDigit(System.Char)">
            <summary>
            Returns true if the Unicode character is a decimal digit.
            </summary>
            <param name="c">The Unicode character.</param>
            <returns>true if the Unicode character is a decimal digit.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CharacterInfo.HexValue(System.Char)">
            <summary>
            Returns the value of a hexadecimal Unicode character.
            </summary>
            <param name="c">The Unicode character.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CharacterInfo.DecValue(System.Char)">
            <summary>
            Returns the value of a decimal Unicode character.
            </summary>
            <param name="c">The Unicode character.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CharacterInfo.IsWhitespace(System.Char)">
            <summary>
            Returns true if the Unicode character represents a whitespace.
            </summary>
            <param name="ch">The Unicode character.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CharacterInfo.IsNewLine(System.Char)">
            <summary>
            Returns true if the Unicode character is a newline character.
            </summary>
            <param name="ch">The Unicode character.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CharacterInfo.IsIdentifierStartCharacter(System.Char)">
            <summary>
            Returns true if the Unicode character can be the starting character of a C# identifier.
            </summary>
            <param name="ch">The Unicode character.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CharacterInfo.IsIdentifierPartCharacter(System.Char)">
            <summary>
            Returns true if the Unicode character can be a part of a C# identifier.
            </summary>
            <param name="ch">The Unicode character.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CharacterInfo.IsValidIdentifier(System.String)">
            <summary>
            Check that the name is a valid identifier.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CharacterInfo.IsFormattingChar(System.Char)">
            <summary>
            Returns true if the Unicode character is a formatting character (Unicode class Cf).
            </summary>
            <param name="ch">The Unicode character.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CharacterInfo.IsFormattingChar(System.Globalization.UnicodeCategory)">
            <summary>
            Returns true if the Unicode character is a formatting character (Unicode class Cf).
            </summary>
            <param name="cat">The Unicode character.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CharacterInfo.IsXmlNameStartChar(System.Char)">
            <summary>
            Determines whether this Unicode character can start a XMLName.
            </summary>
            <param name="ch">The Unicode character.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CharacterInfo.IsXmlNameChar(System.Char)">
            <summary>
            Determines if this Unicode character can be part of an XML Name.
            </summary>
            <param name="ch">The Unicode character.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.InternalSyntax.DirectiveParser.ParseErrorOrWarningDirective(Roslyn.Compilers.CSharp.InternalSyntax.SyntaxToken,Roslyn.Compilers.CSharp.InternalSyntax.SyntaxToken,System.Boolean)">
            <summary>
            An error/warning directive tells the compiler to indicate a syntactic error/warning
            at the current location.
            
            Format: #error Error message string
            Resulting message: from the first non-whitespace character after the directive
            keyword until the end of the directive (aka EOD) at the line break or EOF.
            Resulting span: [first non-whitespace char, EOD)
            
            Examples (pipes indicate span):
            #error |foo|
            #error  |foo|
            #error |foo |
            #error |foo bar|
            #error |//foo|
            #error |/*foo*/|
            #error |/*foo|
            </summary>
            <param name="hash">The '#' token.</param>
            <param name="keyword">The 'error' or 'warning' token.</param>
            <param name="isActive">True if the error/warning should be recorded.</param>
            <returns>An ErrorDirective or WarningDirective node.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.InternalSyntax.LanguageParser.ScanExternAliasDirective">
            <summary>
            Returns true if the lookahead tokens compose extern alias directive.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.InternalSyntax.LanguageParser.IsTrueIdentifier">
            <summary>
            True if current identifier token is not really some contextual keyword
            </summary>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.InternalSyntax.LanguageParser.ParseStatementNoDeclaration(System.Boolean)">
            <summary>
            Parses any statement but a declaration statement. Returns null if the lookahead looks like a declaration.
            </summary>
            <remarks>
            Variable declarations in global code are parsed as field declarations so we need to fallback if we encounter a declaration statement.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.InternalSyntax.LanguageParser.IsPossibleTypedIdentifierStart(Roslyn.Compilers.CSharp.InternalSyntax.SyntaxToken,Roslyn.Compilers.CSharp.InternalSyntax.SyntaxToken,System.Boolean)">
            <returns>
            true if the current token can be the first token of a typed identifier (a type name followed by an identifier),
            false if it definitely can't be,
            null if we need to scan further to find out.
            </returns>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.InternalSyntax.LanguageParser.ScanTypeFlags.NotType">
            <summary>
            Definitely not a type name.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.InternalSyntax.LanguageParser.ScanTypeFlags.MustBeType">
            <summary>
            Definitely a type name: either a predefined type (int, string, etc.) or an array type name (ending with a bracket).
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.InternalSyntax.LanguageParser.ScanTypeFlags.GenericTypeOrExpression">
            <summary>
            Might be a generic (qualified) type name or an expression.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.InternalSyntax.LanguageParser.ScanTypeFlags.NonGenericTypeOrExpression">
            <summary>
            Might be a non-generic (qualified) type name or an expression.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.InternalSyntax.LanguageParser.ScanTypeFlags.AliasQualifiedName">
            <summary>
            A type name with alias prefix (Alias::Name)
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.InternalSyntax.LanguageParser.ScanTypeFlags.NullableType">
            <summary>
            Nullable type (ending with ?).
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.InternalSyntax.LanguageParser.ScanTypeFlags.PointerOrMultiplication">
            <summary>
            Might be a pointer type or a multiplication.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.InternalSyntax.Lexer.ScanEndOfLine">
            <summary>
            Scans a new-line sequence (either a single new-line character or a CR-LF combo).
            </summary>
            <returns>A trivia node with the new-line text</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.InternalSyntax.Lexer.ScanWhitespace">
            <summary>
            Scans all of the whitespace (not new-lines) into a trivia node until it runs out.
            </summary>
            <returns>A trivia node with the whitespace text</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.InternalSyntax.Lexer.LexXmlToken">
            <summary>
            Lexer entry point for LexMode.XmlDocComment
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.InternalSyntax.Lexer.LexXmlElementTagToken">
            <summary>
            Lexer entry point for LexMode.XmlElementTag
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.InternalSyntax.Lexer.LexXmlAttributeTextToken">
            <summary>
            Lexer entry point for LexMode.XmlAttributeText
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.InternalSyntax.Lexer.LexXmlCDataSectionTextToken">
            <summary>
            Lexer entry point for LexMode.XmlCDataSectionText
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.InternalSyntax.Lexer.LexXmlCommentTextToken">
            <summary>
            Lexer entry point for LexMode.XmlCommentText
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.InternalSyntax.Lexer.LexXmlProcessingInstructionTextToken">
            <summary>
            Lexer entry point for LexMode.XmlProcessingInstructionText
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.InternalSyntax.Lexer.LexXmlDocCommentLeadingTrivia(Roslyn.Compilers.CSharp.InternalSyntax.SyntaxListBuilder@)">
            <summary>
            Collects XML doc comment exterior trivia, and therefore is a no op unless we are in the Start or Exterior of an XML doc comment.
            </summary>
            <param name="trivia">List in which to collect the trivia</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.InternalSyntax.Lexer.LexXmlWhitespaceAndNewLineTrivia(Roslyn.Compilers.CSharp.InternalSyntax.SyntaxListBuilder@)">
            <summary>
            Collects whitespace and new line trivia for XML doc comments. Does not see XML doc comment exterior trivia, and is a no op unless we are in the interior.
            </summary>
            <param name="trivia">List in which to collect the trivia</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compiler.CompileSynthesizedMethodMetadata(Roslyn.Compilers.CSharp.Compilation,Roslyn.Compilers.CSharp.Emit.Module,System.Threading.CancellationToken)">
            <summary>
            Traverse the symbol table and call Module.AddCompilerGeneratedDefinition for each
            synthesized explicit implementation stub that has been generated (e.g. when the real
            implementation doesn't have the appropriate custom modifiers).
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compiler.BindRegularCSharpFieldInitializers(Roslyn.Compilers.CSharp.Compilation,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.FieldInitializer}},Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.CSharp.BoundInitializer},Roslyn.Compilers.DiagnosticBag)">
            <summary>
            In regular C#, all field initializers are assignments to fields and the assigned expressions
            may not reference instance members.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compiler.BindScriptFieldInitializers(Roslyn.Compilers.CSharp.Compilation,Roslyn.Compilers.CSharp.MethodSymbol,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.FieldInitializer}},Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.CSharp.BoundInitializer},Roslyn.Compilers.DiagnosticBag)">
            <summary>
            In script C#, some field initializers are assignments to fields and others are global
            statements.  There are no restrictions on accessing instance members.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compiler.BindConstructorInitializer(Roslyn.Compilers.CSharp.MethodSymbol,Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.CSharp.Compilation)">
            <summary>
            Bind the (implicit or explicit) constructor initializer of a constructor symbol.
            </summary>
            <param name="constructor">Constructor method.</param>
            <param name="diagnostics">Accumulates errors (e.g. access "this" in constructor initializer).</param>
            <param name="compilation">Used to retrieve binder.</param>
            <returns>A bound expression for the constructor initializer call.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compiler.BindDefaultConstructorInitializer(Roslyn.Compilers.CSharp.MethodSymbol,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            If there's no syntax, we can't get a binder so we just loop over the base type's
            constructors explicitly, looking for one without parameters.
            </summary>
            <param name="constructor">Constructor with the initializer we're binding.</param>
            <param name="diagnostics">Accumulates errors (e.g. base constructor inaccessible).</param>
            <returns>A bound expression for the constructor initializer call.</returns>
            <remarks>
            This method should be kept consistent with Binder.BindConstructorInitializer (e.g. same error codes).
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compiler.MakeSubmissionInitialization(Roslyn.Compilers.CSharp.MethodSymbol,Roslyn.Compilers.CSharp.SynthesizedSubmissionFields,Roslyn.Compilers.CSharp.Compilation)">
            <summary>
            Generates a submission initialization part of a Script type constructor that represents an interactive submission.
            </summary>
            <remarks>
            The constructor takes a parameter of type <see cref="T:Roslyn.Scripting.Session"/> - the session reference.
            It adds the object being constructed into the session by calling <see cref="M:Microsoft.CSharp.RuntimeHelpers.SessionHelpers.SetSubmission(Roslyn.Scripting.Session,System.Int32,System.Object)"/>,
            and retrieves strongly typed references on all previous submission script classes whose members are referenced by this submission.
            The references are stored to fields of the submission (<paramref name="synthesizedFields"/>).
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Conversions.ResolveDelegateMethodGroup(Roslyn.Compilers.CSharp.Binder,Roslyn.Compilers.CSharp.BoundMethodGroup,Roslyn.Compilers.CSharp.MethodSymbol)">
            <summary>
            Resolve method group based on the optional delegate invoke method.
            If the invoke method is null, ignore arguments in resolution.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Conversions.GetDelegateInvokeMethodIfAvailable(Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            Return the Invoke method symbol if the type is a delegate
            type and the Invoke method is available, otherwise null.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticFacts.HaveSameSignature(Roslyn.Compilers.CSharp.MethodSymbol,Roslyn.Compilers.CSharp.MethodSymbol)">
            <summary>
            C#4 10.6: The name, the type parameter list and the formal parameter list of a method
            define the signature (§3.6) of the method. Specifically, the signature of a method
            consists of its name, the number of type parameters and the number, modifiers, and types
            of its formal parameters. For these purposes, any type parameter of the method that
            occurs in the type of a formal parameter is identified not by its name, but by its
            ordinal position in the type argument list of the method. The return type is not part of
            a method’s signature, nor are the names of the type parameters or the formal parameters.
            
            C#4 3.6: For the purposes of signatures, the types object and dynamic are considered the
            same. 
            
            C#4 3.6: We implement the rules for ref/out by mapping both to ref.  The caller (i.e.
            checking for proper overrides or partial methods, etc) should check that ref/out are
            consistent.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticFacts.HaveSameSignatureAndConstraintsAndReturnType(Roslyn.Compilers.CSharp.MethodSymbol,Roslyn.Compilers.CSharp.MethodSymbol)">
            <summary>
            Tests whether these two methods have the same signatures (see HaveSameSignature),
            constraints, and return type when comparing their signatures. For these purposes,
            any type parameter of the method that occurs in the constraints is identified not
            by its name, but by its ordinal position in the type argument list of the method.
            
            C#4 3.6: For the purposes of return type comparison, the types object and dynamic
            are considered the same. 
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticFacts.IsSymbolAccessible(Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.CSharp.NamedTypeSymbol,Roslyn.Compilers.CSharp.NamedTypeSymbol)">
            <summary>
            Checks if 'symbol' is accessible from within named type 'within'.  If 'symbol' is accessed off
            of an expression then 'throughTypeOpt' is the type of that expression. This is needed to
            properly do protected access checks.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticFacts.IsSymbolAccessible(Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.CSharp.AssemblySymbol)">
            <summary>
            Checks if 'symbol' is accessible from within assembly 'within'.  
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SynthesizedEntryPointSymbol">
            <summary>
            Represents an interactive code entry point that is inserted into the compilation if there is not an existing one. 
            
            private static void {Main}()
            {
                new {ThisScriptClass}();
            }
            
            or 
            
            private static T {Factory}(InteractiveSession session) 
            {
               T submissionResult;
               new {ThisScriptClass}(session, out submissionResult);
               return submissionResult;
            }
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourcePropertySymbol.IsAccessibilityMoreRestrictive(Roslyn.Compilers.CSharp.Accessibility,Roslyn.Compilers.CSharp.Accessibility)">
            <summary>
            Return true if the accessor accessibility is more restrictive
            than the property accessibility, otherwise false.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourcePropertySymbol.MakeSynthesizedSealedAccessor">
            <remarks>
            Only non-null for sealed properties without both accessors.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SourcePropertySymbol.SynthesizedSealedAccessorOpt">
            <summary>
            If this property is sealed, then we have to emit both accessors - regardless of whether
            they are present in the source - so that they can be marked final. (i.e. sealed).
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.IndexedTypeParameterSymbol">
            <summary>
            Indexed type parameters are used in place of type parameters for method signatures.  There is
            a unique mapping from index to a single IndexedTypeParameterSymbol.  
            
            They don't have a containing symbol or locations.
            
            They do not have constraints, variance, or attributes. 
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.IndexedTypeParameterSymbol.Take(System.Int32)">
            <summary>
            Create a vector of n dummy type parameters.  Always reuses the same type parameter symbol
            for the same position.
            </summary>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolExtensions.ArePropertyTypesEqual(Roslyn.Compilers.CSharp.PropertySymbol,Roslyn.Compilers.CSharp.PropertySymbol,System.Boolean)">
            <summary>
            Compare the types of two properties, optionally with respect to custom modifiers.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolExtensions.CustomModifierCount(Roslyn.Compilers.CSharp.MethodSymbol)">
            <summary>
            Count the number of custom modifiers in/on the return type
            and parameters of the specified method.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolExtensions.CustomModifierCount(Roslyn.Compilers.CSharp.PropertySymbol)">
            <summary>
            Count the number of custom modifiers in/on the type
            and parameters (for indexers) of the specified property.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolExtensions.HasCustomModifiers(Roslyn.Compilers.CSharp.MethodSymbol)">
            <summary>
            Count the number of custom modifiers in/on the return type
            and parameters of the specified method.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolExtensions.GetMemberArity(Roslyn.Compilers.CSharp.Symbol)">
            <summary>
            Return the arity of a member.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeSymbolExtensions.IsValidForAttributeArgument(Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.CSharp.Compilation)">
            <summary>
            Determines if the given type is a valid attribute argument type
            </summary>
            <param name="type">Type to validated</param>
            <param name="compilation">compilation</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeSymbolExtensions.ValidateAttributeArgumentType(Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.CSharp.Compilation)">
            <summary>
            Determines if the given type is a valid attribute argument type
            </summary>
            <param name="type">Type to validated</param>
            <param name="compilation">compilation</param>
            <returns>TypedConstantKind for the attribute argument type</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeSymbolExtensions.ContainsTypeParameter(Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.CSharp.TypeParameterSymbol)">
            <summary>
            (null TypeParameterSymbol "parameter"): Checks if the given type is a type parameter 
            or its referent type is a type parameter (array/pointer) or contains a type parameter (aggregate type)
            (non-null TypeParameterSymbol "parameter"): above + also checks if the type parameter
            is the same as "parameter"
            </summary>
            <param name="type"></param>
            <param name="parameter"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeSymbolExtensions.GetNonErrorGuess(Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            Guess the non-error type that the given type was intended to represent.
            If the type itself is not an error type, then it will be returned.
            Otherwise, the underlying type (if any) of the error type will be
            returned.
            </summary>
            <remarks>
            Any non-null type symbol returned is guaranteed not to be an error type.
            
            It is possible to pass in a constructed type and received back an 
            unconstructed type.  This can occur when the type passed in was
            constructed from an error type - the underlying definition will be
            available, but there won't be a good way to "re-substitute" back up
            to the level of the specified type.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeSymbolExtensions.GetNonErrorTypeKindGuess(Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            Guess the non-error typekind that the given type was intended to represent,
            if possible. If not, return TypeKind.Error.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeSymbolExtensions.ImplementsIDisposable(Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            Return true if the type implements the (special) System.IDisposable interface.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeSymbolExtensions.IsSameType(Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.CSharp.TypeSymbol,System.Boolean,System.Boolean)">
            <summary>
            Determines if two type symbols represent the same type, according to the language
            semantics.
            </summary>
            <param name="t1">First type.</param>
            <param name="t2">Second type.</param>
            <param name="ignoreCustomModifiers">True to compare without regard to custom modifiers, false by default.</param>
            <param name="ignoreDynamic">True to ignore the distinction between object and dynamic, false by default.</param>
            <returns>True if the types are equivalent.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeSymbolExtensions.IsSameTypeIgnoring(Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.CSharp.TypeSymbol,System.Boolean,System.Boolean)">
            <summary>
            Logical equality on TypeSymbols that ignores custom modifiers and/or the object/dynamic distinction.
            Differs from IsSameType for arrays, pointers, and generic instantiations.
            </summary>
            <remarks>
            Ported from VB.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeSymbolExtensions.CustomModifierCount(Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            Count the custom modifiers within the specified TypeSymbol.
            Potentially non-zero for arrays, pointers, and generic instantiations.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeSymbolExtensions.HasCustomModifiers(Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            Check for custom modifiers within the specified TypeSymbol.
            Potentially true for arrays, pointers, and generic instantiations.
            </summary>
            <remarks>
            A much less efficient implementation would be CustomModifierCount() == 0.
            CONSIDER: Could share a backing method with CustomModifierCount.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeSymbolExtensions.CanUnifyWith(Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            Return true if this type can unify with the specified type
            (i.e. is the same for some substitution of type parameters).
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeSymbolExtensions.GetNextBaseType(Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.ConsList{Roslyn.Compilers.CSharp.Symbol},Roslyn.Compilers.CSharp.Compilation,System.Collections.Generic.HashSet{Roslyn.Compilers.CSharp.Symbol}@)">
            <summary>
            Used when iterating through base types in contexts in which the caller needs to avoid cycles and can't use BaseType
            (perhaps because BaseType is in the process of being computed)
            </summary>
            <param name="type"></param>
            <param name="basesBeingResolved"></param>
            <param name="compilation"></param>
            <param name="visited"></param>
            <returns></returns>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LocalDeclarationStatementSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNodeExtensions.CanHaveAssociatedLocalBinder(Roslyn.Compilers.CSharp.SyntaxNode)">
            <summary>
            This method is used to keep the code that generates binders in sync
            with the code that searches for binders.  We don't want the searcher
            to skip over any nodes that could have associated binders, especially
            if changes are made later.
            
            "Local binder" is a vague term that refers to binders that represent
            scopes for names (e.g. BlockBinders) rather than binders that tweak
            default behaviors (e.g. FieldInitializerBinders).  Local binders are
            created by LocalBinderFactory.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SyntaxTriviaList">
            <summary>
            A List of SyntaxTrivia.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTriviaList.IndexOf(Roslyn.Compilers.CSharp.SyntaxTrivia)">
            <summary>
            Returns the index of the given SyntaxTrivia.
            </summary>
            <param name="trivia"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTriviaList.First">
            <summary>
            Returns the first SyntaxTrivia in the list.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTriviaList.FirstOrDefault">
            <summary>
            Returns the first SyntaxTrivia in the list or the default value of SyntaxTrivia if the list has no items.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTriviaList.Last">
            <summary>
            Returns the last SyntaxTrivia in the list. May throw ArgumentOutOfRange exception.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTriviaList.LastOrDefault">
            <summary>
            Returns the last SyntaxTrivia in the list or the default value of SyntaxTrivia if the list has no items.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTriviaList.Any">
            <summary>
            Does this list have any items.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTriviaList.Any(Roslyn.Compilers.CSharp.SyntaxKind)">
            <summary>
            Does this list contain any item of the given kind.
            </summary>
            <param name="kind"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTriviaList.GetEnumerator">
            <summary>
            Get an enumerator for this list.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTriviaList.CopyTo(System.Int32,Roslyn.Compilers.CSharp.SyntaxTrivia[],System.Int32,System.Int32)">
            <summary>
            Copy count number of items starting at offset from this list into array starting at arrayOffset.
            </summary>
            <param name="offset"></param>
            <param name="array"></param>
            <param name="arrayOffset"></param>
            <param name="count"></param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTriviaList.Equals(Roslyn.Compilers.CSharp.SyntaxTriviaList)">
            <summary>
            Compares equality between this list and other list.
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTriviaList.op_Equality(Roslyn.Compilers.CSharp.SyntaxTriviaList,Roslyn.Compilers.CSharp.SyntaxTriviaList)">
            <summary>
            Are two SyntaxTriviaLists, left and right equal.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTriviaList.op_Inequality(Roslyn.Compilers.CSharp.SyntaxTriviaList,Roslyn.Compilers.CSharp.SyntaxTriviaList)">
            <summary>
            Are two SyntaxTriviaLists, left and right not equal.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTriviaList.op_Implicit(Roslyn.Compilers.CSharp.SyntaxTrivia)~Roslyn.Compilers.CSharp.SyntaxTriviaList">
            <summary>
            Implicitly converts SyntaxTrivia to SyntaxTriviaList.
            </summary>
            <param name="trivia"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTriviaList.Equals(System.Object)">
            <summary>
            Is this list equal to the passed in object.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTriviaList.op_Addition(Roslyn.Compilers.CSharp.SyntaxTriviaList,Roslyn.Compilers.CSharp.SyntaxTriviaList)">
            <summary>
            Adds two SyntaxTriviaLists, list1 and list2 into a new SyntaxTriviaList and returns it.
            </summary>
            <param name="list1"></param>
            <param name="list2"></param>
            <returns></returns>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.SyntaxTriviaList.Empty">
            <summary>
            Default instance of SyntaxTriviaList.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxTriviaList.Count">
            <summary>
            Count of items in the list.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxTriviaList.Item(System.Int32)">
            <summary>
            Returns the SyntaxTrivia at this index.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxTriviaList.HasDiagnostics">
            <summary>
            Does any SyntaxTrivia in this list has diagnostics.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SyntaxTriviaList.Enumerator">
            <remarks>
            We could implement the enumerator using the indexer of the SyntaxTriviaList, but then
            every node's offset would be computed separately.  Since we know that we will be accessing
            the nodes in order, we can maintain a running offset value ourselves and avoid this
            overhead.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTriviaList.Enumerator.MoveNext">
            <summary>
            Move to the next item in the list.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxTriviaList.Enumerator.Current">
            <summary>
            The SyntaxTrivia item at the current location.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.LookupPosition">
            <summary>
            This class contains a variety of helper methods for determining whether a
            position is within the scope (and not just the span) of a node.  In general,
            general, the scope extends from the first token up to, but not including,
            the last token.  For example, the open brace of a block is within the scope
            of the block, but the close brace is not.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LookupPosition.IsInBlock(System.Int32,Roslyn.Compilers.CSharp.BlockSyntax)">
            <summary>
            A position is considered to be inside a block if it is on or after
            the open brace and strictly before the close brace.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LookupPosition.IsInStatementScope(System.Int32,Roslyn.Compilers.CSharp.StatementSyntax)">
            <remarks>
            Used to determine whether it would be appropriate to use the binder for the statement (if any).
            Not used to determine whether the position is syntactically within the statement.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LookupPosition.IsInCatchClauseScope(System.Int32,Roslyn.Compilers.CSharp.CatchClauseSyntax)">
            <remarks>
            Used to determine whether it would be appropriate to use the binder for the statement (if any).
            Not used to determine whether the position is syntactically within the statement.
            </remarks>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ThreeState">
            <summary>
            Represent an optional bool as a single byte.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeUnification.CanUnify(Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            Determine whether there is any substitution of type parameters that will
            make two types identical.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeUnification.CanUnifyHelper(Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.CSharp.MutableTypeMap@)">
            <summary>
            Determine whether there is any substitution of type parameters that will
            make two types identical.
            </summary>
            <param name="t1">LHS</param>
            <param name="t2">RHS</param>
            <param name="substitution">
            Substitutions performed so far (or null for none).
            Keys are type parameters, values are types (possibly type parameters).
            Will be updated with new subsitutions by the callee.
            Should be ignored when false is returned.
            </param>
            <returns>True if there exists a type map such that Map(LHS) == Map(RHS).</returns>
            <remarks>
            Derived from Dev10's BSYMMGR::UnifyTypes.
            Two types will not unify if they have different custom modifiers.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeUnification.Contains(Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.CSharp.TypeParameterSymbol)">
            <summary>
            Return true if the given type contains the specified type parameter.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.CompilationReference">
            <summary>
            Represents a reference to another Compilation. 
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CompilationReference.#ctor(Roslyn.Compilers.CSharp.Compilation,System.Boolean,System.String)">
            <summary>
            Create a CompilationReference.
            </summary>
            <param name="compilation">The compilation to reference.</param>
            <param name="embedInteropTypes">Should interop types be embedded in the created assembly?</param>
            <param name="alias">A namespace alias for this reference.</param>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.CompilationReference.Compilation">
            <summary>
            Returns the referenced Compilation.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.CompilationStage">
            <summary>
            Represents the possible compilation stages for which it is possible to get diagnostics
            (errors).
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SubstitutedNestedTypeSymbol">
            <summary>
            A named type symbol that results from substituting a new owner for a type declaration.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SubstitutedNamedTypeSymbol">
            <summary>
            Either a SubstitutedNestedTypeSymbol or a ConstructedNamedTypeSymbol, which share in common that they
            have type parameters substituted.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ConstructedNamedTypeSymbol">
            <summary>
            A generic named type symbol that has been constructed with type arguments distinct from its own type parameters.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ErrorTypeSymbol">
            <summary>
            An ErrorSymbol is used when the compiler cannot determine a symbol object to return because
            of an error. For example, if a field is declared "Foo x;", and the type "Foo" cannot be
            found, an ErrorSymbol is returned when asking the field "x" what it's type is.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ErrorTypeSymbol.GetMembers(System.Threading.CancellationToken)">
            <summary>
            Get all the members of this symbol.
            </summary>
            <returns>A ReadOnlyArray containing all the members of this symbol. If this symbol has no members,
            returns an empty ReadOnlyArray. Never returns Null.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ErrorTypeSymbol.GetMembers(System.String,System.Threading.CancellationToken)">
            <summary>
            Get all the members of this symbol that have a particular name.
            </summary>
            <returns>A ReadOnlyArray containing all the members of this symbol with the given name. If there are
            no members with this name, returns an empty ReadOnlyArray. Never returns Null.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ErrorTypeSymbol.GetTypeMembers(System.Threading.CancellationToken)">
            <summary>
            Get all the members of this symbol that are types.
            </summary>
            <returns>An IEnumerable containing all the types that are members of this symbol. If this symbol has no type members,
            returns an empty IEnumerable. Never returns Nothing.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ErrorTypeSymbol.GetTypeMembers(System.String,System.Threading.CancellationToken)">
            <summary>
            Get all the members of this symbol that are types that have a particular name, of any arity.
            </summary>
            <returns>A ReadOnlyArray containing all the types that are members of this symbol with the given name.
            If this symbol has no type members with this name,
            returns an empty ReadOnlyArray. Never returns Null.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ErrorTypeSymbol.GetTypeMembers(System.String,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Get all the members of this symbol that are types that have a particular name and arity
            </summary>
            <returns>An IEnumerable containing all the types that are members of this symbol with the given name and arity.
            If this symbol has no type members with this name and arity,
            returns an empty IEnumerable. Never returns Nothing.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ErrorTypeSymbol.Accept``2(Roslyn.Compilers.CSharp.SymbolVisitor{``0,``1},``0)">
            <summary>
            Implements visitor pattern.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ErrorTypeSymbol.ErrorInfo">
            <summary>
            The underlying error.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ErrorTypeSymbol.ResultKind">
            <summary>
            Summary of the reason why the type is bad.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ErrorTypeSymbol.CandidateSymbols">
            <summary>
            If applicable, candidate (non-error) symbols that might have been what the user intended.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ErrorTypeSymbol.IsReferenceType">
            <summary>
            Returns true if this type is known to be a reference type. It is never the case that
            IsReferenceType and IsValueType both return true. However, for an unconstrained type
            parameter, IsReferenceType and IsValueType will both return false.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ErrorTypeSymbol.IsValueType">
            <summary>
            Returns true if this type is known to be a value type. It is never the case that
            IsReferenceType and IsValueType both return true. However, for an unconstrained type
            parameter, IsReferenceType and IsValueType will both return false.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ErrorTypeSymbol.MemberNames">
            <summary>
            Collection of names of members declared within this type.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ErrorTypeSymbol.Kind">
            <summary>
            Gets the kind of this symbol.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ErrorTypeSymbol.TypeKind">
            <summary>
            Gets the kind of this type.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ErrorTypeSymbol.ContainingSymbol">
            <summary>
            Get the symbol that logically contains this symbol. 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ErrorTypeSymbol.Locations">
            <summary>
            Gets the locations where this symbol was originally defined, either in source or
            metadata. Some symbols (for example, partial classes) may be defined in more than one
            location.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ErrorTypeSymbol.Arity">
            <summary>
            Returns the arity of this type, or the number of type parameters it takes.
            A non-generic type has zero arity.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ErrorTypeSymbol.Name">
            <summary>
            Gets the name of this symbol. Symbols without a name return the empty string; null is
            never returned.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ErrorTypeSymbol.TypeArguments">
            <summary>
            Returns the type arguments that have been substituted for the type parameters. 
            If nothing has been substituted for a give type parameters,
            then the type parameter itself is consider the type argument.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ErrorTypeSymbol.TypeParameters">
            <summary>
            Returns the type parameters that this type has. If this is a non-generic type,
            returns an empty ReadOnlyArray.  
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ErrorTypeSymbol.ConstructedFrom">
            <summary>
            Returns the type symbol that this type was constructed from. This type symbol
            has the same containing type (if any), but has type arguments that are the same
            as the type parameters (although its containing type might not).
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ErrorTypeSymbol.DeclaredAccessibility">
            <summary>
            Get this accessibility that was declared on this symbol. For symbols that do not have
            accessibility declared on them, returns NotApplicable.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ErrorTypeSymbol.IsStatic">
            <summary>
            Returns true if this symbol is "static"; i.e., declared with the "static" modifier or
            implicitly static.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ErrorTypeSymbol.IsAbstract">
            <summary>
            Returns true if this symbol was declared as requiring an override; i.e., declared with
            the "abstract" modifier. Also returns true on a type declared as "abstract", all
            interface types, and members of interface types.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ErrorTypeSymbol.IsSealed">
            <summary>
            Returns true if this symbol was declared to override a base class member and was also
            sealed from further overriding; i.e., declared with the "sealed" modifier.  Also set for
            types that do not allow a derived class (declared with "sealed" or "static" or "struct"
            or "enum" or "delegate").
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ErrorTypeSymbol.SpecialType">
            <summary>
            Gets corresponding special TypeId of this type.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.MergedNamespaceSymbol">
            <summary>
            A MergedNamespaceSymbol represents a namespace that merges the contents of two or more other
            namespaces. Any sub-namespaces with the same names are also merged if they have two or more
            instances.
            
            Merged namespaces are used to merged the symbols from multiple metadata modules and the
            source "module" into a single symbol tree that represents all the available symbols. The
            compiler resolves names against this merged set of symbols.
            
            Typically there will not be very many merged namespaces in a Compilation: only the root
            namespaces and namespaces that are used in multiple referenced modules. (Microsoft, System,
            System.Xml, System.Diagnostics, System.Threading, ...)
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MergedNamespaceSymbol.Create(Roslyn.Compilers.CSharp.NamespaceExtent,Roslyn.Compilers.CSharp.NamespaceSymbol,System.Collections.Generic.IEnumerable{Roslyn.Compilers.CSharp.NamespaceSymbol},System.String)">
            <summary>
            Create a possibly merged namespace symbol. If only a single namespace is passed it, it
            is just returned directly. If two or more namespaces are passed in, then a new merged
            namespace is created with the given extent and container.
            </summary>
            <param name="extent">The namespace extent to use, IF a merged namespace is created.</param>
            <param name="containingNamespace">The containing namespace to used, IF a merged
            namespace is created.</param>
            <param name="namespacesToMerge">One or more namespaces to merged. If just one, then it
            is returned. The merged namespace symbol may hold onto the array.</param>
            <param name="nameOpt">An optional name to give the resulting namespace.</param>
            <returns>A namespace symbol representing the merged namespace.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MergedNamespaceSymbol.SlowGetChildrenOfName(System.String)">
            <summary>
            Method that is called from the CachingLookup to lookup the children of a given name.
            Looks in all the constituent namespaces.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MergedNamespaceSymbol.SlowGetChildNames">
            <summary>
            Method that is called from the CachingLookup to get all child names. Looks in all
            constituent namespaces.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Metadata.PE.PEAssemblySymbol">
            <summary>
            Represents an assembly imported from a PE.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.MetadataOrSourceAssemblySymbol">
            <summary>
            Represents source or metadata assembly.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MetadataOrSourceAssemblySymbol.lazySpecialTypes">
            <summary>
            An array of cached Cor types defined in this assembly.
            Lazily filled by GetSpecialType method.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MetadataOrSourceAssemblySymbol.cachedSpecialTypes">
            <summary>
            How many Cor types have we cached so far.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MetadataOrSourceAssemblySymbol.GetDeclaredSpecialType(Roslyn.Compilers.SpecialType)">
            <summary>
            Lookup declaration for predefined CorLib type in this Assembly.
            </summary>
            <param name="type"></param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MetadataOrSourceAssemblySymbol.RegisterDeclaredSpecialType(Roslyn.Compilers.CSharp.NamedTypeSymbol)">
            <summary>
            Register declaration of predefined CorLib type in this Assembly.
            </summary>
            <param name="corType"></param>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MetadataOrSourceAssemblySymbol.lazySpecialTypeMembers">
            <summary>
            Not yet known value is represented by ErrorTypeSymbol.UnknownResultType
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MetadataOrSourceAssemblySymbol.GetDeclaredSpecialTypeMember(Roslyn.Compilers.SpecialMember)">
            <summary>
            Lookup member declaration in predefined CorLib type in this Assembly. Only valid if this 
            assembly is the Cor Library
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MetadataOrSourceAssemblySymbol.KeepLookingForDeclaredSpecialTypes">
            <summary>
            Continue looking for declaration of predefined CorLib type in this Assembly
            while symbols for new type declarations are constructed.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Metadata.PE.PEAssemblySymbol.assembly">
            <summary>
            An Assembly object providing metadata for the assembly.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Metadata.PE.PEAssemblySymbol.documentationProvider">
            <summary>
            An IMetadataDocumentationProvider providing XML documentation for this assembly.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Metadata.PE.PEAssemblySymbol.modules">
            <summary>
            The list of contained PEModuleSymbol objects.
            The list doesn't use type ReadOnlyCollection(Of PEModuleSymbol) so that we
            can return it from Modules property as is.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Metadata.PE.PEAssemblySymbol.noPiaResolutionAssemblies">
            <summary>
            An array of assemblies involved in canonical type resolution of
            NoPia local types defined within this assembly. In other words, all 
            references used by a compilation referencing this assembly.
            The array and its content is provided by AssemblyManager and must not be modified.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Metadata.PE.PEAssemblySymbol.linkedReferencedAssemblies">
            <summary>
            An array of assemblies referenced by this assembly, which are linked (/l-ed) by 
            each compilation that is using this AssemblySymbol as a reference. 
            If this AssemblySymbol is linked too, it will be in this array too.
            The array and its content is provided by AssemblyManager and must not be modified.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Metadata.PE.PEAssemblySymbol.isLinked">
            <summary>
            Assembly is /l-ed by compilation that is using it as a reference.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Metadata.PE.PEAssemblySymbol.lazyCustomAttributes">
            <summary>
            Assembly's custom attributes
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Metadata.PE.PEFieldSymbol">
            <summary>
            The class to represent all fields imported from a PE/module.
            </summary>
            <remarks></remarks>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Metadata.PE.PENamespaceSymbol">
            <summary>
            The base class to represent a namespace imported from a PE/module. Namespaces that differ
            only by casing in name are not merged.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Metadata.PE.PENamespaceSymbol.lazyNamespaces">
            <summary>
            A map of namespaces immediately contained within this namespace 
            mapped by their name (case-sensitively).
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Metadata.PE.PENamespaceSymbol.lazyTypes">
            <summary>
            A map of types immediately contained within this namespace 
            grouped by their name (case-sensitively).
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Metadata.PE.PENamespaceSymbol.LoadAllMembers(System.Collections.Generic.IEnumerable{System.Linq.IGrouping{System.String,System.UInt32}})">
            <summary>
            Initializes namespaces and types maps with information about 
            namespaces and types immediately contained within this namespace.
            </summary>
            <param name="typesByNS">
            The sequence of groups of TypeDef row ids for types contained within the namespace, 
            recursively including those from nested namespaces. The row ids must be grouped by the 
            fully-qualified namespace name case-sensitively. There could be multiple groups 
            for each fully-qualified namespace name. The groups must be sorted by
            their key in case-sensitive manner. Empty string must be used as namespace name for types 
            immediately contained within Global namespace. Therefore, all types in this namespace, if any, 
            must be in several first IGroupings.
            </param>
            <remarks></remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Metadata.PE.PENamespaceSymbol.LazyInitializeNamespaces(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Collections.Generic.IEnumerable{System.Linq.IGrouping{System.String,System.UInt32}}}})">
            <summary>
            Create symbols for nested namespaces and initialize namespaces map.
            </summary>
            <param name="childNamespaces"></param>
            <remarks></remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Metadata.PE.PENamespaceSymbol.LazyInitializeTypes(System.Collections.Generic.IEnumerable{System.Linq.IGrouping{System.String,System.UInt32}})">
            <summary>
            Create symbols for nested types and initialize types map.
            </summary>
            <param name="typeGroups"></param>
            <remarks></remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Metadata.PE.PENamespaceSymbol.ContainingPEModule">
            <summary>
            Returns PEModuleSymbol containing the namespace.
            </summary>
            <returns>PEModuleSymbol containing the namespace.</returns>
            <remarks></remarks>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Metadata.PE.PEGlobalNamespaceSymbol.moduleSymbol">
            <summary>
            The module containing the namespace.
            </summary>
            <remarks></remarks>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Metadata.PE.PEMethodSymbol">
            <summary>
            The class to represent all methods imported from a PE/module.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Metadata.PE.PEMethodSymbol.SetAssociatedProperty(Roslyn.Compilers.CSharp.Metadata.PE.PEPropertySymbol,Roslyn.Compilers.CSharp.MethodKind)">
            <summary>
            Associate the method with a particular property. Returns
            false if the method is already associated with a property.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Metadata.PE.PEModuleSymbol">
            <summary>
            Represents a net-module imported from a PE. Can be a primary module of an assembly.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Metadata.PE.PEModuleSymbol.assemblySymbol">
            <summary>
            Owning AssemblySymbol. This can be a PEAssemblySymbol or a SourceAssemblySymbol.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Metadata.PE.PEModuleSymbol.module">
            <summary>
            A Module object providing metadata.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Metadata.PE.PEModuleSymbol.globalNamespace">
            <summary>
            Global namespace.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Metadata.PE.PEModuleSymbol.lazySystemTypeSymbol">
            <summary>
            Cache the symbol for well-known type System.Type because we use it frequently
            (for attributes).
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Metadata.PE.PEModuleSymbol.TypeDefRowIdToTypeMap">
            <summary>
            This is a map from TypeDef row id to the target TypeSymbol. 
            It is used by MetadataDecoder to speed-up type reference resolution
            for metadata coming from this module. The map is lazily populated
            as we load types from the module.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Metadata.PE.PEModuleSymbol.TypeRefRowIdToTypeMap">
            <summary>
            This is a map from TypeRef row id to the target TypeSymbol. 
            It is used by MetadataDecoder to speed-up type reference resolution
            for metadata coming from this module. The map is lazily populated
            by MetadataDecoder as we resolve TypeRefs from the module.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Metadata.PE.PEModuleSymbol.lazyCustomAttributes">
            <summary>
            Module's custom attributes
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Metadata.PE.PENamedTypeSymbol">
            <summary>
            The class to represent all types imported from a PE/module.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Metadata.PE.PENamedTypeSymbol.lazyNestedTypes">
            <summary>
            A map of types immediately contained within this type 
            grouped by their name (case-sensitively).
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Metadata.PE.PENamedTypeSymbol.lazyMemberNames">
            <summary>
            A set of all the names of the members in this type.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Metadata.PE.PENamedTypeSymbol.lazyMembers">
            <summary>
            A map of members immediately contained within this type 
            grouped by their name (case-sensitively).
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Metadata.PE.PENamedTypeSymbol.lazyKind">
            <summary>
            Lazily initialized by TypeKind property.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Metadata.PE.PENamedTypeSymbol.lazyContainsExtensionMethods">
            <summary>
            Lazily initialized by MightContainExtensionMethods property.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Metadata.PE.PENestedNamespaceSymbol">
            <summary>
            The class to represent all, but Global, namespaces imported from a PE/module.
            Namespaces that differ only by casing in name are not merged.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Metadata.PE.PENestedNamespaceSymbol.containingNamespaceSymbol">
            <summary>
            The parent namespace. There is always one, Global namespace contains all
            top level namespaces. 
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Metadata.PE.PENestedNamespaceSymbol.name">
            <summary>
            The name of the namespace.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Metadata.PE.PENestedNamespaceSymbol.typesByNS">
            <summary>
            The sequence of groups of TypeDef row ids for types contained within the namespace, 
            recursively including those from nested namespaces. The row ids are grouped by the 
            fully-qualified namespace name case-sensitively. There could be multiple groups 
            for each fully-qualified namespace name. The groups are sorted by their 
            key in case-sensitive manner. Empty string is used as namespace name for types 
            immediately contained within Global namespace. Therefore, all types in this namespace, if any, 
            will be in several first IGroupings.
            
            This member is initialized by constructor and is cleared in EnsureAllMembersLoaded 
            as soon as symbols for children are created.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Metadata.PE.PENestedNamespaceSymbol.#ctor(System.String,Roslyn.Compilers.CSharp.Metadata.PE.PENamespaceSymbol,System.Collections.Generic.IEnumerable{System.Linq.IGrouping{System.String,System.UInt32}})">
            <summary>
            Constructor.
            </summary>
            <param name="name">
            Name of the namespace, must be not empty.
            </param>
            <param name="containingNamespace">
            Containing namespace.
            </param>
            <param name="typesByNS">
            The sequence of groups of TypeDef row ids for types contained within the namespace, 
            recursively including those from nested namespaces. The row ids are grouped by the 
            fully-qualified namespace name case-sensitively. There could be multiple groups 
            for each fully-qualified namespace name. The groups are sorted by their 
            key in case-sensitive manner. Empty string is used as namespace name for types 
            immediately contained within Global namespace. Therefore, all types in this namespace, if any, 
            will be in several first IGroupings.
            </param>
            <remarks></remarks>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Metadata.PE.PEParameterSymbol">
            <summary>
            The class to represent all method parameters imported from a PE/module.
            </summary>
            <remarks></remarks>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Metadata.PE.PEPropertySymbol">
            <summary>
            The class to represent all properties imported from a PE/module.
            </summary>
            <remarks></remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Metadata.PE.PEPropertySymbol.ExplicitInterfaceImplementations">
            <summary>
            Intended behavior: this property, P, explicitly implements an interface property, IP, 
            if any of the following is true:
            
            1) P.get explicitly implements IP.get and P.set explicitly implements IP.set
            2) P.get explicitly implements IP.get and there is no IP.set
            3) P.set explicitly implements IP.set and there is no IP.get
            
            Extra or missing accessors will not result in errors, P will simply not report that
            it explicitly implements IP.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Metadata.PE.PETypeParameterSymbol">
            <summary>
            The class to represent all generic type parameters imported from a PE/module.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Metadata.PE.PETypeParameterSymbol.lazyConstraintTypes">
            <summary>
            Lazily initialized by EnsureConstraintTypesAreLoaded.
            </summary>
            <remarks></remarks>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.MissingMetadataTypeSymbol">
            <summary>
            A <see cref="T:Roslyn.Compilers.CSharp.MissingMetadataTypeSymbol"/> is a special kind of <see cref="T:Roslyn.Compilers.CSharp.ErrorTypeSymbol"/> that represents
            a type symbol that was attempted to be read from metadata, but couldn't be
            found, because:
              a) The metadata file it lives in wasn't referenced
              b) The metadata file was referenced, but didn't contain the type
              c) The metadata file was referenced, contained the correct outer type, but
                 didn't contains a nested type in that outer type.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MissingMetadataTypeSymbol.Arity">
            <summary>
            Get the arity of the missing type.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.MissingMetadataTypeSymbol.TopLevel">
            <summary>
            Represents not nested missing type.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MissingMetadataTypeSymbol.TopLevel.lazyTypeId">
            <summary>
            CorLibTypes.TypeId
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MissingMetadataTypeSymbol.TopLevel.NamespaceName">
            <summary>
            This is the FULL namespace name (e.g., "System.Collections.Generic")
            of the type that couldn't be found.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.MissingMetadataTypeSymbol.Nested">
            <summary>
            Represents nested missing type.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.NamespaceExtent">
            <summary>
            A NamespaceExtent represents whether a namespace contains types and sub-namespaces from a
            particular module, assembly, or merged across all modules (source and metadata) in a
            particular compilation.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamespaceExtent.#ctor(Roslyn.Compilers.CSharp.ModuleSymbol)">
            <summary>
            Create a NamespaceExtent that represents a given ModuleSymbol.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamespaceExtent.#ctor(Roslyn.Compilers.CSharp.AssemblySymbol)">
            <summary>
            Create a NamespaceExtent that represents a given AssemblySymbol.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamespaceExtent.#ctor(Roslyn.Compilers.CSharp.Compilation)">
            <summary>
            Create a NamespaceExtent that represents a given Compilation.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamespaceExtent.Kind">
            <summary>
            Returns what kind of extent: Module, Assembly, or Compilation.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamespaceExtent.Module">
            <summary>
            If the Kind is ExtendKind.Module, returns the module symbol that this namespace
            encompasses. Otherwise throws InvalidOperationException.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamespaceExtent.Assembly">
            <summary>
            If the Kind is ExtendKind.Assembly, returns the assembly symbol that this namespace
            encompasses. Otherwise throws InvalidOperationException.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamespaceExtent.Compilation">
            <summary>
            If the Kind is ExtendKind.Compilation, returns the compilation symbol that this
            namespace encompasses. Otherwise throws InvalidOperationException.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.NamespaceExtent.ExtentKind">
            <summary>
            Describes the kind of the namespace extent.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.NoPiaAmbiguousCanonicalTypeSymbol">
            <summary>
            A NoPiaAmbiguousCanonicalTypeSymbol is a special kind of ErrorSymbol that represents a NoPia
            embedded type symbol that was attempted to be substituted with canonical type, but the
            canonocal type was ambiguous.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.NoPiaIllegalGenericInstantiationSymbol">
            <summary>
            A NoPiaIllegalGenericInstantiationSymbol is a special kind of ErrorSymbol that represents a
            generic type instantiation that cannot cross assembly boundaries according to NoPia rules.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.NoPiaMissingCanonicalTypeSymbol">
            <summary>
            A NoPiaMissingCanonicalTypeSymbol is a special kind of ErrorSymbol that represents a NoPia
            embedded type symbol that was attempted to be substituted with canonical type, but the
            canonocal type couldn't be found.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Retargeting.RetargetingAssemblySymbol">
            <summary>
            Essentially this is a wrapper around another AssemblySymbol that is responsible for retargeting
            symbols from one assembly to another. It can retarget symbols for multiple assemblies at the same time. 
            
            For example, compilation C1 references v1 of Lib.dll and compilation C2 references C1 and v2 of Lib.dll. 
            In this case, in context of C2, all types from v1 of Lib.dll leaking through C1 (through method 
            signatures, etc.) must be retargeted to the types from v2 of Lib.dll. This is what 
            RetargetingAssemblySymbol is responsible for. In the example above, modules in C2 do not 
            reference C1.m_AssemblySymbol, but reference a special RetargetingAssemblySymbol created for 
            C1 by AssemblyManager.
            
            Here is how retargeting is implemented in general:
            - Symbols from underlying assembly are substituted with retargeting symbols.
            - Symbols from referenced assemblies that can be reused as is (i.e. doesn't have to be retargeted) are
              used as is.
            - Symbols from referenced assemblies that must be retargeted are substituted with result of retargeting.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Retargeting.RetargetingAssemblySymbol.underlyingAssembly">
            <summary>
            The underlying AssemblySymbol, it leaks symbols that should be retargeted.
            This cannot be an instance of RetargetingAssemblySymbol.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Retargeting.RetargetingAssemblySymbol.modules">
            <summary>
            The list of contained ModuleSymbol objects. First item in the list
            is RetargetingModuleSymbol that wraps corresponding SourceModuleSymbol 
            from underlyingAssembly.Modules list, the rest are PEModuleSymbols for 
            added modules.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Retargeting.RetargetingAssemblySymbol.noPiaResolutionAssemblies">
            <summary>
            An array of assemblies involved in canonical type resolution of
            NoPia local types defined within this assembly. In other words, all 
            references used by a compilation referencing this assembly.
            The array and its content is provided by AssemblyManager and must not be modified.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Retargeting.RetargetingAssemblySymbol.linkedReferencedAssemblies">
            <summary>
            An array of assemblies referenced by this assembly, which are linked (/l-ed) by 
            each compilation that is using this AssemblySymbol as a reference. 
            If this AssemblySymbol is linked too, it will be in this array too.
            The array and its content is provided by AssemblyManager and must not be modified.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Retargeting.RetargetingAssemblySymbol.NoPiaUnificationMap">
            <summary>
            A map from a local NoPia type to corresponding canonical type.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Retargeting.RetargetingAssemblySymbol.isLinked">
            <summary>
            Assembly is /l-ed by compilation that is using it as a reference.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Retargeting.RetargetingAssemblySymbol.#ctor(Roslyn.Compilers.CSharp.SourceAssemblySymbol,System.Boolean)">
            <summary>
            Constructor.
            </summary>
            <param name="underlyingAssembly">
            The underlying AssemblySymbol, cannot be an instance of RetargetingAssemblySymbol.
            </param>
            <param name="isLinked">
            Assembly is /l-ed by compilation that is using it as a reference.
            </param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Retargeting.RetargetingAssemblySymbol.GetDeclaredSpecialType(Roslyn.Compilers.SpecialType)">
            <summary>
            Lookup declaration for FX type in this Assembly.
            </summary>
            <param name="type"></param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Retargeting.RetargetingAssemblySymbol.UnderlyingAssembly">
            <summary>
            The underlying AssemblySymbol.
            This cannot be an instance of RetargetingAssemblySymbol.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Retargeting.RetargetingFieldSymbol">
            <summary>
            Represents a field in a RetargetingModuleSymbol. Essentially this is a wrapper around 
            another FieldSymbol that is responsible for retargeting symbols from one assembly to another. 
            It can retarget symbols for multiple assemblies at the same time.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Retargeting.RetargetingFieldSymbol.retargetingModule">
            <summary>
            Owning RetargetingModuleSymbol.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Retargeting.RetargetingFieldSymbol.underlyingField">
            <summary>
            The underlying FieldSymbol, cannot be another RetargetingFieldSymbol.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Retargeting.RetargetingMethodSymbol">
            <summary>
            Represents a method in a RetargetingModuleSymbol. Essentially this is a wrapper around 
            another MethodSymbol that is responsible for retargeting symbols from one assembly to another. 
            It can retarget symbols for multiple assemblies at the same time.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Retargeting.RetargetingMethodSymbol.retargetingModule">
            <summary>
            Owning RetargetingModuleSymbol.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Retargeting.RetargetingMethodSymbol.underlyingMethod">
            <summary>
            The underlying MethodSymbol, cannot be another RetargetingMethodSymbol.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Retargeting.RetargetingModuleSymbol">
            <summary>
            Represents a primary module of a RetargetingAssemblySymbol. Essentially this is a wrapper around 
            another SourceModuleSymbol that is responsible for retargeting symbols from one assembly to another. 
            It can retarget symbols for multiple assemblies at the same time.
            
            Here is how retargeting is implemented in general:
            - Symbols from underlying module are substituted with retargeting symbols.
            - Symbols from referenced assemblies that can be reused as is (i.e. don't have to be retargeted) are
              used as is.
            - Symbols from referenced assemblies that must be retargeted are substituted with result of retargeting.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Retargeting.RetargetingModuleSymbol.retargetingAssembly">
            <summary>
            Owning RetargetingAssemblySymbol.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Retargeting.RetargetingModuleSymbol.underlyingModule">
            <summary>
            The underlying ModuleSymbol, cannot be another RetargetingModuleSymbol.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Retargeting.RetargetingModuleSymbol.retargetingAssemblyMap">
            <summary>
            The map that captures information about what assembly should be retargeted 
            to what assembly. Key is the AssemblySymbol the underlying module references,
            value is the corresponding AssemblySymbol this module references and corresponding
            retargeting map for symbols.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Retargeting.RetargetingModuleSymbol.SymbolMap">
            <summary>
            Retargeting map from underlying module to this one.
            
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Retargeting.RetargetingModuleSymbol.#ctor(Roslyn.Compilers.CSharp.Retargeting.RetargetingAssemblySymbol,Roslyn.Compilers.CSharp.SourceModuleSymbol)">
            <summary>
            Constructor.
            </summary>
            <param name="retargetingAssembly">
            Owning assembly.
            </param>
            <param name="underlyingModule">
            The underlying ModuleSymbol, cannot be another RetargetingModuleSymbol.
            </param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Retargeting.RetargetingModuleSymbol.SetReferences(Roslyn.Compilers.ReadOnlyArray{System.Reflection.AssemblyName},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.AssemblySymbol})">
            <summary>
            A helper method for AssemblyManager to set AssemblySymbols for assemblies 
            referenced by this module.
            </summary>
            <param name="names"></param>
            <param name="symbols"></param>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Retargeting.RetargetingModuleSymbol.UnderlyingModule">
            <summary>
            The underlying ModuleSymbol, cannot be another RetargetingModuleSymbol.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Retargeting.RetargetingNamedTypeSymbol">
            <summary>
            Represents a type of a RetargetingModuleSymbol. Essentially this is a wrapper around 
            another NamedTypeSymbol that is responsible for retargeting referenced symbols from one assembly to another. 
            It can retarget symbols for multiple assemblies at the same time.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Retargeting.RetargetingNamedTypeSymbol.retargetingModule">
            <summary>
            Owning RetargetingModuleSymbol.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Retargeting.RetargetingNamedTypeSymbol.underlyingType">
            <summary>
            The underlying NamedTypeSymbol, cannot be another RetargetingNamedTypeSymbol.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Retargeting.RetargetingNamespaceSymbol">
            <summary>
            Represents a namespace of a RetargetingModuleSymbol. Essentially this is a wrapper around 
            another NamespaceSymbol that is responsible for retargeting symbols from one assembly to another. 
            It can retarget symbols for multiple assemblies at the same time.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Retargeting.RetargetingNamespaceSymbol.retargetingModule">
            <summary>
            Owning RetargetingModuleSymbol.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Retargeting.RetargetingNamespaceSymbol.underlyingNamespace">
            <summary>
            The underlying NamespaceSymbol, cannot be another RetargetingNamespaceSymbol.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Retargeting.RetargetingParameterSymbol">
            <summary>
            Represents a parameter of a RetargetingMethodSymbol. Essentially this is a wrapper around 
            another ParameterSymbol that is responsible for retargeting symbols from one assembly to another. 
            It can retarget symbols for multiple assemblies at the same time.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Retargeting.RetargetingParameterSymbol.retargetingMethod">
            <summary>
            Owning RetargetingMethodSymbol.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Retargeting.RetargetingParameterSymbol.underlyingParameter">
            <summary>
            The underlying ParameterSymbol, cannot be another RetargetingParameterSymbol.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Retargeting.RetargetingTypeParameterSymbol">
            <summary>
            Represents a type parameter in a RetargetingModuleSymbol. Essentially this is a wrapper around 
            another TypeParameterSymbol that is responsible for retargeting symbols from one assembly to another. 
            It can retarget symbols for multiple assemblies at the same time.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Retargeting.RetargetingTypeParameterSymbol.retargetingModule">
            <summary>
            Owning RetargetingModuleSymbol.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Retargeting.RetargetingTypeParameterSymbol.underlyingTypeParameter">
            <summary>
            The underlying TypeParameterSymbol, cannot be another RetargetingTypeParameterSymbol.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.CSErrorTypeSymbol">
            <summary>
            An error type, used to represent the type of a type binding
            operation when binding fails.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CSErrorTypeSymbol.ExtractNonErrorType(Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            If (we believe) we know which symbol the user intended, then we should retain that information
            in the corresponding error symbol - it can be useful for deciding how to handle the error.
            For example, we might want to know whether (we believe) the error type was supposed to be an
            interface, so that we can put it in a derived type's interface list, rather than in the base
            type slot.
            
            Sometimes we will return the original definition of the intended symbol.  For example, if we see 
            <![CDATA[IFoo<int>]]> and we have an IFoo with a different arity or accessibility 
            (e.g. <![CDATA[IFoo<int>]]> was constructed from an error symbol based on <![CDATA[IFoo<T>]]>), 
            then we'll return <![CDATA[IFoo<T>]]>, rather than trying to construct a corresponding closed
            type (which may not be difficult/possible in the case of nested types or mismatched arities).
            
            NOTE: Any non-null type symbol returned is guaranteed not to be an error type.
            </summary>
            <remarks>
            TypeSymbolExtensions.GetNonErrorGuess is a more discoverable version of this functionality.
            However, the real definition is in this class so that it can access the private field 
            nonErrorGuessType.
            </remarks>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.LookupFilter">
            <summary>
            represents one-to-one symbol -> SingleLookupResult filter.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.LookupResult">
            <summary>
            A LookupResult summarizes the result of a name lookup within a scope It also allows
            combining name lookups from different scopes in an easy way.
            
            A LookupResult can be ONE OF:
               empty - nothing found.
               a viable result - this kind of result prevents lookup into further scopes of lower priority.
                                 Viable results should be without error; ambiguity is handled in the caller.
                                 (Note that handling multiple "viable" results is not the same as in the VB compiler)
               a non-accessible result - this kind of result means that search continues into further scopes of lower priority for
                                 a viable result. An error is attached with the inaccessibility errors. Non-accessible results take priority over
                                 non-viable results.
               a non-viable result - a result that means that the search continues into further scopes of lower priority for
                                     a viable or non-accessible result. An error is attached with the error that indicates
                                     why the result is non-viable.  A typical readon would be that it is the wrong kind of symbol.
            
            Note that the class is poolable so its instances can be obtained from a pool vai GetInstance.
            Also it is a good idea to call Free on instances after they no longer needed.
            
            The typical pattern is "caller allocates / caller frees" -
               
               var result = LookupResult.GetInstance();
             
               scope.Lookup(result, "foo");
               ... use result ...
                    
               result.Clear();
               anotherScope.Lookup(result, "moo");
               ... use result ...
            
               result.Free();   //result and its content is invalid after this
               
            
            
            </summary>
            <remarks>
            Currently LookupResult is intended only for name lookup, not for overload resolution. It is
            not clear if overload resolution will work with the structure as is, require enhancements,
            or be best served by an alternate mechanism.
            
            We might want to extend this to a more general priority scheme.
            
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LookupResult.SetFrom(Roslyn.Compilers.CSharp.SingleLookupResult)">
            <summary>
            Set current result according to another.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LookupResult.SetFrom(Roslyn.Compilers.CSharp.LookupResult)">
            <summary>
            Set current result according to another.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LookupResult.SetFrom(Roslyn.Compilers.CSharp.Symbol)">
            <summary>
            Set current result according to a given symbol.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LookupResult.SetFrom(System.Collections.Generic.IEnumerable{Roslyn.Compilers.CSharp.Symbol})">
            <summary>
            Accumulate symbol sequence into a given result.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LookupResult.SetFrom``1(Roslyn.Compilers.ReadOnlyArray{``0})">
            <summary>
            Accumulate symbol sequence into a given result.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LookupResult.SingleSymbolOrDefault">
            <summary>
            Return the single symbol if there is exactly one, otherwise null.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LookupResult.IsMultiViable">
            <summary>
            Is the result viable with one or more symbols?
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SourceAssemblySymbol">
            <summary>
            Represents an assembly built by compiler.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.SourceAssemblySymbol.compilation">
            <summary>
            A Compilation the assembly is created for.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.SourceAssemblySymbol.AssemblyNameField">
            <summary>
            Assembly's identity, maybe incomplete.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.SourceAssemblySymbol.modules">
            <summary>
            A list of modules the assembly consists of. 
            The first (index=0) module is a SourceModuleSymbol, which is a primary module, the rest are net-modules.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.SourceAssemblySymbol.lazyCustomAttributes">
            <summary>
            Assembly's custom attributes 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SourceAssemblySymbol.Compilation">
            <summary>
            A Compilation the assembly is created for.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SourceModuleSymbol">
            <summary>
            Represents the primary module of an assembly being built by compiler.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.SourceModuleSymbol.assemblySymbol">
            <summary>
            Owning assembly.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.SourceModuleSymbol.sources">
            <summary>
            The declarations corresponding to the source files of this module.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.SourceModuleSymbol.lazyCustomAttributes">
            <summary>
            Module's custom attributes 
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.SourceModuleSymbol.name">
            <summary>
            The name (contains extension)
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.TypedConstant">
            <summary>
            TypedConstant represents a constant value used as an argument to an Attribute. The Typed constant can represent
            a primitive type, an enum type, a system.type or an array of TypedConstants. 
            
            Kind            _value                              _type
            Primitive       Boxed value, string or nothing      TypeSymbol for the boxed value
            Enum            Boxed value of the underlying type  TypeSymbol for enum
            Type            TypeSymbol or nothing               TypeSymbol for System.Type
            Array           TypeConstant() or nothing           ArrayTypeSymbol
            Error           nothing                             ErrorTypeSymbol
            
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypedConstant.ToString">
            <summary>
            Returns the System.String that represents the current TypedConstant.
            </summary>
            <returns>A System.String that represents the current TypedConstant.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypedConstant.GetTypedConstantKind(Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.CSharp.Compilation)">
            <remarks>
            TypedConstant isn't computing its own kind from the type symbol because it doesn't
            have a way to recognize the well-known type System.Type.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypedConstant.Kind">
            <summary>
            Returns the kind of the <see cref="T:Roslyn.Compilers.CSharp.TypedConstant"/>. 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypedConstant.Type">
            <summary>
            Returns the <see cref="T:Roslyn.Compilers.CSharp.TypeSymbol"/> of the <see cref="T:Roslyn.Compilers.CSharp.TypedConstant"/>.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypedConstant.Value">
            <summary>
            Returns the value of a non-array <see cref="T:Roslyn.Compilers.CSharp.TypedConstant"/>. Throws if called on an array <see cref="T:Roslyn.Compilers.CSharp.TypedConstant"/>.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypedConstant.Values">
            <summary>
            Returns the value of an array <see cref="T:Roslyn.Compilers.CSharp.TypedConstant"/>. Throws if called on a non-array <see cref="T:Roslyn.Compilers.CSharp.TypedConstant"/>.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.TypeMap">
            <summary>
            Utility class for substituting actual type arguments for formal generic type parameters.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ChildSyntaxList">
            <summary>
            A list of child SyntaxNodeOrToken structs.
            </summary>
            <summary>
            A list of child SyntaxNodeOrToken structs.
            </summary>
            <summary>
            A list of child SyntaxNodeOrToken structs.
            </summary>
            <summary>
            A list of child SyntaxNodeOrToken structs.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.ChildSyntaxList._node">
            <summary>
            The underlying syntax node
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.ChildSyntaxList._count">
            <summary>
            The count of elements in this list
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ChildSyntaxList.#ctor(Roslyn.Compilers.CSharp.SyntaxNode)">
            <summary>
            Initializes a new instance of the <see cref="T:Roslyn.Compilers.CSharp.ChildSyntaxList"/> struct.
            </summary>
            <param name="node">The underlying syntax node.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ChildSyntaxList.CountNodes(Roslyn.Compilers.CSharp.InternalSyntax.SyntaxNode)">
            <summary>
            Counts the nodes.
            </summary>
            <param name="green">The green.</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ChildSyntaxList.ItemInternal(Roslyn.Compilers.CSharp.SyntaxNode,System.Int32)">
            <summary>
            internal indexer that does not verify index.
            Used when caller has already ensured that index is within bounds.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ChildSyntaxList.Reverse">
            <summary>
            Returns the reversed list.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ChildSyntaxList.GetEnumerator">
            <summary>
            Gets an enumerator that iterates through the collection.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ChildSyntaxList.System#Collections#Generic#IEnumerable{Roslyn#Compilers#CSharp#SyntaxNodeOrToken}#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ChildSyntaxList.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ChildSyntaxList.Count">
            <summary>
            Gets the count of elements in this list
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ChildSyntaxList.Node">
            <summary>
            Gets the underlying node.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ChildSyntaxList.Item(System.Int32)">
            <summary>
            Gets the <see cref="T:Roslyn.Compilers.CSharp.SyntaxNodeOrToken"/> at the specified index.
            </summary>
            
            <exception cref="T:System.IndexOutOfRangeException">If <paramref name="index"/> is out of range</exception>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ChildSyntaxList.Enumerator">
            <summary>
            An enumerator or the ChildSyntaxList
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ChildSyntaxList.Enumerator.#ctor(Roslyn.Compilers.CSharp.SyntaxNode,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Roslyn.Compilers.CSharp.ChildSyntaxList.Enumerator"/> struct.
            </summary>
            <param name="node">The underlying syntax node.</param>
            <param name="count">The count of elements.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ChildSyntaxList.Enumerator.MoveNext">
            <summary>
            Moves the next.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ChildSyntaxList.Enumerator.Reset">
            <summary>
            Resets this instance.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ChildSyntaxList.Enumerator.Current">
            <summary>
            Gets the element this enumerator instance is pointing to.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ChildSyntaxList.EnumeratorImpl.#ctor(Roslyn.Compilers.CSharp.SyntaxNode,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Roslyn.Compilers.CSharp.ChildSyntaxList.EnumeratorImpl"/> class.
            </summary>
            <param name="node">The underlying syntax node.</param>
            <param name="count">The count of elements.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ChildSyntaxList.EnumeratorImpl.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
            </returns>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ChildSyntaxList.EnumeratorImpl.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ChildSyntaxList.EnumeratorImpl.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ChildSyntaxList.EnumeratorImpl.Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
            <returns>
            The element in the collection at the current position of the enumerator.
              </returns>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ChildSyntaxList.EnumeratorImpl.System#Collections#IEnumerator#Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
            <returns>
            The element in the collection at the current position of the enumerator.
              </returns>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ChildSyntaxList.Reversed">
            <summary>
            A reversed list of child SyntaxNodeOrToken structs.
            </summary>
            <summary>
            A reversed list of child SyntaxNodeOrToken structs.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.ChildSyntaxList.Reversed._node">
            <summary>
            The underlying syntax node
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.ChildSyntaxList.Reversed._count">
            <summary>
            The count of elements in this list
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ChildSyntaxList.Reversed.#ctor(Roslyn.Compilers.CSharp.SyntaxNode,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Roslyn.Compilers.CSharp.ChildSyntaxList.Reversed"/> struct.
            </summary>
            <param name="node">The underlying syntax node.</param>
            <param name="count">The count of elements in this list.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ChildSyntaxList.Reversed.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ChildSyntaxList.Reversed.System#Collections#Generic#IEnumerable{Roslyn#Compilers#CSharp#SyntaxNodeOrToken}#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ChildSyntaxList.Reversed.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ChildSyntaxList.Reversed.Count">
            <summary>
            Gets the count of elements in this list
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ChildSyntaxList.Reversed.Item(System.Int32)">
            <summary>
            Gets the <see cref="T:Roslyn.Compilers.CSharp.SyntaxNodeOrToken"/> at the specified index.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ChildSyntaxList.Reversed.Enumerator">
            <summary>
            Enumerator or the Reversed list 
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ChildSyntaxList.Reversed.Enumerator.#ctor(Roslyn.Compilers.CSharp.SyntaxNode,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Roslyn.Compilers.CSharp.ChildSyntaxList.Reversed.Enumerator"/> struct.
            </summary>
            <param name="node">The underlying syntax node.</param>
            <param name="count">The count of elements.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ChildSyntaxList.Reversed.Enumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
            </returns>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ChildSyntaxList.Reversed.Enumerator.System#Collections#IEnumerator#Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ChildSyntaxList.Reversed.Enumerator.System#IDisposable#Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ChildSyntaxList.Reversed.Enumerator.Current">
            <summary>
            Gets the element the enumerator instance is currently pointing to.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ChildSyntaxList.Reversed.Enumerator.System#Collections#IEnumerator#Current">
            <summary>
            Gets the element the enumerator instance is currently pointing to.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.DelegateDeclarationSyntax">
            <summary>Delegate declaration syntax.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.MemberDeclarationSyntax">
            <summary>Member declaration syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.DelegateDeclarationSyntax.Attributes">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.DelegateDeclarationSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.DelegateDeclarationSyntax.DelegateKeyword">
            <summary>Gets the "delegate" keyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.DelegateDeclarationSyntax.ReturnType">
            <summary>Gets the return type.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.DelegateDeclarationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.DelegateDeclarationSyntax.ParameterList">
            <summary>Gets the parameter list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.DelegateDeclarationSyntax.ConstraintClauses">
            <summary>Gets the constraint clause list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.DelegateDeclarationSyntax.SemicolonToken">
            <summary>Gets the semicolon token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.StructuredTriviaSyntax">
            <summary>
            It's a non terminal Trivia SyntaxNode that has a tree underneath it.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.StructuredTriviaSyntax.Roslyn#Compilers#Common#IStructuredTriviaSyntax#ParentTrivia">
            <summary>
            Get parent trivia.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SyntaxWalker">
            <summary>
            Represents a <see cref="T:Roslyn.Compilers.CSharp.SyntaxVisitor"/> that descends an entire <see cref="T:Roslyn.Compilers.CSharp.SyntaxNode"/> graph
            visiting each SyntaxNode and its child SyntaxNodes and <see cref="T:Roslyn.Compilers.CSharp.SyntaxToken"/>s in depth-first order.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.NameSyntax">
            <summary>Provides the base class from which the classes that represent name syntax nodes are derived. This is an abstract class.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.TypeSyntax">
            <summary>Provides the base class from which the classes that represent type syntax nodes are derived. This is an abstract class.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.ExpressionSyntax">
            <summary>Provides the base class from which the classes that represent expression syntax nodes are derived. This is an abstract class.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.SimpleNameSyntax">
            <summary>Provides the base class from which the classes that represent simple name syntax nodes are derived. This is an abstract class.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.SimpleNameSyntax.Identifier">
            <summary>SyntaxToken representing the identifier of the simple name.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.IdentifierNameSyntax">
            <summary>Class which represents the syntax node for identifier name.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.IdentifierNameSyntax.Identifier">
            <summary>SyntaxToken representing the keyword for the kind of the identifier name.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.QualifiedNameSyntax">
            <summary>Class which represents the syntax node for qualified name.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.QualifiedNameSyntax.Left">
            <summary>NameSyntax node representing the name on the left side of the dot token of the qualified name.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.QualifiedNameSyntax.DotToken">
            <summary>SyntaxToken representing the dot.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.QualifiedNameSyntax.Right">
            <summary>SimpleNameSyntax node representing the name on the right side of the dot token of the qualified name.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.GenericNameSyntax">
            <summary>Class which represents the syntax node for generic name.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.GenericNameSyntax.Identifier">
            <summary>SyntaxToken representing the name of the identifier of the generic name.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.GenericNameSyntax.TypeArgumentList">
            <summary>TypeArgumentListSyntax node representing the list of type arguments of the generic name.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.TypeArgumentListSyntax">
            <summary>Class which represents the syntax node for type argument list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.TypeArgumentListSyntax.LessThanToken">
            <summary>SyntaxToken representing less than.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.TypeArgumentListSyntax.Arguments">
            <summary>SeparatedSyntaxList of TypeSyntax node representing the type arguments.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.TypeArgumentListSyntax.GreaterThanToken">
            <summary>SyntaxToken representing greater than.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.AliasQualifiedNameSyntax">
            <summary>Class which represents the syntax node for alias qualified name.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.AliasQualifiedNameSyntax.Alias">
            <summary>IdentifierNameSyntax node representing the name of the alias</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.AliasQualifiedNameSyntax.ColonColonToken">
            <summary>SyntaxToken representing colon colon.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.AliasQualifiedNameSyntax.Name">
            <summary>SimpleNameSyntax node representing the name that is being alias qualified.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.PredefinedTypeSyntax">
            <summary>Class which represents the syntax node for predefined types.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.PredefinedTypeSyntax.Keyword">
            <summary>SyntaxToken which represents the keyword corresponding to the predefined type.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.ArrayTypeSyntax">
            <summary>Class which represents the syntax node for the array type.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ArrayTypeSyntax.ElementType">
            <summary>TypeSyntax node representing the type of the element of the array.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ArrayTypeSyntax.RankSpecifiers">
            <summary>SyntaxList of ArrayRankSpecifierSyntax nodes representing the list of rank specifiers for the array.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.PointerTypeSyntax">
            <summary>Class which represents the syntax node for pointer type.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.PointerTypeSyntax.ElementType">
            <summary>TypeSyntax node that represents the element type of the pointer.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.PointerTypeSyntax.AsteriskToken">
            <summary>SyntaxToken representing the asterisk.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.NullableTypeSyntax">
            <summary>Class which represents the syntax node for a nullable type.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.NullableTypeSyntax.ElementType">
            <summary>TypeSyntax node representing the type of the element.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.NullableTypeSyntax.QuestionToken">
            <summary>SyntaxToken representing the question mark.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.ParenthesizedExpressionSyntax">
            <summary>Class which represents the syntax node for parenthesized expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ParenthesizedExpressionSyntax.OpenParenToken">
            <summary>SyntaxToken representing the open parenthesis.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ParenthesizedExpressionSyntax.Expression">
            <summary>ExpressionSyntax node representing the expression enclosed within the parenthesis.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ParenthesizedExpressionSyntax.CloseParenToken">
            <summary>SyntaxToken representing the close parenthesis.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.PrefixUnaryExpressionSyntax">
            <summary>Class which represents the syntax node for prefix unary expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.PrefixUnaryExpressionSyntax.OperatorToken">
            <summary>SyntaxToken representing the kind of the operator of the prefix unary expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.PrefixUnaryExpressionSyntax.Operand">
            <summary>ExpressionSyntax representing the operand of the prefix unary expression.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.PostfixUnaryExpressionSyntax">
            <summary>Class which represents the syntax node for postfix unary expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.PostfixUnaryExpressionSyntax.Operand">
            <summary>ExpressionSyntax representing the operand of the postfix unary expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.PostfixUnaryExpressionSyntax.OperatorToken">
            <summary>SyntaxToken representing the kind of the operator of the postfix unary expression.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.MemberAccessExpressionSyntax">
            <summary>Class which represents the syntax node for member access expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.MemberAccessExpressionSyntax.Expression">
            <summary>ExpressionSyntax node representing the object that the member belongs to.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.MemberAccessExpressionSyntax.OperatorToken">
            <summary>SyntaxToken representing the kind of the operator in the member access expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.MemberAccessExpressionSyntax.Name">
            <summary>SimpleNameSyntax node representing the member being accessed.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.BinaryExpressionSyntax">
            <summary>Class which represents an expression that has a binary operator.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.BinaryExpressionSyntax.Left">
            <summary>ExpressionSyntax node representing the expression on the left of the binary operator.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.BinaryExpressionSyntax.OperatorToken">
            <summary>SyntaxToken representing the operator of the binary expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.BinaryExpressionSyntax.Right">
            <summary>ExpressionSyntax node representing the expression on the right of the binary operator.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.ConditionalExpressionSyntax">
            <summary>Class which represents the syntax node for conditional expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ConditionalExpressionSyntax.Condition">
            <summary>ExpressionSyntax node representing the condition of the conditional expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ConditionalExpressionSyntax.QuestionToken">
            <summary>SyntaxToken representing the question mark.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ConditionalExpressionSyntax.WhenTrue">
            <summary>ExpressionSyntax node representing the expression to be executed when the condition is true.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ConditionalExpressionSyntax.WhenFalse">
            <summary>ExpressionSyntax node representing the expression to be executed when the condition is false.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.InstanceExpressionSyntax">
            <summary>Provides the base class from which the classes that represent instance expression syntax nodes are derived. This is an abstract class.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.ThisExpressionSyntax">
            <summary>Class which represents the syntax node for a this expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ThisExpressionSyntax.Token">
            <summary>SyntaxToken representing the this keyword.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.BaseExpressionSyntax">
            <summary>Class which represents the syntax node for a base expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.BaseExpressionSyntax.Token">
            <summary>SyntaxToken representing the base keyword.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.LiteralExpressionSyntax">
            <summary>Class which represents the syntax node for a literal expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.LiteralExpressionSyntax.Token">
            <summary>SyntaxToken representing the keyword corresponding to the kind of the literal expression.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.MakeRefExpressionSyntax">
            <summary>Class which represents the syntax node for MakeRef expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.MakeRefExpressionSyntax.Keyword">
            <summary>SyntaxToken representing the MakeRefKeyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.MakeRefExpressionSyntax.ArgumentList">
            <summary>ArgumentListSyntax node representing the list of arguments of the primary function.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.RefTypeExpressionSyntax">
            <summary>Class which represents the syntax node for RefType expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.RefTypeExpressionSyntax.Keyword">
            <summary>SyntaxToken representing the RefTypeKeyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.RefTypeExpressionSyntax.ArgumentList">
            <summary>ArgumentListSyntax node representing the list of arguments of the primary function.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.RefValueExpressionSyntax">
            <summary>Class which represents the syntax node for RefValue expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.RefValueExpressionSyntax.Keyword">
            <summary>SyntaxToken representing the RefValueKeyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.RefValueExpressionSyntax.ArgumentList">
            <summary>ArgumentListSyntax node representing the list of arguments of the primary function.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.CheckedExpressionSyntax">
            <summary>Class which represents the syntax node for Checked or Unchecked expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.CheckedExpressionSyntax.Keyword">
            <summary>SyntaxToken representing the checked or unchecked keyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.CheckedExpressionSyntax.ArgumentList">
            <summary>ArgumentListSyntax node representing the list of arguments of the primary function.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.DefaultExpressionSyntax">
            <summary>Class which represents the syntax node for Default expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.DefaultExpressionSyntax.Keyword">
            <summary>SyntaxToken representing the DefaultKeyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.DefaultExpressionSyntax.ArgumentList">
            <summary>ArgumentListSyntax node representing the list of arguments of the primary function.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.TypeOfExpressionSyntax">
            <summary>Class which represents the syntax node for TypeOf expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.TypeOfExpressionSyntax.Keyword">
            <summary>SyntaxToken representing the TypeOfKeyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.TypeOfExpressionSyntax.ArgumentList">
            <summary>ArgumentListSyntax node representing the list of arguments of the primary function.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.SizeOfExpressionSyntax">
            <summary>Class which represents the syntax node for SizeOf expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.SizeOfExpressionSyntax.Keyword">
            <summary>SyntaxToken representing the SizeOfKeyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.SizeOfExpressionSyntax.ArgumentList">
            <summary>ArgumentListSyntax node representing the list of arguments of the primary function.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.InvocationExpressionSyntax">
            <summary>Class which represents the syntax node for invocation expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.InvocationExpressionSyntax.Expression">
            <summary>ExpressionSyntax node representing the expression part of the invocation.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.InvocationExpressionSyntax.ArgumentList">
            <summary>ArgumentListSyntax node representing the list of arguments of the invocation expression.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.ElementAccessExpressionSyntax">
            <summary>Class which represents the syntax node for element access expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ElementAccessExpressionSyntax.Expression">
            <summary>ExpressionSyntax node representing the expression which is accessing the element.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ElementAccessExpressionSyntax.ArgumentList">
            <summary>BracketedArgumentListSyntax node representing the list of arguments of the element access expression.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.BaseArgumentListSyntax">
            <summary>Provides the base class from which the classes that represent argument list syntax nodes are derived. This is an abstract class.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.BaseArgumentListSyntax.Arguments">
            <summary>SeparatedSyntaxList of ArgumentSyntax nodes representing the list of arguments.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.ArgumentListSyntax">
            <summary>Class which represents the syntax node for the list of arguments.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ArgumentListSyntax.OpenParenToken">
            <summary>SyntaxToken representing open parenthesis.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ArgumentListSyntax.Arguments">
            <summary>SeparatedSyntaxList of ArgumentSyntax representing the list of arguments.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ArgumentListSyntax.CloseParenToken">
            <summary>SyntaxToken representing close parenthesis.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.BracketedArgumentListSyntax">
            <summary>Class which represents the syntax node for bracketed argument list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.BracketedArgumentListSyntax.OpenBracketToken">
            <summary>SyntaxToken representing open bracket.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.BracketedArgumentListSyntax.Arguments">
            <summary>SeparatedSyntaxList of ArgumentSyntax representing the list of arguments.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.BracketedArgumentListSyntax.CloseBracketToken">
            <summary>SyntaxToken representing close bracket.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.ArgumentSyntax">
            <summary>Class which represents the syntax node for argument.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ArgumentSyntax.NameColonOpt">
            <summary>NameColonSyntax node representing the optional name arguments.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ArgumentSyntax.RefOrOutKeywordOpt">
            <summary>SyntaxToken representing the optional ref or out keyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ArgumentSyntax.Expression">
            <summary>ExpressionSyntax node representing the argument.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.NameColonSyntax">
            <summary>Class which represents the syntax node for name colon syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.NameColonSyntax.Identifier">
            <summary>SyntaxToken representing the identifer name.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.NameColonSyntax.ColonToken">
            <summary>SyntaxToken representing colon.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.CastExpressionSyntax">
            <summary>Class which represents the syntax node for cast expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.CastExpressionSyntax.OpenParenToken">
            <summary>SyntaxToken representing the open parenthesis.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.CastExpressionSyntax.Type">
            <summary>TypeSyntax node representing the type the expression is being casted to.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.CastExpressionSyntax.CloseParenToken">
            <summary>SyntaxToken representing the close parenthesis.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.CastExpressionSyntax.Expression">
            <summary>ExpressionSyntax node representing the expression that is being casted.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.AnonymousMethodExpressionSyntax">
            <summary>Class which represents the syntax node for anonymous method expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.AnonymousMethodExpressionSyntax.DelegateKeyword">
            <summary>SyntaxToken representing the delegate keyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.AnonymousMethodExpressionSyntax.ParameterListOpt">
            <summary>List of parameters of the anonymous method expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.AnonymousMethodExpressionSyntax.Block">
            <summary>BlockSyntax node representing the body of the anonymous method.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.SimpleLambdaExpressionSyntax">
            <summary>Class which represents the syntax node for a simple lambda expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.SimpleLambdaExpressionSyntax.Parameter">
            <summary>ParameterSyntax node representing the parameter of the lambda expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.SimpleLambdaExpressionSyntax.ArrowToken">
            <summary>SyntaxToken representing equals greater than.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.SimpleLambdaExpressionSyntax.Body">
            <summary>SyntaxNode representing the body of the lambda expression.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.ParenthesizedLambdaExpressionSyntax">
            <summary>Class which represents the syntax node for parenthesized lambda expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ParenthesizedLambdaExpressionSyntax.ParameterList">
            <summary>ParameterListSyntax node representing the list of parameters for the lambda expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ParenthesizedLambdaExpressionSyntax.ArrowToken">
            <summary>SyntaxToken representing equals greater than.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ParenthesizedLambdaExpressionSyntax.Body">
            <summary>SyntaxNode representing the body of the lambda expression.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.InitializerExpressionSyntax">
            <summary>Class which represents the syntax node for initializer expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.InitializerExpressionSyntax.OpenBraceToken">
            <summary>SyntaxToken representing the open brace.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.InitializerExpressionSyntax.Expressions">
            <summary>SeparatedSyntaxList of ExpressionSyntax representing the list of expressions in the initializer expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.InitializerExpressionSyntax.CloseBraceToken">
            <summary>SyntaxToken representing the close brace.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.ObjectCreationExpressionSyntax">
            <summary>Class which represents the syntax node for object creation expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ObjectCreationExpressionSyntax.NewKeyword">
            <summary>SyntaxToken representing the new keyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ObjectCreationExpressionSyntax.Type">
            <summary>TypeSyntax representing the type of the object being created.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ObjectCreationExpressionSyntax.ArgumentListOpt">
            <summary>ArgumentListSyntax representing the list of arguments passed as part of the object creation expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ObjectCreationExpressionSyntax.InitializerOpt">
            <summary>InitializerExpressionSyntax representing the initializer expression for the object being created.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.AnonymousObjectCreationExpressionSyntax">
            <summary>Class which represents the syntax node for anonymous object creation expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.AnonymousObjectCreationExpressionSyntax.NewKeyword">
            <summary>SyntaxToken representing the new keyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.AnonymousObjectCreationExpressionSyntax.Initializer">
            <summary>InitializerExpressionSyntax node representing the initializer of the anonymous object creation expression.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.ArrayCreationExpressionSyntax">
            <summary>Class which represents the syntax node for array creation expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ArrayCreationExpressionSyntax.NewKeyword">
            <summary>SyntaxToken representing the new keyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ArrayCreationExpressionSyntax.Type">
            <summary>ArrayTypeSyntax node representing the type of the array.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ArrayCreationExpressionSyntax.InitializerOpt">
            <summary>InitializerExpressionSyntax node representing the initializer of the array creation expression.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.ImplicitArrayCreationExpressionSyntax">
            <summary>Class which represents the syntax node for implicit array creation expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ImplicitArrayCreationExpressionSyntax.NewKeyword">
            <summary>SyntaxToken representing the new keyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ImplicitArrayCreationExpressionSyntax.OpenBracketToken">
            <summary>SyntaxToken representing the open bracket.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ImplicitArrayCreationExpressionSyntax.Commas">
            <summary>SyntaxList of SyntaxToken representing the commas in the implicit array creation expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ImplicitArrayCreationExpressionSyntax.CloseBracketToken">
            <summary>SyntaxToken representing the close bracket.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ImplicitArrayCreationExpressionSyntax.Initializer">
            <summary>InitializerExpressionSyntax representing the initializer expression of the implicit array creation expression.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.StackAllocArrayCreationExpressionSyntax">
            <summary>Class which represents the syntax node for stackalloc array creation expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.StackAllocArrayCreationExpressionSyntax.StackAllocKeyword">
            <summary>SyntaxToken representing the stackalloc keyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.StackAllocArrayCreationExpressionSyntax.Type">
            <summary>TypeSyntax node representing the type of the stackalloc array.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.FromClauseSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.LetClauseSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.JoinClauseSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.JoinIntoClauseSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.QueryContinuationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.MemberDeclarationSyntax">
            <summary>Member declaration syntax.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.StatementSyntax">
            <summary>Represents the base class for all statements syntax classes.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.LocalDeclarationStatementSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.VariableDeclaratorSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.LabeledStatementSyntax">
            <summary>Represents a labeled statement syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.LabeledStatementSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.LabeledStatementSyntax.ColonToken">
            <summary>Gets a SyntaxToken that represents the colon succeeding the statement's label.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.GotoStatementSyntax">
            <summary>
            Represents a goto statement syntax
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.GotoStatementSyntax.GotoKeyword">
            <summary>
            Gets a SyntaxToken that represents the goto keyword.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.GotoStatementSyntax.ExpressionOpt">
            <summary>
            Gets a constant expression for a goto case statement.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.GotoStatementSyntax.SemicolonToken">
            <summary>
            Gets a SyntaxToken that represents the semi-colon at the end of the statement.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ForEachStatementSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.IfStatementSyntax">
            <summary>
            Represents an if statement syntax.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.IfStatementSyntax.IfKeyword">
            <summary>
            Gets a SyntaxToken that represents the if keyword.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.IfStatementSyntax.OpenParenToken">
            <summary>
            Gets a SyntaxToken that represents the open parenthesis before the if statement's condition expression.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.IfStatementSyntax.Condition">
            <summary>
            Gets an ExpressionSyntax that represents the condition of the if statement.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.IfStatementSyntax.CloseParenToken">
            <summary>
            Gets a SyntaxToken that represents the close parenthesis after the if statement's condition expression.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.IfStatementSyntax.Statement">
            <summary>
            Gets a StatementSyntax the represents the statement to be executed when the condition is true.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.IfStatementSyntax.ElseOpt">
            <summary>
            Gets an ElseClauseSyntax that represents the statement to be executed when the condition is false if such statement exists.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.ElseClauseSyntax">
            <summary>Represents an else statement syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ElseClauseSyntax.ElseKeyword">
            <summary>
            Gets a syntax token
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.SwitchStatementSyntax">
            <summary>Represents a switch statement syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.SwitchStatementSyntax.SwitchKeyword">
            <summary>
            Gets a SyntaxToken that represents the switch keyword.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.SwitchStatementSyntax.OpenParenToken">
            <summary>
            Gets a SyntaxToken that represents the open parenthesis preceding the switch expression.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.SwitchStatementSyntax.Expression">
            <summary>
            Gets an ExpressionSyntax representing the expression of the switch statement.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.SwitchStatementSyntax.CloseParenToken">
            <summary>
            Gets a SyntaxToken that represents the open parenthesis succeeding the switch expression.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.SwitchStatementSyntax.OpenBraceToken">
            <summary>
            Gets a SyntaxToken that represents the open braces preceding the switch sections.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.SwitchStatementSyntax.Sections">
            <summary>
            Gets a SyntaxList of SwitchSectionSyntax's that represents the switch sections of the switch statement.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.SwitchStatementSyntax.CloseBraceToken">
            <summary>
            Gets a SyntaxToken that represents the open braces succeeding the switch sections.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.SwitchSectionSyntax">
            <summary>Represents a switch section syntax of a switch statement.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.SwitchSectionSyntax.Labels">
            <summary>
            Gets a SyntaxList of SwitchLabelSyntax's the represents the possible labels that control can transfer to within the section.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.SwitchSectionSyntax.Statements">
            <summary>
            Gets a SyntaxList of StatementSyntax's the represents the statements to be executed when control transfer to a label the belongs to the section.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.SwitchLabelSyntax">
            <summary>Represents a switch label within a switch statement.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.SwitchLabelSyntax.CaseOrDefaultKeyword">
            <summary>
            Gets a SyntaxToken that represents a case or default keywords that belongs to a switch label.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.SwitchLabelSyntax.ValueOpt">
            <summary>
            Gets an ExpressionSyntax that represents the constant expression that gets matched for the case label. For default label the property returns null.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.SwitchLabelSyntax.ColonToken">
            <summary>
            Gets a SyntaxToken that represents the colon that terminates the switch label.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.CompilationUnitSyntax.Attributes">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.ExternAliasDirectiveSyntax">
            <summary>
            Represents an ExternAlias directive syntax, e.g. "extern alias MyAlias;" with specifying "/r:MyAlias=SomeAssembly.dll " on the compiler command line.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ExternAliasDirectiveSyntax.ExternKeyword">
            <summary>SyntaxToken representing the extern keyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ExternAliasDirectiveSyntax.AliasKeyword">
            <summary>SyntaxToken representing the alias keyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ExternAliasDirectiveSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ExternAliasDirectiveSyntax.SemicolonToken">
            <summary>SyntaxToken representing the semicolon token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.NamespaceDeclarationSyntax.SemicolonTokenOpt">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.AttributeDeclarationSyntax">
            <summary>Class representing one or more attributes applied to a language construct.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.AttributeDeclarationSyntax.OpenBracketToken">
            <summary>Gets the open bracket token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.AttributeDeclarationSyntax.Attributes">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.AttributeDeclarationSyntax.CloseBracketToken">
            <summary>Gets the close bracket token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.AttributeTargetSpecifierSyntax">
            <summary>Class representing what language construct an attribute targets.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.AttributeTargetSpecifierSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.AttributeTargetSpecifierSyntax.ColonToken">
            <summary>Gets the colon token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.AttributeSyntax">
            <summary>Attribute syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.AttributeSyntax.Name">
            <summary>Gets the name.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.AttributeArgumentListSyntax">
            <summary>Attribute argument list syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.AttributeArgumentListSyntax.OpenParenToken">
            <summary>Gets the open paren token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.AttributeArgumentListSyntax.Arguments">
            <summary>Gets the arguments syntax list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.AttributeArgumentListSyntax.CloseParenToken">
            <summary>Gets the close paren token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.AttributeArgumentSyntax">
            <summary>Attribute argument syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.AttributeArgumentSyntax.Expression">
            <summary>Gets the expression.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.NameEqualsSyntax">
            <summary>Class representing an identifier followed by an equals token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.NameEqualsSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.TypeParameterListSyntax">
            <summary>Type parameter list syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.TypeParameterListSyntax.LessThanToken">
            <summary>Gets the &lt; token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.TypeParameterListSyntax.Parameters">
            <summary>Gets the parameter list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.TypeParameterListSyntax.GreaterThanToken">
            <summary>Gets the &gt; token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.TypeParameterSyntax">
            <summary>Type parameter syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.TypeParameterSyntax.Attributes">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.TypeParameterSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.BaseTypeDeclarationSyntax">
            <summary>Base class for type declaration syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.BaseTypeDeclarationSyntax.Attributes">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.BaseTypeDeclarationSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.BaseTypeDeclarationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.BaseTypeDeclarationSyntax.BaseListOpt">
            <summary>Gets the base type list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.BaseTypeDeclarationSyntax.OpenBraceToken">
            <summary>Gets the open brace token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.BaseTypeDeclarationSyntax.CloseBraceToken">
            <summary>Gets the close brace token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.BaseTypeDeclarationSyntax.SemicolonTokenOpt">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.TypeDeclarationSyntax">
            <summary>Base class for type declaration syntax (class, struct, interface).</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.TypeDeclarationSyntax.Keyword">
            <summary>Gets the type keyword token ("class", "struct", "interface").</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.TypeDeclarationSyntax.ConstraintClauses">
            <summary>Gets the type constraint list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.TypeDeclarationSyntax.Members">
            <summary>Gets the member declarations.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.ClassDeclarationSyntax">
            <summary>Class type declaration syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ClassDeclarationSyntax.Keyword">
            <summary>Gets the class keyword token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.StructDeclarationSyntax">
            <summary>Struct type declaration syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.StructDeclarationSyntax.Keyword">
            <summary>Gets the struct keyword token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.InterfaceDeclarationSyntax">
            <summary>Interface type declaration syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.InterfaceDeclarationSyntax.Keyword">
            <summary>Gets the interface keyword token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.EnumDeclarationSyntax">
            <summary>Enum type declaration syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.EnumDeclarationSyntax.EnumKeyword">
            <summary>Gets the enum keyword token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.EnumDeclarationSyntax.Members">
            <summary>Gets the members declaration list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.EnumDeclarationSyntax.SemicolonTokenOpt">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.DelegateDeclarationSyntax">
            <summary>Delegate declaration syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.DelegateDeclarationSyntax.Attributes">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.DelegateDeclarationSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.DelegateDeclarationSyntax.DelegateKeyword">
            <summary>Gets the "delegate" keyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.DelegateDeclarationSyntax.ReturnType">
            <summary>Gets the return type.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.DelegateDeclarationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.DelegateDeclarationSyntax.ParameterList">
            <summary>Gets the parameter list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.DelegateDeclarationSyntax.ConstraintClauses">
            <summary>Gets the constraint clause list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.DelegateDeclarationSyntax.SemicolonToken">
            <summary>Gets the semicolon token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.EnumMemberDeclarationSyntax.Attributes">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.EnumMemberDeclarationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.BaseListSyntax">
            <summary>Base list syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.BaseListSyntax.ColonToken">
            <summary>Gets the colon token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.BaseListSyntax.Types">
            <summary>Gets the base type references.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.TypeParameterConstraintClauseSyntax">
            <summary>Type parameter constraint clause.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.TypeParameterConstraintClauseSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.TypeParameterConstraintClauseSyntax.ColonToken">
            <summary>Gets the colon token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.TypeParameterConstraintClauseSyntax.Constraints">
            <summary>Gets the constraints list.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.TypeParameterConstraintSyntax">
            <summary>Base type for type parameter constraint syntax.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.ConstructorConstraintSyntax">
            <summary>Constructor constraint syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ConstructorConstraintSyntax.NewKeyword">
            <summary>Gets the "new" keyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ConstructorConstraintSyntax.OpenParenToken">
            <summary>Gets the open paren keyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ConstructorConstraintSyntax.CloseParenToken">
            <summary>Gets the close paren keyword.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.ClassOrStructConstraintSyntax">
            <summary>Base type for class or struct constraint syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ClassOrStructConstraintSyntax.ClassOrStructKeyword">
            <summary>Gets the constraint keyword ("class" or "struct").</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.TypeConstraintSyntax">
            <summary>Type constraint syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.TypeConstraintSyntax.Type">
            <summary>Gets the type syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.FieldDeclarationSyntax.Attributes">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.FieldDeclarationSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.EventFieldDeclarationSyntax.Attributes">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.EventFieldDeclarationSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.BaseMethodDeclarationSyntax">
            <summary>Base type for method declaration syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.BaseMethodDeclarationSyntax.Attributes">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.BaseMethodDeclarationSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.BaseMethodDeclarationSyntax.ParameterList">
            <summary>Gets the parameter list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.BaseMethodDeclarationSyntax.SemicolonTokenOpt">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.MethodDeclarationSyntax">
            <summary>Method declaration syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.MethodDeclarationSyntax.ReturnType">
            <summary>Gets the return type syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.MethodDeclarationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.MethodDeclarationSyntax.ConstraintClauses">
            <summary>Gets the constraint clause list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.MethodDeclarationSyntax.SemicolonTokenOpt">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.OperatorDeclarationSyntax">
            <summary>Operator declaration syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.OperatorDeclarationSyntax.ReturnType">
            <summary>Gets the return type.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.OperatorDeclarationSyntax.OperatorKeyword">
            <summary>Gets the "operator" keyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.OperatorDeclarationSyntax.OperatorToken">
            <summary>Gets the operator token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.ConversionOperatorDeclarationSyntax">
            <summary>Conversion operator declaration syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ConversionOperatorDeclarationSyntax.ImplicitOrExplicitKeyword">
            <summary>Gets the "implicit" or "explicit" token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ConversionOperatorDeclarationSyntax.OperatorKeyword">
            <summary>Gets the "operator" token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ConversionOperatorDeclarationSyntax.Type">
            <summary>Gets the type.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ConversionOperatorDeclarationSyntax.SemicolonTokenOpt">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.ConstructorDeclarationSyntax">
            <summary>Constructor declaration syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ConstructorDeclarationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ConstructorDeclarationSyntax.SemicolonTokenOpt">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.ConstructorInitializerSyntax">
            <summary>Constructor initializer syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ConstructorInitializerSyntax.ColonToken">
            <summary>Gets the colon token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ConstructorInitializerSyntax.ThisOrBaseKeyword">
            <summary>Gets the "this" or "base" keyword.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.DestructorDeclarationSyntax">
            <summary>Destructor declaration syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.DestructorDeclarationSyntax.TildeToken">
            <summary>Gets the tilde token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.DestructorDeclarationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.DestructorDeclarationSyntax.SemicolonTokenOpt">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.BasePropertyDeclarationSyntax">
            <summary>Base type for property declaration syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.BasePropertyDeclarationSyntax.Attributes">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.BasePropertyDeclarationSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.BasePropertyDeclarationSyntax.Type">
            <summary>Gets the type syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.BasePropertyDeclarationSyntax.ExplicitInterfaceSpecifierOpt">
            <summary>Gets the optional explicit interface specifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.PropertyDeclarationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.EventDeclarationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.IndexerDeclarationSyntax.ParameterList">
            <summary>Gets the parameter list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.AccessorDeclarationSyntax.Attributes">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.AccessorDeclarationSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.AccessorDeclarationSyntax.Keyword">
            <summary>Gets the keyword token, or identifier if an erroneous accessor declaration.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.AccessorDeclarationSyntax.BodyOpt">
            <summary>Gets the optional body block which may be empty, but it is null if there are no braces.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.AccessorDeclarationSyntax.SemicolonTokenOpt">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.BaseParameterListSyntax">
            <summary>Base type for parameter list syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.BaseParameterListSyntax.Parameters">
            <summary>Gets the parameter list.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.ParameterListSyntax">
            <summary>Parameter list syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ParameterListSyntax.OpenParenToken">
            <summary>Gets the open paren token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ParameterListSyntax.CloseParenToken">
            <summary>Gets the close paren token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.BracketedParameterListSyntax">
            <summary>Parameter list syntax with surrounding brackets.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.BracketedParameterListSyntax.OpenBracketToken">
            <summary>Gets the open bracket token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.BracketedParameterListSyntax.CloseBracketToken">
            <summary>Gets the close bracket token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.ParameterSyntax">
            <summary>Parameter syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ParameterSyntax.Attributes">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ParameterSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ParameterSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.IncompleteMemberSyntax.Attributes">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.IncompleteMemberSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.GenericNameSyntax">
            <summary>Class which represents the syntax node for generic name.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.GenericNameSyntax.Identifier">
            <summary>SyntaxToken representing the name of the identifier of the generic name.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.GenericNameSyntax.TypeArgumentList">
            <summary>TypeArgumentListSyntax node representing the list of type arguments of the generic name.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.TypeArgumentListSyntax">
            <summary>Class which represents the syntax node for type argument list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeArgumentListSyntax.LessThanToken">
            <summary>SyntaxToken representing less than.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeArgumentListSyntax.Arguments">
            <summary>SeparatedSyntaxList of TypeSyntax node representing the type arguments.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeArgumentListSyntax.GreaterThanToken">
            <summary>SyntaxToken representing greater than.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ParenthesizedExpressionSyntax">
            <summary>Class which represents the syntax node for parenthesized expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParenthesizedExpressionSyntax.OpenParenToken">
            <summary>SyntaxToken representing the open parenthesis.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParenthesizedExpressionSyntax.Expression">
            <summary>ExpressionSyntax node representing the expression enclosed within the parenthesis.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParenthesizedExpressionSyntax.CloseParenToken">
            <summary>SyntaxToken representing the close parenthesis.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.PrefixUnaryExpressionSyntax">
            <summary>Class which represents the syntax node for prefix unary expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.PrefixUnaryExpressionSyntax.OperatorToken">
            <summary>SyntaxToken representing the kind of the operator of the prefix unary expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.PrefixUnaryExpressionSyntax.Operand">
            <summary>ExpressionSyntax representing the operand of the prefix unary expression.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.PostfixUnaryExpressionSyntax">
            <summary>Class which represents the syntax node for postfix unary expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.PostfixUnaryExpressionSyntax.Operand">
            <summary>ExpressionSyntax representing the operand of the postfix unary expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.PostfixUnaryExpressionSyntax.OperatorToken">
            <summary>SyntaxToken representing the kind of the operator of the postfix unary expression.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.MemberAccessExpressionSyntax">
            <summary>Class which represents the syntax node for member access expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MemberAccessExpressionSyntax.Expression">
            <summary>ExpressionSyntax node representing the object that the member belongs to.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MemberAccessExpressionSyntax.OperatorToken">
            <summary>SyntaxToken representing the kind of the operator in the member access expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MemberAccessExpressionSyntax.Name">
            <summary>SimpleNameSyntax node representing the member being accessed.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.BinaryExpressionSyntax">
            <summary>Class which represents an expression that has a binary operator.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BinaryExpressionSyntax.Left">
            <summary>ExpressionSyntax node representing the expression on the left of the binary operator.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BinaryExpressionSyntax.OperatorToken">
            <summary>SyntaxToken representing the operator of the binary expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BinaryExpressionSyntax.Right">
            <summary>ExpressionSyntax node representing the expression on the right of the binary operator.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ConditionalExpressionSyntax">
            <summary>Class which represents the syntax node for conditional expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ConditionalExpressionSyntax.Condition">
            <summary>ExpressionSyntax node representing the condition of the conditional expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ConditionalExpressionSyntax.QuestionToken">
            <summary>SyntaxToken representing the question mark.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ConditionalExpressionSyntax.WhenTrue">
            <summary>ExpressionSyntax node representing the expression to be executed when the condition is true.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ConditionalExpressionSyntax.WhenFalse">
            <summary>ExpressionSyntax node representing the expression to be executed when the condition is false.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InstanceExpressionSyntax">
            <summary>Provides the base class from which the classes that represent instance expression syntax nodes are derived. This is an abstract class.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ThisExpressionSyntax">
            <summary>Class which represents the syntax node for a this expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ThisExpressionSyntax.Token">
            <summary>SyntaxToken representing the this keyword.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.BaseExpressionSyntax">
            <summary>Class which represents the syntax node for a base expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BaseExpressionSyntax.Token">
            <summary>SyntaxToken representing the base keyword.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.LiteralExpressionSyntax">
            <summary>Class which represents the syntax node for a literal expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LiteralExpressionSyntax.Token">
            <summary>SyntaxToken representing the keyword corresponding to the kind of the literal expression.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.MakeRefExpressionSyntax">
            <summary>Class which represents the syntax node for MakeRef expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MakeRefExpressionSyntax.Keyword">
            <summary>SyntaxToken representing the MakeRefKeyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MakeRefExpressionSyntax.ArgumentList">
            <summary>ArgumentListSyntax node representing the list of arguments of the primary function.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.RefTypeExpressionSyntax">
            <summary>Class which represents the syntax node for RefType expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.RefTypeExpressionSyntax.Keyword">
            <summary>SyntaxToken representing the RefTypeKeyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.RefTypeExpressionSyntax.ArgumentList">
            <summary>ArgumentListSyntax node representing the list of arguments of the primary function.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.RefValueExpressionSyntax">
            <summary>Class which represents the syntax node for RefValue expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.RefValueExpressionSyntax.Keyword">
            <summary>SyntaxToken representing the RefValueKeyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.RefValueExpressionSyntax.ArgumentList">
            <summary>ArgumentListSyntax node representing the list of arguments of the primary function.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.CheckedExpressionSyntax">
            <summary>Class which represents the syntax node for Checked or Unchecked expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.CheckedExpressionSyntax.Keyword">
            <summary>SyntaxToken representing the checked or unchecked keyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.CheckedExpressionSyntax.ArgumentList">
            <summary>ArgumentListSyntax node representing the list of arguments of the primary function.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.DefaultExpressionSyntax">
            <summary>Class which represents the syntax node for Default expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.DefaultExpressionSyntax.Keyword">
            <summary>SyntaxToken representing the DefaultKeyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.DefaultExpressionSyntax.ArgumentList">
            <summary>ArgumentListSyntax node representing the list of arguments of the primary function.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.TypeOfExpressionSyntax">
            <summary>Class which represents the syntax node for TypeOf expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeOfExpressionSyntax.Keyword">
            <summary>SyntaxToken representing the TypeOfKeyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeOfExpressionSyntax.ArgumentList">
            <summary>ArgumentListSyntax node representing the list of arguments of the primary function.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SizeOfExpressionSyntax">
            <summary>Class which represents the syntax node for SizeOf expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SizeOfExpressionSyntax.Keyword">
            <summary>SyntaxToken representing the SizeOfKeyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SizeOfExpressionSyntax.ArgumentList">
            <summary>ArgumentListSyntax node representing the list of arguments of the primary function.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InvocationExpressionSyntax">
            <summary>Class which represents the syntax node for invocation expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InvocationExpressionSyntax.Expression">
            <summary>ExpressionSyntax node representing the expression part of the invocation.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InvocationExpressionSyntax.ArgumentList">
            <summary>ArgumentListSyntax node representing the list of arguments of the invocation expression.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ElementAccessExpressionSyntax">
            <summary>Class which represents the syntax node for element access expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ElementAccessExpressionSyntax.Expression">
            <summary>ExpressionSyntax node representing the expression which is accessing the element.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ElementAccessExpressionSyntax.ArgumentList">
            <summary>BracketedArgumentListSyntax node representing the list of arguments of the element access expression.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.BaseArgumentListSyntax">
            <summary>Provides the base class from which the classes that represent argument list syntax nodes are derived. This is an abstract class.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BaseArgumentListSyntax.Arguments">
            <summary>SeparatedSyntaxList of ArgumentSyntax nodes representing the list of arguments.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ArgumentListSyntax">
            <summary>Class which represents the syntax node for the list of arguments.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ArgumentListSyntax.OpenParenToken">
            <summary>SyntaxToken representing open parenthesis.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ArgumentListSyntax.Arguments">
            <summary>SeparatedSyntaxList of ArgumentSyntax representing the list of arguments.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ArgumentListSyntax.CloseParenToken">
            <summary>SyntaxToken representing close parenthesis.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.BracketedArgumentListSyntax">
            <summary>Class which represents the syntax node for bracketed argument list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BracketedArgumentListSyntax.OpenBracketToken">
            <summary>SyntaxToken representing open bracket.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BracketedArgumentListSyntax.Arguments">
            <summary>SeparatedSyntaxList of ArgumentSyntax representing the list of arguments.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BracketedArgumentListSyntax.CloseBracketToken">
            <summary>SyntaxToken representing close bracket.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ArgumentSyntax">
            <summary>Class which represents the syntax node for argument.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ArgumentSyntax.NameColonOpt">
            <summary>NameColonSyntax node representing the optional name arguments.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ArgumentSyntax.RefOrOutKeywordOpt">
            <summary>SyntaxToken representing the optional ref or out keyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ArgumentSyntax.Expression">
            <summary>ExpressionSyntax node representing the argument.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.NameColonSyntax">
            <summary>Class which represents the syntax node for name colon syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NameColonSyntax.Identifier">
            <summary>SyntaxToken representing the identifer name.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NameColonSyntax.ColonToken">
            <summary>SyntaxToken representing colon.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.CastExpressionSyntax">
            <summary>Class which represents the syntax node for cast expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.CastExpressionSyntax.OpenParenToken">
            <summary>SyntaxToken representing the open parenthesis.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.CastExpressionSyntax.Type">
            <summary>TypeSyntax node representing the type the expression is being casted to.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.CastExpressionSyntax.CloseParenToken">
            <summary>SyntaxToken representing the close parenthesis.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.CastExpressionSyntax.Expression">
            <summary>ExpressionSyntax node representing the expression that is being casted.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.AnonymousMethodExpressionSyntax">
            <summary>Class which represents the syntax node for anonymous method expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AnonymousMethodExpressionSyntax.DelegateKeyword">
            <summary>SyntaxToken representing the delegate keyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AnonymousMethodExpressionSyntax.ParameterListOpt">
            <summary>List of parameters of the anonymous method expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AnonymousMethodExpressionSyntax.Block">
            <summary>BlockSyntax node representing the body of the anonymous method.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SimpleLambdaExpressionSyntax">
            <summary>Class which represents the syntax node for a simple lambda expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SimpleLambdaExpressionSyntax.Parameter">
            <summary>ParameterSyntax node representing the parameter of the lambda expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SimpleLambdaExpressionSyntax.ArrowToken">
            <summary>SyntaxToken representing equals greater than.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SimpleLambdaExpressionSyntax.Body">
            <summary>SyntaxNode representing the body of the lambda expression.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ParenthesizedLambdaExpressionSyntax">
            <summary>Class which represents the syntax node for parenthesized lambda expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParenthesizedLambdaExpressionSyntax.ParameterList">
            <summary>ParameterListSyntax node representing the list of parameters for the lambda expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParenthesizedLambdaExpressionSyntax.ArrowToken">
            <summary>SyntaxToken representing equals greater than.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParenthesizedLambdaExpressionSyntax.Body">
            <summary>SyntaxNode representing the body of the lambda expression.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InitializerExpressionSyntax">
            <summary>Class which represents the syntax node for initializer expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InitializerExpressionSyntax.OpenBraceToken">
            <summary>SyntaxToken representing the open brace.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InitializerExpressionSyntax.Expressions">
            <summary>SeparatedSyntaxList of ExpressionSyntax representing the list of expressions in the initializer expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InitializerExpressionSyntax.CloseBraceToken">
            <summary>SyntaxToken representing the close brace.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ObjectCreationExpressionSyntax">
            <summary>Class which represents the syntax node for object creation expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ObjectCreationExpressionSyntax.NewKeyword">
            <summary>SyntaxToken representing the new keyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ObjectCreationExpressionSyntax.Type">
            <summary>TypeSyntax representing the type of the object being created.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ObjectCreationExpressionSyntax.ArgumentListOpt">
            <summary>ArgumentListSyntax representing the list of arguments passed as part of the object creation expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ObjectCreationExpressionSyntax.InitializerOpt">
            <summary>InitializerExpressionSyntax representing the initializer expression for the object being created.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.AnonymousObjectCreationExpressionSyntax">
            <summary>Class which represents the syntax node for anonymous object creation expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AnonymousObjectCreationExpressionSyntax.NewKeyword">
            <summary>SyntaxToken representing the new keyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AnonymousObjectCreationExpressionSyntax.Initializer">
            <summary>InitializerExpressionSyntax node representing the initializer of the anonymous object creation expression.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ArrayCreationExpressionSyntax">
            <summary>Class which represents the syntax node for array creation expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ArrayCreationExpressionSyntax.NewKeyword">
            <summary>SyntaxToken representing the new keyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ArrayCreationExpressionSyntax.Type">
            <summary>ArrayTypeSyntax node representing the type of the array.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ArrayCreationExpressionSyntax.InitializerOpt">
            <summary>InitializerExpressionSyntax node representing the initializer of the array creation expression.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ImplicitArrayCreationExpressionSyntax">
            <summary>Class which represents the syntax node for implicit array creation expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ImplicitArrayCreationExpressionSyntax.NewKeyword">
            <summary>SyntaxToken representing the new keyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ImplicitArrayCreationExpressionSyntax.OpenBracketToken">
            <summary>SyntaxToken representing the open bracket.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ImplicitArrayCreationExpressionSyntax.Commas">
            <summary>SyntaxList of SyntaxToken representing the commas in the implicit array creation expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ImplicitArrayCreationExpressionSyntax.CloseBracketToken">
            <summary>SyntaxToken representing the close bracket.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ImplicitArrayCreationExpressionSyntax.Initializer">
            <summary>InitializerExpressionSyntax representing the initializer expression of the implicit array creation expression.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.StackAllocArrayCreationExpressionSyntax">
            <summary>Class which represents the syntax node for stackalloc array creation expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.StackAllocArrayCreationExpressionSyntax.StackAllocKeyword">
            <summary>SyntaxToken representing the stackalloc keyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.StackAllocArrayCreationExpressionSyntax.Type">
            <summary>TypeSyntax node representing the type of the stackalloc array.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.FromClauseSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LetClauseSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.JoinClauseSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.JoinIntoClauseSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.QueryContinuationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.VariableDeclaratorSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.LabeledStatementSyntax">
            <summary>Represents a labeled statement syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LabeledStatementSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LabeledStatementSyntax.ColonToken">
            <summary>Gets a SyntaxToken that represents the colon succeeding the statement's label.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.GotoStatementSyntax">
            <summary>
            Represents a goto statement syntax
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.GotoStatementSyntax.GotoKeyword">
            <summary>
            Gets a SyntaxToken that represents the goto keyword.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.GotoStatementSyntax.ExpressionOpt">
            <summary>
            Gets a constant expression for a goto case statement.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.GotoStatementSyntax.SemicolonToken">
            <summary>
            Gets a SyntaxToken that represents the semi-colon at the end of the statement.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ForEachStatementSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.IfStatementSyntax">
            <summary>
            Represents an if statement syntax.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.IfStatementSyntax.IfKeyword">
            <summary>
            Gets a SyntaxToken that represents the if keyword.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.IfStatementSyntax.OpenParenToken">
            <summary>
            Gets a SyntaxToken that represents the open parenthesis before the if statement's condition expression.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.IfStatementSyntax.Condition">
            <summary>
            Gets an ExpressionSyntax that represents the condition of the if statement.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.IfStatementSyntax.CloseParenToken">
            <summary>
            Gets a SyntaxToken that represents the close parenthesis after the if statement's condition expression.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.IfStatementSyntax.Statement">
            <summary>
            Gets a StatementSyntax the represents the statement to be executed when the condition is true.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.IfStatementSyntax.ElseOpt">
            <summary>
            Gets an ElseClauseSyntax that represents the statement to be executed when the condition is false if such statement exists.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ElseClauseSyntax">
            <summary>Represents an else statement syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ElseClauseSyntax.ElseKeyword">
            <summary>
            Gets a syntax token
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SwitchStatementSyntax">
            <summary>Represents a switch statement syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SwitchStatementSyntax.SwitchKeyword">
            <summary>
            Gets a SyntaxToken that represents the switch keyword.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SwitchStatementSyntax.OpenParenToken">
            <summary>
            Gets a SyntaxToken that represents the open parenthesis preceding the switch expression.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SwitchStatementSyntax.Expression">
            <summary>
            Gets an ExpressionSyntax representing the expression of the switch statement.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SwitchStatementSyntax.CloseParenToken">
            <summary>
            Gets a SyntaxToken that represents the open parenthesis succeeding the switch expression.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SwitchStatementSyntax.OpenBraceToken">
            <summary>
            Gets a SyntaxToken that represents the open braces preceding the switch sections.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SwitchStatementSyntax.Sections">
            <summary>
            Gets a SyntaxList of SwitchSectionSyntax's that represents the switch sections of the switch statement.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SwitchStatementSyntax.CloseBraceToken">
            <summary>
            Gets a SyntaxToken that represents the open braces succeeding the switch sections.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SwitchSectionSyntax">
            <summary>Represents a switch section syntax of a switch statement.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SwitchSectionSyntax.Labels">
            <summary>
            Gets a SyntaxList of SwitchLabelSyntax's the represents the possible labels that control can transfer to within the section.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SwitchSectionSyntax.Statements">
            <summary>
            Gets a SyntaxList of StatementSyntax's the represents the statements to be executed when control transfer to a label the belongs to the section.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SwitchLabelSyntax">
            <summary>Represents a switch label within a switch statement.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SwitchLabelSyntax.CaseOrDefaultKeyword">
            <summary>
            Gets a SyntaxToken that represents a case or default keywords that belongs to a switch label.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SwitchLabelSyntax.ValueOpt">
            <summary>
            Gets an ExpressionSyntax that represents the constant expression that gets matched for the case label. For default label the property returns null.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SwitchLabelSyntax.ColonToken">
            <summary>
            Gets a SyntaxToken that represents the colon that terminates the switch label.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ExternAliasDirectiveSyntax">
            <summary>
            Represents an ExternAlias directive syntax, e.g. "extern alias MyAlias;" with specifying "/r:MyAlias=SomeAssembly.dll " on the compiler command line.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ExternAliasDirectiveSyntax.ExternKeyword">
            <summary>SyntaxToken representing the extern keyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ExternAliasDirectiveSyntax.AliasKeyword">
            <summary>SyntaxToken representing the alias keyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ExternAliasDirectiveSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ExternAliasDirectiveSyntax.SemicolonToken">
            <summary>SyntaxToken representing the semicolon token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamespaceDeclarationSyntax.SemicolonTokenOpt">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.AttributeDeclarationSyntax">
            <summary>Class representing one or more attributes applied to a language construct.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AttributeDeclarationSyntax.OpenBracketToken">
            <summary>Gets the open bracket token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AttributeDeclarationSyntax.Attributes">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AttributeDeclarationSyntax.CloseBracketToken">
            <summary>Gets the close bracket token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.AttributeSyntax">
            <summary>Attribute syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AttributeSyntax.Name">
            <summary>Gets the name.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.AttributeArgumentListSyntax">
            <summary>Attribute argument list syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AttributeArgumentListSyntax.OpenParenToken">
            <summary>Gets the open paren token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AttributeArgumentListSyntax.Arguments">
            <summary>Gets the arguments syntax list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AttributeArgumentListSyntax.CloseParenToken">
            <summary>Gets the close paren token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.AttributeArgumentSyntax">
            <summary>Attribute argument syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AttributeArgumentSyntax.Expression">
            <summary>Gets the expression.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.NameEqualsSyntax">
            <summary>Class representing an identifier followed by an equals token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NameEqualsSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.TypeParameterListSyntax">
            <summary>Type parameter list syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeParameterListSyntax.LessThanToken">
            <summary>Gets the &lt; token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeParameterListSyntax.Parameters">
            <summary>Gets the parameter list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeParameterListSyntax.GreaterThanToken">
            <summary>Gets the &gt; token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.TypeParameterSyntax">
            <summary>Type parameter syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeParameterSyntax.Attributes">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeParameterSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.BaseTypeDeclarationSyntax">
            <summary>Base class for type declaration syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BaseTypeDeclarationSyntax.Attributes">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BaseTypeDeclarationSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BaseTypeDeclarationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BaseTypeDeclarationSyntax.BaseListOpt">
            <summary>Gets the base type list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BaseTypeDeclarationSyntax.OpenBraceToken">
            <summary>Gets the open brace token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BaseTypeDeclarationSyntax.CloseBraceToken">
            <summary>Gets the close brace token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BaseTypeDeclarationSyntax.SemicolonTokenOpt">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.TypeDeclarationSyntax">
            <summary>Base class for type declaration syntax (class, struct, interface).</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeDeclarationSyntax.Keyword">
            <summary>Gets the type keyword token ("class", "struct", "interface").</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeDeclarationSyntax.ConstraintClauses">
            <summary>Gets the type constraint list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeDeclarationSyntax.Members">
            <summary>Gets the member declarations.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ClassDeclarationSyntax">
            <summary>Class type declaration syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ClassDeclarationSyntax.Keyword">
            <summary>Gets the class keyword token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.StructDeclarationSyntax">
            <summary>Struct type declaration syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.StructDeclarationSyntax.Keyword">
            <summary>Gets the struct keyword token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InterfaceDeclarationSyntax">
            <summary>Interface type declaration syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InterfaceDeclarationSyntax.Keyword">
            <summary>Gets the interface keyword token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.EnumDeclarationSyntax">
            <summary>Enum type declaration syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.EnumDeclarationSyntax.EnumKeyword">
            <summary>Gets the enum keyword token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.EnumDeclarationSyntax.Members">
            <summary>Gets the members declaration list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.EnumDeclarationSyntax.SemicolonTokenOpt">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.EnumMemberDeclarationSyntax.Attributes">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.EnumMemberDeclarationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.BaseListSyntax">
            <summary>Base list syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BaseListSyntax.ColonToken">
            <summary>Gets the colon token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BaseListSyntax.Types">
            <summary>Gets the base type references.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.TypeParameterConstraintClauseSyntax">
            <summary>Type parameter constraint clause.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeParameterConstraintClauseSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeParameterConstraintClauseSyntax.ColonToken">
            <summary>Gets the colon token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeParameterConstraintClauseSyntax.Constraints">
            <summary>Gets the constraints list.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.TypeParameterConstraintSyntax">
            <summary>Base type for type parameter constraint syntax.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ConstructorConstraintSyntax">
            <summary>Constructor constraint syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ConstructorConstraintSyntax.NewKeyword">
            <summary>Gets the "new" keyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ConstructorConstraintSyntax.OpenParenToken">
            <summary>Gets the open paren keyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ConstructorConstraintSyntax.CloseParenToken">
            <summary>Gets the close paren keyword.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ClassOrStructConstraintSyntax">
            <summary>Base type for class or struct constraint syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ClassOrStructConstraintSyntax.ClassOrStructKeyword">
            <summary>Gets the constraint keyword ("class" or "struct").</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.TypeConstraintSyntax">
            <summary>Type constraint syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeConstraintSyntax.Type">
            <summary>Gets the type syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.FieldDeclarationSyntax.Attributes">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.FieldDeclarationSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.EventFieldDeclarationSyntax.Attributes">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.EventFieldDeclarationSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.BaseMethodDeclarationSyntax">
            <summary>Base type for method declaration syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BaseMethodDeclarationSyntax.Attributes">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BaseMethodDeclarationSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BaseMethodDeclarationSyntax.ParameterList">
            <summary>Gets the parameter list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BaseMethodDeclarationSyntax.SemicolonTokenOpt">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.MethodDeclarationSyntax">
            <summary>Method declaration syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodDeclarationSyntax.ReturnType">
            <summary>Gets the return type syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodDeclarationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodDeclarationSyntax.ConstraintClauses">
            <summary>Gets the constraint clause list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodDeclarationSyntax.SemicolonTokenOpt">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.OperatorDeclarationSyntax">
            <summary>Operator declaration syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.OperatorDeclarationSyntax.ReturnType">
            <summary>Gets the return type.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.OperatorDeclarationSyntax.OperatorKeyword">
            <summary>Gets the "operator" keyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.OperatorDeclarationSyntax.OperatorToken">
            <summary>Gets the operator token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ConversionOperatorDeclarationSyntax">
            <summary>Conversion operator declaration syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ConversionOperatorDeclarationSyntax.ImplicitOrExplicitKeyword">
            <summary>Gets the "implicit" or "explicit" token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ConversionOperatorDeclarationSyntax.OperatorKeyword">
            <summary>Gets the "operator" token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ConversionOperatorDeclarationSyntax.Type">
            <summary>Gets the type.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ConversionOperatorDeclarationSyntax.SemicolonTokenOpt">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ConstructorDeclarationSyntax">
            <summary>Constructor declaration syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ConstructorDeclarationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ConstructorDeclarationSyntax.SemicolonTokenOpt">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ConstructorInitializerSyntax">
            <summary>Constructor initializer syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ConstructorInitializerSyntax.ColonToken">
            <summary>Gets the colon token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ConstructorInitializerSyntax.ThisOrBaseKeyword">
            <summary>Gets the "this" or "base" keyword.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.DestructorDeclarationSyntax">
            <summary>Destructor declaration syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.DestructorDeclarationSyntax.TildeToken">
            <summary>Gets the tilde token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.DestructorDeclarationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.DestructorDeclarationSyntax.SemicolonTokenOpt">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.BasePropertyDeclarationSyntax">
            <summary>Base type for property declaration syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BasePropertyDeclarationSyntax.Attributes">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BasePropertyDeclarationSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BasePropertyDeclarationSyntax.Type">
            <summary>Gets the type syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BasePropertyDeclarationSyntax.ExplicitInterfaceSpecifierOpt">
            <summary>Gets the optional explicit interface specifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.PropertyDeclarationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.EventDeclarationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.IndexerDeclarationSyntax.ParameterList">
            <summary>Gets the parameter list.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.BaseParameterListSyntax">
            <summary>Base type for parameter list syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BaseParameterListSyntax.Parameters">
            <summary>Gets the parameter list.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ParameterListSyntax">
            <summary>Parameter list syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParameterListSyntax.OpenParenToken">
            <summary>Gets the open paren token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParameterListSyntax.CloseParenToken">
            <summary>Gets the close paren token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.BracketedParameterListSyntax">
            <summary>Parameter list syntax with surrounding brackets.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BracketedParameterListSyntax.OpenBracketToken">
            <summary>Gets the open bracket token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BracketedParameterListSyntax.CloseBracketToken">
            <summary>Gets the close bracket token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ParameterSyntax">
            <summary>Parameter syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParameterSyntax.Attributes">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParameterSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParameterSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.IncompleteMemberSyntax.Attributes">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.IncompleteMemberSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SyntaxRewriter">
            <summary>
            Represents a <see cref="T:Roslyn.Compilers.CSharp.SyntaxVisitor`1"/> which descends an entire <see cref="T:Roslyn.Compilers.CSharp.SyntaxNode"/> graph and
            may replace or remove visited SyntaxNodes in depth-first order.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Syntax">
            <summary>
            A class containing factory methods for constructing syntax nodes, tokens and trivia.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.IdentifierName(Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new IdentifierNameSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.QualifiedName(Roslyn.Compilers.CSharp.NameSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SimpleNameSyntax)">
            <summary>Creates a new QualifiedNameSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.GenericName(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.TypeArgumentListSyntax)">
            <summary>Creates a new GenericNameSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.TypeArgumentList(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SeparatedSyntaxList{Roslyn.Compilers.CSharp.TypeSyntax},Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new TypeArgumentListSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.AliasQualifiedName(Roslyn.Compilers.CSharp.IdentifierNameSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SimpleNameSyntax)">
            <summary>Creates a new AliasQualifiedNameSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.PredefinedType(Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new PredefinedTypeSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ArrayType(Roslyn.Compilers.CSharp.TypeSyntax,Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.ArrayRankSpecifierSyntax})">
            <summary>Creates a new ArrayTypeSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ArrayRankSpecifier(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SeparatedSyntaxList{Roslyn.Compilers.CSharp.ExpressionSyntax},Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new ArrayRankSpecifierSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.PointerType(Roslyn.Compilers.CSharp.TypeSyntax,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new PointerTypeSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.NullableType(Roslyn.Compilers.CSharp.TypeSyntax,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new NullableTypeSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ParenthesizedExpression(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new ParenthesizedExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.PrefixUnaryExpression(Roslyn.Compilers.CSharp.SyntaxKind,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>Creates a new PrefixUnaryExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.PostfixUnaryExpression(Roslyn.Compilers.CSharp.SyntaxKind,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new PostfixUnaryExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.MemberAccessExpression(Roslyn.Compilers.CSharp.SyntaxKind,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SimpleNameSyntax)">
            <summary>Creates a new MemberAccessExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.BinaryExpression(Roslyn.Compilers.CSharp.SyntaxKind,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>Creates a new BinaryExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ConditionalExpression(Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>Creates a new ConditionalExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ThisExpression(Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new ThisExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.BaseExpression(Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new BaseExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.LiteralExpression(Roslyn.Compilers.CSharp.SyntaxKind,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new LiteralExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.MakeRefExpression(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ArgumentListSyntax)">
            <summary>Creates a new MakeRefExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.RefTypeExpression(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ArgumentListSyntax)">
            <summary>Creates a new RefTypeExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.RefValueExpression(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ArgumentListSyntax)">
            <summary>Creates a new RefValueExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.CheckedExpression(Roslyn.Compilers.CSharp.SyntaxKind,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ArgumentListSyntax)">
            <summary>Creates a new CheckedExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.DefaultExpression(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ArgumentListSyntax)">
            <summary>Creates a new DefaultExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.TypeOfExpression(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ArgumentListSyntax)">
            <summary>Creates a new TypeOfExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.SizeOfExpression(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ArgumentListSyntax)">
            <summary>Creates a new SizeOfExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.InvocationExpression(Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.ArgumentListSyntax)">
            <summary>Creates a new InvocationExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ElementAccessExpression(Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.BracketedArgumentListSyntax)">
            <summary>Creates a new ElementAccessExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ArgumentList(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SeparatedSyntaxList{Roslyn.Compilers.CSharp.ArgumentSyntax},Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new ArgumentListSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.BracketedArgumentList(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SeparatedSyntaxList{Roslyn.Compilers.CSharp.ArgumentSyntax},Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new BracketedArgumentListSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Argument(Roslyn.Compilers.CSharp.NameColonSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>Creates a new ArgumentSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.NameColon(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new NameColonSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.CastExpression(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.TypeSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>Creates a new CastExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.AnonymousMethodExpression(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ParameterListSyntax,Roslyn.Compilers.CSharp.BlockSyntax)">
            <summary>Creates a new AnonymousMethodExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.SimpleLambdaExpression(Roslyn.Compilers.CSharp.ParameterSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxNode)">
            <summary>Creates a new SimpleLambdaExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ParenthesizedLambdaExpression(Roslyn.Compilers.CSharp.ParameterListSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxNode)">
            <summary>Creates a new ParenthesizedLambdaExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.InitializerExpression(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SeparatedSyntaxList{Roslyn.Compilers.CSharp.ExpressionSyntax},Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new InitializerExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ObjectCreationExpression(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.TypeSyntax,Roslyn.Compilers.CSharp.ArgumentListSyntax,Roslyn.Compilers.CSharp.InitializerExpressionSyntax)">
            <summary>Creates a new ObjectCreationExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.AnonymousObjectCreationExpression(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.InitializerExpressionSyntax)">
            <summary>Creates a new AnonymousObjectCreationExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ArrayCreationExpression(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ArrayTypeSyntax,Roslyn.Compilers.CSharp.InitializerExpressionSyntax)">
            <summary>Creates a new ArrayCreationExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ImplicitArrayCreationExpression(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.InitializerExpressionSyntax)">
            <summary>Creates a new ImplicitArrayCreationExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.StackAllocArrayCreationExpression(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.TypeSyntax)">
            <summary>Creates a new StackAllocArrayCreationExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.QueryExpression(Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.QueryClauseSyntax},Roslyn.Compilers.CSharp.SelectOrGroupClauseSyntax,Roslyn.Compilers.CSharp.QueryContinuationSyntax)">
            <summary>Creates a new QueryExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.FromClause(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.TypeSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>Creates a new FromClauseSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.LetClause(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>Creates a new LetClauseSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.JoinClause(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.TypeSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.JoinIntoClauseSyntax)">
            <summary>Creates a new JoinClauseSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.JoinIntoClause(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new JoinIntoClauseSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.WhereClause(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>Creates a new WhereClauseSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.OrderByClause(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SeparatedSyntaxList{Roslyn.Compilers.CSharp.OrderingSyntax})">
            <summary>Creates a new OrderByClauseSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Ordering(Roslyn.Compilers.CSharp.SyntaxKind,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new OrderingSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.SelectClause(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>Creates a new SelectClauseSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.GroupClause(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>Creates a new GroupClauseSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.QueryContinuation(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.QueryExpressionSyntax)">
            <summary>Creates a new QueryContinuationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.GlobalStatement(Roslyn.Compilers.CSharp.StatementSyntax)">
            <summary>Creates a new GlobalStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Block(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.StatementSyntax},Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new BlockSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.LocalDeclarationStatement(Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.VariableDeclarationSyntax,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new LocalDeclarationStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.VariableDeclaration(Roslyn.Compilers.CSharp.TypeSyntax,Roslyn.Compilers.CSharp.SeparatedSyntaxList{Roslyn.Compilers.CSharp.VariableDeclaratorSyntax})">
            <summary>Creates a new VariableDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.VariableDeclarator(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.BracketedArgumentListSyntax,Roslyn.Compilers.CSharp.EqualsValueClauseSyntax)">
            <summary>Creates a new VariableDeclaratorSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.EqualsValueClause(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>Creates a new EqualsValueClauseSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ExpressionStatement(Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new ExpressionStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.EmptyStatement(Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new EmptyStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.LabeledStatement(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.StatementSyntax)">
            <summary>Creates a new LabeledStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.GotoStatement(Roslyn.Compilers.CSharp.SyntaxKind,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new GotoStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.BreakStatement(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new BreakStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ContinueStatement(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new ContinueStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ReturnStatement(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new ReturnStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ThrowStatement(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new ThrowStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.YieldStatement(Roslyn.Compilers.CSharp.SyntaxKind,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new YieldStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.WhileStatement(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.StatementSyntax)">
            <summary>Creates a new WhileStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.DoStatement(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.StatementSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new DoStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ForStatement(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.VariableDeclarationSyntax,Roslyn.Compilers.CSharp.SeparatedSyntaxList{Roslyn.Compilers.CSharp.ExpressionSyntax},Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SeparatedSyntaxList{Roslyn.Compilers.CSharp.ExpressionSyntax},Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.StatementSyntax)">
            <summary>Creates a new ForStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ForEachStatement(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.TypeSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.StatementSyntax)">
            <summary>Creates a new ForEachStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.UsingStatement(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.VariableDeclarationSyntax,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.StatementSyntax)">
            <summary>Creates a new UsingStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.FixedStatement(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.VariableDeclarationSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.StatementSyntax)">
            <summary>Creates a new FixedStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.CheckedStatement(Roslyn.Compilers.CSharp.SyntaxKind,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.BlockSyntax)">
            <summary>Creates a new CheckedStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.UnsafeStatement(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.BlockSyntax)">
            <summary>Creates a new UnsafeStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.LockStatement(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.StatementSyntax)">
            <summary>Creates a new LockStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.IfStatement(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.StatementSyntax,Roslyn.Compilers.CSharp.ElseClauseSyntax)">
            <summary>Creates a new IfStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ElseClause(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.StatementSyntax)">
            <summary>Creates a new ElseClauseSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.SwitchStatement(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.SwitchSectionSyntax},Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new SwitchStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.SwitchSection(Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.SwitchLabelSyntax},Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.StatementSyntax})">
            <summary>Creates a new SwitchSectionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.SwitchLabel(Roslyn.Compilers.CSharp.SyntaxKind,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new SwitchLabelSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.TryStatement(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.BlockSyntax,Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.CatchClauseSyntax},Roslyn.Compilers.CSharp.FinallyClauseSyntax)">
            <summary>Creates a new TryStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.CatchClause(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.CatchDeclarationSyntax,Roslyn.Compilers.CSharp.BlockSyntax)">
            <summary>Creates a new CatchClauseSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.CatchDeclaration(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.TypeSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new CatchDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.FinallyClause(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.BlockSyntax)">
            <summary>Creates a new FinallyClauseSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.CompilationUnit(Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.ExternAliasDirectiveSyntax},Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.UsingDirectiveSyntax},Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.AttributeDeclarationSyntax},Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.MemberDeclarationSyntax},Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new CompilationUnitSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ExternAliasDirective(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new ExternAliasDirectiveSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.UsingDirective(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.NameEqualsSyntax,Roslyn.Compilers.CSharp.NameSyntax,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new UsingDirectiveSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.NamespaceDeclaration(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.NameSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.ExternAliasDirectiveSyntax},Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.UsingDirectiveSyntax},Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.MemberDeclarationSyntax},Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new NamespaceDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.AttributeDeclaration(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.AttributeTargetSpecifierSyntax,Roslyn.Compilers.CSharp.SeparatedSyntaxList{Roslyn.Compilers.CSharp.AttributeSyntax},Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new AttributeDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.AttributeTargetSpecifier(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new AttributeTargetSpecifierSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Attribute(Roslyn.Compilers.CSharp.NameSyntax,Roslyn.Compilers.CSharp.AttributeArgumentListSyntax)">
            <summary>Creates a new AttributeSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.AttributeArgumentList(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SeparatedSyntaxList{Roslyn.Compilers.CSharp.AttributeArgumentSyntax},Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new AttributeArgumentListSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.AttributeArgument(Roslyn.Compilers.CSharp.NameEqualsSyntax,Roslyn.Compilers.CSharp.NameColonSyntax,Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>Creates a new AttributeArgumentSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.NameEquals(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new NameEqualsSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.TypeParameterList(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SeparatedSyntaxList{Roslyn.Compilers.CSharp.TypeParameterSyntax},Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new TypeParameterListSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.TypeParameter(Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.AttributeDeclarationSyntax},Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new TypeParameterSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ClassDeclaration(Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.AttributeDeclarationSyntax},Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.TypeParameterListSyntax,Roslyn.Compilers.CSharp.BaseListSyntax,Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.TypeParameterConstraintClauseSyntax},Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.MemberDeclarationSyntax},Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new ClassDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.StructDeclaration(Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.AttributeDeclarationSyntax},Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.TypeParameterListSyntax,Roslyn.Compilers.CSharp.BaseListSyntax,Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.TypeParameterConstraintClauseSyntax},Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.MemberDeclarationSyntax},Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new StructDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.InterfaceDeclaration(Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.AttributeDeclarationSyntax},Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.TypeParameterListSyntax,Roslyn.Compilers.CSharp.BaseListSyntax,Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.TypeParameterConstraintClauseSyntax},Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.MemberDeclarationSyntax},Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new InterfaceDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.EnumDeclaration(Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.AttributeDeclarationSyntax},Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.BaseListSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SeparatedSyntaxList{Roslyn.Compilers.CSharp.EnumMemberDeclarationSyntax},Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new EnumDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.DelegateDeclaration(Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.AttributeDeclarationSyntax},Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.TypeSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.TypeParameterListSyntax,Roslyn.Compilers.CSharp.ParameterListSyntax,Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.TypeParameterConstraintClauseSyntax},Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new DelegateDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.EnumMemberDeclaration(Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.AttributeDeclarationSyntax},Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.EqualsValueClauseSyntax)">
            <summary>Creates a new EnumMemberDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.BaseList(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SeparatedSyntaxList{Roslyn.Compilers.CSharp.TypeSyntax})">
            <summary>Creates a new BaseListSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.TypeParameterConstraintClause(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SeparatedSyntaxList{Roslyn.Compilers.CSharp.TypeParameterConstraintSyntax})">
            <summary>Creates a new TypeParameterConstraintClauseSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ConstructorConstraint(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new ConstructorConstraintSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ClassOrStructConstraint(Roslyn.Compilers.CSharp.SyntaxKind,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new ClassOrStructConstraintSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.TypeConstraint(Roslyn.Compilers.CSharp.TypeSyntax)">
            <summary>Creates a new TypeConstraintSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.FieldDeclaration(Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.AttributeDeclarationSyntax},Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.VariableDeclarationSyntax,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new FieldDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.EventFieldDeclaration(Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.AttributeDeclarationSyntax},Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.VariableDeclarationSyntax,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new EventFieldDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ExplicitInterfaceSpecifier(Roslyn.Compilers.CSharp.NameSyntax,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new ExplicitInterfaceSpecifierSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.MethodDeclaration(Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.AttributeDeclarationSyntax},Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.TypeSyntax,Roslyn.Compilers.CSharp.ExplicitInterfaceSpecifierSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.TypeParameterListSyntax,Roslyn.Compilers.CSharp.ParameterListSyntax,Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.TypeParameterConstraintClauseSyntax},Roslyn.Compilers.CSharp.BlockSyntax,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new MethodDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.OperatorDeclaration(Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.AttributeDeclarationSyntax},Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.TypeSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ParameterListSyntax,Roslyn.Compilers.CSharp.BlockSyntax,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new OperatorDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ConversionOperatorDeclaration(Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.AttributeDeclarationSyntax},Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.TypeSyntax,Roslyn.Compilers.CSharp.ParameterListSyntax,Roslyn.Compilers.CSharp.BlockSyntax,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new ConversionOperatorDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ConstructorDeclaration(Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.AttributeDeclarationSyntax},Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ParameterListSyntax,Roslyn.Compilers.CSharp.ConstructorInitializerSyntax,Roslyn.Compilers.CSharp.BlockSyntax,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new ConstructorDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ConstructorInitializer(Roslyn.Compilers.CSharp.SyntaxKind,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ArgumentListSyntax)">
            <summary>Creates a new ConstructorInitializerSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.DestructorDeclaration(Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.AttributeDeclarationSyntax},Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ParameterListSyntax,Roslyn.Compilers.CSharp.BlockSyntax,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new DestructorDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.PropertyDeclaration(Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.AttributeDeclarationSyntax},Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.TypeSyntax,Roslyn.Compilers.CSharp.ExplicitInterfaceSpecifierSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.AccessorListSyntax)">
            <summary>Creates a new PropertyDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.EventDeclaration(Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.AttributeDeclarationSyntax},Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.TypeSyntax,Roslyn.Compilers.CSharp.ExplicitInterfaceSpecifierSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.AccessorListSyntax)">
            <summary>Creates a new EventDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.IndexerDeclaration(Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.AttributeDeclarationSyntax},Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.TypeSyntax,Roslyn.Compilers.CSharp.ExplicitInterfaceSpecifierSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.BracketedParameterListSyntax,Roslyn.Compilers.CSharp.AccessorListSyntax)">
            <summary>Creates a new IndexerDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.AccessorList(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.AccessorDeclarationSyntax},Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new AccessorListSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.AccessorDeclaration(Roslyn.Compilers.CSharp.SyntaxKind,Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.AttributeDeclarationSyntax},Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.BlockSyntax,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new AccessorDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ParameterList(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SeparatedSyntaxList{Roslyn.Compilers.CSharp.ParameterSyntax},Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new ParameterListSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.BracketedParameterList(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SeparatedSyntaxList{Roslyn.Compilers.CSharp.ParameterSyntax},Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new BracketedParameterListSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Parameter(Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.AttributeDeclarationSyntax},Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.TypeSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.EqualsValueClauseSyntax)">
            <summary>Creates a new ParameterSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.IncompleteMember(Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.AttributeDeclarationSyntax},Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.TypeSyntax)">
            <summary>Creates a new IncompleteMemberSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.SkippedTokens(Roslyn.Compilers.CSharp.SyntaxTokenList)">
            <summary>Creates a new SkippedTokensSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.DocumentationComment(Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.XmlNodeSyntax},Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new DocumentationCommentSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.XmlElement(Roslyn.Compilers.CSharp.XmlElementStartTagSyntax,Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.XmlNodeSyntax},Roslyn.Compilers.CSharp.XmlElementEndTagSyntax)">
            <summary>Creates a new XmlElementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.XmlElementStartTag(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.XmlNameSyntax,Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.XmlAttributeSyntax},Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new XmlElementStartTagSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.XmlElementEndTag(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.XmlNameSyntax,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new XmlElementEndTagSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.XmlEmptyElement(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.XmlNameSyntax,Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.XmlAttributeSyntax},Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new XmlEmptyElementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.XmlName(Roslyn.Compilers.CSharp.XmlPrefixSyntax,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new XmlNameSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.XmlPrefix(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new XmlPrefixSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.XmlAttribute(Roslyn.Compilers.CSharp.XmlNameSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new XmlAttributeSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.XmlText(Roslyn.Compilers.CSharp.SyntaxTokenList)">
            <summary>Creates a new XmlTextSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.XmlCDataSection(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new XmlCDataSectionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.XmlProcessingInstruction(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.XmlNameSyntax,Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new XmlProcessingInstructionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.XmlComment(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new XmlCommentSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.IfDirective(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.SyntaxToken,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Creates a new IfDirectiveSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ElifDirective(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.SyntaxToken,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Creates a new ElifDirectiveSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ElseDirective(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,System.Boolean,System.Boolean)">
            <summary>Creates a new ElseDirectiveSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.EndIfDirective(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,System.Boolean)">
            <summary>Creates a new EndIfDirectiveSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.RegionDirective(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,System.Boolean)">
            <summary>Creates a new RegionDirectiveSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.EndRegionDirective(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,System.Boolean)">
            <summary>Creates a new EndRegionDirectiveSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ErrorDirective(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,System.Boolean)">
            <summary>Creates a new ErrorDirectiveSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.WarningDirective(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,System.Boolean)">
            <summary>Creates a new WarningDirectiveSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.BadDirective(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,System.Boolean)">
            <summary>Creates a new BadDirectiveSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.DefineDirective(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,System.Boolean)">
            <summary>Creates a new DefineDirectiveSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.UndefDirective(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,System.Boolean)">
            <summary>Creates a new UndefDirectiveSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.LineDirective(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,System.Boolean)">
            <summary>Creates a new LineDirectiveSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.PragmaWarningDirective(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SeparatedSyntaxList{Roslyn.Compilers.CSharp.ExpressionSyntax},Roslyn.Compilers.CSharp.SyntaxToken,System.Boolean)">
            <summary>Creates a new PragmaWarningDirectiveSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.PragmaChecksumDirective(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,System.Boolean)">
            <summary>Creates a new PragmaChecksumDirectiveSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ReferenceDirective(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,System.Boolean)">
            <summary>Creates a new ReferenceDirectiveSyntax instance.</summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Syntax.CarriageReturnLineFeed">
            <summary>
            An trivia with kind EndOfLineTrivia containing both the carriage return and line feed characters.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Syntax.LineFeed">
            <summary>
            An trivia with kind EndOfLineTrivia containing a single line feed character.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Syntax.CarriageReturn">
            <summary>
            An trivia with kind EndOfLineTrivia containing a single carriage return character.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Syntax.Space">
            <summary>
             A trivia with kind WhitespaceTrivia containing a single space character.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Syntax.Tab">
            <summary>
            A trivia with kind WhitespaceTrivia containing a single tab character.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Syntax.ElasticCarriageReturnLineFeed">
            <summary>
            An elastic trivia with kind EndOfLineTrivia containing both the carriage return and line feed characters.
            Elastic trivia are used to denote trivia that was not produced by parsing source text, and are usually not
            preserved during formatting.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Syntax.ElasticLineFeed">
            <summary>
            An elastic trivia with kind EndOfLineTrivia containing a single line feed character. Elastic trivia are used
            to denote trivia that was not produced by parsing source text, and are usually not preserved during
            formatting.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Syntax.ElasticCarriageReturn">
            <summary>
            An elastic trivia with kind EndOfLineTrivia containing a single carriage return character. Elastic trivia
            are used to denote trivia that was not produced by parsing source text, and are usually not preserved during
            formatting.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Syntax.ElasticSpace">
            <summary>
            An elastic trivia with kind WhitespaceTrivia containing a single space character. Elastic trivia are used to
            denote trivia that was not produced by parsing source text, and are usually not preserved during formatting.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Syntax.ElasticTab">
            <summary>
            An elastic trivia with kind WhitespaceTrivia containing a single tab character. Elastic trivia are used to
            denote trivia that was not produced by parsing source text, and are usually not preserved during formatting.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Syntax.ElasticMarker">
            <summary>
            An elastic trivia with kind WhitespaceTrivia containing no characters. Elastic marker trivia are included
            automatically by factory methods when trivia is not specified. Syntax formatting will replace elastic
            markers with appropriate trivia.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.EndOfLine(System.String,System.Boolean)">
            <summary>
            Creates a trivia with kind EndOfLineTrivia containing the specified text. 
            </summary>
            <param name="text">The text of the trivia. Any text can be specified here, however only carriage return and
            line feed characters are recognized by the parser as end of line.</param>
            <param name="elastic">If true, the trivia produced is an elastic trivia. Elastic trivia are used to denote
            trivia that was not produced by parsing source text, and are usually not preserved during
            formatting.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Whitespace(System.String,System.Boolean)">
            <summary>
            Creates a trivia with kind WhitespaceTrivia containing the specified text.
            </summary>
            <param name="text">The text of the whitespace. Any text can be specified here, however only specific
            whitespace characters are recognized by the parser.</param>
            <param name="elastic">If true, the trivia produced is an elastic trivia. Elastic trivia are used to denote
            trivia that was not produced by parsing source text, and are usually not preserved during
            formatting.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Comment(System.String)">
            <summary>
            Creates a trivia with kind either SingleLineCommentTrivia or MultiLineCommentTrivia containing the specified
            text.
            </summary>
            <param name="text">The entire text of the comment including the leading '//' token for single line comments
            or stop or start tokens for multiline comments.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.DisabledText(System.String)">
            <summary>
            Creates a trivia with kind DisabledTextTrivia. Disabled text corresponds to any text between directives that
            is not considered active.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.PreprocessingMessage(System.String)">
            <summary>
            Creates a trivia with kind SkipptedTextTrivia. Skipped text trivia are sometimes produced during parsing to
            denote invalid text that is ignored.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Token(Roslyn.Compilers.CSharp.SyntaxKind)">
            <summary>
            Creates a token corresponding to a syntax kind. This method can be used for token syntax kinds whose text
            can be inferred by the kind alone.
            </summary>
            <param name="kind">A syntax kind value for a token. These have the suffix Token or Keyword.</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Token(Roslyn.Compilers.CSharp.SyntaxTriviaList,Roslyn.Compilers.CSharp.SyntaxKind)">
            <summary>
            Creates a token corresponding to syntax kind. This method can be used for token syntax kinds whose text can
            be inferred by the kind alone.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="kind">A syntax kind value for a token. These have the suffix Token or Keyword.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Token(Roslyn.Compilers.CSharp.SyntaxKind,Roslyn.Compilers.CSharp.SyntaxTriviaList)">
            <summary>
            Creates a token corresponding to syntax kind. This method can be used for token syntax kinds whose text can
            be inferred by the kind alone.
            </summary>
            <param name="kind">A syntax kind value for a token. These have the suffix Token or Keyword.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Token(Roslyn.Compilers.CSharp.SyntaxTriviaList,Roslyn.Compilers.CSharp.SyntaxKind,Roslyn.Compilers.CSharp.SyntaxTriviaList)">
            <summary>
            Creates a token corresponding to syntax kind. This method can be used for token syntax kinds whose text can
            be inferred by the kind alone.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="kind">A syntax kind value for a token. These have the suffix Token or Keyword.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.MissingToken(Roslyn.Compilers.CSharp.SyntaxKind)">
            <summary>
            Creates a missing token corresponding to syntax kind. A missing token is produced by the parser when an
            expected token is not found. A missing token has no text and normally has associated diagnostics.
            </summary>
            <param name="kind">A syntax kind value for a token. These have the suffix Token or Keyword.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.MissingToken(Roslyn.Compilers.CSharp.SyntaxTriviaList,Roslyn.Compilers.CSharp.SyntaxKind,Roslyn.Compilers.CSharp.SyntaxTriviaList)">
            <summary>
            Creates a missing token corresponding to syntax kind. A missing token is produced by the parser when an
            expected token is not found. A missing token has no text and normally has associated diagnostics.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="kind">A syntax kind value for a token. These have the suffix Token or Keyword.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Identifier(System.String)">
            <summary>
            Creates a token with kind IdentiferToken containing the specified text.
            <param name="text">The raw text of the identifier name, including any escapes or leading '@'
            character.</param>
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Identifier(Roslyn.Compilers.CSharp.SyntaxTriviaList,System.String,Roslyn.Compilers.CSharp.SyntaxTriviaList)">
            <summary>
            Creates a token with kind IdentiferToken containing the specified text.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="text">The raw text of the identifier name, including any escapes or leading '@'
            character.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Identifier(System.String,Roslyn.Compilers.CSharp.SyntaxTriviaList)">
            <summary>
            Creates a token with kind IdentiferToken containing the specified text.
            </summary>
            <param name="text">The raw text of the identifier name, including any escapes or leading '@'
            character.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Identifier(Roslyn.Compilers.CSharp.SyntaxKind,Roslyn.Compilers.CSharp.SyntaxTriviaList,System.String,System.String,Roslyn.Compilers.CSharp.SyntaxTriviaList)">
            <summary>
            Creates a token with kind IdentiferToken containing the specified text.
            </summary>
            <param name="contextualKind">An alternative SyntaxKind that can be inferred for this token in special
            contexts. These are usually keywords.</param>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="text">The raw text of the identifier name, including any escapes or leading '@'
            character.</param>
            <param name="valueText">The text of the identifier name without escapes or leading '@' character.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Literal(System.String,System.Int32)">
            <summary>
            Creates a token with kind NumericLiteralToken from the text and corresponding integer value.
            </summary>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The integer value.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Literal(Roslyn.Compilers.CSharp.SyntaxTriviaList,System.String,System.Int32,Roslyn.Compilers.CSharp.SyntaxTriviaList)">
            <summary>
            Creates a token with kind NumericLiteralToken from the text and corresponding integer value.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The integer value.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Literal(System.String,System.UInt32)">
            <summary>
            Creates a token with kind NumericLiteralToken from the text and corresponding unsigned integer value.
            </summary>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The unsigned integer value.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Literal(Roslyn.Compilers.CSharp.SyntaxTriviaList,System.String,System.UInt32,Roslyn.Compilers.CSharp.SyntaxTriviaList)">
            <summary>
            Creates a token with kind NumericLiteraToken from the text and corresponding unsigned integer value.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The unsigned integer value.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Literal(System.String,System.Int64)">
            <summary>
            Creates a token with kind NumericLiteralToken from the text and corresponding long integer value.
            </summary>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The long integer value.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Literal(Roslyn.Compilers.CSharp.SyntaxTriviaList,System.String,System.Int64,Roslyn.Compilers.CSharp.SyntaxTriviaList)">
            <summary>
            Creates a token with kind NumericLiteralToken from the text and corresponding long integer value.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The long integer value.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Literal(System.String,System.UInt64)">
            <summary>
            Creates a token with kind NumericLiteralToken from the text and corresponding unsigned long integer value.
            </summary>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The unsigned long integer value.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Literal(Roslyn.Compilers.CSharp.SyntaxTriviaList,System.String,System.UInt64,Roslyn.Compilers.CSharp.SyntaxTriviaList)">
            <summary>
            Creates a token with kind NumericLiteralToken from the text and corresponding unsigned long integer value.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The unsigned long integer value.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Literal(System.String,System.Single)">
            <summary>
            Creates a token with kind NumericLiteralToken from the text and corresponding float value.
            </summary>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The float value.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Literal(Roslyn.Compilers.CSharp.SyntaxTriviaList,System.String,System.Single,Roslyn.Compilers.CSharp.SyntaxTriviaList)">
            <summary>
            Creates a token with kind NumericLiteralToken from the text and corresponding float value.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The float value.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Literal(System.String,System.Double)">
            <summary>
            Creates a token with kind NumericLiteralToken from the text and corresponding double value.
            </summary>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The double value.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Literal(Roslyn.Compilers.CSharp.SyntaxTriviaList,System.String,System.Double,Roslyn.Compilers.CSharp.SyntaxTriviaList)">
            <summary>
            Creates a token with kind NumericLiteralToken from the text and corresponding double value.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The double value.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Literal(System.String,System.Decimal)">
            <summary>
            Creates a token with kind NumericLiteralToken from the text and corresponding decimal value.
            </summary>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The decimal value.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Literal(Roslyn.Compilers.CSharp.SyntaxTriviaList,System.String,System.Decimal,Roslyn.Compilers.CSharp.SyntaxTriviaList)">
            <summary>
            Creates a token with kind NumericLiteralToken from the text and corresponding decimal value.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The decimal value.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Literal(System.String,System.String)">
            <summary>
            Creates a token with kind StringLiteralToken from the text and corresponding double value.
            </summary>
            <param name="text">The raw text of the literal, including quotes and escape sequences.</param>
            <param name="value">The string value.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Literal(Roslyn.Compilers.CSharp.SyntaxTriviaList,System.String,System.String,Roslyn.Compilers.CSharp.SyntaxTriviaList)">
            <summary>
            Creates a token with kind StringLiteralToken from the text and corresponding string value.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="text">The raw text of the literal, including quotes and escape sequences.</param>
            <param name="value">The string value.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Literal(System.String,System.Char)">
            <summary>
            Creates a token with kind CharacterLiteralToken from the text and corresponding double value.
            </summary>
            <param name="text">The raw text of the literal, including quotes and escape sequences.</param>
            <param name="value">The string value.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Literal(Roslyn.Compilers.CSharp.SyntaxTriviaList,System.String,System.Char,Roslyn.Compilers.CSharp.SyntaxTriviaList)">
            <summary>
            Creates a token with kind CharacterLiteralToken from the text and corresponding character value.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="text">The raw text of the literal, including quotes and escape sequences.</param>
            <param name="value">The character value.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.BadToken(Roslyn.Compilers.CSharp.SyntaxTriviaList,System.String,Roslyn.Compilers.CSharp.SyntaxTriviaList)">
            <summary>
            Creates a token with kind BadToken. Bad Token Bad! :-)
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="text">The raw text of the bad token.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.XmlText(Roslyn.Compilers.CSharp.SyntaxTriviaList,System.String,System.String,Roslyn.Compilers.CSharp.SyntaxTriviaList)">
            <summary>
            Creates a token with kind XmlTextLiteralToken.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The xml text value.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.XmlTextNewLine(Roslyn.Compilers.CSharp.SyntaxTriviaList,System.String,System.String,Roslyn.Compilers.CSharp.SyntaxTriviaList)">
            <summary>
            Creates a token with kind XmlTextLiteralNewLineToken.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The xml text new line value.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.XmlEntity(Roslyn.Compilers.CSharp.SyntaxTriviaList,System.String,System.String,Roslyn.Compilers.CSharp.SyntaxTriviaList)">
            <summary>
            Creates a token with kind XmlEntityLiteralToken.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The xml entity value.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.DocumentationCommentExteriorTrivia(System.String)">
            <summary>
            Creates a trivia with kind DocumentationCommentExteriaTrivia.
            </summary>
            <param name="text">The raw text of the literal.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.List``1">
            <summary>
            Creates an empty list of syntax nodes.
            </summary>
            <typeparam name="TNode">The specific type of the element nodes.</typeparam>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.List``1(``0)">
            <summary>
            Creates a singleton list of syntax nodes.
            </summary>
            <typeparam name="TNode">The specific type of the element nodes.</typeparam>
            <param name="node">The single element node.</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.List``1(``0[])">
            <summary>
            Creates a list of syntax nodes.
            </summary>
            <typeparam name="TNode">The specific type of the element nodes.</typeparam>
            <param name="nodes">An array of element nodes.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.List``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Creates a list of syntax nodes.
            </summary>
            <typeparam name="TNode">The specific type of the element nodes.</typeparam>
            <param name="nodes">A sequence of element nodes.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.TokenList">
            <summary>
            Creates an empty list of tokens.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.TokenList(Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>
            Creates a singleton list of tokens.
            </summary>
            <param name="token">The single token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.TokenList(Roslyn.Compilers.CSharp.SyntaxToken[])">
            <summary>
            Creates a list of tokens.
            </summary>
            <param name="tokens">An array of tokens.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.TokenList(System.Collections.Generic.IEnumerable{Roslyn.Compilers.CSharp.SyntaxToken})">
            <summary>
            Creates a list of tokens.
            </summary>
            <param name="tokens"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Trivia(Roslyn.Compilers.CSharp.StructuredTriviaSyntax)">
            <summary>
            Creates a trivia from a StructuredTriviaSyntax node.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.TriviaList">
            <summary>
            Creates an empty list of trivia.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.TriviaList(Roslyn.Compilers.CSharp.SyntaxTrivia)">
            <summary>
            Creates a singleton list of trivia.
            </summary>
            <param name="trivia">A single trivia.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.TriviaList(Roslyn.Compilers.CSharp.SyntaxTrivia[])">
            <summary>
            Creates a list of trivia.
            </summary>
            <param name="trivias">An array of trivia.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.TriviaList(System.Collections.Generic.IEnumerable{Roslyn.Compilers.CSharp.SyntaxTrivia})">
            <summary>
            Create a list of trivia.
            </summary>
            <param name="trivias">A sequence of trivia.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.SeparatedList``1">
            <summary>
            Create an empty separated list.
            </summary>
            <typeparam name="TNode">The specific type of the element nodes.</typeparam>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.SeparatedList``1(``0)">
            <summary>
            Create a singleton separated list.
            </summary>
            <typeparam name="TNode">The specific type of the element nodes.</typeparam>
            <param name="node">A single node.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.SeparatedList``1(Roslyn.Compilers.CSharp.SyntaxNodeOrToken[])">
            <summary>
            Create a singleton separated list from a sequence of nodes or tokens, alternating between nodes and
            separator tokens.
            </summary>
            <typeparam name="TNode">The specific type of the element nodes.</typeparam>
            <param name="nodes">An array of nodes or tokens, alternating between nodes and separator tokens.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.SeparatedList``1(System.Collections.Generic.IEnumerable{Roslyn.Compilers.CSharp.SyntaxNodeOrToken})">
            <summary>
            Create a singleton separated list from a sequence of nodes or tokens, alternating between nodes and
            separator tokens.
            </summary>
            <typeparam name="TNode">The specific type of the element nodes.</typeparam>
            <param name="nodes">A sequence of nodes or tokens, alternating between nodes and separator tokens.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.SeparatedList``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{Roslyn.Compilers.CSharp.SyntaxToken})">
            <summary>
            Creates a separated list of nodes from a sequence of nodes and a sequence of separator tokens.
            </summary>
            <typeparam name="TNode">The specific type of the element nodes.</typeparam>
            <param name="nodes">A sequence of syntax nodes.</param>
            <param name="separators">A sequence of token to be interleaved between the nodes. The number of tokens must
            be one less than the number of nodes.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.IdentifierName(System.String)">
            <summary>
            Creates an IdentifierNameSyntax node.
            </summary>
            <param name="name">The identifier name.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ParseLeadingTrivia(System.String,System.Int32)">
            <summary>
            Parse a list of trivia rules for leading trivia.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ParseTrailingTrivia(System.String,System.Int32)">
            <summary>
            Parse a list of trivia using the parsing rules for trailing trivia.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ParseToken(System.String,System.Int32)">
            <summary>
            Parse a C# language token.
            </summary>
            <param name="text">The text of the token including leading and trailing trivia.</param>
            <param name="offset">Optional offset into text.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ParseTokens(System.String,System.Int32,System.Int32)">
            <summary>
            Parse a sequence of C# language tokens.
            </summary>
            <param name="text">The text of all the tokens.</param>
            <param name="initialTokenPosition">An integer to use as the starting position of the first token.</param>
            <param name="offset">Optional offset into text.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ParseName(System.String,System.Int32)">
            <summary>
            Parse a NameSyntax node using the grammar rule for names.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ParseTypeName(System.String,System.Int32)">
            <summary>
            Parse a TypeNameSyntax node using the grammar rule for type names.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ParseExpression(System.String,System.Int32,Roslyn.Compilers.CSharp.ParseOptions)">
            <summary>
            Parse an ExpressionSyntax node using the lowest precedence grammar rule for expressions.
            </summary>
            <param name="text">The text of the expression.</param>
            <param name="offset">Optional offset into text.</param>
            <param name="options">The optional parse options to use. If no options are specified default options are
            used.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ParseStatement(System.String,System.Int32,Roslyn.Compilers.CSharp.ParseOptions)">
            <summary>
            Parse a StatementSyntaxNode using grammar rule for statements.
            </summary>
            <param name="text">The text of the statement.</param>
            <param name="offset">Optional offset into text.</param>
            <param name="options">The optional parse options to use. If no options are specified default options are
            used.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ParseCompilationUnit(System.String,System.Int32,Roslyn.Compilers.CSharp.ParseOptions)">
            <summary>
            Parse a CompilationUnitSyntax using the grammar rule for an entire compilation unit (file). To produce a
            SyntaxTree instance, using SyntaxTree.ParseCompilationUnit instead.
            </summary>
            <param name="text">The text of the compilation unit.</param>
            <param name="offset">Optional offset into text.</param>
            <param name="options">The optional parse options to use. If no options are specified default options are
            used.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ParseParameterList(System.String,System.Int32,Roslyn.Compilers.CSharp.ParseOptions)">
            <summary>
            Parse a ParameterListSyntax node.
            </summary>
            <param name="text">The text of the parenthesized parameter list.</param>
            <param name="offset">Optional offset into text.</param>
            <param name="options">The optional parse options to use. If no options are specified default options are
            used.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ParseBracketedParameterList(System.String,System.Int32,Roslyn.Compilers.CSharp.ParseOptions)">
            <summary>
            Parse a BracketedParameterListSyntax node.
            </summary>
            <param name="text">The text of the bracketed parameter list.</param>
            <param name="offset">Optional offset into text.</param>
            <param name="options">The optional parse options to use. If no options are specified default options are
            used.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ParseArgumentList(System.String,System.Int32,Roslyn.Compilers.CSharp.ParseOptions)">
            <summary>
            Parse an ArgumentListSyntax node.
            </summary>
            <param name="text">The text of the parenthesized argument list.</param>
            <param name="offset">Optional offset into text.</param>
            <param name="options">The optional parse options to use. If no options are specified default options are
            used.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ParseBracketedArgumentList(System.String,System.Int32,Roslyn.Compilers.CSharp.ParseOptions)">
            <summary>
            Parse a BracketedArgumentListSyntax node.
            </summary>
            <param name="text">The text of the bracketed argument list.</param>
            <param name="offset">Optional offset into text.</param>
            <param name="options">The optional parse options to use. If no options are specified default options are
            used.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.MakeIText(System.String,System.Int32)">
            <summary>
            Helper method for wrapping a string in an IText.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.AreEquivalent(Roslyn.Compilers.CSharp.SyntaxTree,Roslyn.Compilers.CSharp.SyntaxTree,System.Boolean)">
            <summary>
            Determines if two trees are the same, disregarding trivia differences.
            </summary>
            <param name="oldTree">The original tree.</param>
            <param name="newTree">The new tree.</param>
            <param name="topLevel"> If true then the trees are equivalent if the contained nodes and tokens declaring
            metadata visible symbolic information are equivalent, ignoring any differences of nodes inside method bodies
            or initializer expressions, otherwise all nodes and tokens must be equivalent. 
            </param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.AreEquivalent(Roslyn.Compilers.CSharp.SyntaxNode,Roslyn.Compilers.CSharp.SyntaxNode,System.Boolean)">
            <summary>
            Determines if two syntax nodes are the same, disregarding trivia differences.
            </summary>
            <param name="oldNode">The old node.</param>
            <param name="newNode">The new node.</param>
            <param name="topLevel"> If true then the nodes are equivalent if the contained nodes and tokens declaring
            metadata visible symbolic information are equivalent, ignoring any differences of nodes inside method bodies
            or initializer expressions, otherwise all nodes and tokens must be equivalent. 
            </param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.GetStandAloneExpression(Roslyn.Compilers.CSharp.SyntaxNode)">
            <summary>
            Gets the containing expression that is actually a language expression and not just typed
            as an ExpressionSyntax for convenience. For example, NameSyntax nodes on the right side
            of qualified names and member access expressions are not language expressions, yet the
            containing qualified names or member access expressions are indeed expressions.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.GetNonGenericExpression(Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>
            Converts a generic name expression into one without the generic arguments.
            </summary>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.DecomposeName(Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.ExpressionSyntax@,System.String@,System.Int32@)">
            <summary>
            Decomposes a name or member access expression into its component parts.
            </summary>
            <param name="expression">The name or member access expression.</param>
            <param name="qualifier">The qualifier (or left-hand-side) of the name expression. This may be null if there is no qualifier.</param>
            <param name="name">The name of the expression.</param>
            <param name="arity">The number of generic type parameters.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.IsCompleteSubmission(Roslyn.Compilers.CSharp.SyntaxTree)">
            <summary>
            Determines whether the given text is considered a syntactically complete submission.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.TypeDeclaration(Roslyn.Compilers.CSharp.DeclarationKind,Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.AttributeDeclarationSyntax},Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.TypeParameterListSyntax,Roslyn.Compilers.CSharp.BaseListSyntax,Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.TypeParameterConstraintClauseSyntax},Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.MemberDeclarationSyntax},Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new ClassDeclarationSyntax instance or InterfaceDeclarationSyntax instance or StructDeclarationSyntax instance .</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.TypeDeclaration(Roslyn.Compilers.CSharp.SyntaxKind,Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.AttributeDeclarationSyntax},Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.TypeParameterListSyntax,Roslyn.Compilers.CSharp.BaseListSyntax,Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.TypeParameterConstraintClauseSyntax},Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.MemberDeclarationSyntax},Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new ClassDeclarationSyntax instance or InterfaceDeclarationSyntax instance or StructDeclarationSyntax instance .</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.InternalSyntax.SeparatedSyntaxList`1.GetSeparator(System.Int32)">
            <summary>
            Gets the separator at the given index in this list.
            </summary>
            <param name="index">The index.</param>
            <returns></returns>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.CSharpLineDirectiveMap">
            <summary>
            Adds C# specific parts to the line directive map.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SeparatedSyntaxList`1.GetSeparator(System.Int32)">
            <summary>
            Gets the separator at the given index in this list.
            </summary>
            <param name="index">The index.</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxFacts.IsGlobalMemberDeclaration(Roslyn.Compilers.CSharp.SyntaxKind)">
            <summary>
            Member declarations that can appear in global code (other than type declarations).
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxFacts.IsAliasQualifier(Roslyn.Compilers.CSharp.SyntaxNode)">
            <summary>
            Returns true if the node is the alias of an AliasQualifiedNameSyntax
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxFacts.IsInvoked(Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>
            Returns true if the node is the object of an invocation expression
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxFacts.IsInTypeOnlyContext(Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>
            Returns true if the node is in a tree location that is expected to be a type
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxFacts.IsInNamespaceOrTypeContext(Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>
            Returns true if a node is in a tree location that is expected to be either a namespace or type
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxList.GetRedElement(Roslyn.Compilers.CSharp.SyntaxNode@,System.Int32)">
            <summary>
            This works the same as GetRedOnly, but intended to be used in lists
            The only difference is that the public parent of the node is not the list, 
            but the list's parent. (element's grand parent).
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNavigation.GetTokens(Roslyn.Compilers.CSharp.SyntaxNode,Roslyn.Compilers.TextSpan,System.Func{Roslyn.Compilers.CSharp.SyntaxToken,System.Boolean},System.Func{Roslyn.Compilers.CSharp.SyntaxTrivia,System.Boolean})">
            <summary>
            Enumerates all tokens under the given node that overlap with given span.
            Only structured trivia for which <paramref name="stepInto"/> (none if null) returns true are visited. 
            Only tokens for which <paramref name="predicate"/> returns true are added into the list.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNavigation.GetTokens(Roslyn.Compilers.CSharp.SyntaxNode,Roslyn.Compilers.TextSpan)">
            <summary>
            Enumerates all tokens under the given node that overlap with given span.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SyntaxNodeOrToken">
            <summary>
            This structure is a union of either a SyntaxNode or a SyntaxToken.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNodeOrToken.GetFirstChildIndexSpanningPosition(Roslyn.Compilers.CSharp.SyntaxNode,System.Int32)">
            <summary>
            binary search of nodes to find the slot.  Consider unifying this with that
            implementation.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxNodeOrToken.HasStructuredTrivia">
            <summary>
            Determine whether any of this node or token's descendent trivia is structured.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList">
            <summary>
            A list of <see cref="T:Roslyn.Compilers.CSharp.SyntaxNodeOrToken"/> structures.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList._parent">
            <summary>
            This list's parent node
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList._node">
            <summary>
            The underlying field
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList._position">
            <summary>
            The character position 
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList._index">
            <summary>
            The index from the parent's children list of this node.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList.#ctor(Roslyn.Compilers.CSharp.SyntaxNode,Roslyn.Compilers.Common.IBaseSyntaxNodeExt,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList"/> structure.
            </summary>
            <param name="parent">The parent node.</param>
            <param name="node">The underlying syntax node.</param>
            <param name="position">The position.</param>
            <param name="index">The index.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList.#ctor(Roslyn.Compilers.CSharp.SyntaxNode)">
            <summary>
            Initializes a new instance of the <see cref="T:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList"/> structure with default values for parent,
            position and index.
            </summary>
            <param name="node">The underlying syntax node.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList.#ctor(Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>
            Initializes a new instance of the <see cref="T:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList"/> structure with default values for parent,
            position and index.
            </summary>
            <param name="token">The underlying syntax token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList.First">
            <summary>
            Gets the first SyntaxNodeOrToken structure from this list.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList.FirstOrDefault">
            <summary>
            Gets the first SyntaxNodeOrToken structure from this list if present, else default(SyntaxNodeOrToken).
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList.Last">
            <summary>
            Gets the last SyntaxNodeOrToken structure from this list.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList.LastOrDefault">
            <summary>
            Gets the last SyntaxNodeOrToken structure from this list if present, else default(SyntaxNodeOrToken).
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList.IndexOf(Roslyn.Compilers.CSharp.SyntaxNodeOrToken)">
            <summary>
            Returns the index from the list for the given nodeOrToken.
            </summary>
            <param name="nodeOrToken">The node or token to search for in the list.</param>
            <returns>The index of the found nodeOrToken, or -1 if it wasn't found</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList.Any">
            <summary>
            Indicates whether there is any element in the list.
            </summary>
            <returns><c>true</c> if there are any elements in the list, else <c>false</c>.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList.Any(Roslyn.Compilers.CSharp.SyntaxKind)">
            <summary>
            Indicates whether there is any element in the list of the given kind.
            </summary>
            <returns><c>true</c> if there are any elements in the list of the given kind, else <c>false</c>.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList.CopyTo(System.Int32,Roslyn.Compilers.CSharp.SyntaxNodeOrToken[],System.Int32,System.Int32)">
            <summary>
            Copies a given count of elements into the given array at specified offsets.
            </summary>
            <param name="offset">The offset to start copying from.</param>
            <param name="array">The array to copy the elements into.</param>
            <param name="arrayOffset">The array offset to start writing to.</param>
            <param name="count">The count of elements to copy.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList.CopyTo(System.Int32,Roslyn.Compilers.ArrayElement{Roslyn.Compilers.Common.IBaseSyntaxNodeExt}[],System.Int32,System.Int32)">
            <summary>
            Copies a given count of elements into the given array at specified offsets.
            </summary>
            <param name="offset">The offset to start copying from.</param>
            <param name="array">The array to copy the elements into.</param>
            <param name="arrayOffset">The array offset to start writing to.</param>
            <param name="count">The count of elements to copy.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList.GetEnumerator">
            <summary>
            Gets the enumerator.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList.System#Collections#Generic#IEnumerable{Roslyn#Compilers#CSharp#SyntaxNodeOrToken}#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList.op_Equality(Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList,Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList)">
            <summary>
            Implements the operator ==.
            </summary>
            <param name="left">The left SyntaxNodeOrTokenList</param>
            <param name="right">The right SyntaxNodeOrTokenList</param>
            <returns>
            <c>true</c> if both lists equal, else <c>false</c>.
            </returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList.op_Inequality(Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList,Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList)">
            <summary>
            Implements the operator !=.
            </summary>
            <param name="left">The left SyntaxNodeOrTokenList</param>
            <param name="right">The right SyntaxNodeOrTokenList</param>
            <returns>
            <c>true</c> if both lists not equal, else <c>false</c>.
            </returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList.Equals(Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>
            <c>true</c> if the current object is equal to the <paramref name="other"/> parameter; otherwise,
            <c>false</c>.
            </returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with this instance.</param>
            <returns>
              <c>true</c> if the specified <see cref="T:System.Object"/> is equal to this instance; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
            </returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList.op_Implicit(Roslyn.Compilers.CSharp.SyntaxNode)~Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList">
            <summary>
            Performs an implicit conversion from <see cref="T:Roslyn.Compilers.CSharp.SyntaxNode"/> to <see cref="T:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList"/>.
            </summary>
            <param name="node">A syntax node.</param>
            <returns>
            The result of the conversion.
            </returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList.op_Implicit(Roslyn.Compilers.CSharp.SyntaxToken)~Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList">
            <summary>
            Performs an implicit conversion from <see cref="T:Roslyn.Compilers.CSharp.SyntaxToken"/> to <see cref="T:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList"/>.
            </summary>
            <param name="token">The syntax token.</param>
            <returns>
            The result of the conversion.
            </returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList.AsSeparatedList``1">
            <summary>
            Returns this list as a <see cref="T:Roslyn.Compilers.CSharp.SeparatedSyntaxList`1"/>.
            </summary>
            <typeparam name="TOther">The type of the list elements in the separated list.</typeparam>
            <returns></returns>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList.Node">
            <summary>
            Gets the underlying syntax node.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList.Count">
            <summary>
            Gets the count of nodes in this list
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList.Item(System.Int32)">
            <summary>
            Gets the <see cref="T:Roslyn.Compilers.CSharp.SyntaxNodeOrToken"/> at the specified index. 
            </summary>
            
            <exception cref="T:System.IndexOutOfRangeException"><paramref name="index"/> is out of range.</exception>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList.Enumerator">
            <summary>
            Enumerator for lists of SyntaxNodeOrToken structs.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList.Enumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
            </returns>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList.Enumerator.System#Collections#IEnumerator#Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList.Enumerator.System#IDisposable#Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList.Enumerator.Current">
            <summary>
            Gets the struct that this enumerator instance is currently pointing to.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList.Enumerator.System#Collections#IEnumerator#Current">
            <summary>
            Gets the struct that this enumerator instance is currently pointing to.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SyntaxToken">
            <summary>
            Represents a token in the syntax tree.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxToken.GetFullText">
            <summary>
            Returns the full text of the token, including surrounding trivia attached to the token.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxToken.GetText">
            <summary>
            Returns the text of the token, excluding surrounding trivia attached to the token.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxToken.WriteTo(System.IO.TextWriter)">
            <summary>
            Writes the full text of this token to the specified TextWriter.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxToken.ToString">
            <summary>
            Returns the token's full text which includes the token and any leading and trailing trivia.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxToken.GetAllTrivia">
            <summary>
            Gets a list of both leading and trailing trivia for the token.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxToken.WithLeadingTrivia(Roslyn.Compilers.CSharp.SyntaxTriviaList)">
            <summary>
            Clones the token and adds the <paramref name="trivia"/> as leading trivia.
            </summary>
            <param name="trivia">The <see cref="T:Roslyn.Compilers.CSharp.SyntaxTriviaList"/> to add as leading trivia.</param>
            <returns>A new token with leading trivia.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxToken.WithTrailingTrivia(Roslyn.Compilers.CSharp.SyntaxTriviaList)">
            <summary>
            Clones the token and adds the <paramref name="trivia"/> as trailing trivia.
            </summary>
            <param name="trivia">The <see cref="T:Roslyn.Compilers.CSharp.SyntaxTriviaList"/> to add as trailing trivia.</param>
            <returns>A new token with trailing trivia.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxToken.op_Equality(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>
            Returns true if <paramref name="a"/> equals <paramref name="b"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxToken.op_Inequality(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>
            Returns true if <paramref name="a"/> is not equal to <paramref name="b"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxToken.Equals(Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>
            Returns true if this <see cref="T:Roslyn.Compilers.CSharp.SyntaxToken"/> equals <paramref name="other"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxToken.Equals(System.Object)">
            <summary>
            Returns true if this <see cref="T:Roslyn.Compilers.CSharp.SyntaxToken"/> equals <paramref name="obj"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxToken.EquivalentTo(Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>
            True is <paramref name="other"/> is equivalent to this <see cref="T:Roslyn.Compilers.CSharp.SyntaxToken"/>.  Two tokens are equivalent
            if they are the same kind, have the same text and have the same full width.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxToken.GetHashCode">
            <summary>
            Serves as a hash function for the <see cref="T:Roslyn.Compilers.CSharp.SyntaxToken"/>
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxToken.op_Implicit(Roslyn.Compilers.CSharp.SyntaxToken)~Roslyn.Compilers.Common.CommonSyntaxToken">
            <summary>
            Converts a <see cref="T:Roslyn.Compilers.CSharp.SyntaxToken"/> to a <see cref="T:Roslyn.Compilers.Common.CommonSyntaxToken"/>
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxToken.op_Explicit(Roslyn.Compilers.Common.CommonSyntaxToken)~Roslyn.Compilers.CSharp.SyntaxToken">
            <summary>
            Converts a <see cref="T:Roslyn.Compilers.Common.CommonSyntaxToken"/> to a <see cref="T:Roslyn.Compilers.CSharp.SyntaxToken"/>
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxToken.op_Implicit(Roslyn.Compilers.CSharp.SyntaxToken)~Roslyn.Compilers.Common.CommonSyntaxNodeOrToken">
            <summary>
            Converts a <see cref="T:Roslyn.Compilers.CSharp.SyntaxToken"/> to a <see cref="T:Roslyn.Compilers.Common.CommonSyntaxNodeOrToken"/>
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxToken.op_Explicit(Roslyn.Compilers.Common.CommonSyntaxNodeOrToken)~Roslyn.Compilers.CSharp.SyntaxToken">
            <summary>
            Converts a <see cref="T:Roslyn.Compilers.Common.CommonSyntaxNodeOrToken"/> to a <see cref="T:Roslyn.Compilers.CSharp.SyntaxToken"/>
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxToken.WithAdditionalAnnotations(Roslyn.Compilers.SyntaxAnnotation[])">
            <summary>
            Adds this annotation to a given syntax token, creating a new syntax token of the same type with the
            annotation on it.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxToken.CopyAnnotations(Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>
            Finds any annotations that are on token "from", and then attaches them to token "to",
            returning a new token with the annotations attached. 
            
            If no annotations are copied, just returns "to".
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxToken.GetNextToken(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Returns the token after this token in the syntax tree.
            </summary>
            <param name="includeSkipped">If true then search inside trailing trivia and skipped token trivia may be
            returned.</param>
            <param name="includeDirectives">If true then search inside trailing trivia and directive trivia may be
            returned</param>
            <param name="includeDocumentationComments">if true then search inside trailing trivia and document comment
            trivia may be returned.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxToken.GetNextToken(System.Func{Roslyn.Compilers.CSharp.SyntaxToken,System.Boolean},System.Func{Roslyn.Compilers.CSharp.SyntaxTrivia,System.Boolean})">
            <summary>
            Returns the token after this token in the syntax tree.
            </summary>
            <param name="predicate">Delegate applied to each token.  The token is returned if the predicate returns
            true.</param>
            <param name="stepInto">Delegate applied to trivia.  If this delegate is present then trailing trivia is
            included in the search.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxToken.GetPreviousToken(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Returns the token before this token in the syntax tree.
            </summary>
            <param name="includeSkipped">If true then search inside leading trivia and skipped token trivia may be
            returned.</param>
            <param name="includeDirectives">If true then search inside leading trivia and directive trivia may be
            returned</param>
            <param name="includeDocumentationComments">if true then search inside leading trivia and document comment
            trivia may be returned.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxToken.GetPreviousToken(System.Func{Roslyn.Compilers.CSharp.SyntaxToken,System.Boolean},System.Func{Roslyn.Compilers.CSharp.SyntaxTrivia,System.Boolean})">
            <summary>
            Returns the token before this token in the syntax tree.
            </summary>
            <param name="predicate">Delegate applied to each token.  The token is returned if the predicate returns
            true.</param>
            <param name="stepInto">Delegate applied to trivia.  If this delegate is present then trailing trivia is
            included in the search.</param>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxToken.Kind">
            <summary>
            The token's <see cref="T:Roslyn.Compilers.CSharp.SyntaxKind"/>.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxToken.ContextualKind">
            <summary>
            The kind of token, given its position in the syntax. This differs from <see cref="P:Roslyn.Compilers.CSharp.SyntaxToken.Kind"/> when a contextual keyword is used in a place in the syntax that gives it
            its keyword meaning.
            </summary>
            <remarks>
            The ContextualKind is relevant only on contextual keyword tokens. ContextualKind differs
            from Kind when a token is used in context where the token should be interpreted as a
            keyword.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxToken.IsMissing">
            <summary>
            Determines whether the node represents a language construct that was actually parsed from the source code. Missing nodes are
            generated by the parser in error scenarios to represent constructs that should have been present
            in the source code in order to compile successfully but were actually missing.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxToken.Text">
            <summary>
            The text of the token as it appeared in the source.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxToken.Value">
            <summary>
            The value designated by the token, if it is a literal (e.g. true, false, 12, "foo").  For example, the sequence of letters of an
            identifier, excluding the escape character if it was escaped in the source,
            or the characters of a string excluding the quotes and with escape sequences
            translated.  For constants, ValueText is the canonical form of the designated
            value (e.g. leading zeroes are dropped).
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxToken.ValueText">
            <summary>
            The string text of the value of the token.  For example, the sequence of letters of an
            identifier, excluding the escape character if it was escaped in the source,
            or the characters of a string excluding the quotes and with escape sequences
            translated.  For constants, ValueText is the canonical form of the designated
            value (e.g. leading zeroes are dropped).
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxToken.Parent">
            <summary>
            The immediately enclosing <see cref="T:Roslyn.Compilers.CSharp.SyntaxNode"/>.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxToken.FullSpan">
            <summary>
            The absolute span of characters of the token, including surrounding trivia that is attached to the token.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxToken.Span">
            <summary>
            The span of characters of the token, excluding trivia surrounding the token.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxToken.FullWidth">
            <summary>
            The full width of the token, including surrounding trivia that is attached to the token.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxToken.Width">
            <summary>
            The width of the token, excluding trivia surrounding the token.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxToken.LeadingWidth">
            <summary>
            The width of trivia attached to and preceding the token.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxToken.TrailingWidth">
            <summary>
            The width of trivia attached to and following the token.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxToken.HasDiagnostics">
            <summary>
            True if any diagnostics are associated with the token in the context of its parse tree.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxToken.HasAnnotations">
            <summary>
            Determines whether this token or any of its trivia has annotations
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxToken.HasDirectives">
            <summary>
            True if any directives are associated with the token in the context of its parse tree.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxToken.HasStructuredTrivia">
            <summary>
            True if any trivia of this token is structured.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxToken.HasLeadingTrivia">
            <summary>
            True if the token has preceding trivia that is attached to the token.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxToken.LeadingTrivia">
            <summary>
            The list of trivia that precedes and is attached to the token.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxToken.HasTrailingTrivia">
            <summary>
            True if the token has trailing trivia that is attached to the token.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxToken.TrailingTrivia">
            <summary>
            The list of trivia that follows and is attached to the token.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SyntaxTokenList">
            <summary>
             Represents a read-only list of <see cref="T:Roslyn.Compilers.CSharp.SyntaxToken"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTokenList.First">
            <summary>
            Returns the first token in the list.
            </summary>
            <returns>The first token in the list.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTokenList.FirstOrDefault">
            <summary>
            Returns the first token in the list or a default token if the list is empty.
            </summary>
            <returns>default(<see cref="T:Roslyn.Compilers.CSharp.SyntaxToken"/>) if source is empty; otherwise, the first token in the
            list.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTokenList.Last">
            <summary>
            Returns the last token in the list.
            </summary>
            <returns> The last token in the list.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTokenList.LastOrDefault">
            <summary>
            Returns the last token in the list of a default token if the list is empty.
            </summary>
            <returns>default(<see cref="T:Roslyn.Compilers.CSharp.SyntaxToken"/>) if list is empty; otherwise, the last token in the
            list.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTokenList.Any">
            <summary>
            Tests whether the list is non-empty.
            </summary>
            <returns>True if the list contains any tokens.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTokenList.Any(Roslyn.Compilers.CSharp.SyntaxKind)">
            <summary>
            Tests whether a list contains tokens of a particular kind.
            </summary>
            <param name="kind">The <see cref="T:Roslyn.Compilers.CSharp.SyntaxKind"/> to test for.</param>
            <returns>Returns true if the list contains a token which matches <paramref name="kind"/></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTokenList.CopyTo(System.Int32,Roslyn.Compilers.CSharp.SyntaxToken[],System.Int32,System.Int32)">
            <summary>
            Copies the elements of the <see cref="T:Roslyn.Compilers.CSharp.SyntaxTokenList"/> to an <see cref="T:System.Array"/>.
            </summary>
            <param name="offset">The starting index in the <see cref="T:Roslyn.Compilers.CSharp.SyntaxTokenList"/></param>
            <param name="array">The one-dimensional <see cref="T:System.Array"/> that is the destination of the elements copied
            from <see cref="T:Roslyn.Compilers.CSharp.SyntaxTokenList"/>. The Array must have zero-based indexing.</param>
            <param name="arrayOffset">The zero-based index in <paramref name="array"/>at which copying begins.</param>
            <param name="count">The number of items to copy.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTokenList.GetEnumerator">
            <summary>
            Returns an enumerator for the tokens in the <see cref="T:Roslyn.Compilers.CSharp.SyntaxTokenList"/>
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTokenList.op_Equality(Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.SyntaxTokenList)">
            <summary>
            Compares <paramref name="left"/> and <paramref name="right"/> for equality.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns>True if the two <see cref="T:Roslyn.Compilers.CSharp.SyntaxTokenList"/>s are equal.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTokenList.op_Inequality(Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.SyntaxTokenList)">
            <summary>
            Compares <paramref name="left"/> and <paramref name="right"/> for inequality.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTokenList.Equals(System.Object)">
            <summary>
            Compares this <see cref="T:Roslyn.Compilers.CSharp.SyntaxTokenList"/> with the <paramref name="obj"/> for equality.
            </summary>
            <returns>True if the two objects are equal.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTokenList.GetHashCode">
            <summary>
            Serves as a hash function for the <see cref="T:Roslyn.Compilers.CSharp.SyntaxTokenList"/>
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTokenList.op_Implicit(Roslyn.Compilers.CSharp.SyntaxToken)~Roslyn.Compilers.CSharp.SyntaxTokenList">
            <summary>
            Converts a <see cref="T:Roslyn.Compilers.CSharp.SyntaxToken"/> to a <see cref="T:Roslyn.Compilers.CSharp.SyntaxTokenList"/>
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxTokenList.Count">
            <summary>
            Returns the number of tokens in the list.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxTokenList.Item(System.Int32)">
            <summary>
            Gets the token at the specified index.
            </summary>
            <param name="index">The zero-based index of the token to get or set.</param>
            <returns>The token at the specified index.</returns>
            <exception cref="T:System.IndexOutOfRangeException">"&gt;<paramref name="index"/>is out of bounds.</exception>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SyntaxTokenList.Enumerator">
            <summary>
            A structure for enumerating the a <see cref="T:Roslyn.Compilers.CSharp.SyntaxTokenList"/>
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTokenList.Enumerator.MoveNext">
            <summary>
            Advances the enumerator to the next token in the collection.
            </summary>
            <returns>true if the enumerator was successfully advanced to the next element; false if the enumerator
            has passed the end of the collection.</returns>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxTokenList.Enumerator.Current">
            <summary>
            Gets the current element in the collection.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SyntaxTree">
            <summary>
            The parsed representation of a C# source document.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTree.GetRoot(System.Threading.CancellationToken)">
            <summary>
            Gets the root node of the syntax tree.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTree.GetText(System.Threading.CancellationToken)">
            <summary>
            Gets the text of the source document.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTree.GetReference(Roslyn.Compilers.CSharp.SyntaxNode)">
            <summary>
            Gets a SyntaxReference for a specified syntax node. SyntaxReferences can be used to regain access to a
            syntax node without keeping the entire tree and source text in memory.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTree.IsEquivalentTo(Roslyn.Compilers.CSharp.SyntaxTree,System.Boolean)">
            <summary>
            Determines if two trees are the same, disregarding trivia differences.
            </summary>
            <param name="tree">The tree to compare against.</param>
            <param name="topLevel"> If true then the trees are equivalent if the contained nodes and tokens declaring
            metadata visible symbolic information are equivalent, ignoring any differences of nodes inside method bodies
            or initializer expressions, otherwise all nodes and tokens must be equivalent. 
            </param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTree.Create(System.String,Roslyn.Compilers.CSharp.CompilationUnitSyntax,Roslyn.Compilers.CSharp.ParseOptions)">
            <summary>
            Create a new syntax tree from a syntax node.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTree.ParseCompilationUnit(System.String,System.String,Roslyn.Compilers.CSharp.ParseOptions,System.Threading.CancellationToken)">
            <summary>
            Produces a syntax tree by parsing the source text.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTree.ParseCompilationUnit(Roslyn.Compilers.IText,System.String,Roslyn.Compilers.CSharp.ParseOptions,System.Threading.CancellationToken)">
            <summary>
            Produces a syntax tree by parsing the source text.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTree.WithChange(Roslyn.Compilers.IText,Roslyn.Compilers.TextChangeRange[])">
            <summary>
            Create a new syntax tree based off this tree, the new source text and a list of changes to the old text. The
            changes must be a list of non-overlapping, non-abutting ranges. The list must be sorted in ascending order
            of the range's start positions.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTree.GetChangedSpans(Roslyn.Compilers.CSharp.SyntaxTree)">
            <summary>
            Produces a pessimistic list of spans that denote the regions of text in this tree that
            are changed from the text of the old tree.
            </summary>
            <param name="oldTree">The old tree.</param>
            <remarks>The list is pessimistic because it may claim more or larger regions than actually changed.</remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTree.GetChanges(Roslyn.Compilers.CSharp.SyntaxTree)">
            <summary>
            Gets a list of text changes that when applied to the old tree produce this tree.
            </summary>
            <param name="oldTree">The old tree.</param>
            <remarks>The list of changes may be different than the original changes that produced this tree.</remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTree.GetChangeRanges(Roslyn.Compilers.CSharp.SyntaxTree)">
            <summary>
            Gets a list of text change ranges that when applied to the old tree produce this tree.
            </summary>
            <param name="oldTree">The old tree.</param>
            <remarks>The list of changes may be different than the original changes that produced this tree.</remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTree.GetLineSpan(Roslyn.Compilers.TextSpan,System.Boolean)">
            <summary>
            Gets a <see cref="T:Roslyn.Compilers.FileLinePositionSpan"/> for a <see cref="T:Roslyn.Compilers.TextSpan"/>. FileLinePositionSpans are used
            primarily for diagnostics and source locations.
            </summary>
            <param name="span">The source <see cref="T:Roslyn.Compilers.TextSpan"/> to convert.</param>
            <param name="usePreprocessorDirectives">An indicator that determines whether preprocessor #line directives
            are used to alter the resulting line span.</param>
            <returns>A resulting <see cref="T:Roslyn.Compilers.FileLinePositionSpan"/>.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTree.GetLocation(Roslyn.Compilers.CSharp.SyntaxNode)">
            <summary>
            Gets a <see cref="T:Roslyn.Compilers.CSharp.Location"/> for the specified syntax node.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTree.GetLocation(Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>
            Gets a <see cref="T:Roslyn.Compilers.CSharp.Location"/> for the specified token.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTree.GetLocation(Roslyn.Compilers.CSharp.SyntaxNodeOrToken)">
            <summary>
            Gets a <see cref="T:Roslyn.Compilers.CSharp.Location"/> for the specified node or token.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTree.GetLocation(Roslyn.Compilers.CSharp.SyntaxTrivia)">
            <summary>
            Gets a <see cref="T:Roslyn.Compilers.CSharp.Location"/> for the specified trivia.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTree.GetLocation(Roslyn.Compilers.TextSpan)">
            <summary>
            Gets a <see cref="T:Roslyn.Compilers.CSharp.Location"/> for the specified text span.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTree.GetDiagnostics(Roslyn.Compilers.CSharp.SyntaxNode)">
            <summary>
            Gets a list of all the diagnostics in the sub tree that has the specified node as its root.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTree.GetDiagnostics(Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>
            Gets a list of all the diagnostics associated with the token and any related trivia.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTree.GetDiagnostics(Roslyn.Compilers.CSharp.SyntaxTrivia)">
            <summary>
            Gets a list of all the diagnostics associated with the trivia.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTree.GetDiagnostics(Roslyn.Compilers.CSharp.SyntaxNodeOrToken)">
            <summary>
            Gets a list of all the diagnostics in either the sub tree that has the specified node as its root or
            associated with the token and its related trivia. 
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTree.GetDiagnostics(System.Threading.CancellationToken)">
            <summary>
            Gets a list of all the diagnostics in the syntax tree.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxTree.FileName">
            <summary>
            The name of the source document file.
            </summary>
            <remarks>
            If this syntax tree is not associated with a file, this FileName can (and often will) be the empty string.
            
            Clients must not assume that a file exists on disk with the given name, even if a non-empty
            string is returned. Clients must also not assume that the values of this property are unique
            within a Compilation.
            
            The FileName is used in two important ways:
               When debug information is emitted, this name is embedded in the debug information.
               When the GetLineSpan function on the SyntaxTree is called, it is used as the file name
               in the returned FileLinePositionSpan.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxTree.Text">
            <summary>
            The text of the source document.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxTree.Options">
            <summary>
            The options used by the parser to produce the syntax tree.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxTree.Root">
            <summary>
            The root node of the syntax tree.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SyntaxTrivia">
            <summary>
            Represents "trivia" in the syntax model. Trivia represent parts of the source code that are
            largely insignificant to the semantic understanding of the code. Trivia includes whitespace,
            comments, directives, text skipped as a result of #if directives, and tokens skipped by the
            parser for error recovery. Trivia are always directly parents by a token. Each token may
            have multiple leading trivia nodes and multiple trailing trivia nodes. 
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTrivia.GetFullText">
            <summary>
            Returns the complete text for the node, including leading and trailing trivia.
            </summary>
            <returns>The complete text for the node, including leading and trailing trivia.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTrivia.GetText">
            <summary>
            Returns the text representation of the node, not including leading and trailing trivia.
            </summary>
            <returns>The test representation of the node, not including leading and trailing trivia.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTrivia.WriteTo(System.IO.TextWriter)">
            <summary>
            Writes the full text of this token to the specified TextWriter.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTrivia.ToString">
            <summary>
            Returns the same result as GetFullText().
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTrivia.GetStructure">
            <summary>
            Gets the syntax node represented the structure of this trivia, if any. The HasStructure property can be used to 
            determine if this trivia has structure.
            </summary>
            <returns>
            A SyntaxNode derived from StructuredTriviaSyntax, with the structured view of this trivia node. 
            If this trivia node does not have structure, returns null.
            </returns>
            <remarks>
            Some types of trivia have structure that can be accessed as additional syntax nodes.
            These forms of trivia include: 
              directives, where the the structure describes the structure of the directive.
              documentation comments, where the structure describes the XML structure of the comment.
              skipped tokens, where the structure describes the tokens that were skipped by the parser.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTrivia.WithAdditionalAnnotations(Roslyn.Compilers.SyntaxAnnotation[])">
            <summary>
            Adds this annotation to a given syntax token, creating a new syntax token of the same type with the
            annotation on it.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTrivia.EquivalentTo(Roslyn.Compilers.CSharp.SyntaxTrivia)">
            <summary>
            Determines whether this node is structurally equivalent to another.
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTrivia.op_Implicit(Roslyn.Compilers.CSharp.SyntaxTrivia)~Roslyn.Compilers.Common.CommonSyntaxTrivia">
            <summary>
            Converts this SyntaxTrivia to a CommonSyntaxTrivia representing the same piece of trivia.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTrivia.op_Explicit(Roslyn.Compilers.Common.CommonSyntaxTrivia)~Roslyn.Compilers.CSharp.SyntaxTrivia">
            <summary>
            Converts a CommonSyntaxTrivia into a SyntaxTrivia representing the same piece of trivia.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxTrivia.Token">
            <summary>
            The parent token that this trivia is attached to, either as leading or trailing trivia.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxTrivia.IsDirective">
            <summary>
            Returns true if this trivia is a directive (#if, #region, etc.)
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxTrivia.IsElastic">
            <summary>
            Returns true if this is an "elastic trivia" node. Elastic trivia never created by the parser, but can be
            added to a syntax tree that was created "manually". Elastic trivia indicates location where the a formatter
            is free to insert additional white space.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxTrivia.Kind">
            <summary>
            Returns the kind of this trivia. The kind distinguishes between different sorts of trivia, such as spaces,
            newlines, comments, each sort of directive, disabled code, skipped tokens.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxTrivia.FullSpan">
            <summary>
            The absolute span of this node in characters, including its leading and trailing trivia.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxTrivia.Span">
            <summary>
            The absolute span of this node in characters, not including its leading and trailing trivia.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxTrivia.FullWidth">
            <summary>
            The complete width of the node in characters, including leading and trailing trivia.
            </summary>
            <remarks>The FullWidth property returns the same value as FullSpan.Length, but is somewhat more
            efficient.</remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxTrivia.Width">
            <summary>
            The width of the node in characters, not including leading and trailing trivia.
            </summary>
            <remarks>
            The Width property returns the same value as Span.Length, but is somewhat more efficient.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxTrivia.HasDiagnostics">
            <summary>
            Determines whether this node or any of its descendent nodes, tokens or trivia have any diagnostics on them.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxTrivia.HasAnnotations">
            <summary>
            Determines whether this node or any of its descendent nodes, tokens, or trivia have any annotations on them.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxTrivia.HasStructure">
            <summary>
            Returns true if this trivia node has structure that is exposed through the GetStructure() method.
            </summary>
            <remarks>
            Some types of trivia have structure that can be accessed as additional syntax nodes.
            These forms of trivia include: 
              directives, where the the structure describes the structure of the directive.
              documentation comments, where the structure describes the XML structure of the comment.
              skipped tokens, where the structure describes the tokens that were skipped by the parser.
            </remarks>
        </member>
    </members>
</doc>
